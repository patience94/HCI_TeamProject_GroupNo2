# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_core', [dirname(__file__)])
        except ImportError:
            import _core
            return _core
        if fp is not None:
            try:
                _mod = imp.load_module('_core', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _core = swig_import_helper()
    del swig_import_helper
else:
    import _core
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _core.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self) -> "PyObject *" : return _core.SwigPyIterator_value(self)
    def incr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" : return _core.SwigPyIterator_incr(self, n)
    def decr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" : return _core.SwigPyIterator_decr(self, n)
    def distance(self, *args) -> "ptrdiff_t" : return _core.SwigPyIterator_distance(self, *args)
    def equal(self, *args) -> "bool" : return _core.SwigPyIterator_equal(self, *args)
    def copy(self) -> "swig::SwigPyIterator *" : return _core.SwigPyIterator_copy(self)
    def next(self) -> "PyObject *" : return _core.SwigPyIterator_next(self)
    def __next__(self) -> "PyObject *" : return _core.SwigPyIterator___next__(self)
    def previous(self) -> "PyObject *" : return _core.SwigPyIterator_previous(self)
    def advance(self, *args) -> "swig::SwigPyIterator *" : return _core.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args) -> "bool" : return _core.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args) -> "bool" : return _core.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args) -> "swig::SwigPyIterator &" : return _core.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args) -> "swig::SwigPyIterator &" : return _core.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args) -> "swig::SwigPyIterator *" : return _core.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args) -> "ptrdiff_t" : return _core.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _core.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class StringVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.StringVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.StringVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.StringVector___bool__(self)
    def __len__(self) -> "std::vector< std::string >::size_type" : return _core.StringVector___len__(self)
    def pop(self) -> "std::vector< std::string >::value_type" : return _core.StringVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< std::string,std::allocator< std::string > > *" : return _core.StringVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.StringVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.StringVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.StringVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &" : return _core.StringVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.StringVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.StringVector_append(self, *args)
    def empty(self) -> "bool" : return _core.StringVector_empty(self)
    def size(self) -> "std::vector< std::string >::size_type" : return _core.StringVector_size(self)
    def clear(self) -> "void" : return _core.StringVector_clear(self)
    def swap(self, *args) -> "void" : return _core.StringVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< std::string >::allocator_type" : return _core.StringVector_get_allocator(self)
    def begin(self) -> "std::vector< std::string >::iterator" : return _core.StringVector_begin(self)
    def end(self) -> "std::vector< std::string >::iterator" : return _core.StringVector_end(self)
    def rbegin(self) -> "std::vector< std::string >::reverse_iterator" : return _core.StringVector_rbegin(self)
    def rend(self) -> "std::vector< std::string >::reverse_iterator" : return _core.StringVector_rend(self)
    def pop_back(self) -> "void" : return _core.StringVector_pop_back(self)
    def erase(self, *args) -> "std::vector< std::string >::iterator" : return _core.StringVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_StringVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.StringVector_push_back(self, *args)
    def front(self) -> "std::vector< std::string >::value_type const &" : return _core.StringVector_front(self)
    def back(self) -> "std::vector< std::string >::value_type const &" : return _core.StringVector_back(self)
    def assign(self, *args) -> "void" : return _core.StringVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.StringVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.StringVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.StringVector_reserve(self, *args)
    def capacity(self) -> "std::vector< std::string >::size_type" : return _core.StringVector_capacity(self)
    __swig_destroy__ = _core.delete_StringVector
    __del__ = lambda self : None;
StringVector_swigregister = _core.StringVector_swigregister
StringVector_swigregister(StringVector)

class DoubleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.DoubleVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.DoubleVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.DoubleVector___bool__(self)
    def __len__(self) -> "std::vector< double >::size_type" : return _core.DoubleVector___len__(self)
    def pop(self) -> "std::vector< double >::value_type" : return _core.DoubleVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< double,std::allocator< double > > *" : return _core.DoubleVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.DoubleVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.DoubleVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.DoubleVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< double >::value_type const &" : return _core.DoubleVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.DoubleVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.DoubleVector_append(self, *args)
    def empty(self) -> "bool" : return _core.DoubleVector_empty(self)
    def size(self) -> "std::vector< double >::size_type" : return _core.DoubleVector_size(self)
    def clear(self) -> "void" : return _core.DoubleVector_clear(self)
    def swap(self, *args) -> "void" : return _core.DoubleVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< double >::allocator_type" : return _core.DoubleVector_get_allocator(self)
    def begin(self) -> "std::vector< double >::iterator" : return _core.DoubleVector_begin(self)
    def end(self) -> "std::vector< double >::iterator" : return _core.DoubleVector_end(self)
    def rbegin(self) -> "std::vector< double >::reverse_iterator" : return _core.DoubleVector_rbegin(self)
    def rend(self) -> "std::vector< double >::reverse_iterator" : return _core.DoubleVector_rend(self)
    def pop_back(self) -> "void" : return _core.DoubleVector_pop_back(self)
    def erase(self, *args) -> "std::vector< double >::iterator" : return _core.DoubleVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_DoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.DoubleVector_push_back(self, *args)
    def front(self) -> "std::vector< double >::value_type const &" : return _core.DoubleVector_front(self)
    def back(self) -> "std::vector< double >::value_type const &" : return _core.DoubleVector_back(self)
    def assign(self, *args) -> "void" : return _core.DoubleVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.DoubleVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.DoubleVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.DoubleVector_reserve(self, *args)
    def capacity(self) -> "std::vector< double >::size_type" : return _core.DoubleVector_capacity(self)
    __swig_destroy__ = _core.delete_DoubleVector
    __del__ = lambda self : None;
DoubleVector_swigregister = _core.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class BoolVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoolVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BoolVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.BoolVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.BoolVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.BoolVector___bool__(self)
    def __len__(self) -> "std::vector< bool >::size_type" : return _core.BoolVector___len__(self)
    def pop(self) -> "std::vector< bool >::value_type" : return _core.BoolVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< bool,std::allocator< bool > > *" : return _core.BoolVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.BoolVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.BoolVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.BoolVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< bool >::value_type" : return _core.BoolVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.BoolVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.BoolVector_append(self, *args)
    def empty(self) -> "bool" : return _core.BoolVector_empty(self)
    def size(self) -> "std::vector< bool >::size_type" : return _core.BoolVector_size(self)
    def clear(self) -> "void" : return _core.BoolVector_clear(self)
    def swap(self, *args) -> "void" : return _core.BoolVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< bool >::allocator_type" : return _core.BoolVector_get_allocator(self)
    def begin(self) -> "std::vector< bool >::iterator" : return _core.BoolVector_begin(self)
    def end(self) -> "std::vector< bool >::iterator" : return _core.BoolVector_end(self)
    def rbegin(self) -> "std::vector< bool >::reverse_iterator" : return _core.BoolVector_rbegin(self)
    def rend(self) -> "std::vector< bool >::reverse_iterator" : return _core.BoolVector_rend(self)
    def pop_back(self) -> "void" : return _core.BoolVector_pop_back(self)
    def erase(self, *args) -> "std::vector< bool >::iterator" : return _core.BoolVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_BoolVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.BoolVector_push_back(self, *args)
    def front(self) -> "std::vector< bool >::value_type" : return _core.BoolVector_front(self)
    def back(self) -> "std::vector< bool >::value_type" : return _core.BoolVector_back(self)
    def assign(self, *args) -> "void" : return _core.BoolVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.BoolVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.BoolVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.BoolVector_reserve(self, *args)
    def capacity(self) -> "std::vector< bool >::size_type" : return _core.BoolVector_capacity(self)
    __swig_destroy__ = _core.delete_BoolVector
    __del__ = lambda self : None;
BoolVector_swigregister = _core.BoolVector_swigregister
BoolVector_swigregister(BoolVector)

class IntVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.IntVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.IntVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.IntVector___bool__(self)
    def __len__(self) -> "std::vector< int >::size_type" : return _core.IntVector___len__(self)
    def pop(self) -> "std::vector< int >::value_type" : return _core.IntVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< int,std::allocator< int > > *" : return _core.IntVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.IntVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.IntVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.IntVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< int >::value_type const &" : return _core.IntVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.IntVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.IntVector_append(self, *args)
    def empty(self) -> "bool" : return _core.IntVector_empty(self)
    def size(self) -> "std::vector< int >::size_type" : return _core.IntVector_size(self)
    def clear(self) -> "void" : return _core.IntVector_clear(self)
    def swap(self, *args) -> "void" : return _core.IntVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< int >::allocator_type" : return _core.IntVector_get_allocator(self)
    def begin(self) -> "std::vector< int >::iterator" : return _core.IntVector_begin(self)
    def end(self) -> "std::vector< int >::iterator" : return _core.IntVector_end(self)
    def rbegin(self) -> "std::vector< int >::reverse_iterator" : return _core.IntVector_rbegin(self)
    def rend(self) -> "std::vector< int >::reverse_iterator" : return _core.IntVector_rend(self)
    def pop_back(self) -> "void" : return _core.IntVector_pop_back(self)
    def erase(self, *args) -> "std::vector< int >::iterator" : return _core.IntVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_IntVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.IntVector_push_back(self, *args)
    def front(self) -> "std::vector< int >::value_type const &" : return _core.IntVector_front(self)
    def back(self) -> "std::vector< int >::value_type const &" : return _core.IntVector_back(self)
    def assign(self, *args) -> "void" : return _core.IntVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.IntVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.IntVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.IntVector_reserve(self, *args)
    def capacity(self) -> "std::vector< int >::size_type" : return _core.IntVector_capacity(self)
    __swig_destroy__ = _core.delete_IntVector
    __del__ = lambda self : None;
IntVector_swigregister = _core.IntVector_swigregister
IntVector_swigregister(IntVector)

class Base(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Base, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Base, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Base *" : return _core.Base___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Base___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Base___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Base_classType
    if _newclass:classType = staticmethod(_core.Base_classType)
    __swig_destroy__ = _core.delete_Base
    __del__ = lambda self : None;
    def _get_objectType(self) -> "char const *" : return _core.Base__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Base__get_isValid(self)
Base_swigregister = _core.Base_swigregister
Base_swigregister(Base)

def Base_classType() -> "char const *" :
  return _core.Base_classType()
Base_classType = _core.Base_classType

Base.__swig_getmethods__["objectType"] = Base._get_objectType
Base.objectType = property(Base._get_objectType, doc="Returns a string indicating the type of the object.")

Base.__swig_getmethods__["isValid"] = Base._get_isValid
Base.isValid = property(Base._get_isValid, doc="Indicates if this object is still valid, i.e. hasn't been deleted or some other action done to invalidate the reference.")

class EnsureGILState(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EnsureGILState, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EnsureGILState, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _core.new_EnsureGILState()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_EnsureGILState
    __del__ = lambda self : None;
EnsureGILState_swigregister = _core.EnsureGILState_swigregister
EnsureGILState_swigregister(EnsureGILState)


def eventDirectorCallNotify(*args) -> "PyObject *" :
  return _core.eventDirectorCallNotify(*args)
eventDirectorCallNotify = _core.eventDirectorCallNotify

def adsk_terminate() -> "void" :
  return _core.adsk_terminate()
adsk_terminate = _core.adsk_terminate

def get_adsk_autoTerminate() -> "bool" :
  return _core.get_adsk_autoTerminate()
get_adsk_autoTerminate = _core.get_adsk_autoTerminate

def set_adsk_autoTerminate(*args) -> "void" :
  return _core.set_adsk_autoTerminate(*args)
set_adsk_autoTerminate = _core.set_adsk_autoTerminate

def adsk_doEvents() -> "void" :
  return _core.adsk_doEvents()
adsk_doEvents = _core.adsk_doEvents
import sys
if 'adsk' in sys.modules:
    sys.modules['adsk'].terminate = adsk_terminate
    sys.modules['adsk'].autoTerminate = lambda value = None: get_adsk_autoTerminate() if value == None else set_adsk_autoTerminate(value)
    sys.modules['adsk'].doEvents = adsk_doEvents

class GenericErrors(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenericErrors, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GenericErrors, name)
    __repr__ = _swig_repr
    Ok = _core.GenericErrors_Ok
    UnexpectedError = _core.GenericErrors_UnexpectedError
    InternalValidationError = _core.GenericErrors_InternalValidationError
    BadApiCallError = _core.GenericErrors_BadApiCallError
    UnderlyingObjectDeletedError = _core.GenericErrors_UnderlyingObjectDeletedError
    OperationFailed = _core.GenericErrors_OperationFailed
    ExpressionError = _core.GenericErrors_ExpressionError
    InvalidGeometryError = _core.GenericErrors_InvalidGeometryError
    ClassSpecificError = _core.GenericErrors_ClassSpecificError
    FunctionSpecificError = _core.GenericErrors_FunctionSpecificError
    def __init__(self): 
        this = _core.new_GenericErrors()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_GenericErrors
    __del__ = lambda self : None;
GenericErrors_swigregister = _core.GenericErrors_swigregister
GenericErrors_swigregister(GenericErrors)

class DocumentTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DocumentTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DocumentTypes, name)
    __repr__ = _swig_repr
    FusionDesignDocumentType = _core.DocumentTypes_FusionDesignDocumentType
    def __init__(self): 
        this = _core.new_DocumentTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_DocumentTypes
    __del__ = lambda self : None;
DocumentTypes_swigregister = _core.DocumentTypes_swigregister
DocumentTypes_swigregister(DocumentTypes)

class OpenDocumentError(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OpenDocumentError, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OpenDocumentError, name)
    __repr__ = _swig_repr
    DocumentNotFoundError = _core.OpenDocumentError_DocumentNotFoundError
    def __init__(self): 
        this = _core.new_OpenDocumentError()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_OpenDocumentError
    __del__ = lambda self : None;
OpenDocumentError_swigregister = _core.OpenDocumentError_swigregister
OpenDocumentError_swigregister(OpenDocumentError)

class CloseError(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CloseError, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CloseError, name)
    __repr__ = _swig_repr
    CloseCancelledError = _core.CloseError_CloseCancelledError
    def __init__(self): 
        this = _core.new_CloseError()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_CloseError
    __del__ = lambda self : None;
CloseError_swigregister = _core.CloseError_swigregister
CloseError_swigregister(CloseError)

class SaveLocalErrors(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SaveLocalErrors, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SaveLocalErrors, name)
    __repr__ = _swig_repr
    SaveCancelledSaveLocalError = _core.SaveLocalErrors_SaveCancelledSaveLocalError
    DiskFullSaveLocalError = _core.SaveLocalErrors_DiskFullSaveLocalError
    FileReadOnlySaveLocalError = _core.SaveLocalErrors_FileReadOnlySaveLocalError
    def __init__(self): 
        this = _core.new_SaveLocalErrors()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_SaveLocalErrors
    __del__ = lambda self : None;
SaveLocalErrors_swigregister = _core.SaveLocalErrors_swigregister
SaveLocalErrors_swigregister(SaveLocalErrors)

class UserLanguages(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UserLanguages, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UserLanguages, name)
    __repr__ = _swig_repr
    ChinesePRCLanguage = _core.UserLanguages_ChinesePRCLanguage
    ChineseTaiwanLanguage = _core.UserLanguages_ChineseTaiwanLanguage
    CzechLanguage = _core.UserLanguages_CzechLanguage
    EnglishLanguage = _core.UserLanguages_EnglishLanguage
    FrenchLanguage = _core.UserLanguages_FrenchLanguage
    GermanLanguage = _core.UserLanguages_GermanLanguage
    HungarianLanguage = _core.UserLanguages_HungarianLanguage
    ItalianLanguage = _core.UserLanguages_ItalianLanguage
    JapaneseLanguage = _core.UserLanguages_JapaneseLanguage
    KoreanLanguage = _core.UserLanguages_KoreanLanguage
    PolishLanguage = _core.UserLanguages_PolishLanguage
    PortugueseBrazilianLanguage = _core.UserLanguages_PortugueseBrazilianLanguage
    RussianLanguage = _core.UserLanguages_RussianLanguage
    SpanishLanguage = _core.UserLanguages_SpanishLanguage
    def __init__(self): 
        this = _core.new_UserLanguages()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_UserLanguages
    __del__ = lambda self : None;
UserLanguages_swigregister = _core.UserLanguages_swigregister
UserLanguages_swigregister(UserLanguages)

class GraphicsDrivers(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GraphicsDrivers, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GraphicsDrivers, name)
    __repr__ = _swig_repr
    DirectX9GraphicsDriver = _core.GraphicsDrivers_DirectX9GraphicsDriver
    DirectX11GraphicsDriver = _core.GraphicsDrivers_DirectX11GraphicsDriver
    AutoSelectGraphicsDriver = _core.GraphicsDrivers_AutoSelectGraphicsDriver
    OpenGLCoreProfileGraphicsDriver = _core.GraphicsDrivers_OpenGLCoreProfileGraphicsDriver
    OpenGLGraphicsDriver = _core.GraphicsDrivers_OpenGLGraphicsDriver
    def __init__(self): 
        this = _core.new_GraphicsDrivers()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_GraphicsDrivers
    __del__ = lambda self : None;
GraphicsDrivers_swigregister = _core.GraphicsDrivers_swigregister
GraphicsDrivers_swigregister(GraphicsDrivers)

class DefaultModelingOrientations(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DefaultModelingOrientations, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DefaultModelingOrientations, name)
    __repr__ = _swig_repr
    YUpModelingOrientation = _core.DefaultModelingOrientations_YUpModelingOrientation
    ZUpModelingOrientation = _core.DefaultModelingOrientations_ZUpModelingOrientation
    def __init__(self): 
        this = _core.new_DefaultModelingOrientations()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_DefaultModelingOrientations
    __del__ = lambda self : None;
DefaultModelingOrientations_swigregister = _core.DefaultModelingOrientations_swigregister
DefaultModelingOrientations_swigregister(DefaultModelingOrientations)

class DefaultOrbits(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DefaultOrbits, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DefaultOrbits, name)
    __repr__ = _swig_repr
    ConstrainedOrbit = _core.DefaultOrbits_ConstrainedOrbit
    FreeOrbit = _core.DefaultOrbits_FreeOrbit
    def __init__(self): 
        this = _core.new_DefaultOrbits()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_DefaultOrbits
    __del__ = lambda self : None;
DefaultOrbits_swigregister = _core.DefaultOrbits_swigregister
DefaultOrbits_swigregister(DefaultOrbits)

class SelectionDisplayStyles(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SelectionDisplayStyles, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SelectionDisplayStyles, name)
    __repr__ = _swig_repr
    NormalDisplayStyle = _core.SelectionDisplayStyles_NormalDisplayStyle
    SimpleDisplayStyle = _core.SelectionDisplayStyles_SimpleDisplayStyle
    def __init__(self): 
        this = _core.new_SelectionDisplayStyles()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_SelectionDisplayStyles
    __del__ = lambda self : None;
SelectionDisplayStyles_swigregister = _core.SelectionDisplayStyles_swigregister
SelectionDisplayStyles_swigregister(SelectionDisplayStyles)

class DegradedSelectionDisplayStyles(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DegradedSelectionDisplayStyles, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DegradedSelectionDisplayStyles, name)
    __repr__ = _swig_repr
    NormalWithGlowDegradedSelectionStyle = _core.DegradedSelectionDisplayStyles_NormalWithGlowDegradedSelectionStyle
    SimpleWithoutGlowDegradedSelectionStyle = _core.DegradedSelectionDisplayStyles_SimpleWithoutGlowDegradedSelectionStyle
    def __init__(self): 
        this = _core.new_DegradedSelectionDisplayStyles()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_DegradedSelectionDisplayStyles
    __del__ = lambda self : None;
DegradedSelectionDisplayStyles_swigregister = _core.DegradedSelectionDisplayStyles_swigregister
DegradedSelectionDisplayStyles_swigregister(DegradedSelectionDisplayStyles)

class TransparencyDisplayEffects(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransparencyDisplayEffects, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TransparencyDisplayEffects, name)
    __repr__ = _swig_repr
    BetterPerformanceTransparencyEffect = _core.TransparencyDisplayEffects_BetterPerformanceTransparencyEffect
    BetterDisplayTransparencyEffect = _core.TransparencyDisplayEffects_BetterDisplayTransparencyEffect
    def __init__(self): 
        this = _core.new_TransparencyDisplayEffects()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_TransparencyDisplayEffects
    __del__ = lambda self : None;
TransparencyDisplayEffects_swigregister = _core.TransparencyDisplayEffects_swigregister
TransparencyDisplayEffects_swigregister(TransparencyDisplayEffects)

class NetworkProxySettings(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NetworkProxySettings, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NetworkProxySettings, name)
    __repr__ = _swig_repr
    AutomaticProxySettings = _core.NetworkProxySettings_AutomaticProxySettings
    NoProxyProxySettings = _core.NetworkProxySettings_NoProxyProxySettings
    WindowsDefaultProxySettings = _core.NetworkProxySettings_WindowsDefaultProxySettings
    OverrideProxySettings = _core.NetworkProxySettings_OverrideProxySettings
    def __init__(self): 
        this = _core.new_NetworkProxySettings()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_NetworkProxySettings
    __del__ = lambda self : None;
NetworkProxySettings_swigregister = _core.NetworkProxySettings_swigregister
NetworkProxySettings_swigregister(NetworkProxySettings)

class FootAndInchDisplayFormats(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FootAndInchDisplayFormats, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FootAndInchDisplayFormats, name)
    __repr__ = _swig_repr
    DecimalFootAndInchDisplay = _core.FootAndInchDisplayFormats_DecimalFootAndInchDisplay
    FractionalFootAndInchDisplay = _core.FootAndInchDisplayFormats_FractionalFootAndInchDisplay
    ArchitecturalFootAndInchDisplay = _core.FootAndInchDisplayFormats_ArchitecturalFootAndInchDisplay
    def __init__(self): 
        this = _core.new_FootAndInchDisplayFormats()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_FootAndInchDisplayFormats
    __del__ = lambda self : None;
FootAndInchDisplayFormats_swigregister = _core.FootAndInchDisplayFormats_swigregister
FootAndInchDisplayFormats_swigregister(FootAndInchDisplayFormats)

class DegreeDisplayFormats(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DegreeDisplayFormats, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DegreeDisplayFormats, name)
    __repr__ = _swig_repr
    DecimalDegreeDisplay = _core.DegreeDisplayFormats_DecimalDegreeDisplay
    MinutesAndSecondsDegreeDisplay = _core.DegreeDisplayFormats_MinutesAndSecondsDegreeDisplay
    def __init__(self): 
        this = _core.new_DegreeDisplayFormats()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_DegreeDisplayFormats
    __del__ = lambda self : None;
DegreeDisplayFormats_swigregister = _core.DegreeDisplayFormats_swigregister
DegreeDisplayFormats_swigregister(DegreeDisplayFormats)

class MaterialDisplayUnits(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MaterialDisplayUnits, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MaterialDisplayUnits, name)
    __repr__ = _swig_repr
    MetricStandardDisplayUnits = _core.MaterialDisplayUnits_MetricStandardDisplayUnits
    MetricMKSDisplayUnits = _core.MaterialDisplayUnits_MetricMKSDisplayUnits
    MetricMMNSDisplayUnits = _core.MaterialDisplayUnits_MetricMMNSDisplayUnits
    MetricCGSDisplayUnits = _core.MaterialDisplayUnits_MetricCGSDisplayUnits
    MetricUMNSDisplayUnits = _core.MaterialDisplayUnits_MetricUMNSDisplayUnits
    EnglishStandardDisplayUnits = _core.MaterialDisplayUnits_EnglishStandardDisplayUnits
    EnglishInchDisplayUnits = _core.MaterialDisplayUnits_EnglishInchDisplayUnits
    EnglishFootDisplayUnits = _core.MaterialDisplayUnits_EnglishFootDisplayUnits
    def __init__(self): 
        this = _core.new_MaterialDisplayUnits()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_MaterialDisplayUnits
    __del__ = lambda self : None;
MaterialDisplayUnits_swigregister = _core.MaterialDisplayUnits_swigregister
MaterialDisplayUnits_swigregister(MaterialDisplayUnits)

class ValueTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ValueTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ValueTypes, name)
    __repr__ = _swig_repr
    StringValueType = _core.ValueTypes_StringValueType
    RealValueType = _core.ValueTypes_RealValueType
    ObjectValueType = _core.ValueTypes_ObjectValueType
    BooleanValueType = _core.ValueTypes_BooleanValueType
    def __init__(self): 
        this = _core.new_ValueTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_ValueTypes
    __del__ = lambda self : None;
ValueTypes_swigregister = _core.ValueTypes_swigregister
ValueTypes_swigregister(ValueTypes)

class ValueInputError(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ValueInputError, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ValueInputError, name)
    __repr__ = _swig_repr
    ValueNotOfTypeError = _core.ValueInputError_ValueNotOfTypeError
    def __init__(self): 
        this = _core.new_ValueInputError()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_ValueInputError
    __del__ = lambda self : None;
ValueInputError_swigregister = _core.ValueInputError_swigregister
ValueInputError_swigregister(ValueInputError)

class VisualStyles(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VisualStyles, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VisualStyles, name)
    __repr__ = _swig_repr
    ShadedVisualStyle = _core.VisualStyles_ShadedVisualStyle
    ShadedWithHiddenEdgesVisualStyle = _core.VisualStyles_ShadedWithHiddenEdgesVisualStyle
    ShadedWithVisibleEdgesOnlyVisualStyle = _core.VisualStyles_ShadedWithVisibleEdgesOnlyVisualStyle
    WireframeVisualStyle = _core.VisualStyles_WireframeVisualStyle
    WireframeWithHiddenEdgesVisualStyle = _core.VisualStyles_WireframeWithHiddenEdgesVisualStyle
    WireframeWithVisibleEdgesOnlyVisualStyle = _core.VisualStyles_WireframeWithVisibleEdgesOnlyVisualStyle
    def __init__(self): 
        this = _core.new_VisualStyles()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_VisualStyles
    __del__ = lambda self : None;
VisualStyles_swigregister = _core.VisualStyles_swigregister
VisualStyles_swigregister(VisualStyles)

class CameraTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CameraTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CameraTypes, name)
    __repr__ = _swig_repr
    OrthographicCameraType = _core.CameraTypes_OrthographicCameraType
    PerspectiveCameraType = _core.CameraTypes_PerspectiveCameraType
    PerspectiveWithOrthoFacesCameraType = _core.CameraTypes_PerspectiveWithOrthoFacesCameraType
    def __init__(self): 
        this = _core.new_CameraTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_CameraTypes
    __del__ = lambda self : None;
CameraTypes_swigregister = _core.CameraTypes_swigregister
CameraTypes_swigregister(CameraTypes)

class ViewOrientations(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ViewOrientations, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ViewOrientations, name)
    __repr__ = _swig_repr
    ArbitraryViewOrientation = _core.ViewOrientations_ArbitraryViewOrientation
    BackViewOrientation = _core.ViewOrientations_BackViewOrientation
    BottomViewOrientation = _core.ViewOrientations_BottomViewOrientation
    FrontViewOrientation = _core.ViewOrientations_FrontViewOrientation
    IsoBottomLeftViewOrientation = _core.ViewOrientations_IsoBottomLeftViewOrientation
    IsoBottomRightViewOrientation = _core.ViewOrientations_IsoBottomRightViewOrientation
    IsoTopLeftViewOrientation = _core.ViewOrientations_IsoTopLeftViewOrientation
    IsoTopRightViewOrientation = _core.ViewOrientations_IsoTopRightViewOrientation
    LeftViewOrientation = _core.ViewOrientations_LeftViewOrientation
    RightViewOrientation = _core.ViewOrientations_RightViewOrientation
    TopViewOrientation = _core.ViewOrientations_TopViewOrientation
    def __init__(self): 
        this = _core.new_ViewOrientations()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_ViewOrientations
    __del__ = lambda self : None;
ViewOrientations_swigregister = _core.ViewOrientations_swigregister
ViewOrientations_swigregister(ViewOrientations)

class HubTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HubTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HubTypes, name)
    __repr__ = _swig_repr
    PersonalHubType = _core.HubTypes_PersonalHubType
    TeamHubType = _core.HubTypes_TeamHubType
    def __init__(self): 
        this = _core.new_HubTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_HubTypes
    __del__ = lambda self : None;
HubTypes_swigregister = _core.HubTypes_swigregister
HubTypes_swigregister(HubTypes)

class UploadStates(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UploadStates, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UploadStates, name)
    __repr__ = _swig_repr
    UploadProcessing = _core.UploadStates_UploadProcessing
    UploadFinished = _core.UploadStates_UploadFinished
    UploadFailed = _core.UploadStates_UploadFailed
    def __init__(self): 
        this = _core.new_UploadStates()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_UploadStates
    __del__ = lambda self : None;
UploadStates_swigregister = _core.UploadStates_swigregister
UploadStates_swigregister(UploadStates)

class Curve2DTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Curve2DTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Curve2DTypes, name)
    __repr__ = _swig_repr
    Line2DCurveType = _core.Curve2DTypes_Line2DCurveType
    Arc2DCurveType = _core.Curve2DTypes_Arc2DCurveType
    Circle2DCurveType = _core.Curve2DTypes_Circle2DCurveType
    Ellipse2DCurveType = _core.Curve2DTypes_Ellipse2DCurveType
    EllipticalArc2DCurveType = _core.Curve2DTypes_EllipticalArc2DCurveType
    InfiniteLine2DCurveType = _core.Curve2DTypes_InfiniteLine2DCurveType
    NurbsCurve2DCurveType = _core.Curve2DTypes_NurbsCurve2DCurveType
    def __init__(self): 
        this = _core.new_Curve2DTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_Curve2DTypes
    __del__ = lambda self : None;
Curve2DTypes_swigregister = _core.Curve2DTypes_swigregister
Curve2DTypes_swigregister(Curve2DTypes)

class Curve3DTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Curve3DTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Curve3DTypes, name)
    __repr__ = _swig_repr
    Line3DCurveType = _core.Curve3DTypes_Line3DCurveType
    Arc3DCurveType = _core.Curve3DTypes_Arc3DCurveType
    Circle3DCurveType = _core.Curve3DTypes_Circle3DCurveType
    Ellipse3DCurveType = _core.Curve3DTypes_Ellipse3DCurveType
    EllipticalArc3DCurveType = _core.Curve3DTypes_EllipticalArc3DCurveType
    InfiniteLine3DCurveType = _core.Curve3DTypes_InfiniteLine3DCurveType
    NurbsCurve3DCurveType = _core.Curve3DTypes_NurbsCurve3DCurveType
    def __init__(self): 
        this = _core.new_Curve3DTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_Curve3DTypes
    __del__ = lambda self : None;
Curve3DTypes_swigregister = _core.Curve3DTypes_swigregister
Curve3DTypes_swigregister(Curve3DTypes)

class SurfaceTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SurfaceTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SurfaceTypes, name)
    __repr__ = _swig_repr
    PlaneSurfaceType = _core.SurfaceTypes_PlaneSurfaceType
    CylinderSurfaceType = _core.SurfaceTypes_CylinderSurfaceType
    ConeSurfaceType = _core.SurfaceTypes_ConeSurfaceType
    SphereSurfaceType = _core.SurfaceTypes_SphereSurfaceType
    TorusSurfaceType = _core.SurfaceTypes_TorusSurfaceType
    EllipticalCylinderSurfaceType = _core.SurfaceTypes_EllipticalCylinderSurfaceType
    EllipticalConeSurfaceType = _core.SurfaceTypes_EllipticalConeSurfaceType
    NurbsSurfaceType = _core.SurfaceTypes_NurbsSurfaceType
    def __init__(self): 
        this = _core.new_SurfaceTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_SurfaceTypes
    __del__ = lambda self : None;
SurfaceTypes_swigregister = _core.SurfaceTypes_swigregister
SurfaceTypes_swigregister(SurfaceTypes)

class NurbsSurfaceProperties(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NurbsSurfaceProperties, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NurbsSurfaceProperties, name)
    __repr__ = _swig_repr
    OpenNurbsSurface = _core.NurbsSurfaceProperties_OpenNurbsSurface
    ClosedNurbsSurface = _core.NurbsSurfaceProperties_ClosedNurbsSurface
    PeriodicNurbsSurface = _core.NurbsSurfaceProperties_PeriodicNurbsSurface
    RationalNurbsSurface = _core.NurbsSurfaceProperties_RationalNurbsSurface
    def __init__(self): 
        this = _core.new_NurbsSurfaceProperties()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_NurbsSurfaceProperties
    __del__ = lambda self : None;
NurbsSurfaceProperties_swigregister = _core.NurbsSurfaceProperties_swigregister
NurbsSurfaceProperties_swigregister(NurbsSurfaceProperties)

class VectorError(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorError, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorError, name)
    __repr__ = _swig_repr
    ZeroLengthVectorError = _core.VectorError_ZeroLengthVectorError
    def __init__(self): 
        this = _core.new_VectorError()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_VectorError
    __del__ = lambda self : None;
VectorError_swigregister = _core.VectorError_swigregister
VectorError_swigregister(VectorError)

class TextureTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TextureTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TextureTypes, name)
    __repr__ = _swig_repr
    UnknownTexture = _core.TextureTypes_UnknownTexture
    ImageTexture = _core.TextureTypes_ImageTexture
    CheckerTexture = _core.TextureTypes_CheckerTexture
    GradientTexture = _core.TextureTypes_GradientTexture
    MarbleTexture = _core.TextureTypes_MarbleTexture
    NoiseTexture = _core.TextureTypes_NoiseTexture
    SpeckleTexture = _core.TextureTypes_SpeckleTexture
    TileTexture = _core.TextureTypes_TileTexture
    WaveTexture = _core.TextureTypes_WaveTexture
    WoodTexture = _core.TextureTypes_WoodTexture
    def __init__(self): 
        this = _core.new_TextureTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_TextureTypes
    __del__ = lambda self : None;
TextureTypes_swigregister = _core.TextureTypes_swigregister
TextureTypes_swigregister(TextureTypes)

class AppearanceSourceTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppearanceSourceTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppearanceSourceTypes, name)
    __repr__ = _swig_repr
    MaterialAppearanceSource = _core.AppearanceSourceTypes_MaterialAppearanceSource
    BodyAppearanceSource = _core.AppearanceSourceTypes_BodyAppearanceSource
    OccurrenceAppearanceSource = _core.AppearanceSourceTypes_OccurrenceAppearanceSource
    FaceAppearanceSource = _core.AppearanceSourceTypes_FaceAppearanceSource
    OverrideAppearanceSource = _core.AppearanceSourceTypes_OverrideAppearanceSource
    def __init__(self): 
        this = _core.new_AppearanceSourceTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_AppearanceSourceTypes
    __del__ = lambda self : None;
AppearanceSourceTypes_swigregister = _core.AppearanceSourceTypes_swigregister
AppearanceSourceTypes_swigregister(AppearanceSourceTypes)

class DialogResults(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DialogResults, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DialogResults, name)
    __repr__ = _swig_repr
    DialogError = _core.DialogResults_DialogError
    DialogOK = _core.DialogResults_DialogOK
    DialogCancel = _core.DialogResults_DialogCancel
    DialogYes = _core.DialogResults_DialogYes
    DialogNo = _core.DialogResults_DialogNo
    def __init__(self): 
        this = _core.new_DialogResults()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_DialogResults
    __del__ = lambda self : None;
DialogResults_swigregister = _core.DialogResults_swigregister
DialogResults_swigregister(DialogResults)

class MessageBoxButtonTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MessageBoxButtonTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MessageBoxButtonTypes, name)
    __repr__ = _swig_repr
    OKButtonType = _core.MessageBoxButtonTypes_OKButtonType
    OKCancelButtonType = _core.MessageBoxButtonTypes_OKCancelButtonType
    RetryCancelButtonType = _core.MessageBoxButtonTypes_RetryCancelButtonType
    YesNoButtonType = _core.MessageBoxButtonTypes_YesNoButtonType
    YesNoCancelButtonType = _core.MessageBoxButtonTypes_YesNoCancelButtonType
    def __init__(self): 
        this = _core.new_MessageBoxButtonTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_MessageBoxButtonTypes
    __del__ = lambda self : None;
MessageBoxButtonTypes_swigregister = _core.MessageBoxButtonTypes_swigregister
MessageBoxButtonTypes_swigregister(MessageBoxButtonTypes)

class MessageBoxIconTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MessageBoxIconTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MessageBoxIconTypes, name)
    __repr__ = _swig_repr
    NoIconIconType = _core.MessageBoxIconTypes_NoIconIconType
    QuestionIconType = _core.MessageBoxIconTypes_QuestionIconType
    InformationIconType = _core.MessageBoxIconTypes_InformationIconType
    WarningIconType = _core.MessageBoxIconTypes_WarningIconType
    CriticalIconType = _core.MessageBoxIconTypes_CriticalIconType
    def __init__(self): 
        this = _core.new_MessageBoxIconTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_MessageBoxIconTypes
    __del__ = lambda self : None;
MessageBoxIconTypes_swigregister = _core.MessageBoxIconTypes_swigregister
MessageBoxIconTypes_swigregister(MessageBoxIconTypes)

class PaletteDockingOptions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PaletteDockingOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PaletteDockingOptions, name)
    __repr__ = _swig_repr
    PaletteDockOptionsNone = _core.PaletteDockingOptions_PaletteDockOptionsNone
    PaletteDockOptionsToVerticalOnly = _core.PaletteDockingOptions_PaletteDockOptionsToVerticalOnly
    PaletteDockOptionsToHorizontalOnly = _core.PaletteDockingOptions_PaletteDockOptionsToHorizontalOnly
    PaletteDockOptionsToVerticalAndHorizontal = _core.PaletteDockingOptions_PaletteDockOptionsToVerticalAndHorizontal
    def __init__(self): 
        this = _core.new_PaletteDockingOptions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_PaletteDockingOptions
    __del__ = lambda self : None;
PaletteDockingOptions_swigregister = _core.PaletteDockingOptions_swigregister
PaletteDockingOptions_swigregister(PaletteDockingOptions)

class PaletteDockingStates(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PaletteDockingStates, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PaletteDockingStates, name)
    __repr__ = _swig_repr
    PaletteDockStateFloating = _core.PaletteDockingStates_PaletteDockStateFloating
    PaletteDockStateTop = _core.PaletteDockingStates_PaletteDockStateTop
    PaletteDockStateBottom = _core.PaletteDockingStates_PaletteDockStateBottom
    PaletteDockStateLeft = _core.PaletteDockingStates_PaletteDockStateLeft
    PaletteDockStateRight = _core.PaletteDockingStates_PaletteDockStateRight
    def __init__(self): 
        this = _core.new_PaletteDockingStates()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_PaletteDockingStates
    __del__ = lambda self : None;
PaletteDockingStates_swigregister = _core.PaletteDockingStates_swigregister
PaletteDockingStates_swigregister(PaletteDockingStates)

class PaletteSnapOptions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PaletteSnapOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PaletteSnapOptions, name)
    __repr__ = _swig_repr
    PaletteSnapOptionsTop = _core.PaletteSnapOptions_PaletteSnapOptionsTop
    PaletteSnapOptionsLeft = _core.PaletteSnapOptions_PaletteSnapOptionsLeft
    PaletteSnapOptionsRight = _core.PaletteSnapOptions_PaletteSnapOptionsRight
    PaletteSnapOptionsBottom = _core.PaletteSnapOptions_PaletteSnapOptionsBottom
    def __init__(self): 
        this = _core.new_PaletteSnapOptions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_PaletteSnapOptions
    __del__ = lambda self : None;
PaletteSnapOptions_swigregister = _core.PaletteSnapOptions_swigregister
PaletteSnapOptions_swigregister(PaletteSnapOptions)

class ListControlDisplayTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListControlDisplayTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ListControlDisplayTypes, name)
    __repr__ = _swig_repr
    CheckBoxListType = _core.ListControlDisplayTypes_CheckBoxListType
    RadioButtonlistType = _core.ListControlDisplayTypes_RadioButtonlistType
    StandardListType = _core.ListControlDisplayTypes_StandardListType
    def __init__(self): 
        this = _core.new_ListControlDisplayTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_ListControlDisplayTypes
    __del__ = lambda self : None;
ListControlDisplayTypes_swigregister = _core.ListControlDisplayTypes_swigregister
ListControlDisplayTypes_swigregister(ListControlDisplayTypes)

class CommandTerminationReason(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CommandTerminationReason, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CommandTerminationReason, name)
    __repr__ = _swig_repr
    UnknownTerminationReason = _core.CommandTerminationReason_UnknownTerminationReason
    CompletedTerminationReason = _core.CommandTerminationReason_CompletedTerminationReason
    CancelledTerminationReason = _core.CommandTerminationReason_CancelledTerminationReason
    AbortedTerminationReason = _core.CommandTerminationReason_AbortedTerminationReason
    PreEmptedTerminationReason = _core.CommandTerminationReason_PreEmptedTerminationReason
    SessionEndingTerminationReason = _core.CommandTerminationReason_SessionEndingTerminationReason
    def __init__(self): 
        this = _core.new_CommandTerminationReason()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_CommandTerminationReason
    __del__ = lambda self : None;
CommandTerminationReason_swigregister = _core.CommandTerminationReason_swigregister
CommandTerminationReason_swigregister(CommandTerminationReason)

class KeyCodes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, KeyCodes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, KeyCodes, name)
    __repr__ = _swig_repr
    NoKeyCode = _core.KeyCodes_NoKeyCode
    SpaceKeyCode = _core.KeyCodes_SpaceKeyCode
    AsteriskKeyCode = _core.KeyCodes_AsteriskKeyCode
    PlusKeyCode = _core.KeyCodes_PlusKeyCode
    CommaKeyCode = _core.KeyCodes_CommaKeyCode
    MinusKeyCode = _core.KeyCodes_MinusKeyCode
    PeriodKeyCode = _core.KeyCodes_PeriodKeyCode
    SlashKeyCode = _core.KeyCodes_SlashKeyCode
    D0KeyCode = _core.KeyCodes_D0KeyCode
    D1KeyCode = _core.KeyCodes_D1KeyCode
    D2KeyCode = _core.KeyCodes_D2KeyCode
    D3KeyCode = _core.KeyCodes_D3KeyCode
    D4KeyCode = _core.KeyCodes_D4KeyCode
    D5KeyCode = _core.KeyCodes_D5KeyCode
    D6KeyCode = _core.KeyCodes_D6KeyCode
    D7KeyCode = _core.KeyCodes_D7KeyCode
    D8KeyCode = _core.KeyCodes_D8KeyCode
    D9KeyCode = _core.KeyCodes_D9KeyCode
    ColonKeyCode = _core.KeyCodes_ColonKeyCode
    SemicolonKeyCode = _core.KeyCodes_SemicolonKeyCode
    LessKeyCode = _core.KeyCodes_LessKeyCode
    EqualKeyCode = _core.KeyCodes_EqualKeyCode
    GreaterKeyCode = _core.KeyCodes_GreaterKeyCode
    QuestionKeyCode = _core.KeyCodes_QuestionKeyCode
    AKeyCode = _core.KeyCodes_AKeyCode
    BKeyCode = _core.KeyCodes_BKeyCode
    CKeyCode = _core.KeyCodes_CKeyCode
    DKeyCode = _core.KeyCodes_DKeyCode
    EKeyCode = _core.KeyCodes_EKeyCode
    FKeyCode = _core.KeyCodes_FKeyCode
    GKeyCode = _core.KeyCodes_GKeyCode
    HKeyCode = _core.KeyCodes_HKeyCode
    IKeyCode = _core.KeyCodes_IKeyCode
    JKeyCode = _core.KeyCodes_JKeyCode
    KKeyCode = _core.KeyCodes_KKeyCode
    LKeyCode = _core.KeyCodes_LKeyCode
    MKeyCode = _core.KeyCodes_MKeyCode
    NKeyCode = _core.KeyCodes_NKeyCode
    OKeyCode = _core.KeyCodes_OKeyCode
    PKeyCode = _core.KeyCodes_PKeyCode
    QKeyCode = _core.KeyCodes_QKeyCode
    RKeyCode = _core.KeyCodes_RKeyCode
    SKeyCode = _core.KeyCodes_SKeyCode
    TKeyCode = _core.KeyCodes_TKeyCode
    UKeyCode = _core.KeyCodes_UKeyCode
    VKeyCode = _core.KeyCodes_VKeyCode
    WKeyCode = _core.KeyCodes_WKeyCode
    XKeyCode = _core.KeyCodes_XKeyCode
    YKeyCode = _core.KeyCodes_YKeyCode
    ZKeyCode = _core.KeyCodes_ZKeyCode
    BracketLeftKeyCode = _core.KeyCodes_BracketLeftKeyCode
    BackslashKeyCode = _core.KeyCodes_BackslashKeyCode
    BracketRightKeyCode = _core.KeyCodes_BracketRightKeyCode
    AsciiCircumKeyCode = _core.KeyCodes_AsciiCircumKeyCode
    UnderscoreKeyCode = _core.KeyCodes_UnderscoreKeyCode
    QuoteLeftKeyCode = _core.KeyCodes_QuoteLeftKeyCode
    BraceLeftKeyCode = _core.KeyCodes_BraceLeftKeyCode
    BarKeyCode = _core.KeyCodes_BarKeyCode
    BraceRightKeyCode = _core.KeyCodes_BraceRightKeyCode
    AsciiTildeKeyCode = _core.KeyCodes_AsciiTildeKeyCode
    GraveAccentKeyCode = _core.KeyCodes_GraveAccentKeyCode
    EscapeKeyCode = _core.KeyCodes_EscapeKeyCode
    TabKeyCode = _core.KeyCodes_TabKeyCode
    BacktabKeyCode = _core.KeyCodes_BacktabKeyCode
    BackspaceKeyCode = _core.KeyCodes_BackspaceKeyCode
    ReturnKeyCode = _core.KeyCodes_ReturnKeyCode
    EnterKeyCode = _core.KeyCodes_EnterKeyCode
    InsertKeyCode = _core.KeyCodes_InsertKeyCode
    DeleteKeyCode = _core.KeyCodes_DeleteKeyCode
    PauseKeyCode = _core.KeyCodes_PauseKeyCode
    PrintKeyCode = _core.KeyCodes_PrintKeyCode
    SysReqKeyCode = _core.KeyCodes_SysReqKeyCode
    ClearKeyCode = _core.KeyCodes_ClearKeyCode
    HomeKeyCode = _core.KeyCodes_HomeKeyCode
    EndKeyCode = _core.KeyCodes_EndKeyCode
    LeftKeyCode = _core.KeyCodes_LeftKeyCode
    UpKeyCode = _core.KeyCodes_UpKeyCode
    RightKeyCode = _core.KeyCodes_RightKeyCode
    DownKeyCode = _core.KeyCodes_DownKeyCode
    PageUpKeyCode = _core.KeyCodes_PageUpKeyCode
    PageDownKeyCode = _core.KeyCodes_PageDownKeyCode
    ShiftKeyCode = _core.KeyCodes_ShiftKeyCode
    ControlKeyCode = _core.KeyCodes_ControlKeyCode
    MetaKeyCode = _core.KeyCodes_MetaKeyCode
    AltKeyCode = _core.KeyCodes_AltKeyCode
    F1KeyCode = _core.KeyCodes_F1KeyCode
    F2KeyCode = _core.KeyCodes_F2KeyCode
    F3KeyCode = _core.KeyCodes_F3KeyCode
    F4KeyCode = _core.KeyCodes_F4KeyCode
    F5KeyCode = _core.KeyCodes_F5KeyCode
    F6KeyCode = _core.KeyCodes_F6KeyCode
    F7KeyCode = _core.KeyCodes_F7KeyCode
    F8KeyCode = _core.KeyCodes_F8KeyCode
    F9KeyCode = _core.KeyCodes_F9KeyCode
    F10KeyCode = _core.KeyCodes_F10KeyCode
    F11KeyCode = _core.KeyCodes_F11KeyCode
    F12KeyCode = _core.KeyCodes_F12KeyCode
    MenuKeyCode = _core.KeyCodes_MenuKeyCode
    def __init__(self): 
        this = _core.new_KeyCodes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_KeyCodes
    __del__ = lambda self : None;
KeyCodes_swigregister = _core.KeyCodes_swigregister
KeyCodes_swigregister(KeyCodes)

class KeyboardModifiers(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, KeyboardModifiers, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, KeyboardModifiers, name)
    __repr__ = _swig_repr
    NoKeyboardModifier = _core.KeyboardModifiers_NoKeyboardModifier
    ShiftKeyboardModifier = _core.KeyboardModifiers_ShiftKeyboardModifier
    CtrlKeyboardModifier = _core.KeyboardModifiers_CtrlKeyboardModifier
    AltKeyboardModifier = _core.KeyboardModifiers_AltKeyboardModifier
    MetaKeyboardModifier = _core.KeyboardModifiers_MetaKeyboardModifier
    def __init__(self): 
        this = _core.new_KeyboardModifiers()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_KeyboardModifiers
    __del__ = lambda self : None;
KeyboardModifiers_swigregister = _core.KeyboardModifiers_swigregister
KeyboardModifiers_swigregister(KeyboardModifiers)

class MouseButtons(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MouseButtons, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MouseButtons, name)
    __repr__ = _swig_repr
    NoMouseButton = _core.MouseButtons_NoMouseButton
    LeftMouseButton = _core.MouseButtons_LeftMouseButton
    RightMouseButton = _core.MouseButtons_RightMouseButton
    MiddleMouseButton = _core.MouseButtons_MiddleMouseButton
    def __init__(self): 
        this = _core.new_MouseButtons()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_MouseButtons
    __del__ = lambda self : None;
MouseButtons_swigregister = _core.MouseButtons_swigregister
MouseButtons_swigregister(MouseButtons)

class DropDownStyles(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DropDownStyles, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DropDownStyles, name)
    __repr__ = _swig_repr
    LabeledIconDropDownStyle = _core.DropDownStyles_LabeledIconDropDownStyle
    TextListDropDownStyle = _core.DropDownStyles_TextListDropDownStyle
    CheckBoxDropDownStyle = _core.DropDownStyles_CheckBoxDropDownStyle
    def __init__(self): 
        this = _core.new_DropDownStyles()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_DropDownStyles
    __del__ = lambda self : None;
DropDownStyles_swigregister = _core.DropDownStyles_swigregister
DropDownStyles_swigregister(DropDownStyles)

class TablePresentationStyles(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TablePresentationStyles, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TablePresentationStyles, name)
    __repr__ = _swig_repr
    nameValueTablePresentationStyle = _core.TablePresentationStyles_nameValueTablePresentationStyle
    itemBorderTablePresentationStyle = _core.TablePresentationStyles_itemBorderTablePresentationStyle
    transparentBackgroundTablePresentationStyle = _core.TablePresentationStyles_transparentBackgroundTablePresentationStyle
    def __init__(self): 
        this = _core.new_TablePresentationStyles()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_TablePresentationStyles
    __del__ = lambda self : None;
TablePresentationStyles_swigregister = _core.TablePresentationStyles_swigregister
TablePresentationStyles_swigregister(TablePresentationStyles)

class AttributeVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AttributeVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AttributeVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.AttributeVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.AttributeVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.AttributeVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::size_type" : return _core.AttributeVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::value_type" : return _core.AttributeVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute >,std::allocator< adsk::core::Ptr< adsk::core::Attribute > > > *" : return _core.AttributeVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.AttributeVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.AttributeVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.AttributeVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::value_type const &" : return _core.AttributeVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.AttributeVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.AttributeVector_append(self, *args)
    def empty(self) -> "bool" : return _core.AttributeVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::size_type" : return _core.AttributeVector_size(self)
    def clear(self) -> "void" : return _core.AttributeVector_clear(self)
    def swap(self, *args) -> "void" : return _core.AttributeVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::allocator_type" : return _core.AttributeVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::iterator" : return _core.AttributeVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::iterator" : return _core.AttributeVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::reverse_iterator" : return _core.AttributeVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::reverse_iterator" : return _core.AttributeVector_rend(self)
    def pop_back(self) -> "void" : return _core.AttributeVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::iterator" : return _core.AttributeVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_AttributeVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.AttributeVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::value_type const &" : return _core.AttributeVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::value_type const &" : return _core.AttributeVector_back(self)
    def assign(self, *args) -> "void" : return _core.AttributeVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.AttributeVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.AttributeVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.AttributeVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute > >::size_type" : return _core.AttributeVector_capacity(self)
    __swig_destroy__ = _core.delete_AttributeVector
    __del__ = lambda self : None;
AttributeVector_swigregister = _core.AttributeVector_swigregister
AttributeVector_swigregister(AttributeVector)

class ColorVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ColorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ColorVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.ColorVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.ColorVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.ColorVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::size_type" : return _core.ColorVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::value_type" : return _core.ColorVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Color >,std::allocator< adsk::core::Ptr< adsk::core::Color > > > *" : return _core.ColorVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.ColorVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.ColorVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.ColorVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::value_type const &" : return _core.ColorVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.ColorVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.ColorVector_append(self, *args)
    def empty(self) -> "bool" : return _core.ColorVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::size_type" : return _core.ColorVector_size(self)
    def clear(self) -> "void" : return _core.ColorVector_clear(self)
    def swap(self, *args) -> "void" : return _core.ColorVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::allocator_type" : return _core.ColorVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::iterator" : return _core.ColorVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::iterator" : return _core.ColorVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::reverse_iterator" : return _core.ColorVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::reverse_iterator" : return _core.ColorVector_rend(self)
    def pop_back(self) -> "void" : return _core.ColorVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::iterator" : return _core.ColorVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_ColorVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.ColorVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::value_type const &" : return _core.ColorVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::value_type const &" : return _core.ColorVector_back(self)
    def assign(self, *args) -> "void" : return _core.ColorVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.ColorVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.ColorVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.ColorVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color > >::size_type" : return _core.ColorVector_capacity(self)
    __swig_destroy__ = _core.delete_ColorVector
    __del__ = lambda self : None;
ColorVector_swigregister = _core.ColorVector_swigregister
ColorVector_swigregister(ColorVector)

class CommandDefinitionVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CommandDefinitionVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CommandDefinitionVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.CommandDefinitionVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.CommandDefinitionVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.CommandDefinitionVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::size_type" : return _core.CommandDefinitionVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::value_type" : return _core.CommandDefinitionVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition >,std::allocator< adsk::core::Ptr< adsk::core::CommandDefinition > > > *" : return _core.CommandDefinitionVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.CommandDefinitionVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.CommandDefinitionVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.CommandDefinitionVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::value_type const &" : return _core.CommandDefinitionVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.CommandDefinitionVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.CommandDefinitionVector_append(self, *args)
    def empty(self) -> "bool" : return _core.CommandDefinitionVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::size_type" : return _core.CommandDefinitionVector_size(self)
    def clear(self) -> "void" : return _core.CommandDefinitionVector_clear(self)
    def swap(self, *args) -> "void" : return _core.CommandDefinitionVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::allocator_type" : return _core.CommandDefinitionVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::iterator" : return _core.CommandDefinitionVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::iterator" : return _core.CommandDefinitionVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::reverse_iterator" : return _core.CommandDefinitionVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::reverse_iterator" : return _core.CommandDefinitionVector_rend(self)
    def pop_back(self) -> "void" : return _core.CommandDefinitionVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::iterator" : return _core.CommandDefinitionVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_CommandDefinitionVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.CommandDefinitionVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::value_type const &" : return _core.CommandDefinitionVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::value_type const &" : return _core.CommandDefinitionVector_back(self)
    def assign(self, *args) -> "void" : return _core.CommandDefinitionVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.CommandDefinitionVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.CommandDefinitionVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.CommandDefinitionVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition > >::size_type" : return _core.CommandDefinitionVector_capacity(self)
    __swig_destroy__ = _core.delete_CommandDefinitionVector
    __del__ = lambda self : None;
CommandDefinitionVector_swigregister = _core.CommandDefinitionVector_swigregister
CommandDefinitionVector_swigregister(CommandDefinitionVector)

class Point2DVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Point2DVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Point2DVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.Point2DVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.Point2DVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.Point2DVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::size_type" : return _core.Point2DVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::value_type" : return _core.Point2DVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D >,std::allocator< adsk::core::Ptr< adsk::core::Point2D > > > *" : return _core.Point2DVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.Point2DVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.Point2DVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.Point2DVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::value_type const &" : return _core.Point2DVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.Point2DVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.Point2DVector_append(self, *args)
    def empty(self) -> "bool" : return _core.Point2DVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::size_type" : return _core.Point2DVector_size(self)
    def clear(self) -> "void" : return _core.Point2DVector_clear(self)
    def swap(self, *args) -> "void" : return _core.Point2DVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::allocator_type" : return _core.Point2DVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::iterator" : return _core.Point2DVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::iterator" : return _core.Point2DVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::reverse_iterator" : return _core.Point2DVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::reverse_iterator" : return _core.Point2DVector_rend(self)
    def pop_back(self) -> "void" : return _core.Point2DVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::iterator" : return _core.Point2DVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_Point2DVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.Point2DVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::value_type const &" : return _core.Point2DVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::value_type const &" : return _core.Point2DVector_back(self)
    def assign(self, *args) -> "void" : return _core.Point2DVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.Point2DVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.Point2DVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.Point2DVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > >::size_type" : return _core.Point2DVector_capacity(self)
    __swig_destroy__ = _core.delete_Point2DVector
    __del__ = lambda self : None;
Point2DVector_swigregister = _core.Point2DVector_swigregister
Point2DVector_swigregister(Point2DVector)

class Point3DVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Point3DVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Point3DVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.Point3DVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.Point3DVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.Point3DVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::size_type" : return _core.Point3DVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::value_type" : return _core.Point3DVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D >,std::allocator< adsk::core::Ptr< adsk::core::Point3D > > > *" : return _core.Point3DVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.Point3DVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.Point3DVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.Point3DVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::value_type const &" : return _core.Point3DVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.Point3DVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.Point3DVector_append(self, *args)
    def empty(self) -> "bool" : return _core.Point3DVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::size_type" : return _core.Point3DVector_size(self)
    def clear(self) -> "void" : return _core.Point3DVector_clear(self)
    def swap(self, *args) -> "void" : return _core.Point3DVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::allocator_type" : return _core.Point3DVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::iterator" : return _core.Point3DVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::iterator" : return _core.Point3DVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::reverse_iterator" : return _core.Point3DVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::reverse_iterator" : return _core.Point3DVector_rend(self)
    def pop_back(self) -> "void" : return _core.Point3DVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::iterator" : return _core.Point3DVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_Point3DVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.Point3DVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::value_type const &" : return _core.Point3DVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::value_type const &" : return _core.Point3DVector_back(self)
    def assign(self, *args) -> "void" : return _core.Point3DVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.Point3DVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.Point3DVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.Point3DVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > >::size_type" : return _core.Point3DVector_capacity(self)
    __swig_destroy__ = _core.delete_Point3DVector
    __del__ = lambda self : None;
Point3DVector_swigregister = _core.Point3DVector_swigregister
Point3DVector_swigregister(Point3DVector)

class SelectionVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SelectionVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SelectionVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.SelectionVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.SelectionVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.SelectionVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::size_type" : return _core.SelectionVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::value_type" : return _core.SelectionVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Selection >,std::allocator< adsk::core::Ptr< adsk::core::Selection > > > *" : return _core.SelectionVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.SelectionVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.SelectionVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.SelectionVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::value_type const &" : return _core.SelectionVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.SelectionVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.SelectionVector_append(self, *args)
    def empty(self) -> "bool" : return _core.SelectionVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::size_type" : return _core.SelectionVector_size(self)
    def clear(self) -> "void" : return _core.SelectionVector_clear(self)
    def swap(self, *args) -> "void" : return _core.SelectionVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::allocator_type" : return _core.SelectionVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::iterator" : return _core.SelectionVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::iterator" : return _core.SelectionVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::reverse_iterator" : return _core.SelectionVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::reverse_iterator" : return _core.SelectionVector_rend(self)
    def pop_back(self) -> "void" : return _core.SelectionVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::iterator" : return _core.SelectionVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_SelectionVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.SelectionVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::value_type const &" : return _core.SelectionVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::value_type const &" : return _core.SelectionVector_back(self)
    def assign(self, *args) -> "void" : return _core.SelectionVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.SelectionVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.SelectionVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.SelectionVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection > >::size_type" : return _core.SelectionVector_capacity(self)
    __swig_destroy__ = _core.delete_SelectionVector
    __del__ = lambda self : None;
SelectionVector_swigregister = _core.SelectionVector_swigregister
SelectionVector_swigregister(SelectionVector)

class UserVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UserVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UserVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.UserVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.UserVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.UserVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::size_type" : return _core.UserVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::value_type" : return _core.UserVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::User >,std::allocator< adsk::core::Ptr< adsk::core::User > > > *" : return _core.UserVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.UserVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.UserVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.UserVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::value_type const &" : return _core.UserVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.UserVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.UserVector_append(self, *args)
    def empty(self) -> "bool" : return _core.UserVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::size_type" : return _core.UserVector_size(self)
    def clear(self) -> "void" : return _core.UserVector_clear(self)
    def swap(self, *args) -> "void" : return _core.UserVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::allocator_type" : return _core.UserVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::iterator" : return _core.UserVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::iterator" : return _core.UserVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::reverse_iterator" : return _core.UserVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::reverse_iterator" : return _core.UserVector_rend(self)
    def pop_back(self) -> "void" : return _core.UserVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::iterator" : return _core.UserVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_UserVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.UserVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::value_type const &" : return _core.UserVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::value_type const &" : return _core.UserVector_back(self)
    def assign(self, *args) -> "void" : return _core.UserVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.UserVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.UserVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.UserVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::User > >::size_type" : return _core.UserVector_capacity(self)
    __swig_destroy__ = _core.delete_UserVector
    __del__ = lambda self : None;
UserVector_swigregister = _core.UserVector_swigregister
UserVector_swigregister(UserVector)

class Vector2DVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector2DVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector2DVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.Vector2DVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.Vector2DVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.Vector2DVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::size_type" : return _core.Vector2DVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::value_type" : return _core.Vector2DVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D >,std::allocator< adsk::core::Ptr< adsk::core::Vector2D > > > *" : return _core.Vector2DVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.Vector2DVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.Vector2DVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.Vector2DVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::value_type const &" : return _core.Vector2DVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.Vector2DVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.Vector2DVector_append(self, *args)
    def empty(self) -> "bool" : return _core.Vector2DVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::size_type" : return _core.Vector2DVector_size(self)
    def clear(self) -> "void" : return _core.Vector2DVector_clear(self)
    def swap(self, *args) -> "void" : return _core.Vector2DVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::allocator_type" : return _core.Vector2DVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::iterator" : return _core.Vector2DVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::iterator" : return _core.Vector2DVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::reverse_iterator" : return _core.Vector2DVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::reverse_iterator" : return _core.Vector2DVector_rend(self)
    def pop_back(self) -> "void" : return _core.Vector2DVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::iterator" : return _core.Vector2DVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_Vector2DVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.Vector2DVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::value_type const &" : return _core.Vector2DVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::value_type const &" : return _core.Vector2DVector_back(self)
    def assign(self, *args) -> "void" : return _core.Vector2DVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.Vector2DVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.Vector2DVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.Vector2DVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector2D > >::size_type" : return _core.Vector2DVector_capacity(self)
    __swig_destroy__ = _core.delete_Vector2DVector
    __del__ = lambda self : None;
Vector2DVector_swigregister = _core.Vector2DVector_swigregister
Vector2DVector_swigregister(Vector2DVector)

class Vector3DVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector3DVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector3DVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.Vector3DVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.Vector3DVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.Vector3DVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::size_type" : return _core.Vector3DVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::value_type" : return _core.Vector3DVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D >,std::allocator< adsk::core::Ptr< adsk::core::Vector3D > > > *" : return _core.Vector3DVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.Vector3DVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.Vector3DVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.Vector3DVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::value_type const &" : return _core.Vector3DVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.Vector3DVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.Vector3DVector_append(self, *args)
    def empty(self) -> "bool" : return _core.Vector3DVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::size_type" : return _core.Vector3DVector_size(self)
    def clear(self) -> "void" : return _core.Vector3DVector_clear(self)
    def swap(self, *args) -> "void" : return _core.Vector3DVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::allocator_type" : return _core.Vector3DVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::iterator" : return _core.Vector3DVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::iterator" : return _core.Vector3DVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::reverse_iterator" : return _core.Vector3DVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::reverse_iterator" : return _core.Vector3DVector_rend(self)
    def pop_back(self) -> "void" : return _core.Vector3DVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::iterator" : return _core.Vector3DVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_Vector3DVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.Vector3DVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::value_type const &" : return _core.Vector3DVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::value_type const &" : return _core.Vector3DVector_back(self)
    def assign(self, *args) -> "void" : return _core.Vector3DVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.Vector3DVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.Vector3DVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.Vector3DVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D > >::size_type" : return _core.Vector3DVector_capacity(self)
    __swig_destroy__ = _core.delete_Vector3DVector
    __del__ = lambda self : None;
Vector3DVector_swigregister = _core.Vector3DVector_swigregister
Vector3DVector_swigregister(Vector3DVector)

class BaseVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BaseVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BaseVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.BaseVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.BaseVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.BaseVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::size_type" : return _core.BaseVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::value_type" : return _core.BaseVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Base >,std::allocator< adsk::core::Ptr< adsk::core::Base > > > *" : return _core.BaseVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.BaseVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.BaseVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.BaseVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::value_type const &" : return _core.BaseVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.BaseVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.BaseVector_append(self, *args)
    def empty(self) -> "bool" : return _core.BaseVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::size_type" : return _core.BaseVector_size(self)
    def clear(self) -> "void" : return _core.BaseVector_clear(self)
    def swap(self, *args) -> "void" : return _core.BaseVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::allocator_type" : return _core.BaseVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::iterator" : return _core.BaseVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::iterator" : return _core.BaseVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::reverse_iterator" : return _core.BaseVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::reverse_iterator" : return _core.BaseVector_rend(self)
    def pop_back(self) -> "void" : return _core.BaseVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::iterator" : return _core.BaseVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_BaseVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.BaseVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::value_type const &" : return _core.BaseVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::value_type const &" : return _core.BaseVector_back(self)
    def assign(self, *args) -> "void" : return _core.BaseVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.BaseVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.BaseVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.BaseVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base > >::size_type" : return _core.BaseVector_capacity(self)
    __swig_destroy__ = _core.delete_BaseVector
    __del__ = lambda self : None;
BaseVector_swigregister = _core.BaseVector_swigregister
BaseVector_swigregister(BaseVector)

class Appearance(Base):
    """An appearance."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Appearance, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Appearance, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Appearance *" : return _core.Appearance___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Appearance___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Appearance___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Appearance_classType
    if _newclass:classType = staticmethod(_core.Appearance_classType)
    __swig_destroy__ = _core.delete_Appearance
    __del__ = lambda self : None;
    def _get_id(self) -> "std::string" :
        """The unique internal ID of this Appearance."""
        return _core.Appearance__get_id(self)

    def _get_isUsed(self) -> "bool" :
        """Returns true if this Appearance is used in the Design."""
        return _core.Appearance__get_isUsed(self)

    def _get_usedBy(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Returns a collection of the entities currently using this appearance. This 
        property is only valid for an appearance in a Design and where the IsUsed
        property returns true. The collection returned can contain
        """
        return _core.Appearance__get_usedBy(self)

    def _get_name(self) -> "std::string" :
        """
        Returns the name of this Appearance. This is the localized name
        shown in the UI.
        """
        return _core.Appearance__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """
        Returns the name of this Appearance. This is the localized name
        shown in the UI.
        """
        return _core.Appearance__set_name(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Property that returns the Parent object of this Appearance (a MaterialLibrary, Design, or AppearanceFavorites collection)."""
        return _core.Appearance__get_parent(self)

    def _get_hasTexture(self) -> "bool" :
        """Property that indicates if this appearance has a texture associated with it."""
        return _core.Appearance__get_hasTexture(self)

    def _get_appearanceProperties(self) -> "adsk::core::Ptr< adsk::core::Properties >" :
        """returns the collection of Properties that define this appearance"""
        return _core.Appearance__get_appearanceProperties(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the Appearance from the Design. This method is only valid for appearances
        that are in a Design and are unused. 
        Returns true if the delete was successful.
        """
        return _core.Appearance_deleteMe(self)

    def copyTo(self, *args) -> "bool" :
        """
        Copies this appearance to the specified target.
        ***Depricated Method: Use the addByCopyMethod on the Appearances object instead, where you can rename the copied Appearance
        and the return type is Appearance rather than bool.*** 
        target : The target can be a Design or MaterialFavorites object. 
        Returns true if the copy was successful.
        """
        return _core.Appearance_copyTo(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Appearance__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Appearance__get_isValid(self)
Appearance_swigregister = _core.Appearance_swigregister
Appearance_swigregister(Appearance)

def Appearance_classType() -> "char const *" :
  return _core.Appearance_classType()
Appearance_classType = _core.Appearance_classType

Appearance.__swig_getmethods__["id"] = Appearance._get_id
Appearance.id = property(Appearance._get_id, doc="The unique internal ID of this Appearance.")

Appearance.__swig_getmethods__["isUsed"] = Appearance._get_isUsed
Appearance.isUsed = property(Appearance._get_isUsed, doc="Returns true if this Appearance is used in the Design.")

Appearance.__swig_getmethods__["usedBy"] = Appearance._get_usedBy
Appearance.usedBy = property(Appearance._get_usedBy, doc="Returns a collection of the entities currently using this appearance. This\nproperty is only valid for an appearance in a Design and where the IsUsed\nproperty returns true. The collection returned can contain")

Appearance.__swig_getmethods__["name"] = Appearance._get_name
Appearance.__swig_setmethods__["name"] = Appearance._set_name
Appearance.name = property(Appearance._get_name, Appearance._set_name, doc="Returns the name of this Appearance. This is the localized name\nshown in the UI.")

Appearance.__swig_getmethods__["parent"] = Appearance._get_parent
Appearance.parent = property(Appearance._get_parent, doc="Property that returns the Parent object of this Appearance (a MaterialLibrary, Design, or AppearanceFavorites collection).")

Appearance.__swig_getmethods__["hasTexture"] = Appearance._get_hasTexture
Appearance.hasTexture = property(Appearance._get_hasTexture, doc="Property that indicates if this appearance has a texture associated with it.")

Appearance.__swig_getmethods__["appearanceProperties"] = Appearance._get_appearanceProperties
Appearance.appearanceProperties = property(Appearance._get_appearanceProperties, doc="returns the collection of Properties that define this appearance")

Appearance.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Appearance) else None
Appearance.cast = lambda arg: arg if isinstance(arg, Appearance) else None

class Appearances(Base):
    """A collection of appearances."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Appearances, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Appearances, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Appearances *" : return _core.Appearances___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Appearances___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Appearances___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.Appearances___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::Appearance >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.Appearances___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Appearances_classType
    if _newclass:classType = staticmethod(_core.Appearances_classType)
    __swig_destroy__ = _core.delete_Appearances
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::Appearance >" :
        """
        Returns the specified Appearance using an index into the collection. 
        index : The index of the appearance to return where the first item in the collection is 0. 
        Returns the specified appearance or null if an invalid index is specified.
        """
        return _core.Appearances_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of Materials in the collection."""
        return _core.Appearances__get_count(self)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::core::Appearance >" :
        """
        Returns the specified Appearance using the name as seen in the user interface. This often isn't
        a reliable way of accessing a specific appearance because appearances are not required to be unique. 
        name : The name of the appearance to return,. 
        Returns the specified appearance or null if there isn't a matching name.
        """
        return _core.Appearances_itemByName(self, *args)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::Appearance >" :
        """
        Returns the Appearance by it's internal unique ID. 
        id : The ID of the appearance to return. 
        Returns the specified appearance or null if there isn't a matching ID.
        """
        return _core.Appearances_itemById(self, *args)

    def addByCopy(self, *args) -> "adsk::core::Ptr< adsk::core::Appearance >" :
        """
        Add an Appearance to a Design by copying an existing Appearance from Favorites, a Library or from the 
        appearances stored in the Design. This method currently only applies to the Appearances collection from a Design and 
        cannot be used to copy an Appearance to a library. 
        appearanceToCopy : The Appearance you want to copy. The Appearance to copy can be from Favorites, a Library or from the 
        appearances stored in the Design. 
        name : The Appearnce name to apply to the copy. 
        Returns the newly created Appearance or null if the copy operation failed.
        """
        return _core.Appearances_addByCopy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Appearances__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Appearances__get_isValid(self)
Appearances_swigregister = _core.Appearances_swigregister
Appearances_swigregister(Appearances)

def Appearances_classType() -> "char const *" :
  return _core.Appearances_classType()
Appearances_classType = _core.Appearances_classType

Appearances.__swig_getmethods__["count"] = Appearances._get_count
Appearances.count = property(Appearances._get_count, doc="The number of Materials in the collection.")

Appearances.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Appearances) else None
Appearances.cast = lambda arg: arg if isinstance(arg, Appearances) else None

class AppearanceTexture(Base):
    """Provides access to a list of properties that define a texture."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppearanceTexture, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AppearanceTexture, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::AppearanceTexture *" : return _core.AppearanceTexture___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.AppearanceTexture___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.AppearanceTexture___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.AppearanceTexture_classType
    if _newclass:classType = staticmethod(_core.AppearanceTexture_classType)
    __swig_destroy__ = _core.delete_AppearanceTexture
    __del__ = lambda self : None;
    def changeTextureImage(self, *args) -> "bool" :
        """
        Changes the image of this texture. 
        imageFilename : Input String specifying the full filename of the texture file to use. 
        Returns true if the change was successful.
        """
        return _core.AppearanceTexture_changeTextureImage(self, *args)

    def _get_properties(self) -> "adsk::core::Ptr< adsk::core::Properties >" :
        """Returns a collection of the properties associated with this texture."""
        return _core.AppearanceTexture__get_properties(self)

    def _get_textureType(self) -> "adsk::core::TextureTypes" :
        """Gets the type of texture this appearance currently is."""
        return _core.AppearanceTexture__get_textureType(self)

    def _get_objectType(self) -> "char const *" : return _core.AppearanceTexture__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.AppearanceTexture__get_isValid(self)
AppearanceTexture_swigregister = _core.AppearanceTexture_swigregister
AppearanceTexture_swigregister(AppearanceTexture)

def AppearanceTexture_classType() -> "char const *" :
  return _core.AppearanceTexture_classType()
AppearanceTexture_classType = _core.AppearanceTexture_classType

AppearanceTexture.__swig_getmethods__["properties"] = AppearanceTexture._get_properties
AppearanceTexture.properties = property(AppearanceTexture._get_properties, doc="Returns a collection of the properties associated with this texture.")

AppearanceTexture.__swig_getmethods__["textureType"] = AppearanceTexture._get_textureType
AppearanceTexture.textureType = property(AppearanceTexture._get_textureType, doc="Gets the type of texture this appearance currently is.")

AppearanceTexture.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, AppearanceTexture) else None
AppearanceTexture.cast = lambda arg: arg if isinstance(arg, AppearanceTexture) else None

class Application(Base):
    """
    The top-level object that represents the Fusion 360 application (all of Fusion 360). 
    This provides access to the modeler and files.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Application, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Application, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Application *" : return _core.Application___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Application___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Application___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Application_classType
    if _newclass:classType = staticmethod(_core.Application_classType)
    __swig_getmethods__["get"] = lambda x: _core.Application_get
    if _newclass:get = staticmethod(_core.Application_get)
    __swig_destroy__ = _core.delete_Application
    __del__ = lambda self : None;
    def _get_documents(self) -> "adsk::core::Ptr< adsk::core::Documents >" :
        """
        Returns the Documents collection object which supports accessing
        opened documents, opening existing documents, and creating new documents.
        """
        return _core.Application__get_documents(self)

    def _get_activeDocument(self) -> "adsk::core::Ptr< adsk::core::Document >" :
        """Returns the current active document."""
        return _core.Application__get_activeDocument(self)

    def _get_activeProduct(self) -> "adsk::core::Ptr< adsk::core::Product >" :
        """Returns the current active product."""
        return _core.Application__get_activeProduct(self)

    def _get_activeViewport(self) -> "adsk::core::Ptr< adsk::core::Viewport >" :
        """Returns the currently active graphics view."""
        return _core.Application__get_activeViewport(self)

    def _get_activeEditObject(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the current edit target as seen in the user interface. This edit target
        is defined as the container object that will be added to if something is created.
        For example, a component can be an edit target so that when new bodies are created they
        are added to that component. A sketch can also be an edit target.
        """
        return _core.Application__get_activeEditObject(self)

    def _get_data(self) -> "adsk::core::Ptr< adsk::core::Data >" :
        """Returns the Data object which provides access the files."""
        return _core.Application__get_data(self)

    def _get_pointTolerance(self) -> "double" :
        """The modeling tolerance used internally when comparing two points. The value is in centimeters."""
        return _core.Application__get_pointTolerance(self)

    def _get_vectorAngleTolerance(self) -> "double" :
        """The modeling tolerance used when comparing vector angles. The value is in radians."""
        return _core.Application__get_vectorAngleTolerance(self)

    def _get_preferences(self) -> "adsk::core::Ptr< adsk::core::Preferences >" :
        """Provides access to all of the application preferences."""
        return _core.Application__get_preferences(self)

    def _get_documentOpening(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >" :
        """
        The DocumentOpening event fires at the VERY start of a document being opened.
        There is no promise that the document will be opened, hence
        a documentOpened event may not follow.
        When a document is being opened that references other documents, only the 
        top-level document will cause a documentOpening event to be fired.
        """
        return _core.Application__get_documentOpening(self)

    def _get_documentOpened(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >" :
        """
        The DocumentOpened event fires at the VERY end of a document being opened so the
        Document object is avialable to be used.
        When a document is opened that references other documents, only the top-level
        document will cause the documentOpened event to be fired. You can access the
        referenced documents by using the documentReferences property of the Document object.
        """
        return _core.Application__get_documentOpened(self)

    def getLastError(self) -> "int" :
        """
        Returns information about the last error that occurred. 
        description : A description of the last error in English. 
        Returns the number of the specific error.
        """
        return _core.Application_getLastError(self)

    def _get_userInterface(self) -> "adsk::core::Ptr< adsk::core::UserInterface >" :
        """Provides access to functionality specific to the user interface."""
        return _core.Application__get_userInterface(self)

    def _get_materialLibraries(self) -> "adsk::core::Ptr< adsk::core::MaterialLibraries >" :
        """Returns the collection of material libraries currently available."""
        return _core.Application__get_materialLibraries(self)

    def _get_favoriteMaterials(self) -> "adsk::core::Ptr< adsk::core::FavoriteMaterials >" :
        """Returns the set of favorite materials."""
        return _core.Application__get_favoriteMaterials(self)

    def _get_favoriteAppearances(self) -> "adsk::core::Ptr< adsk::core::FavoriteAppearances >" :
        """Returns the set of favorite appearances."""
        return _core.Application__get_favoriteAppearances(self)

    def _get_supportedProductTypes(self) -> "std::vector< std::string,std::allocator< std::string > >" :
        """
        Returns an array containing the names of the products types currently
        supported by Fusion 360. For example, the name returned for Fusion 360 is
        'DesignProductType'. These product type names are used to identify
        specific products in some other API functions such as the productType
        property on the Workspace and ToolbarPanel objects.
        """
        return _core.Application__get_supportedProductTypes(self)

    def _get_importManager(self) -> "adsk::core::Ptr< adsk::core::ImportManager >" :
        """
        Returns the ImportManager. You use the ImportManager
        to import files (of various neutral formats.) into existing components or new document.
        """
        return _core.Application__get_importManager(self)

    def _get_userName(self) -> "std::string" :
        """Returns the user name of the Autodesk account currently logged in."""
        return _core.Application__get_userName(self)

    def _get_userId(self) -> "std::string" :
        """
        Returns the internal name of the Autodesk account currently logged in.
        This can be used by applications sold through the Autodesk Exchange Store
        to verify that the user has in fact purchased the product.
        """
        return _core.Application__get_userId(self)

    def _get_isOffLine(self) -> "bool" :
        """Gets and sets if Fusion 360 is offline or not."""
        return _core.Application__get_isOffLine(self)

    def _set_isOffLine(self, *args) -> "bool" :
        """Gets and sets if Fusion 360 is offline or not."""
        return _core.Application__set_isOffLine(self, *args)

    def _get_isStartupComplete(self) -> "bool" :
        """
        Boolean property indicating whether Fusion 360 has completed its initialization. 
        This includes initialization of all the Add-ins loaded at startup.
        """
        return _core.Application__get_isStartupComplete(self)

    def _get_onlineStatusChanged(self) -> "adsk::core::Ptr< adsk::core::ApplicationEvent >" :
        """
        The onlineStatusChanged event fires immediately after Fusion 360 goes Online or Offline. 
        This event fires whether or not the online status was changed deliberately by the user by using the Fusion 360 
        'Work Offline' command or because of inadvertent network/internet connectivity issues. 
        You can get the isOffline property of ApplicationEventArgs to determine whether Fusion 360 has gone Offline or 
        has come back Online.
        The client can add or remove ApplicationEventHandlers from the ApplicationEvent.
        """
        return _core.Application__get_onlineStatusChanged(self)

    def _get_startupCompleted(self) -> "adsk::core::Ptr< adsk::core::ApplicationEvent >" :
        """
        The startupCompleted event fires after Fusion 360 has completed its initialization. 
        This includes initialization of all the Add-ins loaded at startup.
        The client can add or remove ApplicationEventHandlers from the ApplicationEvent.
        """
        return _core.Application__get_startupCompleted(self)

    def _get_currentUser(self) -> "adsk::core::Ptr< adsk::core::User >" :
        """Returns the User that is currently logged in."""
        return _core.Application__get_currentUser(self)

    def _get_insertingFromURL(self) -> "adsk::core::Ptr< adsk::core::WebRequestEvent >" :
        """
        The insertingFromURL event fires when the user has clicked a link in a web
        page that uses the Fusion 360 protocol handler to insert a file as new component.
        This event is fired at the beginning of the request but before Fusion 360 has
        take any action so that it's still possible to cancel the operation.
        """
        return _core.Application__get_insertingFromURL(self)

    def _get_insertedFromURL(self) -> "adsk::core::Ptr< adsk::core::WebRequestEvent >" :
        """
        The insertedFromURL event fires after the user has clicked a link in a web
        page that uses the Fusion 360 protocol handler to insert a file as new component
        and that operation has completed.
        """
        return _core.Application__get_insertedFromURL(self)

    def _get_openingFromURL(self) -> "adsk::core::Ptr< adsk::core::WebRequestEvent >" :
        """
        The openingFromURL event fires when the user has clicked a link in a web
        page that uses the Fusion 360 protocol handler to create a new file using an
        existing file as the initial contents. This event is fired at the beginning 
        of the request but before Fusion 360 has take any action so that it's still 
        possible to cancel the operation.
        """
        return _core.Application__get_openingFromURL(self)

    def _get_openedFromURL(self) -> "adsk::core::Ptr< adsk::core::WebRequestEvent >" :
        """
        The openedFromURL event fires after the user has clicked a link in a web
        page that uses the Fusion 360 protocol handler to create a new using an existing
        file as the initial contents and that operation has completed.
        """
        return _core.Application__get_openedFromURL(self)

    def _get_version(self) -> "std::string" :
        """Returns the current version of the Fusion 360 application."""
        return _core.Application__get_version(self)

    def registerCustomEvent(self, *args) -> "adsk::core::Ptr< adsk::core::CustomEvent >" :
        """
        This registers a new CustomEvent which is intended to be primarily used 
        used to send an event from a worker thread you've created back to your
        add-in running in the primary thread. It's also possible that two add-ins
        could be cooperating and another add-in can fire the event to your add-in. 
        eventId : This serves as the unique ID for this event and is used by the worker thread or other
        add-in to identify which custom event to fire using the fireCustomEvent method. 
        Returns the registered CustomEvent or null in the case of failure, which would typically
        be because the provided eventId is not unique.
        """
        return _core.Application_registerCustomEvent(self, *args)

    def fireCustomEvent(self, *args) -> "bool" :
        """
        Fires a previously registered custom event. This method is used by a worker thread or another
        add-in to fire an event to the add-in that registered the event and is running in the primary thread.
        Firing a custom event does not immediately result in the event handler being called. When a custom
        event is fired the event is put on the queue and will be handled in the main thread when Fusion 360 is idle. 
        eventId : The ID of the custom event you want to fire. 
        additionalInfo : Any additional information you want to pass through the event to the add-in in the primary thread. 
        Returns true if the event was successfully added to the event queue. A value of true does not indicate
        that the event was fired and handled but only that it's been put on the primary thread's event queue to
        be fired when application is idle.
        """
        return _core.Application_fireCustomEvent(self, *args)

    def unregisterCustomEvent(self, *args) -> "bool" :
        """
        Unregisters an existing CustomEvent. 
        eventId : Th unique ID of the custom event you want to unregister. 
        Returns True if the unregister succeeded.
        """
        return _core.Application_unregisterCustomEvent(self, *args)

    def _get_documentCreated(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >" :
        """The DocumentCreated event fires when a new document is created."""
        return _core.Application__get_documentCreated(self)

    def _get_documentClosing(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >" :
        """
        The DocumentClosing event fires at the VERY start of a document being closed.
        User can set the isSaveCanceled property of DocumentEventArgs to true to cancel the document close.
        """
        return _core.Application__get_documentClosing(self)

    def _get_documentClosed(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >" :
        """
        The DocumentClosed event fires at the VERY end of a document being closed. The 
        Document object is not longer available because it has been closed.
        """
        return _core.Application__get_documentClosed(self)

    def _get_documentSaving(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >" :
        """
        The DocumentSaving event fires at the VERY start of a document being saved.
        You can set the isSaveCanceled property of DocumentEventArgs to true to cancel the document save.
        """
        return _core.Application__get_documentSaving(self)

    def _get_documentSaved(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >" :
        """The DocumentSaved event fires after the save operation has been completed."""
        return _core.Application__get_documentSaved(self)

    def _get_documentActivating(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >" :
        """The DocumentActivating event fires at the VERY start of a document being activated."""
        return _core.Application__get_documentActivating(self)

    def _get_documentActivated(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >" :
        """The DocumentActivated event fires at the VERY end of a document being activated."""
        return _core.Application__get_documentActivated(self)

    def _get_documentDeactivating(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >" :
        """The DocumentDeactivating event fires at the VERY start of a document being deactivated."""
        return _core.Application__get_documentDeactivating(self)

    def _get_documentDeactivated(self) -> "adsk::core::Ptr< adsk::core::DocumentEvent >" :
        """The DocumentDeactivated event fires at the VERY end of a document being deactivated."""
        return _core.Application__get_documentDeactivated(self)

    def _get_cameraChanged(self) -> "adsk::core::Ptr< adsk::core::CameraEvent >" :
        """
        The cameraChanged event fires immediately after a change in the camera has been made.
        Camera changes happen when user changes the view by rotating, zooming in or out, panning, 
        changing from parallel to perspective, or when the extents of the viewport changes.
        You can add or remove event handlers from the CameraEvent.
        """
        return _core.Application__get_cameraChanged(self)

    def _get_measureManager(self) -> "adsk::core::Ptr< adsk::core::MeasureManager >" :
        """Get the MeasureManager object which can be used to perform measurements of geometry."""
        return _core.Application__get_measureManager(self)

    def executeTextCommand(self, *args) -> "std::string" :
        """
        Executes the input text command. 
        command : The text command to execute. 
        Returns the result of the input text command.
        """
        return _core.Application_executeTextCommand(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Application__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Application__get_isValid(self)
Application_swigregister = _core.Application_swigregister
Application_swigregister(Application)

def Application_classType() -> "char const *" :
  return _core.Application_classType()
Application_classType = _core.Application_classType

def Application_get() -> "adsk::core::Ptr< adsk::core::Application >" :
  return _core.Application_get()
Application_get = _core.Application_get

Application.__swig_getmethods__["documents"] = Application._get_documents
Application.documents = property(Application._get_documents, doc="Returns the Documents collection object which supports accessing\nopened documents, opening existing documents, and creating new documents.")

Application.__swig_getmethods__["activeDocument"] = Application._get_activeDocument
Application.activeDocument = property(Application._get_activeDocument, doc="Returns the current active document.")

Application.__swig_getmethods__["activeProduct"] = Application._get_activeProduct
Application.activeProduct = property(Application._get_activeProduct, doc="Returns the current active product.")

Application.__swig_getmethods__["activeViewport"] = Application._get_activeViewport
Application.activeViewport = property(Application._get_activeViewport, doc="Returns the currently active graphics view.")

Application.__swig_getmethods__["activeEditObject"] = Application._get_activeEditObject
Application.activeEditObject = property(Application._get_activeEditObject, doc="Returns the current edit target as seen in the user interface. This edit target\nis defined as the container object that will be added to if something is created.\nFor example, a component can be an edit target so that when new bodies are created they\nare added to that component. A sketch can also be an edit target.")

Application.__swig_getmethods__["data"] = Application._get_data
Application.data = property(Application._get_data, doc="Returns the Data object which provides access the files.")

Application.__swig_getmethods__["pointTolerance"] = Application._get_pointTolerance
Application.pointTolerance = property(Application._get_pointTolerance, doc="The modeling tolerance used internally when comparing two points. The value is in centimeters.")

Application.__swig_getmethods__["vectorAngleTolerance"] = Application._get_vectorAngleTolerance
Application.vectorAngleTolerance = property(Application._get_vectorAngleTolerance, doc="The modeling tolerance used when comparing vector angles. The value is in radians.")

Application.__swig_getmethods__["preferences"] = Application._get_preferences
Application.preferences = property(Application._get_preferences, doc="Provides access to all of the application preferences.")

Application.__swig_getmethods__["documentOpening"] = Application._get_documentOpening
Application.documentOpening = property(Application._get_documentOpening, doc="The DocumentOpening event fires at the VERY start of a document being opened.\nThere is no promise that the document will be opened, hence\na documentOpened event may not follow.\nWhen a document is being opened that references other documents, only the\ntop-level document will cause a documentOpening event to be fired.")

Application.__swig_getmethods__["documentOpened"] = Application._get_documentOpened
Application.documentOpened = property(Application._get_documentOpened, doc="The DocumentOpened event fires at the VERY end of a document being opened so the\nDocument object is avialable to be used.\nWhen a document is opened that references other documents, only the top-level\ndocument will cause the documentOpened event to be fired. You can access the\nreferenced documents by using the documentReferences property of the Document object.")

Application.__swig_getmethods__["userInterface"] = Application._get_userInterface
Application.userInterface = property(Application._get_userInterface, doc="Provides access to functionality specific to the user interface.")

Application.__swig_getmethods__["materialLibraries"] = Application._get_materialLibraries
Application.materialLibraries = property(Application._get_materialLibraries, doc="Returns the collection of material libraries currently available.")

Application.__swig_getmethods__["favoriteMaterials"] = Application._get_favoriteMaterials
Application.favoriteMaterials = property(Application._get_favoriteMaterials, doc="Returns the set of favorite materials.")

Application.__swig_getmethods__["favoriteAppearances"] = Application._get_favoriteAppearances
Application.favoriteAppearances = property(Application._get_favoriteAppearances, doc="Returns the set of favorite appearances.")

Application.__swig_getmethods__["supportedProductTypes"] = Application._get_supportedProductTypes
Application.supportedProductTypes = property(Application._get_supportedProductTypes, doc="Returns an array containing the names of the products types currently\nsupported by Fusion 360. For example, the name returned for Fusion 360 is\n'DesignProductType'. These product type names are used to identify\nspecific products in some other API functions such as the productType\nproperty on the Workspace and ToolbarPanel objects.")

Application.__swig_getmethods__["importManager"] = Application._get_importManager
Application.importManager = property(Application._get_importManager, doc="Returns the ImportManager. You use the ImportManager\nto import files (of various neutral formats.) into existing components or new document.")

Application.__swig_getmethods__["userName"] = Application._get_userName
Application.userName = property(Application._get_userName, doc="Returns the user name of the Autodesk account currently logged in.")

Application.__swig_getmethods__["userId"] = Application._get_userId
Application.userId = property(Application._get_userId, doc="Returns the internal name of the Autodesk account currently logged in.\nThis can be used by applications sold through the Autodesk Exchange Store\nto verify that the user has in fact purchased the product.")

Application.__swig_getmethods__["isOffLine"] = Application._get_isOffLine
Application.__swig_setmethods__["isOffLine"] = Application._set_isOffLine
Application.isOffLine = property(Application._get_isOffLine, Application._set_isOffLine, doc="Gets and sets if Fusion 360 is offline or not.")

Application.__swig_getmethods__["isStartupComplete"] = Application._get_isStartupComplete
Application.isStartupComplete = property(Application._get_isStartupComplete, doc="Boolean property indicating whether Fusion 360 has completed its initialization.\nThis includes initialization of all the Add-ins loaded at startup.")

Application.__swig_getmethods__["onlineStatusChanged"] = Application._get_onlineStatusChanged
Application.onlineStatusChanged = property(Application._get_onlineStatusChanged, doc="The onlineStatusChanged event fires immediately after Fusion 360 goes Online or Offline.\nThis event fires whether or not the online status was changed deliberately by the user by using the Fusion 360\n'Work Offline' command or because of inadvertent network/internet connectivity issues.\nYou can get the isOffline property of ApplicationEventArgs to determine whether Fusion 360 has gone Offline or\nhas come back Online.\nThe client can add or remove ApplicationEventHandlers from the ApplicationEvent.")

Application.__swig_getmethods__["startupCompleted"] = Application._get_startupCompleted
Application.startupCompleted = property(Application._get_startupCompleted, doc="The startupCompleted event fires after Fusion 360 has completed its initialization.\nThis includes initialization of all the Add-ins loaded at startup.\nThe client can add or remove ApplicationEventHandlers from the ApplicationEvent.")

Application.__swig_getmethods__["currentUser"] = Application._get_currentUser
Application.currentUser = property(Application._get_currentUser, doc="Returns the User that is currently logged in.")

Application.__swig_getmethods__["insertingFromURL"] = Application._get_insertingFromURL
Application.insertingFromURL = property(Application._get_insertingFromURL, doc="The insertingFromURL event fires when the user has clicked a link in a web\npage that uses the Fusion 360 protocol handler to insert a file as new component.\nThis event is fired at the beginning of the request but before Fusion 360 has\ntake any action so that it's still possible to cancel the operation.")

Application.__swig_getmethods__["insertedFromURL"] = Application._get_insertedFromURL
Application.insertedFromURL = property(Application._get_insertedFromURL, doc="The insertedFromURL event fires after the user has clicked a link in a web\npage that uses the Fusion 360 protocol handler to insert a file as new component\nand that operation has completed.")

Application.__swig_getmethods__["openingFromURL"] = Application._get_openingFromURL
Application.openingFromURL = property(Application._get_openingFromURL, doc="The openingFromURL event fires when the user has clicked a link in a web\npage that uses the Fusion 360 protocol handler to create a new file using an\nexisting file as the initial contents. This event is fired at the beginning\nof the request but before Fusion 360 has take any action so that it's still\npossible to cancel the operation.")

Application.__swig_getmethods__["openedFromURL"] = Application._get_openedFromURL
Application.openedFromURL = property(Application._get_openedFromURL, doc="The openedFromURL event fires after the user has clicked a link in a web\npage that uses the Fusion 360 protocol handler to create a new using an existing\nfile as the initial contents and that operation has completed.")

Application.__swig_getmethods__["version"] = Application._get_version
Application.version = property(Application._get_version, doc="Returns the current version of the Fusion 360 application.")

Application.__swig_getmethods__["documentCreated"] = Application._get_documentCreated
Application.documentCreated = property(Application._get_documentCreated, doc="The DocumentCreated event fires when a new document is created.")

Application.__swig_getmethods__["documentClosing"] = Application._get_documentClosing
Application.documentClosing = property(Application._get_documentClosing, doc="The DocumentClosing event fires at the VERY start of a document being closed.\nUser can set the isSaveCanceled property of DocumentEventArgs to true to cancel the document close.")

Application.__swig_getmethods__["documentClosed"] = Application._get_documentClosed
Application.documentClosed = property(Application._get_documentClosed, doc="The DocumentClosed event fires at the VERY end of a document being closed. The\nDocument object is not longer available because it has been closed.")

Application.__swig_getmethods__["documentSaving"] = Application._get_documentSaving
Application.documentSaving = property(Application._get_documentSaving, doc="The DocumentSaving event fires at the VERY start of a document being saved.\nYou can set the isSaveCanceled property of DocumentEventArgs to true to cancel the document save.")

Application.__swig_getmethods__["documentSaved"] = Application._get_documentSaved
Application.documentSaved = property(Application._get_documentSaved, doc="The DocumentSaved event fires after the save operation has been completed.")

Application.__swig_getmethods__["documentActivating"] = Application._get_documentActivating
Application.documentActivating = property(Application._get_documentActivating, doc="The DocumentActivating event fires at the VERY start of a document being activated.")

Application.__swig_getmethods__["documentActivated"] = Application._get_documentActivated
Application.documentActivated = property(Application._get_documentActivated, doc="The DocumentActivated event fires at the VERY end of a document being activated.")

Application.__swig_getmethods__["documentDeactivating"] = Application._get_documentDeactivating
Application.documentDeactivating = property(Application._get_documentDeactivating, doc="The DocumentDeactivating event fires at the VERY start of a document being deactivated.")

Application.__swig_getmethods__["documentDeactivated"] = Application._get_documentDeactivated
Application.documentDeactivated = property(Application._get_documentDeactivated, doc="The DocumentDeactivated event fires at the VERY end of a document being deactivated.")

Application.__swig_getmethods__["cameraChanged"] = Application._get_cameraChanged
Application.cameraChanged = property(Application._get_cameraChanged, doc="The cameraChanged event fires immediately after a change in the camera has been made.\nCamera changes happen when user changes the view by rotating, zooming in or out, panning,\nchanging from parallel to perspective, or when the extents of the viewport changes.\nYou can add or remove event handlers from the CameraEvent.")

Application.__swig_getmethods__["measureManager"] = Application._get_measureManager
Application.measureManager = property(Application._get_measureManager, doc="Get the MeasureManager object which can be used to perform measurements of geometry.")

Application.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Application) else None
Application.cast = lambda arg: arg if isinstance(arg, Application) else None

class ApplicationCommandEventHandler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ApplicationCommandEventHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ApplicationCommandEventHandler, name)
    __repr__ = _swig_repr
    def notify(self, *args) -> "void" : return _core.ApplicationCommandEventHandler_notify(self, *args)
    def __init__(self): 
        if self.__class__ == ApplicationCommandEventHandler:
            _self = None
        else:
            _self = self
        this = _core.new_ApplicationCommandEventHandler(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_ApplicationCommandEventHandler
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _core.disown_ApplicationCommandEventHandler(self)
        return weakref_proxy(self)
ApplicationCommandEventHandler_swigregister = _core.ApplicationCommandEventHandler_swigregister
ApplicationCommandEventHandler_swigregister(ApplicationCommandEventHandler)

ApplicationCommandEventHandler.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ApplicationCommandEventHandler) else None
ApplicationCommandEventHandler.cast = lambda arg: arg if isinstance(arg, ApplicationCommandEventHandler) else None

class ApplicationEventHandler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ApplicationEventHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ApplicationEventHandler, name)
    __repr__ = _swig_repr
    def notify(self, *args) -> "void" : return _core.ApplicationEventHandler_notify(self, *args)
    def __init__(self): 
        if self.__class__ == ApplicationEventHandler:
            _self = None
        else:
            _self = self
        this = _core.new_ApplicationEventHandler(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_ApplicationEventHandler
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _core.disown_ApplicationEventHandler(self)
        return weakref_proxy(self)
ApplicationEventHandler_swigregister = _core.ApplicationEventHandler_swigregister
ApplicationEventHandler_swigregister(ApplicationEventHandler)

ApplicationEventHandler.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ApplicationEventHandler) else None
ApplicationEventHandler.cast = lambda arg: arg if isinstance(arg, ApplicationEventHandler) else None

class Attribute(Base):
    """
    Represents an attribute associated with a specific entity, Product, or Document.
    An attribute is a named value.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Attribute, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Attribute, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Attribute *" : return _core.Attribute___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Attribute___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Attribute___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Attribute_classType
    if _newclass:classType = staticmethod(_core.Attribute_classType)
    __swig_destroy__ = _core.delete_Attribute
    __del__ = lambda self : None;
    def _get_groupName(self) -> "std::string" :
        """Gets the name of the group this attribute is a part of."""
        return _core.Attribute__get_groupName(self)

    def _get_name(self) -> "std::string" :
        """Gets the name of the attribute."""
        return _core.Attribute__get_name(self)

    def _get_value(self) -> "std::string" :
        """
        Gets and sets the value of this attribute.
        The size of an attribute value is limited to 2MB (2097152 bytes). If you need to
        save data that is larger than 2MB you'll need to break the data into pieces and 
        save it in multiple attributes.
        """
        return _core.Attribute__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """
        Gets and sets the value of this attribute.
        The size of an attribute value is limited to 2MB (2097152 bytes). If you need to
        save data that is larger than 2MB you'll need to break the data into pieces and 
        save it in multiple attributes.
        """
        return _core.Attribute__set_value(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the parent entity this attribute is associated with. This can return null 
        in some cases. For example a BRepEdge might have been consumed by a fillet
        feature but can come back if the model is rolled back or the fillet is deleted.
        It's possible that the original parent that an attribute was placed on has been
        split. For example, if an attribute is placed on a face and then a slot is created
        that cuts the face into two pieces and the attribute is available from each face. 
        In this case the parent property will return the 'primary' face, which in most cases 
        is somewhat arbitrary. You can get the other entities the attribute is associated 
        with by using the otherParents property.
        """
        return _core.Attribute__get_parent(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes this attribute. 
        Returns true if the delete was successful.
        """
        return _core.Attribute_deleteMe(self)

    def _get_otherParents(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        In the case where the entity the attribute was originally placed on has been split,
        this property will return the other entities the attribute is associated with. 
        For example, if an attribute is placed on a face and then a slot is created
        that cuts the face into two pieces and the attribute is available from both faces. 
        The parent property returns the 'primary' entity and this property returns any other 
        entities, if any. If there aren't any other associated entities the ObjectCollection 
        returned will be empty.
        """
        return _core.Attribute__get_otherParents(self)

    def _get_objectType(self) -> "char const *" : return _core.Attribute__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Attribute__get_isValid(self)
Attribute_swigregister = _core.Attribute_swigregister
Attribute_swigregister(Attribute)

def Attribute_classType() -> "char const *" :
  return _core.Attribute_classType()
Attribute_classType = _core.Attribute_classType

Attribute.__swig_getmethods__["groupName"] = Attribute._get_groupName
Attribute.groupName = property(Attribute._get_groupName, doc="Gets the name of the group this attribute is a part of.")

Attribute.__swig_getmethods__["name"] = Attribute._get_name
Attribute.name = property(Attribute._get_name, doc="Gets the name of the attribute.")

Attribute.__swig_getmethods__["value"] = Attribute._get_value
Attribute.__swig_setmethods__["value"] = Attribute._set_value
Attribute.value = property(Attribute._get_value, Attribute._set_value, doc="Gets and sets the value of this attribute.\nThe size of an attribute value is limited to 2MB (2097152 bytes). If you need to\nsave data that is larger than 2MB you'll need to break the data into pieces and\nsave it in multiple attributes.")

Attribute.__swig_getmethods__["parent"] = Attribute._get_parent
Attribute.parent = property(Attribute._get_parent, doc="Returns the parent entity this attribute is associated with. This can return null\nin some cases. For example a BRepEdge might have been consumed by a fillet\nfeature but can come back if the model is rolled back or the fillet is deleted.\nIt's possible that the original parent that an attribute was placed on has been\nsplit. For example, if an attribute is placed on a face and then a slot is created\nthat cuts the face into two pieces and the attribute is available from each face.\nIn this case the parent property will return the 'primary' face, which in most cases\nis somewhat arbitrary. You can get the other entities the attribute is associated\nwith by using the otherParents property.")

Attribute.__swig_getmethods__["otherParents"] = Attribute._get_otherParents
Attribute.otherParents = property(Attribute._get_otherParents, doc="In the case where the entity the attribute was originally placed on has been split,\nthis property will return the other entities the attribute is associated with.\nFor example, if an attribute is placed on a face and then a slot is created\nthat cuts the face into two pieces and the attribute is available from both faces.\nThe parent property returns the 'primary' entity and this property returns any other\nentities, if any. If there aren't any other associated entities the ObjectCollection\nreturned will be empty.")

Attribute.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Attribute) else None
Attribute.cast = lambda arg: arg if isinstance(arg, Attribute) else None

class Attributes(Base):
    """
    Provides access to attributes associated with a specific entity,
    Product, or Document. Also supports the creation of new attributes.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Attributes, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Attributes, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Attributes *" : return _core.Attributes___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Attributes___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Attributes___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.Attributes___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::Attribute >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.Attributes___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Attributes_classType
    if _newclass:classType = staticmethod(_core.Attributes_classType)
    __swig_destroy__ = _core.delete_Attributes
    __del__ = lambda self : None;
    def _get_count(self) -> "size_t" :
        """Returns the number of attributes in the collection."""
        return _core.Attributes__get_count(self)

    def item(self, *args) -> "adsk::core::Ptr< adsk::core::Attribute >" :
        """
        Returns the specified attribute using an index into the collection. 
        index : The index of the attribute within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified attribute or null if an invalid index was specified.
        """
        return _core.Attributes_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::core::Attribute >" :
        """
        Returns the specified attribute using the name of the attribute. 
        groupName : The name of the attribute group this attribute will belong to. 
        name : The name of the attribute. 
        Returns the specified attribute or null if no attribute exists with the specified name.
        """
        return _core.Attributes_itemByName(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::core::Attribute >" :
        """
        Adds a new attribute to the parent entity. If an attribute already exists on the entity with the
        same groupName and name already exists, this will update the existing attribute with the new value. 
        groupName : The name of the attribute group to create this attribute within. 
        name : The name of the attribute. This must be unique with respect to other attributes in the group. 
        value : The value of the attribute. The size of an attribute value is limited to 2MB (2097152 bytes). If
        you need to save data that is larger than 2MB you'll need to break it into pieces and save it in
        multiple attributes. 
        Returns the newly created attribute or null if the creation failed. If an attribute with the 
        same groupName and name already exists, it will return the existing attribute.
        """
        return _core.Attributes_add(self, *args)

    def itemsByGroup(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute >,std::allocator< adsk::core::Ptr< adsk::core::Attribute > > >" :
        """
        Returns an array of all of the attributes that belong to the specified group. 
        groupName : The name of the group. 
        Returns an array of attributes or will fail in the case where an invalid group name is specified.
        """
        return _core.Attributes_itemsByGroup(self, *args)

    def _get_groupNames(self) -> "std::vector< std::string,std::allocator< std::string > >" :
        """
        Returns an array of strings that are all of the name of attribute groups that exist on this entity.
        An empty array can be returns if there are no attributes on the entity.
        """
        return _core.Attributes__get_groupNames(self)

    def _get_objectType(self) -> "char const *" : return _core.Attributes__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Attributes__get_isValid(self)
Attributes_swigregister = _core.Attributes_swigregister
Attributes_swigregister(Attributes)

def Attributes_classType() -> "char const *" :
  return _core.Attributes_classType()
Attributes_classType = _core.Attributes_classType

Attributes.__swig_getmethods__["count"] = Attributes._get_count
Attributes.count = property(Attributes._get_count, doc="Returns the number of attributes in the collection.")

Attributes.__swig_getmethods__["groupNames"] = Attributes._get_groupNames
Attributes.groupNames = property(Attributes._get_groupNames, doc="Returns an array of strings that are all of the name of attribute groups that exist on this entity.\nAn empty array can be returns if there are no attributes on the entity.")

Attributes.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Attributes) else None
Attributes.cast = lambda arg: arg if isinstance(arg, Attributes) else None

class BoundingBox2D(Base):
    """
    Transient object that represents a 2D bounding box. A 2D bounding box is a rectangle box that is parallel
    to the x and y axes. The box is defined by a minimum point (smallest x-y values) and maximum point (largest x-y values). 
    This object is a wrapper for these points and serves as a way to pass bounding box information
    in and out of functions. It also provides some convenience function when working with the bounding box data.
    They are created statically using the create method of the BoundingBox2D class.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoundingBox2D, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BoundingBox2D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::BoundingBox2D *" : return _core.BoundingBox2D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.BoundingBox2D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.BoundingBox2D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.BoundingBox2D_classType
    if _newclass:classType = staticmethod(_core.BoundingBox2D_classType)
    __swig_getmethods__["create"] = lambda x: _core.BoundingBox2D_create
    if _newclass:create = staticmethod(_core.BoundingBox2D_create)
    __swig_destroy__ = _core.delete_BoundingBox2D
    __del__ = lambda self : None;
    def _get_minPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """Gets and sets the minimum point of the box."""
        return _core.BoundingBox2D__get_minPoint(self)

    def _set_minPoint(self, *args) -> "bool" :
        """Gets and sets the minimum point of the box."""
        return _core.BoundingBox2D__set_minPoint(self, *args)

    def _get_maxPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """Gets and sets the maximum point of the box."""
        return _core.BoundingBox2D__get_maxPoint(self)

    def _set_maxPoint(self, *args) -> "bool" :
        """Gets and sets the maximum point of the box."""
        return _core.BoundingBox2D__set_maxPoint(self, *args)

    def contains(self, *args) -> "bool" :
        """
        Determines if the specified point lies within the bounding box. 
        point : The point to test containment with. 
        Returns true if the point lies within the bounding box.
        """
        return _core.BoundingBox2D_contains(self, *args)

    def expand(self, *args) -> "bool" :
        """
        Expand this bounding box to contain the specified point. 
        point : The point to expand the box to. 
        Returns true if successful.
        """
        return _core.BoundingBox2D_expand(self, *args)

    def intersects(self, *args) -> "bool" :
        """
        Test if this bounding box intersects with the specified bounding box. 
        boundingBox : The bounding box to test intersection with. 
        Returns true if the bounding boxes intersect.
        """
        return _core.BoundingBox2D_intersects(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::BoundingBox2D >" :
        """
        Create a copy of this bounding box. 
        Returns the new bounding box copy.
        """
        return _core.BoundingBox2D_copy(self)

    def combine(self, *args) -> "bool" :
        """
        Combines this bounding box with the input bounding box. If the input
        bounding box extends outside this bounding box then this bounding box will
        be extended to encompass both of the original bounding boxes. 
        boundingBox : The other bounding box. It is not edited but is used to extend the boundaries
        of the bounding box the method is being called on. 
        Returns true if the combine was successful.
        """
        return _core.BoundingBox2D_combine(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.BoundingBox2D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.BoundingBox2D__get_isValid(self)
BoundingBox2D_swigregister = _core.BoundingBox2D_swigregister
BoundingBox2D_swigregister(BoundingBox2D)

def BoundingBox2D_classType() -> "char const *" :
  return _core.BoundingBox2D_classType()
BoundingBox2D_classType = _core.BoundingBox2D_classType

def BoundingBox2D_create(*args) -> "adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Point2D > const &" :
  return _core.BoundingBox2D_create(*args)
BoundingBox2D_create = _core.BoundingBox2D_create

BoundingBox2D.__swig_getmethods__["minPoint"] = BoundingBox2D._get_minPoint
BoundingBox2D.__swig_setmethods__["minPoint"] = BoundingBox2D._set_minPoint
BoundingBox2D.minPoint = property(BoundingBox2D._get_minPoint, BoundingBox2D._set_minPoint, doc="Gets and sets the minimum point of the box.")

BoundingBox2D.__swig_getmethods__["maxPoint"] = BoundingBox2D._get_maxPoint
BoundingBox2D.__swig_setmethods__["maxPoint"] = BoundingBox2D._set_maxPoint
BoundingBox2D.maxPoint = property(BoundingBox2D._get_maxPoint, BoundingBox2D._set_maxPoint, doc="Gets and sets the maximum point of the box.")

BoundingBox2D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BoundingBox2D) else None
BoundingBox2D.cast = lambda arg: arg if isinstance(arg, BoundingBox2D) else None

class BoundingBox3D(Base):
    """
    Transient object that represents a 3D bounding box. 
    It defines a rectangular box whose sides are parallel to the model space x, y, and z
    planes. Because of the fixed orientation of the box it can be fully defined
    by two points at opposing corners; the min and max points. This object is usually
    used to provide a rough approximation of the volume in space that an entity occupies.
    It also provides some convenience function when working with the bounding box data.
    They are created statically using the create method of the BoundingBox3D class.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoundingBox3D, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BoundingBox3D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::BoundingBox3D *" : return _core.BoundingBox3D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.BoundingBox3D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.BoundingBox3D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.BoundingBox3D_classType
    if _newclass:classType = staticmethod(_core.BoundingBox3D_classType)
    __swig_getmethods__["create"] = lambda x: _core.BoundingBox3D_create
    if _newclass:create = staticmethod(_core.BoundingBox3D_create)
    __swig_destroy__ = _core.delete_BoundingBox3D
    __del__ = lambda self : None;
    def _get_minPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets the minimum point corner of the box."""
        return _core.BoundingBox3D__get_minPoint(self)

    def _set_minPoint(self, *args) -> "bool" :
        """Gets and sets the minimum point corner of the box."""
        return _core.BoundingBox3D__set_minPoint(self, *args)

    def _get_maxPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets the maximum point corner of the box."""
        return _core.BoundingBox3D__get_maxPoint(self)

    def _set_maxPoint(self, *args) -> "bool" :
        """Gets and sets the maximum point corner of the box."""
        return _core.BoundingBox3D__set_maxPoint(self, *args)

    def contains(self, *args) -> "bool" :
        """
        Determines if the specified point is within the bound box. 
        point : The point you want to check to see if it's in the bounding box. 
        Returns true if the point is within the bounding box.
        """
        return _core.BoundingBox3D_contains(self, *args)

    def expand(self, *args) -> "bool" :
        """
        Expands the size of bounding box to include the specified point. 
        point : The point to include within the bounding box. 
        Returns true if the expansion was successful.
        """
        return _core.BoundingBox3D_expand(self, *args)

    def intersects(self, *args) -> "bool" :
        """
        Determines if the two bounding boxes intersect. 
        boundingBox : The other bounding box to check for intersection with. 
        Returns true if the two boxes intersect.
        """
        return _core.BoundingBox3D_intersects(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """
        Creates an independent copy of this bounding box. 
        Returns the new bounding box or null if the copy failed.
        """
        return _core.BoundingBox3D_copy(self)

    def combine(self, *args) -> "bool" :
        """
        Combines this bounding box with the input bounding box. If the input
        bounding box extends outside this bounding box then this bounding box will
        be extended to encompass both of the original bounding boxes. 
        boundingBox : The other bounding box. It is not edited but is used to extend the boundaries
        of the bounding box the method is being called on. 
        Returns true if the combine was successful.
        """
        return _core.BoundingBox3D_combine(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.BoundingBox3D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.BoundingBox3D__get_isValid(self)
BoundingBox3D_swigregister = _core.BoundingBox3D_swigregister
BoundingBox3D_swigregister(BoundingBox3D)

def BoundingBox3D_classType() -> "char const *" :
  return _core.BoundingBox3D_classType()
BoundingBox3D_classType = _core.BoundingBox3D_classType

def BoundingBox3D_create(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point3D > const &" :
  return _core.BoundingBox3D_create(*args)
BoundingBox3D_create = _core.BoundingBox3D_create

BoundingBox3D.__swig_getmethods__["minPoint"] = BoundingBox3D._get_minPoint
BoundingBox3D.__swig_setmethods__["minPoint"] = BoundingBox3D._set_minPoint
BoundingBox3D.minPoint = property(BoundingBox3D._get_minPoint, BoundingBox3D._set_minPoint, doc="Gets and sets the minimum point corner of the box.")

BoundingBox3D.__swig_getmethods__["maxPoint"] = BoundingBox3D._get_maxPoint
BoundingBox3D.__swig_setmethods__["maxPoint"] = BoundingBox3D._set_maxPoint
BoundingBox3D.maxPoint = property(BoundingBox3D._get_maxPoint, BoundingBox3D._set_maxPoint, doc="Gets and sets the maximum point corner of the box.")

BoundingBox3D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BoundingBox3D) else None
BoundingBox3D.cast = lambda arg: arg if isinstance(arg, BoundingBox3D) else None

class Camera(Base):
    """
    The Camera class represents the information that specifies how a model
    is viewed and displayed. It's analogous to a real camera where it has
    a position in space, is pointed towards a specific point and is oriented
    in a particular way.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Camera, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Camera, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Camera *" : return _core.Camera___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Camera___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Camera___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Camera_classType
    if _newclass:classType = staticmethod(_core.Camera_classType)
    __swig_destroy__ = _core.delete_Camera
    __del__ = lambda self : None;
    def _get_eye(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets the position of the eye in world space."""
        return _core.Camera__get_eye(self)

    def _set_eye(self, *args) -> "bool" :
        """Gets and sets the position of the eye in world space."""
        return _core.Camera__set_eye(self, *args)

    def _get_target(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets the camera target point in world space."""
        return _core.Camera__get_target(self)

    def _set_target(self, *args) -> "bool" :
        """Gets and sets the camera target point in world space."""
        return _core.Camera__set_target(self, *args)

    def _get_cameraType(self) -> "adsk::core::CameraTypes" :
        """Gets and sets the current camera type."""
        return _core.Camera__get_cameraType(self)

    def _set_cameraType(self, *args) -> "bool" :
        """Gets and sets the current camera type."""
        return _core.Camera__set_cameraType(self, *args)

    def _get_perspectiveAngle(self) -> "double" :
        """
        Gets and sets the perspective angle of the camera. This
        property is only valid when the CameraType property is
        either Perspective or PerspectiveWithOrthoFaces.
        """
        return _core.Camera__get_perspectiveAngle(self)

    def _set_perspectiveAngle(self, *args) -> "bool" :
        """
        Gets and sets the perspective angle of the camera. This
        property is only valid when the CameraType property is
        either Perspective or PerspectiveWithOrthoFaces.
        """
        return _core.Camera__set_perspectiveAngle(self, *args)

    def _get_upVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Defines the 'up' direction for the camera which controls the orientation of the camera around the line
        defined between the eye and target points.
        """
        return _core.Camera__get_upVector(self)

    def _set_upVector(self, *args) -> "bool" :
        """
        Defines the 'up' direction for the camera which controls the orientation of the camera around the line
        defined between the eye and target points.
        """
        return _core.Camera__set_upVector(self, *args)

    def _get_viewExtents(self) -> "double" :
        """
        Defines the area that's visible by the camera. This
        value is the radius of a sphere centered at the target point.
        The camera will display everything within that sphere and
        everything in front of and behind the sphere. Additional
        geometry outside of the sphere will also be visible depending
        on the shape of the window. Setting this
        value can cause the eye and/or perspective angle to be
        modified when the camera type is perspective.
        """
        return _core.Camera__get_viewExtents(self)

    def _set_viewExtents(self, *args) -> "bool" :
        """
        Defines the area that's visible by the camera. This
        value is the radius of a sphere centered at the target point.
        The camera will display everything within that sphere and
        everything in front of and behind the sphere. Additional
        geometry outside of the sphere will also be visible depending
        on the shape of the window. Setting this
        value can cause the eye and/or perspective angle to be
        modified when the camera type is perspective.
        """
        return _core.Camera__set_viewExtents(self, *args)

    def _get_isFitView(self) -> "bool" :
        """
        If this property is true, when this camera is applied to a viewport it
        will modify the camera such that the entire model is displayed in the viewport. 
        When getting a camera from a viewport this property is always initialized to false.
        """
        return _core.Camera__get_isFitView(self)

    def _set_isFitView(self, *args) -> "bool" :
        """
        If this property is true, when this camera is applied to a viewport it
        will modify the camera such that the entire model is displayed in the viewport. 
        When getting a camera from a viewport this property is always initialized to false.
        """
        return _core.Camera__set_isFitView(self, *args)

    def _get_isSmoothTransition(self) -> "bool" :
        """
        Determines whether Fusion 360 does a smooth transition to this camera positoin when the
        camera is assigned to a ViewPort. If this is true it will do a smooth transition from
        the current camera position to the new camera position. If false, the view will jump
        to the position defined by the camera with no intermediate steps. This is useful if
        you're providing a series of cameras to control the camera animation.
        """
        return _core.Camera__get_isSmoothTransition(self)

    def _set_isSmoothTransition(self, *args) -> "bool" :
        """
        Determines whether Fusion 360 does a smooth transition to this camera positoin when the
        camera is assigned to a ViewPort. If this is true it will do a smooth transition from
        the current camera position to the new camera position. If false, the view will jump
        to the position defined by the camera with no intermediate steps. This is useful if
        you're providing a series of cameras to control the camera animation.
        """
        return _core.Camera__set_isSmoothTransition(self, *args)

    def _get_viewOrientation(self) -> "adsk::core::ViewOrientations" :
        """
        Sets the camera to a standard orientation. If this is set,
        it will result in resetting all of the camera values except
        the camera type.
        """
        return _core.Camera__get_viewOrientation(self)

    def _set_viewOrientation(self, *args) -> "bool" :
        """
        Sets the camera to a standard orientation. If this is set,
        it will result in resetting all of the camera values except
        the camera type.
        """
        return _core.Camera__set_viewOrientation(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Camera__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Camera__get_isValid(self)
Camera_swigregister = _core.Camera_swigregister
Camera_swigregister(Camera)

def Camera_classType() -> "char const *" :
  return _core.Camera_classType()
Camera_classType = _core.Camera_classType

Camera.__swig_getmethods__["eye"] = Camera._get_eye
Camera.__swig_setmethods__["eye"] = Camera._set_eye
Camera.eye = property(Camera._get_eye, Camera._set_eye, doc="Gets and sets the position of the eye in world space.")

Camera.__swig_getmethods__["target"] = Camera._get_target
Camera.__swig_setmethods__["target"] = Camera._set_target
Camera.target = property(Camera._get_target, Camera._set_target, doc="Gets and sets the camera target point in world space.")

Camera.__swig_getmethods__["cameraType"] = Camera._get_cameraType
Camera.__swig_setmethods__["cameraType"] = Camera._set_cameraType
Camera.cameraType = property(Camera._get_cameraType, Camera._set_cameraType, doc="Gets and sets the current camera type.")

Camera.__swig_getmethods__["perspectiveAngle"] = Camera._get_perspectiveAngle
Camera.__swig_setmethods__["perspectiveAngle"] = Camera._set_perspectiveAngle
Camera.perspectiveAngle = property(Camera._get_perspectiveAngle, Camera._set_perspectiveAngle, doc="Gets and sets the perspective angle of the camera. This\nproperty is only valid when the CameraType property is\neither Perspective or PerspectiveWithOrthoFaces.")

Camera.__swig_getmethods__["upVector"] = Camera._get_upVector
Camera.__swig_setmethods__["upVector"] = Camera._set_upVector
Camera.upVector = property(Camera._get_upVector, Camera._set_upVector, doc="Defines the 'up' direction for the camera which controls the orientation of the camera around the line\ndefined between the eye and target points.")

Camera.__swig_getmethods__["viewExtents"] = Camera._get_viewExtents
Camera.__swig_setmethods__["viewExtents"] = Camera._set_viewExtents
Camera.viewExtents = property(Camera._get_viewExtents, Camera._set_viewExtents, doc="Defines the area that's visible by the camera. This\nvalue is the radius of a sphere centered at the target point.\nThe camera will display everything within that sphere and\neverything in front of and behind the sphere. Additional\ngeometry outside of the sphere will also be visible depending\non the shape of the window. Setting this\nvalue can cause the eye and/or perspective angle to be\nmodified when the camera type is perspective.")

Camera.__swig_getmethods__["isFitView"] = Camera._get_isFitView
Camera.__swig_setmethods__["isFitView"] = Camera._set_isFitView
Camera.isFitView = property(Camera._get_isFitView, Camera._set_isFitView, doc="If this property is true, when this camera is applied to a viewport it\nwill modify the camera such that the entire model is displayed in the viewport.\nWhen getting a camera from a viewport this property is always initialized to false.")

Camera.__swig_getmethods__["isSmoothTransition"] = Camera._get_isSmoothTransition
Camera.__swig_setmethods__["isSmoothTransition"] = Camera._set_isSmoothTransition
Camera.isSmoothTransition = property(Camera._get_isSmoothTransition, Camera._set_isSmoothTransition, doc="Determines whether Fusion 360 does a smooth transition to this camera positoin when the\ncamera is assigned to a ViewPort. If this is true it will do a smooth transition from\nthe current camera position to the new camera position. If false, the view will jump\nto the position defined by the camera with no intermediate steps. This is useful if\nyou're providing a series of cameras to control the camera animation.")

Camera.__swig_getmethods__["viewOrientation"] = Camera._get_viewOrientation
Camera.__swig_setmethods__["viewOrientation"] = Camera._set_viewOrientation
Camera.viewOrientation = property(Camera._get_viewOrientation, Camera._set_viewOrientation, doc="Sets the camera to a standard orientation. If this is set,\nit will result in resetting all of the camera values except\nthe camera type.")

Camera.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Camera) else None
Camera.cast = lambda arg: arg if isinstance(arg, Camera) else None

class CameraEventHandler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CameraEventHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CameraEventHandler, name)
    __repr__ = _swig_repr
    def notify(self, *args) -> "void" : return _core.CameraEventHandler_notify(self, *args)
    def __init__(self): 
        if self.__class__ == CameraEventHandler:
            _self = None
        else:
            _self = self
        this = _core.new_CameraEventHandler(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_CameraEventHandler
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _core.disown_CameraEventHandler(self)
        return weakref_proxy(self)
CameraEventHandler_swigregister = _core.CameraEventHandler_swigregister
CameraEventHandler_swigregister(CameraEventHandler)

CameraEventHandler.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CameraEventHandler) else None
CameraEventHandler.cast = lambda arg: arg if isinstance(arg, CameraEventHandler) else None

class Color(Base):
    """The Color class wraps all of the information that defines a simple color."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Color, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Color, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Color *" : return _core.Color___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Color___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Color___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Color_classType
    if _newclass:classType = staticmethod(_core.Color_classType)
    __swig_getmethods__["create"] = lambda x: _core.Color_create
    if _newclass:create = staticmethod(_core.Color_create)
    __swig_destroy__ = _core.delete_Color
    __del__ = lambda self : None;
    def _get_red(self) -> "short" :
        """Gets and sets the red component of the color. The value can be 0 to 255."""
        return _core.Color__get_red(self)

    def _set_red(self, *args) -> "bool" :
        """Gets and sets the red component of the color. The value can be 0 to 255."""
        return _core.Color__set_red(self, *args)

    def _get_green(self) -> "short" :
        """Gets and sets the green component of the color. The value can be 0 to 255."""
        return _core.Color__get_green(self)

    def _set_green(self, *args) -> "bool" :
        """Gets and sets the green component of the color. The value can be 0 to 255."""
        return _core.Color__set_green(self, *args)

    def _get_blue(self) -> "short" :
        """Gets and sets the blue component of the color. The value can be 0 to 255."""
        return _core.Color__get_blue(self)

    def _set_blue(self, *args) -> "bool" :
        """Gets and sets the blue component of the color. The value can be 0 to 255."""
        return _core.Color__set_blue(self, *args)

    def _get_opacity(self) -> "short" :
        """Gets and sets the opacity of the color. The value can be 0 to 255."""
        return _core.Color__get_opacity(self)

    def _set_opacity(self, *args) -> "bool" :
        """Gets and sets the opacity of the color. The value can be 0 to 255."""
        return _core.Color__set_opacity(self, *args)

    def getColor(self) -> "bool" :
        """
        Gets all of the information defining this color. 
        red : The red component of the color. The value can be 0 to 255. 
        green : The green component of the color. The value can be 0 to 255. 
        blue : The blue component of the color. The value can be 0 to 255. 
        opacity : The opacity of the color. The value can be 0 to 255. A value of 255 indicates
        it is completely opaque. 
        Returns true if getting the color information was successful.
        """
        return _core.Color_getColor(self)

    def setColor(self, *args) -> "bool" :
        """
        Sets all of the color information. 
        red : The red component of the color. The value can be 0 to 255. 
        green : The green component of the color. The value can be 0 to 255. 
        blue : The blue component of the color. The value can be 0 to 255. 
        opacity : The opacity of the color. The value can be 0 to 255. A value of 255 indicates
        it is completely opaque. Depending on where the color is used, the opacity
        value may be ignored. 
        Returns true if setting the color information was successful.
        """
        return _core.Color_setColor(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Color__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Color__get_isValid(self)
Color_swigregister = _core.Color_swigregister
Color_swigregister(Color)

def Color_classType() -> "char const *" :
  return _core.Color_classType()
Color_classType = _core.Color_classType

def Color_create(*args) -> "adsk::core::Ptr< adsk::core::Color >" :
  return _core.Color_create(*args)
Color_create = _core.Color_create

Color.__swig_getmethods__["red"] = Color._get_red
Color.__swig_setmethods__["red"] = Color._set_red
Color.red = property(Color._get_red, Color._set_red, doc="Gets and sets the red component of the color. The value can be 0 to 255.")

Color.__swig_getmethods__["green"] = Color._get_green
Color.__swig_setmethods__["green"] = Color._set_green
Color.green = property(Color._get_green, Color._set_green, doc="Gets and sets the green component of the color. The value can be 0 to 255.")

Color.__swig_getmethods__["blue"] = Color._get_blue
Color.__swig_setmethods__["blue"] = Color._set_blue
Color.blue = property(Color._get_blue, Color._set_blue, doc="Gets and sets the blue component of the color. The value can be 0 to 255.")

Color.__swig_getmethods__["opacity"] = Color._get_opacity
Color.__swig_setmethods__["opacity"] = Color._set_opacity
Color.opacity = property(Color._get_opacity, Color._set_opacity, doc="Gets and sets the opacity of the color. The value can be 0 to 255.")

Color.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Color) else None
Color.cast = lambda arg: arg if isinstance(arg, Color) else None

class Command(Base):
    """
    The Command class contains all of the functionality needed by a command to gather
    various command input from a user, provide previews, and create the final result
    which is also encapsulated within a transaction so it can be undone.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Command, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Command, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Command *" : return _core.Command___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Command___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Command___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Command_classType
    if _newclass:classType = staticmethod(_core.Command_classType)
    __swig_destroy__ = _core.delete_Command
    __del__ = lambda self : None;
    def _get_parentCommandDefinition(self) -> "adsk::core::Ptr< adsk::core::CommandDefinition >" :
        """Gets the parent CommandDefinition object."""
        return _core.Command__get_parentCommandDefinition(self)

    def _get_activate(self) -> "adsk::core::Ptr< adsk::core::CommandEvent >" :
        """
        Gets an event that is fired when the command is first activated or re-activated after being suspended. 
        Returns a CommandEvent object that is used to connect and release from the event.
        """
        return _core.Command__get_activate(self)

    def _get_deactivate(self) -> "adsk::core::Ptr< adsk::core::CommandEvent >" :
        """
        Gets an event that is fired when the command is deactivated. The command still exists and could still be activated again. 
        Returns a CommandEvent object that is used to connect and release from the event.
        """
        return _core.Command__get_deactivate(self)

    def _get_destroy(self) -> "adsk::core::Ptr< adsk::core::CommandEvent >" :
        """
        Gets an event that is fired when the command is destroyed. The command is destroyed and can be cleaned up. 
        Returns a CommandEvent object that is used to connect and release from the event.
        """
        return _core.Command__get_destroy(self)

    def _get_execute(self) -> "adsk::core::Ptr< adsk::core::CommandEvent >" :
        """
        Gets an event that is fired when the command has completed gathering the required input and now
        needs to perform whatever action the command does. 
        Returns a CommandEvent object that is used to connect and release from the event.
        """
        return _core.Command__get_execute(self)

    def _get_executePreview(self) -> "adsk::core::Ptr< adsk::core::CommandEvent >" :
        """
        Gets an event that is fired when the command has completed gathering the required input and now
        needs to perform a preview. 
        Returns a CommandEvent object that is used to connect and release from the event.
        """
        return _core.Command__get_executePreview(self)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """
        Gets the associated CommandInputs object which provides the ability
        to create new command inputs and provides access to any existing inputs
        that have already been created for this command.
        """
        return _core.Command__get_commandInputs(self)

    def _get_inputChanged(self) -> "adsk::core::Ptr< adsk::core::InputChangedEvent >" :
        """
        Gets an event that is fired whenever an input value is changed. 
        Returns an InputChangedEvent object that is used to connect and release from the event.
        """
        return _core.Command__get_inputChanged(self)

    def _get_validateInputs(self) -> "adsk::core::Ptr< adsk::core::ValidateInputsEvent >" :
        """
        Gets an event that is fired to allow you to check if the current state of the inputs are valid for execution. 
        Returns a ValidateInputsEvent object that is used to connect and release from the event.
        """
        return _core.Command__get_validateInputs(self)

    def _get_keyDown(self) -> "adsk::core::Ptr< adsk::core::KeyboardEvent >" :
        """Geta an event that is fired when a key on the keyboard is pressed down."""
        return _core.Command__get_keyDown(self)

    def _get_keyUp(self) -> "adsk::core::Ptr< adsk::core::KeyboardEvent >" :
        """Gets an event that is fired when a key on the keyboard goes up."""
        return _core.Command__get_keyUp(self)

    def _get_mouseClick(self) -> "adsk::core::Ptr< adsk::core::MouseEvent >" :
        """Gets an event that is fired when the mouse is clicked, (a button is pressed and released)."""
        return _core.Command__get_mouseClick(self)

    def _get_mouseDoubleClick(self) -> "adsk::core::Ptr< adsk::core::MouseEvent >" :
        """Gets an event that is fired when the mouse is double-clicked, (clicked twice within the time specified by a system setting.)"""
        return _core.Command__get_mouseDoubleClick(self)

    def _get_mouseDown(self) -> "adsk::core::Ptr< adsk::core::MouseEvent >" :
        """Gets an event that is fired when a mouse button is pressed."""
        return _core.Command__get_mouseDown(self)

    def _get_mouseMove(self) -> "adsk::core::Ptr< adsk::core::MouseEvent >" :
        """Gets an event that is fired when the mouse is moved."""
        return _core.Command__get_mouseMove(self)

    def _get_mouseUp(self) -> "adsk::core::Ptr< adsk::core::MouseEvent >" :
        """Gets an event that is fired when a mouse button is released."""
        return _core.Command__get_mouseUp(self)

    def _get_mouseWheel(self) -> "adsk::core::Ptr< adsk::core::MouseEvent >" :
        """Gets an event that is fired when the mouse wheel is rotated."""
        return _core.Command__get_mouseWheel(self)

    def _get_mouseDragBegin(self) -> "adsk::core::Ptr< adsk::core::MouseEvent >" :
        """
        Gets an event that is fired when a mouse drag starts, 
        (the mouse is pressed and moved).
        """
        return _core.Command__get_mouseDragBegin(self)

    def _get_mouseDrag(self) -> "adsk::core::Ptr< adsk::core::MouseEvent >" :
        """
        Gets an event that is fired when the mouse is in drag mode, 
        (being moved while a button is pressed).
        """
        return _core.Command__get_mouseDrag(self)

    def _get_mouseDragEnd(self) -> "adsk::core::Ptr< adsk::core::MouseEvent >" :
        """Gets an event that is fired when the mouse button is released after a drag."""
        return _core.Command__get_mouseDragEnd(self)

    def _get_isOKButtonVisible(self) -> "bool" :
        """
        Specifies if the OK button is visible or not.
        If set to false then the OK button is removed and the
        'CANCEL' button text changes to 'CLOSE'. You can override
        the default button text using the cancelButtonText property.
        """
        return _core.Command__get_isOKButtonVisible(self)

    def _set_isOKButtonVisible(self, *args) -> "bool" :
        """
        Specifies if the OK button is visible or not.
        If set to false then the OK button is removed and the
        'CANCEL' button text changes to 'CLOSE'. You can override
        the default button text using the cancelButtonText property.
        """
        return _core.Command__set_isOKButtonVisible(self, *args)

    def _get_okButtonText(self) -> "std::string" :
        """
        Gets and sets the text displayed on the OK button. When the OK and Cancel
        buttons are displayed, this text defaults to 'OK'. If the Cancel button
        is not displayed the text defaults to 'CLOSE'.
        """
        return _core.Command__get_okButtonText(self)

    def _set_okButtonText(self, *args) -> "bool" :
        """
        Gets and sets the text displayed on the OK button. When the OK and Cancel
        buttons are displayed, this text defaults to 'OK'. If the Cancel button
        is not displayed the text defaults to 'CLOSE'.
        """
        return _core.Command__set_okButtonText(self, *args)

    def _get_cancelButtonText(self) -> "std::string" :
        """
        Gets and sets the text displayed on the Cancel button. The value of this
        property is ignored if the isCancelButtonVisible property is false.
        """
        return _core.Command__get_cancelButtonText(self)

    def _set_cancelButtonText(self, *args) -> "bool" :
        """
        Gets and sets the text displayed on the Cancel button. The value of this
        property is ignored if the isCancelButtonVisible property is false.
        """
        return _core.Command__set_cancelButtonText(self, *args)

    def setDialogInitialSize(self, *args) -> "bool" :
        """
        Sets the initial size of the dialog when it is first displayed. If this is not
        set, Fusion 360 will use a default size for the dialog. 
        width : The width of the dialog in pixels. 
        height : The height of the dialog in pixels. 
        Returns true if the default size was successfully set.
        """
        return _core.Command_setDialogInitialSize(self, *args)

    def setDialogMinimumSize(self, *args) -> "bool" :
        """
        Sets the minimum size for the dialog when resized to by the user. If this is not
        set, a default minimum size is used. 
        width : The minimum width of the dialog in pixels. 
        height : The minimum height of the dialog in pixels. 
        Returns true if the minimum size was successfully set.
        """
        return _core.Command_setDialogMinimumSize(self, *args)

    def _get_isRepeatable(self) -> "bool" :
        """Gets and Sets if this command is repeatable using the 'Repeat Last Command' option from the Fusion 360 marking menu."""
        return _core.Command__get_isRepeatable(self)

    def _set_isRepeatable(self, *args) -> "bool" :
        """Gets and Sets if this command is repeatable using the 'Repeat Last Command' option from the Fusion 360 marking menu."""
        return _core.Command__set_isRepeatable(self, *args)

    def _get_selectionEvent(self) -> "adsk::core::Ptr< adsk::core::SelectionEvent >" :
        """This event has been retired. Equivalent functionality is supported by the preSelect event."""
        return _core.Command__get_selectionEvent(self)

    def _get_isExecutedWhenPreEmpted(self) -> "bool" :
        """
        Specifies what the behavior will be when a command is pre-empted by the user executing another
        command. If true (the default), and all of the current inputs are valid, the command will be 
        executed just the same as if the user clicked the OK button. If false, the command is terminated.
        """
        return _core.Command__get_isExecutedWhenPreEmpted(self)

    def _set_isExecutedWhenPreEmpted(self, *args) -> "bool" :
        """
        Specifies what the behavior will be when a command is pre-empted by the user executing another
        command. If true (the default), and all of the current inputs are valid, the command will be 
        executed just the same as if the user clicked the OK button. If false, the command is terminated.
        """
        return _core.Command__set_isExecutedWhenPreEmpted(self, *args)

    def _get_helpFile(self) -> "std::string" :
        """
        <p class='api'>Gets and sets the associated html help file for this command. If this is defined
        then the help button will be displayed in the lower-left corner of the command dialog
        and when clicked the help file will be displayed using the application defined by the
        operating system for that file type. For example if the helpfile references a .htm or .html
        file, the default browser will be invoked to display the file. If a .pdf file is used then
        whatever the default application is for viewing a pdf file will be invoked.</p>
        <p class='api'>The file referenced must be a local file and cannot be a url. However, you can use a local
        html file that redirects to a url.</p>
        <pre class='api-code'><html>
        &lt;head&gt;
        &lt;meta http-equiv='refresh' content='0; url=http://example.com/' /&gt;
        &lt;/head&gt;
        &lt;body&gt;&lt;/body&gt;
        &lt;/html&gt;
        </pre>
        <p class='api'>The filename can be either a full path or a relative path with respect to the script or add-in 
        .py, .js, .dll, or .dylib file. If this is an empty string, (which is the default), then the 
        help button will not be displayed.</p>
        """
        return _core.Command__get_helpFile(self)

    def _set_helpFile(self, *args) -> "bool" :
        """
        <p class='api'>Gets and sets the associated html help file for this command. If this is defined
        then the help button will be displayed in the lower-left corner of the command dialog
        and when clicked the help file will be displayed using the application defined by the
        operating system for that file type. For example if the helpfile references a .htm or .html
        file, the default browser will be invoked to display the file. If a .pdf file is used then
        whatever the default application is for viewing a pdf file will be invoked.</p>
        <p class='api'>The file referenced must be a local file and cannot be a url. However, you can use a local
        html file that redirects to a url.</p>
        <pre class='api-code'><html>
        &lt;head&gt;
        &lt;meta http-equiv='refresh' content='0; url=http://example.com/' /&gt;
        &lt;/head&gt;
        &lt;body&gt;&lt;/body&gt;
        &lt;/html&gt;
        </pre>
        <p class='api'>The filename can be either a full path or a relative path with respect to the script or add-in 
        .py, .js, .dll, or .dylib file. If this is an empty string, (which is the default), then the 
        help button will not be displayed.</p>
        """
        return _core.Command__set_helpFile(self, *args)

    def _get_isAutoExecute(self) -> "bool" :
        """
        Gets and sets whether this command will automatically execute if no command inputs have been
        defined. If any command inputs have been created, the value of this property is ignored and
        the command dialog will be displayed and the command will execute when the user clicks 'OK'.
        if no command inputs have been defined and this is set to False, then the command will not
        execute but will remain running.
        The default value for this property is true so that the command will execute if no command inputs
        have been defined.
        """
        return _core.Command__get_isAutoExecute(self)

    def _set_isAutoExecute(self, *args) -> "bool" :
        """
        Gets and sets whether this command will automatically execute if no command inputs have been
        defined. If any command inputs have been created, the value of this property is ignored and
        the command dialog will be displayed and the command will execute when the user clicks 'OK'.
        if no command inputs have been defined and this is set to False, then the command will not
        execute but will remain running.
        The default value for this property is true so that the command will execute if no command inputs
        have been defined.
        """
        return _core.Command__set_isAutoExecute(self, *args)

    def doExecute(self, *args) -> "bool" :
        """
        Causes the execution of this command which results in the execute event being fired. This is the
        same effect as the user clicking the 'OK' button in the command dialog and is most useful when there
        is no command dialog (no command inputs where created) and the isAutoExecute property has been set
        to False. This allows you to execute the command through code. 
        terminate : In the case where there isn't a command dialog you can also use the terminate argument to specify if 
        the command should terminate after execution or continue running. This is similar to the sketch line
        command where each line placement results in the creation of an undoable line but the command continues
        to run to allow additional lines to be placed. 
        Returns true if the execution of the command was successful.
        """
        return _core.Command_doExecute(self, *args)

    def doExecutePreview(self) -> "bool" :
        """
        Causes the executePreview event of this command to be fired. This is most useful when there
        is no command dialog (no command inputs where created) and the isAutoExecute property has been set
        to False. This allows you to force the preview to be generated instead of relying on changing
        command inputs. 
        Returns true if the execute Preview event was successfully fired..
        """
        return _core.Command_doExecutePreview(self)

    def _get_isPositionDependent(self) -> "bool" :
        """
        When working in a parametric design in Fusion and you move any occurrences, those move operations are
        pending and aren't captured until you use the 'Capture Position' command from the POSITION panel or
        use the 'Revert' command from the same panel to move them all back to their original positions. If
        the design is in a pending situation and you run a command like 'Create Sketch', a dialog appears
        asking if you want to capture the current position or not before continuing. This is because
        the creation of a sketch can be dependent on the current positions of occurrences in the design. Other comamnds, like
        'Fillet', depend directly on model geometry and do not rely on occurrence positions so running the Fillet command
        does not display the dialog and does not affect the pending state of the occurrences.
        This property allows you to specify if your command is dependent on the current position of occurrences
        or not. One good way to know if your command is dependent or not is to run the commands in the UI that are 
        equivalent to the API functions you're using and see if the dialog that prompts to save or abort appears. 
        If it does, then you know your command is dependent on occurrence positions.
        If this property is true, then the dialog will appear if there are any pending moved occurrences.
        The user can choose whether to capture the current changes or abort them, and then your command will continue.
        If you set this property to false, (which is the default), then even if there are pending changes, the occurrences 
        are left in their current positions and your command will run.
        """
        return _core.Command__get_isPositionDependent(self)

    def _set_isPositionDependent(self, *args) -> "bool" :
        """
        When working in a parametric design in Fusion and you move any occurrences, those move operations are
        pending and aren't captured until you use the 'Capture Position' command from the POSITION panel or
        use the 'Revert' command from the same panel to move them all back to their original positions. If
        the design is in a pending situation and you run a command like 'Create Sketch', a dialog appears
        asking if you want to capture the current position or not before continuing. This is because
        the creation of a sketch can be dependent on the current positions of occurrences in the design. Other comamnds, like
        'Fillet', depend directly on model geometry and do not rely on occurrence positions so running the Fillet command
        does not display the dialog and does not affect the pending state of the occurrences.
        This property allows you to specify if your command is dependent on the current position of occurrences
        or not. One good way to know if your command is dependent or not is to run the commands in the UI that are 
        equivalent to the API functions you're using and see if the dialog that prompts to save or abort appears. 
        If it does, then you know your command is dependent on occurrence positions.
        If this property is true, then the dialog will appear if there are any pending moved occurrences.
        The user can choose whether to capture the current changes or abort them, and then your command will continue.
        If you set this property to false, (which is the default), then even if there are pending changes, the occurrences 
        are left in their current positions and your command will run.
        """
        return _core.Command__set_isPositionDependent(self, *args)

    def setCursor(self, *args) -> "bool" :
        """
        Specifies the cursor to display at the mouse. 
        cursorImage : The path to the png image to display as the cursor. This can either be a relative path from the py, dll, or dylib file
        of the full path. Specifying an empty string will set the cursor back to the default cursor. 
        xHotSpot : Specifies the position of the x pixel within the image that is the 'hot' spot or the point that is used as the mouse point. A value of
        zero indicates the far left of the image. If an empty string is used as the cursorImage, this value is ignored. 
        yHotSpot : Specifies the position of the y pixel within the image that is the 'hot' spot or the point that is used as the mouse point. A value of
        zero indicates the top of the image. If an empty string is used as the cursorImage, this value is ignored. 
        Returns true if setting the cursor was successful.
        """
        return _core.Command_setCursor(self, *args)

    def getCursor(self) -> "bool" :
        """
        Gets the custom cursor information currently being used. 
        cursorImage : The full path to the png image that is being displayed as the cursor. 
        xHotSpot : Gets the position of the x pixel within the image that is the 'hot' spot or the point that is used as the mouse point. A value of
        zero indicates the left of the image. 
        yHotSpot : Gets the position of the y pixel within the image that is the 'hot' spot or the point that is used as the mouse point. A value of
        zero indicates the top of the image. 
        Returns true if getting the cursor information was successful.
        """
        return _core.Command_getCursor(self)

    def _get_preSelect(self) -> "adsk::core::Ptr< adsk::core::SelectionEvent >" :
        """
        This event is used to be able to particpate in the selection process in a dynamic way. 
        When a user is selecting geometry, they move the mouse over the model and if the 
        entity the mouse is currently over is valid for selection it will highlight indicating that 
        it can be selected. This process of determining what is available for selection and highlighting
        it is refered to as the 'pre-select' behavior. 
        You use functions on the SelectionCommandInput object to define what types of entities are
        selectable and in many cases this coarse level of specification is all that's needed, but in other
        cases you may need more control over the selection. For example, you might want to allow the user to
        selection construction planes and planar faces, which can easily be controlled by defining those as
        valid entities for selection in the SelectionCommandInput object. But if you only want to allow the
        user to select planes that are parallel then you need some dynamic control over the selection, which
        can be done using the preSelect event.
        In the example of selecting parallel planes, you would still set the valid selection types for the
        SelectionCommandInput to allow selection of construction planes and planar faces. This will limit
        the selection to only planes but any plane can still be selected. You'll also need to connect to the
        preSelect event for the command. As the user moves the mouse over any construction plane
        or planar face, the preSelect event will fire for the plane the mouse is current over. If no planes
        have yet been selected, then you allow allow the user to select this plane. If one or more planes have
        already selected, then in the preSelect event you'll check to see if the plane the mouse is over is 
        parallel to the first plane already selected. If it is then you allow it to be selected. If it isn't 
        parallel then you set the isSelectable property of the provided SelectEventArgs object to False so 
        that it won't pre-highlight and won't be selectable.
        The entity and mouse position on the entity can be obtained through the Selection object returned 
        through the selection property of the SelectionEventArgs object provided through the event.
        """
        return _core.Command__get_preSelect(self)

    def _get_preSelectMouseMove(self) -> "adsk::core::Ptr< adsk::core::SelectionEvent >" :
        """
        This event fires continually while the mouse is moved over an entity that is valid for selected.
        The entity and mouse position on the entity can be obtained through the Selection object returned 
        through the selection property of the SelectionEventArgs object provided through the event.
        """
        return _core.Command__get_preSelectMouseMove(self)

    def _get_preSelectEnd(self) -> "adsk::core::Ptr< adsk::core::SelectionEvent >" :
        """
        This event fires when the moused is moved away from an entity that was in a pre-select state. If
        your add-in has done something in reaction to the preSelect, like draw some custom graphics, this
        event provides the notification to clean up whatever you've done that's associated with the current
        pre-select.
        The entity and mouse position on the entity can be obtained through the Selection object returned 
        through the selection property of the SelectionEventArgs object provided through the event.
        """
        return _core.Command__get_preSelectEnd(self)

    def _get_select(self) -> "adsk::core::Ptr< adsk::core::SelectionEvent >" :
        """
        This even fires when the user selects an entity. This is different from the pre-select where an
        entity is shown as being available for selection as the mouse passes over the entity. This is the actual
        selection where the user has clicked the mouse on the entity.
        The entity and mouse position on the entity can be obtained through the Selection object returned 
        through the selection property of the SelectionEventArgs object provided through the event.
        """
        return _core.Command__get_select(self)

    def _get_unselect(self) -> "adsk::core::Ptr< adsk::core::SelectionEvent >" :
        """
        This even fires when the user unselects an entity by clicking the mouse again on selected entity
        or canceling previous selection.
        The entity and mouse position on the entity can be obtained through the Selection object returned 
        through the selection property of the SelectionEventArgs object provided through the event.
        """
        return _core.Command__get_unselect(self)

    def _get_objectType(self) -> "char const *" : return _core.Command__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Command__get_isValid(self)
Command_swigregister = _core.Command_swigregister
Command_swigregister(Command)

def Command_classType() -> "char const *" :
  return _core.Command_classType()
Command_classType = _core.Command_classType

Command.__swig_getmethods__["parentCommandDefinition"] = Command._get_parentCommandDefinition
Command.parentCommandDefinition = property(Command._get_parentCommandDefinition, doc="Gets the parent CommandDefinition object.")

Command.__swig_getmethods__["activate"] = Command._get_activate
Command.activate = property(Command._get_activate, doc="Gets an event that is fired when the command is first activated or re-activated after being suspended.\nReturns a CommandEvent object that is used to connect and release from the event.")

Command.__swig_getmethods__["deactivate"] = Command._get_deactivate
Command.deactivate = property(Command._get_deactivate, doc="Gets an event that is fired when the command is deactivated. The command still exists and could still be activated again.\nReturns a CommandEvent object that is used to connect and release from the event.")

Command.__swig_getmethods__["destroy"] = Command._get_destroy
Command.destroy = property(Command._get_destroy, doc="Gets an event that is fired when the command is destroyed. The command is destroyed and can be cleaned up.\nReturns a CommandEvent object that is used to connect and release from the event.")

Command.__swig_getmethods__["execute"] = Command._get_execute
Command.execute = property(Command._get_execute, doc="Gets an event that is fired when the command has completed gathering the required input and now\nneeds to perform whatever action the command does.\nReturns a CommandEvent object that is used to connect and release from the event.")

Command.__swig_getmethods__["executePreview"] = Command._get_executePreview
Command.executePreview = property(Command._get_executePreview, doc="Gets an event that is fired when the command has completed gathering the required input and now\nneeds to perform a preview.\nReturns a CommandEvent object that is used to connect and release from the event.")

Command.__swig_getmethods__["commandInputs"] = Command._get_commandInputs
Command.commandInputs = property(Command._get_commandInputs, doc="Gets the associated CommandInputs object which provides the ability\nto create new command inputs and provides access to any existing inputs\nthat have already been created for this command.")

Command.__swig_getmethods__["inputChanged"] = Command._get_inputChanged
Command.inputChanged = property(Command._get_inputChanged, doc="Gets an event that is fired whenever an input value is changed.\nReturns an InputChangedEvent object that is used to connect and release from the event.")

Command.__swig_getmethods__["validateInputs"] = Command._get_validateInputs
Command.validateInputs = property(Command._get_validateInputs, doc="Gets an event that is fired to allow you to check if the current state of the inputs are valid for execution.\nReturns a ValidateInputsEvent object that is used to connect and release from the event.")

Command.__swig_getmethods__["keyDown"] = Command._get_keyDown
Command.keyDown = property(Command._get_keyDown, doc="Geta an event that is fired when a key on the keyboard is pressed down.")

Command.__swig_getmethods__["keyUp"] = Command._get_keyUp
Command.keyUp = property(Command._get_keyUp, doc="Gets an event that is fired when a key on the keyboard goes up.")

Command.__swig_getmethods__["mouseClick"] = Command._get_mouseClick
Command.mouseClick = property(Command._get_mouseClick, doc="Gets an event that is fired when the mouse is clicked, (a button is pressed and released).")

Command.__swig_getmethods__["mouseDoubleClick"] = Command._get_mouseDoubleClick
Command.mouseDoubleClick = property(Command._get_mouseDoubleClick, doc="Gets an event that is fired when the mouse is double-clicked, (clicked twice within the time specified by a system setting.)")

Command.__swig_getmethods__["mouseDown"] = Command._get_mouseDown
Command.mouseDown = property(Command._get_mouseDown, doc="Gets an event that is fired when a mouse button is pressed.")

Command.__swig_getmethods__["mouseMove"] = Command._get_mouseMove
Command.mouseMove = property(Command._get_mouseMove, doc="Gets an event that is fired when the mouse is moved.")

Command.__swig_getmethods__["mouseUp"] = Command._get_mouseUp
Command.mouseUp = property(Command._get_mouseUp, doc="Gets an event that is fired when a mouse button is released.")

Command.__swig_getmethods__["mouseWheel"] = Command._get_mouseWheel
Command.mouseWheel = property(Command._get_mouseWheel, doc="Gets an event that is fired when the mouse wheel is rotated.")

Command.__swig_getmethods__["mouseDragBegin"] = Command._get_mouseDragBegin
Command.mouseDragBegin = property(Command._get_mouseDragBegin, doc="Gets an event that is fired when a mouse drag starts,\n(the mouse is pressed and moved).")

Command.__swig_getmethods__["mouseDrag"] = Command._get_mouseDrag
Command.mouseDrag = property(Command._get_mouseDrag, doc="Gets an event that is fired when the mouse is in drag mode,\n(being moved while a button is pressed).")

Command.__swig_getmethods__["mouseDragEnd"] = Command._get_mouseDragEnd
Command.mouseDragEnd = property(Command._get_mouseDragEnd, doc="Gets an event that is fired when the mouse button is released after a drag.")

Command.__swig_getmethods__["isOKButtonVisible"] = Command._get_isOKButtonVisible
Command.__swig_setmethods__["isOKButtonVisible"] = Command._set_isOKButtonVisible
Command.isOKButtonVisible = property(Command._get_isOKButtonVisible, Command._set_isOKButtonVisible, doc="Specifies if the OK button is visible or not.\nIf set to false then the OK button is removed and the\n'CANCEL' button text changes to 'CLOSE'. You can override\nthe default button text using the cancelButtonText property.")

Command.__swig_getmethods__["okButtonText"] = Command._get_okButtonText
Command.__swig_setmethods__["okButtonText"] = Command._set_okButtonText
Command.okButtonText = property(Command._get_okButtonText, Command._set_okButtonText, doc="Gets and sets the text displayed on the OK button. When the OK and Cancel\nbuttons are displayed, this text defaults to 'OK'. If the Cancel button\nis not displayed the text defaults to 'CLOSE'.")

Command.__swig_getmethods__["cancelButtonText"] = Command._get_cancelButtonText
Command.__swig_setmethods__["cancelButtonText"] = Command._set_cancelButtonText
Command.cancelButtonText = property(Command._get_cancelButtonText, Command._set_cancelButtonText, doc="Gets and sets the text displayed on the Cancel button. The value of this\nproperty is ignored if the isCancelButtonVisible property is false.")

Command.__swig_getmethods__["isRepeatable"] = Command._get_isRepeatable
Command.__swig_setmethods__["isRepeatable"] = Command._set_isRepeatable
Command.isRepeatable = property(Command._get_isRepeatable, Command._set_isRepeatable, doc="Gets and Sets if this command is repeatable using the 'Repeat Last Command' option from the Fusion 360 marking menu.")

Command.__swig_getmethods__["selectionEvent"] = Command._get_selectionEvent
Command.selectionEvent = property(Command._get_selectionEvent, doc="This event has been retired. Equivalent functionality is supported by the preSelect event.")

Command.__swig_getmethods__["isExecutedWhenPreEmpted"] = Command._get_isExecutedWhenPreEmpted
Command.__swig_setmethods__["isExecutedWhenPreEmpted"] = Command._set_isExecutedWhenPreEmpted
Command.isExecutedWhenPreEmpted = property(Command._get_isExecutedWhenPreEmpted, Command._set_isExecutedWhenPreEmpted, doc="Specifies what the behavior will be when a command is pre-empted by the user executing another\ncommand. If true (the default), and all of the current inputs are valid, the command will be\nexecuted just the same as if the user clicked the OK button. If false, the command is terminated.")

Command.__swig_getmethods__["helpFile"] = Command._get_helpFile
Command.__swig_setmethods__["helpFile"] = Command._set_helpFile
Command.helpFile = property(Command._get_helpFile, Command._set_helpFile, doc="<p class='api'>Gets and sets the associated html help file for this command. If this is defined\nthen the help button will be displayed in the lower-left corner of the command dialog\nand when clicked the help file will be displayed using the application defined by the\noperating system for that file type. For example if the helpfile references a .htm or .html\nfile, the default browser will be invoked to display the file. If a .pdf file is used then\nwhatever the default application is for viewing a pdf file will be invoked.</p>\n<p class='api'>The file referenced must be a local file and cannot be a url. However, you can use a local\nhtml file that redirects to a url.</p>\n<pre class='api-code'><html>\n&lt;head&gt;\n&lt;meta http-equiv='refresh' content='0; url=http://example.com/' /&gt;\n&lt;/head&gt;\n&lt;body&gt;&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n<p class='api'>The filename can be either a full path or a relative path with respect to the script or add-in\n.py, .js, .dll, or .dylib file. If this is an empty string, (which is the default), then the\nhelp button will not be displayed.</p>")

Command.__swig_getmethods__["isAutoExecute"] = Command._get_isAutoExecute
Command.__swig_setmethods__["isAutoExecute"] = Command._set_isAutoExecute
Command.isAutoExecute = property(Command._get_isAutoExecute, Command._set_isAutoExecute, doc="Gets and sets whether this command will automatically execute if no command inputs have been\ndefined. If any command inputs have been created, the value of this property is ignored and\nthe command dialog will be displayed and the command will execute when the user clicks 'OK'.\nif no command inputs have been defined and this is set to False, then the command will not\nexecute but will remain running.\nThe default value for this property is true so that the command will execute if no command inputs\nhave been defined.")

Command.__swig_getmethods__["isPositionDependent"] = Command._get_isPositionDependent
Command.__swig_setmethods__["isPositionDependent"] = Command._set_isPositionDependent
Command.isPositionDependent = property(Command._get_isPositionDependent, Command._set_isPositionDependent, doc="When working in a parametric design in Fusion and you move any occurrences, those move operations are\npending and aren't captured until you use the 'Capture Position' command from the POSITION panel or\nuse the 'Revert' command from the same panel to move them all back to their original positions. If\nthe design is in a pending situation and you run a command like 'Create Sketch', a dialog appears\nasking if you want to capture the current position or not before continuing. This is because\nthe creation of a sketch can be dependent on the current positions of occurrences in the design. Other comamnds, like\n'Fillet', depend directly on model geometry and do not rely on occurrence positions so running the Fillet command\ndoes not display the dialog and does not affect the pending state of the occurrences.\nThis property allows you to specify if your command is dependent on the current position of occurrences\nor not. One good way to know if your command is dependent or not is to run the commands in the UI that are\nequivalent to the API functions you're using and see if the dialog that prompts to save or abort appears.\nIf it does, then you know your command is dependent on occurrence positions.\nIf this property is true, then the dialog will appear if there are any pending moved occurrences.\nThe user can choose whether to capture the current changes or abort them, and then your command will continue.\nIf you set this property to false, (which is the default), then even if there are pending changes, the occurrences\nare left in their current positions and your command will run.")

Command.__swig_getmethods__["preSelect"] = Command._get_preSelect
Command.preSelect = property(Command._get_preSelect, doc="This event is used to be able to particpate in the selection process in a dynamic way.\nWhen a user is selecting geometry, they move the mouse over the model and if the\nentity the mouse is currently over is valid for selection it will highlight indicating that\nit can be selected. This process of determining what is available for selection and highlighting\nit is refered to as the 'pre-select' behavior.\nYou use functions on the SelectionCommandInput object to define what types of entities are\nselectable and in many cases this coarse level of specification is all that's needed, but in other\ncases you may need more control over the selection. For example, you might want to allow the user to\nselection construction planes and planar faces, which can easily be controlled by defining those as\nvalid entities for selection in the SelectionCommandInput object. But if you only want to allow the\nuser to select planes that are parallel then you need some dynamic control over the selection, which\ncan be done using the preSelect event.\nIn the example of selecting parallel planes, you would still set the valid selection types for the\nSelectionCommandInput to allow selection of construction planes and planar faces. This will limit\nthe selection to only planes but any plane can still be selected. You'll also need to connect to the\npreSelect event for the command. As the user moves the mouse over any construction plane\nor planar face, the preSelect event will fire for the plane the mouse is current over. If no planes\nhave yet been selected, then you allow allow the user to select this plane. If one or more planes have\nalready selected, then in the preSelect event you'll check to see if the plane the mouse is over is\nparallel to the first plane already selected. If it is then you allow it to be selected. If it isn't\nparallel then you set the isSelectable property of the provided SelectEventArgs object to False so\nthat it won't pre-highlight and won't be selectable.\nThe entity and mouse position on the entity can be obtained through the Selection object returned\nthrough the selection property of the SelectionEventArgs object provided through the event.")

Command.__swig_getmethods__["preSelectMouseMove"] = Command._get_preSelectMouseMove
Command.preSelectMouseMove = property(Command._get_preSelectMouseMove, doc="This event fires continually while the mouse is moved over an entity that is valid for selected.\nThe entity and mouse position on the entity can be obtained through the Selection object returned\nthrough the selection property of the SelectionEventArgs object provided through the event.")

Command.__swig_getmethods__["preSelectEnd"] = Command._get_preSelectEnd
Command.preSelectEnd = property(Command._get_preSelectEnd, doc="This event fires when the moused is moved away from an entity that was in a pre-select state. If\nyour add-in has done something in reaction to the preSelect, like draw some custom graphics, this\nevent provides the notification to clean up whatever you've done that's associated with the current\npre-select.\nThe entity and mouse position on the entity can be obtained through the Selection object returned\nthrough the selection property of the SelectionEventArgs object provided through the event.")

Command.__swig_getmethods__["select"] = Command._get_select
Command.select = property(Command._get_select, doc="This even fires when the user selects an entity. This is different from the pre-select where an\nentity is shown as being available for selection as the mouse passes over the entity. This is the actual\nselection where the user has clicked the mouse on the entity.\nThe entity and mouse position on the entity can be obtained through the Selection object returned\nthrough the selection property of the SelectionEventArgs object provided through the event.")

Command.__swig_getmethods__["unselect"] = Command._get_unselect
Command.unselect = property(Command._get_unselect, doc="This even fires when the user unselects an entity by clicking the mouse again on selected entity\nor canceling previous selection.\nThe entity and mouse position on the entity can be obtained through the Selection object returned\nthrough the selection property of the SelectionEventArgs object provided through the event.")

Command.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Command) else None
Command.cast = lambda arg: arg if isinstance(arg, Command) else None

class CommandCreatedEventHandler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CommandCreatedEventHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CommandCreatedEventHandler, name)
    __repr__ = _swig_repr
    def notify(self, *args) -> "void" : return _core.CommandCreatedEventHandler_notify(self, *args)
    def __init__(self): 
        if self.__class__ == CommandCreatedEventHandler:
            _self = None
        else:
            _self = self
        this = _core.new_CommandCreatedEventHandler(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_CommandCreatedEventHandler
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _core.disown_CommandCreatedEventHandler(self)
        return weakref_proxy(self)
CommandCreatedEventHandler_swigregister = _core.CommandCreatedEventHandler_swigregister
CommandCreatedEventHandler_swigregister(CommandCreatedEventHandler)

CommandCreatedEventHandler.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CommandCreatedEventHandler) else None
CommandCreatedEventHandler.cast = lambda arg: arg if isinstance(arg, CommandCreatedEventHandler) else None

class CommandDefinition(Base):
    """
    The CommandDefinition is the base class of the various types of commands. Command types are based
    on the type of control used to execute them in the user-interface. For example, most commands will
    use a ButtonDefinition since they're executed using a button in the user-interface. A command definition
    contains the information that defines the user-interface. For example, the name and icon. The command
    definition and also gets the notification when the user interacts with the associated control.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CommandDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CommandDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::CommandDefinition *" : return _core.CommandDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.CommandDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.CommandDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.CommandDefinition_classType
    if _newclass:classType = staticmethod(_core.CommandDefinition_classType)
    __swig_destroy__ = _core.delete_CommandDefinition
    __del__ = lambda self : None;
    def execute(self, *args) -> "bool" :
        """
        Executes this command definition. This is the same as the user clicking
        a button that is associated with this command definition. 
        input : A list of named values that will provide input to the command. The values supported are unique for each command.
        and not all commands support input values. 
        Returns true or false indicating if the execution was successful.
        """
        return _core.CommandDefinition_execute(self, *args)

    def _get_commandCreated(self) -> "adsk::core::Ptr< adsk::core::CommandCreatedEvent >" :
        """
        This event is fired when the associated control is manipulated by the user. A new Command object 
        is created and passed back through this event which you can then use to interact with the user
        to get any input the command requires.
        """
        return _core.CommandDefinition__get_commandCreated(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes this command definition. This is only valid for API created command definitions
        and will fail if the isNative property is true. 
        Returns true or false indicating if the deletion was successful.
        """
        return _core.CommandDefinition_deleteMe(self)

    def _get_isNative(self) -> "bool" :
        """
        Gets if this is a native command definition. If True then there
        are limitations to edits that can be done on the command definition.
        For example a native command definition cannot be deleted.
        """
        return _core.CommandDefinition__get_isNative(self)

    def _get_id(self) -> "std::string" :
        """
        Gets the unique id for this command definition. This is guaranteed to be unique with
        respect to all other command definitions.
        """
        return _core.CommandDefinition__get_id(self)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip. 
        The tooltip is always shown but as the user hovers over the control it will progressively display the tool clip along with the tooltip text.
        """
        return _core.CommandDefinition__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip. 
        The tooltip is always shown but as the user hovers over the control it will progressively display the tool clip along with the tooltip text.
        """
        return _core.CommandDefinition__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description and/or tool clip are also specified then
        the tooltip will progressively display more information as the user hovers the mouse over the control.
        """
        return _core.CommandDefinition__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description and/or tool clip are also specified then
        the tooltip will progressively display more information as the user hovers the mouse over the control.
        """
        return _core.CommandDefinition__set_tooltip(self, *args)

    def _get_resourceFolder(self) -> "std::string" :
        """
        Gets or sets the directory that contains any additional files associated with this command.
        These are typically the image files that will be used for a button and the 
        html files for a tool clip or helps and tips.
        """
        return _core.CommandDefinition__get_resourceFolder(self)

    def _set_resourceFolder(self, *args) -> "bool" :
        """
        Gets or sets the directory that contains any additional files associated with this command.
        These are typically the image files that will be used for a button and the 
        html files for a tool clip or helps and tips.
        """
        return _core.CommandDefinition__set_resourceFolder(self, *args)

    def _get_controlDefinition(self) -> "adsk::core::Ptr< adsk::core::ControlDefinition >" :
        """
        Gets the ControlDefinition associated with this command. The control definition
        defines the type of control that can exist in the user interface to execute this command.
        You can use properties on the control definition to define the look and behavior of 
        the control.
        """
        return _core.CommandDefinition__get_controlDefinition(self)

    def _get_name(self) -> "std::string" :
        """Gets or sets the visible name of the command when seen in the user interface."""
        return _core.CommandDefinition__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Gets or sets the visible name of the command when seen in the user interface."""
        return _core.CommandDefinition__set_name(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.CommandDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.CommandDefinition__get_isValid(self)
CommandDefinition_swigregister = _core.CommandDefinition_swigregister
CommandDefinition_swigregister(CommandDefinition)

def CommandDefinition_classType() -> "char const *" :
  return _core.CommandDefinition_classType()
CommandDefinition_classType = _core.CommandDefinition_classType

CommandDefinition.__swig_getmethods__["commandCreated"] = CommandDefinition._get_commandCreated
CommandDefinition.commandCreated = property(CommandDefinition._get_commandCreated, doc="This event is fired when the associated control is manipulated by the user. A new Command object\nis created and passed back through this event which you can then use to interact with the user\nto get any input the command requires.")

CommandDefinition.__swig_getmethods__["isNative"] = CommandDefinition._get_isNative
CommandDefinition.isNative = property(CommandDefinition._get_isNative, doc="Gets if this is a native command definition. If True then there\nare limitations to edits that can be done on the command definition.\nFor example a native command definition cannot be deleted.")

CommandDefinition.__swig_getmethods__["id"] = CommandDefinition._get_id
CommandDefinition.id = property(CommandDefinition._get_id, doc="Gets the unique id for this command definition. This is guaranteed to be unique with\nrespect to all other command definitions.")

CommandDefinition.__swig_getmethods__["toolClipFilename"] = CommandDefinition._get_toolClipFilename
CommandDefinition.__swig_setmethods__["toolClipFilename"] = CommandDefinition._set_toolClipFilename
CommandDefinition.toolClipFilename = property(CommandDefinition._get_toolClipFilename, CommandDefinition._set_toolClipFilename, doc="Gets or sets the full filename of the image file (png) used for the tool clip.\nThe tooltip is always shown but as the user hovers over the control it will progressively display the tool clip along with the tooltip text.")

CommandDefinition.__swig_getmethods__["tooltip"] = CommandDefinition._get_tooltip
CommandDefinition.__swig_setmethods__["tooltip"] = CommandDefinition._set_tooltip
CommandDefinition.tooltip = property(CommandDefinition._get_tooltip, CommandDefinition._set_tooltip, doc="Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description and/or tool clip are also specified then\nthe tooltip will progressively display more information as the user hovers the mouse over the control.")

CommandDefinition.__swig_getmethods__["resourceFolder"] = CommandDefinition._get_resourceFolder
CommandDefinition.__swig_setmethods__["resourceFolder"] = CommandDefinition._set_resourceFolder
CommandDefinition.resourceFolder = property(CommandDefinition._get_resourceFolder, CommandDefinition._set_resourceFolder, doc="Gets or sets the directory that contains any additional files associated with this command.\nThese are typically the image files that will be used for a button and the\nhtml files for a tool clip or helps and tips.")

CommandDefinition.__swig_getmethods__["controlDefinition"] = CommandDefinition._get_controlDefinition
CommandDefinition.controlDefinition = property(CommandDefinition._get_controlDefinition, doc="Gets the ControlDefinition associated with this command. The control definition\ndefines the type of control that can exist in the user interface to execute this command.\nYou can use properties on the control definition to define the look and behavior of\nthe control.")

CommandDefinition.__swig_getmethods__["name"] = CommandDefinition._get_name
CommandDefinition.__swig_setmethods__["name"] = CommandDefinition._set_name
CommandDefinition.name = property(CommandDefinition._get_name, CommandDefinition._set_name, doc="Gets or sets the visible name of the command when seen in the user interface.")

CommandDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CommandDefinition) else None
CommandDefinition.cast = lambda arg: arg if isinstance(arg, CommandDefinition) else None

class CommandDefinitions(Base):
    """
    Provides access to all of the available command definitions. This is all those created via
    the API but also includes the command definitions defined by Fusion 360 for the native commands.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CommandDefinitions, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CommandDefinitions, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::CommandDefinitions *" : return _core.CommandDefinitions___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.CommandDefinitions___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.CommandDefinitions___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.CommandDefinitions___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::CommandDefinition >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.CommandDefinitions___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.CommandDefinitions_classType
    if _newclass:classType = staticmethod(_core.CommandDefinitions_classType)
    __swig_destroy__ = _core.delete_CommandDefinitions
    __del__ = lambda self : None;
    def addButtonDefinition(self, *args) -> "adsk::core::Ptr< adsk::core::CommandDefinition >" :
        """
        Creates a new command definition that can be used to create a button control and handle the response when the button is clicked. 
        id : The unique identifier for this command definition. It must be unique with respect to all other command definitions and is
        limited to the following set of characters, [A-Z][a-z][0-9] and _. 
        name : The name displayed in the UI for the associated button control. 
        tooltip : The full description of the command as seen in the extended tooltip in the user interface.
        Using the returned CommandDefinition you can also optionally set the toolClipFilename property
        to show an image the extended tooltip. 
        resourceFolder : Specifies the folder where the resources for this command are located. These are various sizes and styles of png
        files that are used for the button image. To fully support all potential options you should create files with
        the following names and sizes: 16x16.png , 32x32.png, 32x32@2x.png (used for retina only), 16x16-dark.png, 32x32-dark.png, 32x32-dark@2x.png
        The dark images are used when the command is highlighted and can contain lighter lines to contrast better with the blue highlighting. If
        you don't provide dark images Fusion 360 will use the regular images when highlighting the button.
        This is an optional argument and if not provided a default icon will be used. 
        Returns the created CommandDefinition object or null if the creation failed.
        """
        return _core.CommandDefinitions_addButtonDefinition(self, *args)

    def addCheckBoxDefinition(self, *args) -> "adsk::core::Ptr< adsk::core::CommandDefinition >" :
        """
        Creates a new command definition that can be used to create a single check box control and handle the response when the check box is clicked. 
        id : The unique identifier for this command definition. It must be unique with respect to all other command definitions and is
        limited to the following set of characters, [A-Z][a-z][0-9] and _. 
        name : The name displayed in the UI for the associated check box control. 
        tooltip : The full description of the command as seen in the extended tooltip in the user interface.
        Using the returned CommandDefinition you can also optionally set the toolClipFilename property
        to show an image in the extended tooltip. 
        isChecked : Indicates if the initial state of the check box. 
        Returns the created CommandDefinition object or null if the creation failed.
        """
        return _core.CommandDefinitions_addCheckBoxDefinition(self, *args)

    def addListDefinition(self, *args) -> "adsk::core::Ptr< adsk::core::CommandDefinition >" :
        """
        Creates a new command definition that can be used to create a list of check boxes, radio buttons, or text with an icon within a pop-up. 
        When the list is of check boxes any combinations of items in the list can be checked. The drop-down also remains displayed allowing the user to
        check and uncheck multiple items however a CommandCreated event is fired for every change.
        When the list is of radio buttons or a list of text items, only one item in the list can be selected at a time. 
        When an item is selected the drop-down is immediately dismissed.
        The items in the list and their initial state are defined using functionality on the associated ListControlDefinition, which is
        accessible through the returned CommandDefinition. 
        id : The unique identifier for this command definition. It must be unique with respect to all other command definitions and is
        limited to the following set of characters, [A-Z][a-z][0-9] and _. 
        name : The name displayed in the UI for the associated selected check box list control. 
        listControlDisplayType : Specifies the type of controls to be displayed within the list. 
        resourceFolder : The folder containing any resources used for items in this list. 
        Returns the created CommandDefinition object or null if the creation failed.
        """
        return _core.CommandDefinitions_addListDefinition(self, *args)

    def item(self, *args) -> "adsk::core::Ptr< adsk::core::CommandDefinition >" :
        """
        Returns the CommandDefinition at the specified index. 
        index : The index of the command definition within the collection to return. The first item in the
        collection has in index of 0. 
        Returns the CommandDefinition at the specified index or null if an invalid index is specified.
        """
        return _core.CommandDefinitions_item(self, *args)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::CommandDefinition >" :
        """
        Returns the CommandDefinition that has the specified ID. 
        id : The ID of the command definition to return. 
        Returns the CommandDefinition with the specified ID or null if there isn't a command definition with that ID.
        """
        return _core.CommandDefinitions_itemById(self, *args)

    def _get_count(self) -> "size_t" :
        """Gets the number of command definitions."""
        return _core.CommandDefinitions__get_count(self)

    def _get_objectType(self) -> "char const *" : return _core.CommandDefinitions__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.CommandDefinitions__get_isValid(self)
CommandDefinitions_swigregister = _core.CommandDefinitions_swigregister
CommandDefinitions_swigregister(CommandDefinitions)

def CommandDefinitions_classType() -> "char const *" :
  return _core.CommandDefinitions_classType()
CommandDefinitions_classType = _core.CommandDefinitions_classType

CommandDefinitions.__swig_getmethods__["count"] = CommandDefinitions._get_count
CommandDefinitions.count = property(CommandDefinitions._get_count, doc="Gets the number of command definitions.")

CommandDefinitions.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CommandDefinitions) else None
CommandDefinitions.cast = lambda arg: arg if isinstance(arg, CommandDefinitions) else None

class CommandEventHandler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CommandEventHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CommandEventHandler, name)
    __repr__ = _swig_repr
    def notify(self, *args) -> "void" : return _core.CommandEventHandler_notify(self, *args)
    def __init__(self): 
        if self.__class__ == CommandEventHandler:
            _self = None
        else:
            _self = self
        this = _core.new_CommandEventHandler(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_CommandEventHandler
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _core.disown_CommandEventHandler(self)
        return weakref_proxy(self)
CommandEventHandler_swigregister = _core.CommandEventHandler_swigregister
CommandEventHandler_swigregister(CommandEventHandler)

CommandEventHandler.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CommandEventHandler) else None
CommandEventHandler.cast = lambda arg: arg if isinstance(arg, CommandEventHandler) else None

class CommandInput(Base):
    """The base class for all command inputs. A CommandInput is used to gather an input value from the user when a command is executed."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::CommandInput *" : return _core.CommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.CommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.CommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.CommandInput_classType
    if _newclass:classType = staticmethod(_core.CommandInput_classType)
    __swig_destroy__ = _core.delete_CommandInput
    __del__ = lambda self : None;
    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.CommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.CommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.CommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.CommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.CommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.CommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.CommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.CommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.CommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.CommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.CommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.CommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.CommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.CommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.CommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.CommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.CommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.CommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.CommandInput__get_isValid(self)
CommandInput_swigregister = _core.CommandInput_swigregister
CommandInput_swigregister(CommandInput)

def CommandInput_classType() -> "char const *" :
  return _core.CommandInput_classType()
CommandInput_classType = _core.CommandInput_classType

CommandInput.__swig_getmethods__["commandInputs"] = CommandInput._get_commandInputs
CommandInput.commandInputs = property(CommandInput._get_commandInputs, doc="Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput.")

CommandInput.__swig_getmethods__["id"] = CommandInput._get_id
CommandInput.id = property(CommandInput._get_id, doc="Gets the unique identifier for this input in the command's CommandInputs.")

CommandInput.__swig_getmethods__["name"] = CommandInput._get_name
CommandInput.name = property(CommandInput._get_name, doc="Gets the user visible name of this input.")

CommandInput.__swig_getmethods__["isEnabled"] = CommandInput._get_isEnabled
CommandInput.__swig_setmethods__["isEnabled"] = CommandInput._set_isEnabled
CommandInput.isEnabled = property(CommandInput._get_isEnabled, CommandInput._set_isEnabled, doc="Gets or sets if this input is currently enabled or disabled for user interaction.")

CommandInput.__swig_getmethods__["isVisible"] = CommandInput._get_isVisible
CommandInput.__swig_setmethods__["isVisible"] = CommandInput._set_isVisible
CommandInput.isVisible = property(CommandInput._get_isVisible, CommandInput._set_isVisible, doc="Gets or sets if this input will be visible to the user.")

CommandInput.__swig_getmethods__["parentCommand"] = CommandInput._get_parentCommand
CommandInput.parentCommand = property(CommandInput._get_parentCommand, doc="Gets the parent Command.")

CommandInput.__swig_getmethods__["isFullWidth"] = CommandInput._get_isFullWidth
CommandInput.__swig_setmethods__["isFullWidth"] = CommandInput._set_isFullWidth
CommandInput.isFullWidth = property(CommandInput._get_isFullWidth, CommandInput._set_isFullWidth, doc="Gets or sets if this input fills the entire width of the dialog. If\ntrue, the name is ignored and the input control will fill the entire width of the command dialog.\nThe default value for this property in a new command input if false, or not to fill the width.\nThis property does not apply to GroupCommandInputs or TabCommandInputs.")

CommandInput.__swig_getmethods__["toolClipFilename"] = CommandInput._get_toolClipFilename
CommandInput.__swig_setmethods__["toolClipFilename"] = CommandInput._set_toolClipFilename
CommandInput.toolClipFilename = property(CommandInput._get_toolClipFilename, CommandInput._set_toolClipFilename, doc="Gets or sets the full filename of the image file (png) used for the tool clip.\nThe tooltip is always shown but as the user hovers over the control it will progressively display\nthe tool clip and description text.")

CommandInput.__swig_getmethods__["tooltip"] = CommandInput._get_tooltip
CommandInput.__swig_setmethods__["tooltip"] = CommandInput._set_tooltip
CommandInput.tooltip = property(CommandInput._get_tooltip, CommandInput._set_tooltip, doc="Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description\nand/or tool clip are also specified then the tooltip will progressively display more information as the\nuser hovers the mouse over the control.")

CommandInput.__swig_getmethods__["tooltipDescription"] = CommandInput._get_tooltipDescription
CommandInput.__swig_setmethods__["tooltipDescription"] = CommandInput._set_tooltipDescription
CommandInput.tooltipDescription = property(CommandInput._get_tooltipDescription, CommandInput._set_tooltipDescription, doc="Gets or sets additional text to display progressively along with the tooltip. The text for the description\ncan contain some basic html formatting tags to format the tags. For example the br tag can be used to\ncreate multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will\nprogressively display the tool clip and description text.")

CommandInput.__swig_getmethods__["parentCommandInput"] = CommandInput._get_parentCommandInput
CommandInput.parentCommandInput = property(CommandInput._get_parentCommandInput, doc="Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput.\nReturns null if their is no parent.")

CommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CommandInput) else None
CommandInput.cast = lambda arg: arg if isinstance(arg, CommandInput) else None

class CommandInputs(Base):
    """
    Provides access to the set of inputs for a command. Command inputs are used to gather inputs from the user when a command is executed.
    The set of inputs used by a command are created and added to the command with the methods in this class.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CommandInputs, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CommandInputs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::CommandInputs *" : return _core.CommandInputs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.CommandInputs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.CommandInputs___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.CommandInputs___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.CommandInputs___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.CommandInputs_classType
    if _newclass:classType = staticmethod(_core.CommandInputs_classType)
    __swig_destroy__ = _core.delete_CommandInputs
    __del__ = lambda self : None;
    def _get_command(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command object."""
        return _core.CommandInputs__get_command(self)

    def item(self, *args) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Returns the specified command input using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.CommandInputs_item(self, *args)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Returns the command input that has the specified ID. 
        id : The unique ID of the command input you want to get. 
        Returns the specified command input or null if the input ID doesn't match an existing command input.
        """
        return _core.CommandInputs_itemById(self, *args)

    def _get_count(self) -> "size_t" :
        """Gets the number of inputs."""
        return _core.CommandInputs__get_count(self)

    def addValueInput(self, *args) -> "adsk::core::Ptr< adsk::core::ValueCommandInput >" :
        """
        Adds a new value input to the command. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        unitType : The unit type of the value. This will be used to validate the input and the returned Value object
        will be of this type. 
        initialValue : The initial value of this input as shown in the dialog. This can be a string or a real. If it's a string
        it must be able to be evaluated using the specified unit type. If it's a real it is assumed to be in database
        units for the specified unit type and is displayed as a string 
        Returns the created ValueCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addValueInput(self, *args)

    def addBoolValueInput(self, *args) -> "adsk::core::Ptr< adsk::core::BoolValueCommandInput >" :
        """
        Adds a new boolean input to the command. The input can be shown as a check box or a button. If it's a button
        you need to specify the resource folder to define the icon to use. Buttons don't have an up or down state but
        can just be clicked. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        isCheckBox : Specifies if this input should be displayed as a check box or a button. If true a check box is
        displayed, if false a button is displayed that can be clicked to toggle it's state. 
        resourceFolder : Specifies the folder that contains the image for the input.
        It's optional if isCheckBox is true. If it's set for check box, the check box will be present as a button and has an up or down state. 
        initialValue : Specifies the initial value of the check box or button where for a check box the value of True results
        in it being checked and for a button a value of true results in the button being pressed. 
        Returns the created BoolValueCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addBoolValueInput(self, *args)

    def addStringValueInput(self, *args) -> "adsk::core::Ptr< adsk::core::StringValueCommandInput >" :
        """
        Adds a new string input to the command. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        initialValue : Specifies the initial value as shown in the dialog. 
        Returns the created StringValueCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addStringValueInput(self, *args)

    def addSelectionInput(self, *args) -> "adsk::core::Ptr< adsk::core::SelectionCommandInput >" :
        """
        Adds a new selection input to the command. This allows you to get entity selections from the user. The default
        behavior is that only one entity can be selected and it can be of any type. To change the selection behavior to
        select specific types and control the number of items selected use the methods and properties on the returned 
        SelectionCommandInput object. You can also use the selectionEvent event that's associated with the command 
        to have additional control over the selection process. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        commandPrompt : The text in the tooltip shown next to the cursor. 
        Returns the created SelectionCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addSelectionInput(self, *args)

    def addDropDownCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::DropDownCommandInput >" :
        """
        Adds a new empty drop-down input to the command. drop-downs of various types are supported.
        To add items to the drop down use the returned DropDownCommandInput object. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed label of this command as seen in the dialog. 
        dropDownStyle : Specifies the style of the drop-down. 
        Returns the created DropDownCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addDropDownCommandInput(self, *args)

    def addButtonRowCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::ButtonRowCommandInput >" :
        """
        Adds a new row of buttons as a command input. Depending on the isMultiSelectEnabled argument it can act like an option list 
        where only a single button on the row can be selected at a time or multiple buttons can be selected.
        The buttons are defined by using the returned ButtonRowCommandInput object. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed label of this command as seen in the dialog. 
        isMultiSelectEnabled : Sets if this button row can have multiple items selected at once or not.
        If True, multiple buttons can be selected at once. If False only one button
        can be selected and selecting another button unselects the one currently selected. 
        Returns the created ButtonRowCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addButtonRowCommandInput(self, *args)

    def addFloatSliderCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::FloatSliderCommandInput >" :
        """
        Adds a new slider input to the command. The value type is double. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        unitType : The unit type of the value. This will be used to validate the input and the returned value will be in the base units for this
        unit type. For example if you specify the unitType to be 'in' the returned value will be in centimeters because inches are
        a length unit and the base unit for length is centimeters. 
        min : Provides the minimum value in database units 
        max : Provides the maximum value in database units 
        hasTwoSliders : Optional input. Indicates if the slider input has two sliders. 
        Returns the created FloatSliderCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addFloatSliderCommandInput(self, *args)

    def addFloatSliderListCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::FloatSliderCommandInput >" :
        """
        Adds a new slider input to the command. The value type is float. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        unitType : The unit type of the value. This will be used to validate the input and the returned Value object
        will be of this type. 
        valueList : Provides the value list (in database units) of the slider command input. This defines all of the values that the slider
        can return. As the user moves the slider it will jump between these values. The low and high values 
        of the list are used as the minimum and maximum values of the slider. 
        hasTwoSliders : Optional input. Indicates if the slider input has two sliders. 
        Returns the created FloatSliderCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addFloatSliderListCommandInput(self, *args)

    def addIntegerSliderCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::IntegerSliderCommandInput >" :
        """
        Adds a new slider input to the command. The value type is integer. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        min : Provides the minimum value. 
        max : Provides the maximum value. 
        hasTwoSliders : Optional input. Indicates if the slider input has two sliders. 
        Returns the created IntegerSliderCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addIntegerSliderCommandInput(self, *args)

    def addIntegerSliderListCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::IntegerSliderCommandInput >" :
        """
        Adds a new slider input to the command. The value type is integer. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        valueList : Provides the value list of the slider command input. This defines all of the values that the slider
        can return. As the user moves the slider it will jump between these values. The low and high values 
        of the list are used as the minimum and maximum values of the slider. 
        hasTwoSliders : Optional input. Indicates if the slider has two sliders. 
        Returns the created IntegerSliderCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addIntegerSliderListCommandInput(self, *args)

    def addTextBoxCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::TextBoxCommandInput >" :
        """
        Adds a text box input to the command. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. If an empty string is provided then
        no name will be displayed and the text box will span the width of the command dialog. 
        formattedText : Gets and sets the formatted text displayed in the dialog. Formatted text includes
        any basic html formatting that has been defined. For example, you can use basic html 
        formatting such as <code>&lt;b&gt;Bold&lt;/b&gt;</code>, <code>&lt;i&gt;Italic&lt;/i&gt;</code>, 
        and <code>&lt;br /&gt;</code> for a line break. It also supports hyperlinks, which when clicked 
        by the user, Fusion 360 will open the specified url in the default browser. Hyperlinks are defined 
        using the <code>&lt;a&gt;</code> tag such as 
        '<code>You are using Autodesk's &lt;a href='http://fusion360.autodesk.com'&gt;Fusion 360&lt;/a&gt;.</code>'. 
        numRows : Specifies the height of the text box as defined by the number of rows of text that can be displayed. 
        If the text is larger than will fit in the box a scroll bar will automatically be displayed. 
        isReadOnly : Specifies if the text box is read-only or not. 
        Returns the created TextBoxCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addTextBoxCommandInput(self, *args)

    def addFloatSpinnerCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::FloatSpinnerCommandInput >" :
        """
        Adds a new spinner input to the command. The value type is float. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        unitType : The unit type of the value. This will be used to validate the input and the returned Value object
        will be of this type. 
        min : Provides the minimum value in database units. 
        max : Provides the maximum value in database units. 
        spinStep : Sets the spin step value in the unit type set by the unitType argument. 
        The value should be more than zero. This is the amount the slider will advance
        when the user clicks the spin button beside the value. 
        initialValue : The initial value of this input as shown in the dialog. This value is assumed to be in database
        units for the specified unit type 
        Returns the created FloatSpinnerCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addFloatSpinnerCommandInput(self, *args)

    def addIntegerSpinnerCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::IntegerSpinnerCommandInput >" :
        """
        Adds a new spinner input to the command. The value type is integer. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        min : Provides the minimum value. 
        max : Provides the maximum value. 
        spinStep : Provides the spin step. The value should be more than zero. This is the amount the slider will advance
        when the user clicks the spin button beside the value. 
        initialValue : The initial value of this input as shown in the dialog. 
        Returns the created IntegerSpinnerCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addIntegerSpinnerCommandInput(self, *args)

    def addRadioButtonGroupCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::RadioButtonGroupCommandInput >" :
        """
        Adds a new Radio Button Group input to the command. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed label of this radio button group as seen in the dialog. 
        Returns the created RadioButtonGroupCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addRadioButtonGroupCommandInput(self, *args)

    def addGroupCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::GroupCommandInput >" :
        """
        Adds a new Group input to the command. Group Command inputs organize a set of command inputs into a collapsible 
        list within a command dialog. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed label of this group as seen in the dialog. 
        Returns the created GroupCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addGroupCommandInput(self, *args)

    def addTabCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::TabCommandInput >" :
        """
        Adds a new Tab input to the command. Tab command inputs contain a set of command inputs and/or group command inputs 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed label of this tab as seen in the dialog. 
        resourceFolder : An optional parameter that specifies the folder that contains the image for the tab.
        If no name is specified (no text on tab), a resourceFolder containing the image to appear 
        on the tab needs to be provided. 
        Returns the created TabCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addTabCommandInput(self, *args)

    def addImageCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::ImageCommandInput >" :
        """
        Adds a new Image input to the command. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed label of this Image as seen in the dialog.
        If a name is not specified (an empty string), the image will be left justified within the dialog.
        If a name is specified it will appear as a left justified label aligned with the other command input labels, 
        and the left side of the image will be aligned with the other command input controls. 
        imageFile : The full path and file name of the image file.
        Supported image format is .png
        Images are displayed in the command dialog using their actual size. 
        Returns the created ImageCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addImageCommandInput(self, *args)

    def addDistanceValueCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::DistanceValueCommandInput >" :
        """
        Adds a new distance value input to the command. This displays a field in the command dialog where a
        distance value can be entered. It displays the distance in the dialog using current document default unit.
        There is also a graphical manipulator associated with the input.
        You use the setManipulator method of the returned DistanceValueCommandInput
        object to define the position and orientation of the manipulator. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed label of this input as seen in the dialog.
        If a name is not specified (an empty string), the input will be centered horizontally within it's row in the dialog.
        If a name is specified it will appear as a left justified label aligned with the other command input labels, 
        and the left side of the image will be aligned with the other command input controls. 
        initialValue : The initial value of the input. If the value input is a number then it is interpreted as centimeters. If it is 
        a string it uses the units specified in the string or if no units are specified it uses the active units of the design. 
        Returns the created DistanceValueCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addDistanceValueCommandInput(self, *args)

    def addDirectionCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::DirectionCommandInput >" :
        """
        Adds a new direction command input to the command. The input can be shown as a check box or a button. If it's a button
        you need to specify the resource folder to define the icon to use for the Button. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        resourceFolder : Specifies the folder that contains the image for the input.
        This is an optional argument. The input is shown as a check box if the resource folder is not set. 
        Returns the created DirectionCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addDirectionCommandInput(self, *args)

    def addTableCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::TableCommandInput >" :
        """
        Adds a new table command input to the command. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed name of this command as seen in the dialog. 
        numberOfColumns : This argument is no longer used. The number of columns displayed is inferred by the
        number of columns that contain command inputs. As you add command inputs to the table
        the display of the table will adjust to show all of the columns that contain a command input. 
        columnRatio : Sets the width ratio of the columns. This is defined using a string
        such as '1:1:1' where this defines that the first three columns are all the same width.
        A value of '2:1' defines that the first column is twice the width of the second.
        If the table has more columns than are defined by this property, they will automatically
        default to a value of 1. If this property defines the width of more columns than are
        displayed, the extra definitions are ignored.
        You can also specify 0 as a column width and this will have the effect of hiding
        that column. Setting a column width to 0 does not delete the column or the command inputs
        but only hides them so they can be turned back on at a later time by resetting the
        column ratio. 
        Returns the created TableCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addTableCommandInput(self, *args)

    def addAngleValueCommandInput(self, *args) -> "adsk::core::Ptr< adsk::core::AngleValueCommandInput >" :
        """
        Adds a new angle value input to the command. This displays a field in the command dialog where an
        angle value can be entered. It displays the angle in the dialog using degrees. There is also a graphical 
        manipulator associated with the input to allow the user to graphically set the value. You use the 
        setManipulator method of the returned AngleValueCommandInput object to define the position and 
        orientation of the manipulator. 
        id : The unique ID of this command input. It must be unique with respect to the other inputs associated with this command. 
        name : The displayed label of this input as seen in the dialog.
        If a name is not specified (an empty string), the input will be centered horizontally within it's row in the dialog.
        If a name is specified it will appear as a left justified label aligned with the other command input labels, 
        and the left side of the image will be aligned with the other command input controls. 
        initialValue : The initial value of the input. If the value input is a number then it is interpreted as radians. If it is 
        a string it uses the units specified in the string or if no units are specified it uses degrees. 
        Returns the created AngleValueCommandInput object or null if the creation failed.
        """
        return _core.CommandInputs_addAngleValueCommandInput(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.CommandInputs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.CommandInputs__get_isValid(self)
CommandInputs_swigregister = _core.CommandInputs_swigregister
CommandInputs_swigregister(CommandInputs)

def CommandInputs_classType() -> "char const *" :
  return _core.CommandInputs_classType()
CommandInputs_classType = _core.CommandInputs_classType

CommandInputs.__swig_getmethods__["command"] = CommandInputs._get_command
CommandInputs.command = property(CommandInputs._get_command, doc="Gets the parent Command object.")

CommandInputs.__swig_getmethods__["count"] = CommandInputs._get_count
CommandInputs.count = property(CommandInputs._get_count, doc="Gets the number of inputs.")

CommandInputs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CommandInputs) else None
CommandInputs.cast = lambda arg: arg if isinstance(arg, CommandInputs) else None

class ControlDefinition(Base):
    """
    The ControlDefinition is the base class for the various types of control definitions. 
    You can use properties on the control definition to define the look and behavior of 
    the control.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ControlDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ControlDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ControlDefinition *" : return _core.ControlDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ControlDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ControlDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ControlDefinition_classType
    if _newclass:classType = staticmethod(_core.ControlDefinition_classType)
    __swig_destroy__ = _core.delete_ControlDefinition
    __del__ = lambda self : None;
    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls."""
        return _core.ControlDefinition__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls."""
        return _core.ControlDefinition__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface."""
        return _core.ControlDefinition__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface."""
        return _core.ControlDefinition__set_isVisible(self, *args)

    def _get_name(self) -> "std::string" :
        """Gets or sets the name for this control. This is the visible name displayed in the user interface."""
        return _core.ControlDefinition__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Gets or sets the name for this control. This is the visible name displayed in the user interface."""
        return _core.ControlDefinition__set_name(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.ControlDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ControlDefinition__get_isValid(self)
ControlDefinition_swigregister = _core.ControlDefinition_swigregister
ControlDefinition_swigregister(ControlDefinition)

def ControlDefinition_classType() -> "char const *" :
  return _core.ControlDefinition_classType()
ControlDefinition_classType = _core.ControlDefinition_classType

ControlDefinition.__swig_getmethods__["isEnabled"] = ControlDefinition._get_isEnabled
ControlDefinition.__swig_setmethods__["isEnabled"] = ControlDefinition._set_isEnabled
ControlDefinition.isEnabled = property(ControlDefinition._get_isEnabled, ControlDefinition._set_isEnabled, doc="Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls.")

ControlDefinition.__swig_getmethods__["isVisible"] = ControlDefinition._get_isVisible
ControlDefinition.__swig_setmethods__["isVisible"] = ControlDefinition._set_isVisible
ControlDefinition.isVisible = property(ControlDefinition._get_isVisible, ControlDefinition._set_isVisible, doc="Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface.")

ControlDefinition.__swig_getmethods__["name"] = ControlDefinition._get_name
ControlDefinition.__swig_setmethods__["name"] = ControlDefinition._set_name
ControlDefinition.name = property(ControlDefinition._get_name, ControlDefinition._set_name, doc="Gets or sets the name for this control. This is the visible name displayed in the user interface.")

ControlDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ControlDefinition) else None
ControlDefinition.cast = lambda arg: arg if isinstance(arg, ControlDefinition) else None

class Curve2D(Base):
    """The base class for all 2D transient geometry classes."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Curve2D, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Curve2D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Curve2D *" : return _core.Curve2D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Curve2D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Curve2D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Curve2D_classType
    if _newclass:classType = staticmethod(_core.Curve2D_classType)
    __swig_destroy__ = _core.delete_Curve2D
    __del__ = lambda self : None;
    def _get_curveType(self) -> "adsk::core::Curve2DTypes" :
        """Returns the type of geometry this curve represents."""
        return _core.Curve2D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator2D >" :
        """Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Curve2D__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms this curve in 2D space. 
        matrix : A 2D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Curve2D_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Curve2D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Curve2D__get_isValid(self)
Curve2D_swigregister = _core.Curve2D_swigregister
Curve2D_swigregister(Curve2D)

def Curve2D_classType() -> "char const *" :
  return _core.Curve2D_classType()
Curve2D_classType = _core.Curve2D_classType

Curve2D.__swig_getmethods__["curveType"] = Curve2D._get_curveType
Curve2D.curveType = property(Curve2D._get_curveType, doc="Returns the type of geometry this curve represents.")

Curve2D.__swig_getmethods__["evaluator"] = Curve2D._get_evaluator
Curve2D.evaluator = property(Curve2D._get_evaluator, doc="Returns an evaluator object that lets you perform additional evaluations on the curve.")

Curve2D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Curve2D) else None
Curve2D.cast = lambda arg: arg if isinstance(arg, Curve2D) else None

class Curve3D(Base):
    """The base class for all 3D transient geometry classes."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Curve3D, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Curve3D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Curve3D *" : return _core.Curve3D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Curve3D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Curve3D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Curve3D_classType
    if _newclass:classType = staticmethod(_core.Curve3D_classType)
    __swig_destroy__ = _core.delete_Curve3D
    __del__ = lambda self : None;
    def _get_curveType(self) -> "adsk::core::Curve3DTypes" :
        """Returns the type of geometry this curve represents."""
        return _core.Curve3D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >" :
        """Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Curve3D__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms this curve in 3D space. 
        matrix : A 3D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Curve3D_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Curve3D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Curve3D__get_isValid(self)
Curve3D_swigregister = _core.Curve3D_swigregister
Curve3D_swigregister(Curve3D)

def Curve3D_classType() -> "char const *" :
  return _core.Curve3D_classType()
Curve3D_classType = _core.Curve3D_classType

Curve3D.__swig_getmethods__["curveType"] = Curve3D._get_curveType
Curve3D.curveType = property(Curve3D._get_curveType, doc="Returns the type of geometry this curve represents.")

Curve3D.__swig_getmethods__["evaluator"] = Curve3D._get_evaluator
Curve3D.evaluator = property(Curve3D._get_evaluator, doc="Returns an evaluator object that lets you perform additional evaluations on the curve.")

Curve3D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Curve3D) else None
Curve3D.cast = lambda arg: arg if isinstance(arg, Curve3D) else None

class CurveEvaluator2D(Base):
    """
    2D curve evaluator that is obtained from a transient curve and allows you to perform
    various evaluations on the curve.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CurveEvaluator2D, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CurveEvaluator2D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::CurveEvaluator2D *" : return _core.CurveEvaluator2D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.CurveEvaluator2D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.CurveEvaluator2D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.CurveEvaluator2D_classType
    if _newclass:classType = staticmethod(_core.CurveEvaluator2D_classType)
    __swig_destroy__ = _core.delete_CurveEvaluator2D
    __del__ = lambda self : None;
    def getCurvatures(self, *args) -> "bool" :
        """
        Get the curvature values at a number of parameter positions on the curve. 
        parameters : The array of parameter positions to return curvature information at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        directions : The output array of the direction of the curvature at each position on the curve.
        The length of this array will be the same as the length of the parameters array provided. 
        curvatures : The output array of the magnitude of the curvature at the position on the curve.
        The length of this array will be the same as the length of the parameters array provided. 
        Returns true if the curvatures were successfully returned.
        """
        return _core.CurveEvaluator2D_getCurvatures(self, *args)

    def getCurvature(self, *args) -> "bool" :
        """
        Get the curvature value at a parameter position on the curve. 
        parameter : The parameter position to return the curvature information at.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        direction : The output direction of the curvature at the position on the curve. 
        curvature : The output magnitude of the curvature at the position on the curve. 
        Returns true if the curvature was successfully returned.
        """
        return _core.CurveEvaluator2D_getCurvature(self, *args)

    def getTangents(self, *args) -> "bool" :
        """
        Get the tangent to the curve at a number of parameter positions on the curve. 
        parameters : The array of parameter positions to return the tangent at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        tangents : The output array of tangent vectors for each position on the curve.
        The length of this array will be the same as the length of the parameters array provided. 
        Returns true if the tangents were successfully returned.
        """
        return _core.CurveEvaluator2D_getTangents(self, *args)

    def getTangent(self, *args) -> "bool" :
        """
        Get the tangent to the curve at a parameter position on the curve. 
        parameter : The parameter position to return the tangent at.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        tangent : The output tangent vector at the curve position. 
        Returns true if the tangent was successfully returned.
        """
        return _core.CurveEvaluator2D_getTangent(self, *args)

    def getEndPoints(self) -> "bool" :
        """
        Get the end points of the curve. 
        startPoint : The output start point of the curve. If the curve is unbounded at the start, this value will be null. 
        endPoint : The output end point of the curve. If the curve is unbounded at the end, this value will be null. 
        Returns true if the end points were successfully returned.
        """
        return _core.CurveEvaluator2D_getEndPoints(self)

    def getLengthAtParameter(self, *args) -> "bool" :
        """
        Get the length of the curve between two parameter positions on the curve. 
        fromParameter : The parameter position to measure the curve length from.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        toParameter : The parameter position to measure the curve length to.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        length : The output curve length between the from and to parameter positions on the curve. 
        Returns true if the length was successfully returned.
        """
        return _core.CurveEvaluator2D_getLengthAtParameter(self, *args)

    def getParameterAtLength(self, *args) -> "bool" :
        """
        Get the parameter position on the curve that is the specified curve length from the specified starting parameter position. 
        fromParameter : The parameter position to start measuring the curve length from.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        length : The curve length to offset the from parameter by.
        A negative length value will offset in the negative parameter direction. 
        parameter : The output parameter value that is the specified curve length from the starting parameter position. 
        Returns true if the parameter was successfully returned.
        """
        return _core.CurveEvaluator2D_getParameterAtLength(self, *args)

    def getParametersAtPoints(self, *args) -> "bool" :
        """
        Get the parameter positions that correspond to a set of points on the curve.
        For reliable results, the points should lie on the curve within model tolerance.
        If the points do not lie on the curve, the parameter of the nearest point on the curve will generally be returned. 
        points : An array of points to get the curve parameter values at. 
        parameters : The output array of parameter positions corresponding to the set of points.
        The length of this array will be equal to the length of the points array specified. 
        Returns true if the parameters were successfully returned.
        """
        return _core.CurveEvaluator2D_getParametersAtPoints(self, *args)

    def getParameterAtPoint(self, *args) -> "bool" :
        """
        Get the parameter position that correspond to a point on the curve.
        For reliable results, the point should lie on the curve within model tolerance.
        If the point does not lie on the curve, the parameter of the nearest point on the curve will generally be returned. 
        point : The point to get the curve parameter value at. 
        parameter : The output parameter position corresponding to the point. 
        Returns true of the parameter was successfully returned.
        """
        return _core.CurveEvaluator2D_getParameterAtPoint(self, *args)

    def getParameterExtents(self) -> "bool" :
        """
        Get the parametric range of the curve. 
        startParameter : The output lower bound of the parameter range. 
        endParameter : The output upper bound of the parameter range. 
        Returns true if the curve is bounded and the parameter extents were successfully returned.
        """
        return _core.CurveEvaluator2D_getParameterExtents(self)

    def getPointsAtParameters(self, *args) -> "bool" :
        """
        Get the points on the curve that correspond to evaluating a set of parameter positions on the curve. 
        parameters : The array of parameter positions to evaluate the curve position at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        points : The output array of curve positions corresponding to evaluating the curve at that parameter position.
        The length of this array will be equal to the length of the parameters array specified. 
        Returns true if the points were successfully returned.
        """
        return _core.CurveEvaluator2D_getPointsAtParameters(self, *args)

    def getPointAtParameter(self, *args) -> "bool" :
        """
        Get the point on the curve that corresponds to evaluating a parameter position on the curve. 
        parameter : The parameter position to evaluate the curve position at.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        point : The output curve position corresponding to evaluating the curve at that parameter position. 
        Returns true if the point was successfully returned.
        """
        return _core.CurveEvaluator2D_getPointAtParameter(self, *args)

    def getFirstDerivatives(self, *args) -> "bool" :
        """
        Get the first derivatives of the curve at the specified parameter positions. 
        parameters : The array of parameter positions to get the curve first derivative at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        firstDerivatives : The output array of first derivative vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        Returns true if the first derivatives were successfully returned.
        """
        return _core.CurveEvaluator2D_getFirstDerivatives(self, *args)

    def getFirstDerivative(self, *args) -> "bool" :
        """
        Get the first derivative of the curve at the specified parameter position. 
        parameter : The parameter position to get the curve first derivative at.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        firstDerivative : The output first derivative vector at the parameter position specified. 
        Returns true if the first derivative was successfully returned.
        """
        return _core.CurveEvaluator2D_getFirstDerivative(self, *args)

    def getSecondDerivatives(self, *args) -> "bool" :
        """
        Get the second derivatives of the curve at the specified parameter positions. 
        parameters : The array of parameter positions to get the curve second derivative at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        secondDerivatives : The output array of second derivative vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        Returns true if the second derivatives were successfully returned.
        """
        return _core.CurveEvaluator2D_getSecondDerivatives(self, *args)

    def getSecondDerivative(self, *args) -> "bool" :
        """
        Get the second derivative of the curve at the specified parameter position. 
        parameter : The parameter position to get the curve second derivative at.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        secondDerivative : The output second derivative vector at the parameter position specified. 
        Returns true if the second derivative was successfully returned.
        """
        return _core.CurveEvaluator2D_getSecondDerivative(self, *args)

    def getThirdDerivatives(self, *args) -> "bool" :
        """
        Get the third derivatives of the curve at the specified parameter positions. 
        parameters : The array of parameter positions to get the curve third derivative at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        thirdDerivatives : The output array of third derivative vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        Returns true if the third derivatives were successfully returned.
        """
        return _core.CurveEvaluator2D_getThirdDerivatives(self, *args)

    def getThirdDerivative(self, *args) -> "bool" :
        """
        Get the third derivative of the curve at the specified parameter position. 
        parameter : The parameter position to get the curve third derivative at.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        thirdDerivative : The output third derivative vector at the parameter position specified. 
        Returns true if the third derivative was successfully returned.
        """
        return _core.CurveEvaluator2D_getThirdDerivative(self, *args)

    def getStrokes(self, *args) -> "bool" :
        """
        Get a sequence of points between two curve parameter positions.
        The points will be a linear interpolation along the curve between these two
        parameter positions where the maximum deviation between the curve and each line
        segment will not exceed the specified tolerance value. 
        fromParameter : The starting parameter position to interpolate points from.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        toParameter : The ending parameter position to interpolate points to.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        tolerance : The maximum distance tolerance between the curve and the linear interpolation. 
        vertexCoordinates : The output array of linear interpolation points. 
        Returns true if the interpolation points were successfully returned.
        """
        return _core.CurveEvaluator2D_getStrokes(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.CurveEvaluator2D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.CurveEvaluator2D__get_isValid(self)
CurveEvaluator2D_swigregister = _core.CurveEvaluator2D_swigregister
CurveEvaluator2D_swigregister(CurveEvaluator2D)

def CurveEvaluator2D_classType() -> "char const *" :
  return _core.CurveEvaluator2D_classType()
CurveEvaluator2D_classType = _core.CurveEvaluator2D_classType

CurveEvaluator2D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CurveEvaluator2D) else None
CurveEvaluator2D.cast = lambda arg: arg if isinstance(arg, CurveEvaluator2D) else None

class CurveEvaluator3D(Base):
    """
    3D curve evaluator that is obtained from a transient curve and allows you to perform
    various evaluations on the curve.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CurveEvaluator3D, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CurveEvaluator3D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::CurveEvaluator3D *" : return _core.CurveEvaluator3D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.CurveEvaluator3D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.CurveEvaluator3D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.CurveEvaluator3D_classType
    if _newclass:classType = staticmethod(_core.CurveEvaluator3D_classType)
    __swig_destroy__ = _core.delete_CurveEvaluator3D
    __del__ = lambda self : None;
    def getCurvatures(self, *args) -> "bool" :
        """
        Get the curvature values at a number of parameter positions on the curve. 
        parameters : The array of parameter positions to return curvature information at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        directions : The output array of the direction of the curvature at each position on the curve.
        The length of this array will be the same as the length of the parameters array provided. 
        curvatures : The output array of the magnitude of the curvature at the position on the curve.
        The length of this array will be the same as the length of the parameters array provided. 
        Returns true if the curvatures were successfully returned.
        """
        return _core.CurveEvaluator3D_getCurvatures(self, *args)

    def getCurvature(self, *args) -> "bool" :
        """
        Get the curvature value at a parameter position on the curve. 
        parameter : The parameter position to return the curvature information at.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        direction : The output direction of the curvature at the position on the curve. 
        curvature : The output magnitude of the curvature at the position on the curve. 
        Returns true if the curvature was successfully returned.
        """
        return _core.CurveEvaluator3D_getCurvature(self, *args)

    def getEndPoints(self) -> "bool" :
        """
        Get the end points of the curve. 
        startPoint : The output start point of the curve. If the curve is unbounded at the start, this value will be null. 
        endPoint : The output end point of the curve. If the curve is unbounded at the end, this value will be null. 
        Returns true if the end points were successfully returned.
        """
        return _core.CurveEvaluator3D_getEndPoints(self)

    def getLengthAtParameter(self, *args) -> "bool" :
        """
        Get the length of the curve between two parameter positions on the curve. 
        fromParameter : The parameter position to measure the curve length from.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        toParameter : The parameter position to measure the curve length to.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        length : The output curve length between the from and to parameter positions on the curve. 
        Returns true if the length was successfully returned.
        """
        return _core.CurveEvaluator3D_getLengthAtParameter(self, *args)

    def getParameterAtLength(self, *args) -> "bool" :
        """
        Get the parameter position on the curve that is the specified curve length from the specified starting parameter position. 
        fromParameter : The parameter position to start measuring the curve length from.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        length : The curve length to offset the from parameter by.
        A negative length value will offset in the negative parameter direction. 
        parameter : The output parameter value that is the specified curve length from the starting parameter position. 
        Returns true if the parameter was successfully returned.
        """
        return _core.CurveEvaluator3D_getParameterAtLength(self, *args)

    def getParametersAtPoints(self, *args) -> "bool" :
        """
        Get the parameter positions that correspond to a set of points on the curve.
        For reliable results, the points should lie on the curve within model tolerance.
        If the points do not lie on the curve, the parameter of the nearest point on the curve will generally be returned. 
        points : An array of points to get the curve parameter values at. 
        parameters : The output array of parameter positions corresponding to the set of points.
        The length of this array will be equal to the length of the points array specified. 
        Returns true if the parameters were successfully returned.
        """
        return _core.CurveEvaluator3D_getParametersAtPoints(self, *args)

    def getParameterAtPoint(self, *args) -> "bool" :
        """
        Get the parameter position that correspond to a point on the curve.
        For reliable results, the point should lie on the curve within model tolerance.
        If the point does not lie on the curve, the parameter of the nearest point on the curve will generally be returned. 
        point : The point to get the curve parameter value at. 
        parameter : The output parameter position corresponding to the point. 
        Returns true of the parameter was successfully returned.
        """
        return _core.CurveEvaluator3D_getParameterAtPoint(self, *args)

    def getParameterExtents(self) -> "bool" :
        """
        Get the parametric range of the curve. 
        startParameter : The output lower bound of the parameter range. 
        endParameter : The output upper bound of the parameter range. 
        Returns true if the curve is bounded and the parameter extents were successfully returned.
        """
        return _core.CurveEvaluator3D_getParameterExtents(self)

    def getPointsAtParameters(self, *args) -> "bool" :
        """
        Get the points on the curve that correspond to evaluating a set of parameter positions on the curve. 
        parameters : The array of parameter positions to evaluate the curve position at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        points : The output array of curve positions corresponding to evaluating the curve at that parameter position.
        The length of this array will be equal to the length of the parameters array specified. 
        Returns true if the points were successfully returned.
        """
        return _core.CurveEvaluator3D_getPointsAtParameters(self, *args)

    def getPointAtParameter(self, *args) -> "bool" :
        """
        Get the point on the curve that corresponds to evaluating a parameter position on the curve. 
        parameter : The parameter position to evaluate the curve position at.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        point : The output curve position corresponding to evaluating the curve at that parameter position. 
        Returns true if the point was successfully returned.
        """
        return _core.CurveEvaluator3D_getPointAtParameter(self, *args)

    def getFirstDerivatives(self, *args) -> "bool" :
        """
        Get the first derivatives of the curve at the specified parameter positions. 
        parameters : The array of parameter positions to get the curve first derivative at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        firstDerivatives : The output array of first derivative vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        Returns true if the first derivatives were successfully returned.
        """
        return _core.CurveEvaluator3D_getFirstDerivatives(self, *args)

    def getFirstDerivative(self, *args) -> "bool" :
        """
        Get the first derivative of the curve at the specified parameter position. 
        parameter : The parameter position to get the curve first derivative at.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        firstDerivative : The output first derivative vector at the parameter position specified. 
        Returns true if the first derivative was successfully returned.
        """
        return _core.CurveEvaluator3D_getFirstDerivative(self, *args)

    def getSecondDerivatives(self, *args) -> "bool" :
        """
        Get the second derivatives of the curve at the specified parameter positions. 
        parameters : The array of parameter positions to get the curve second derivative at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        secondDerivatives : The output array of second derivative vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        Returns true if the second derivatives were successfully returned.
        """
        return _core.CurveEvaluator3D_getSecondDerivatives(self, *args)

    def getSecondDerivative(self, *args) -> "bool" :
        """
        Get the second derivative of the curve at the specified parameter position. 
        parameter : The parameter position to get the curve second derivative at.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        secondDerivative : The output second derivative vector at the parameter position specified. 
        Returns true if the second derivative was successfully returned.
        """
        return _core.CurveEvaluator3D_getSecondDerivative(self, *args)

    def getThirdDerivatives(self, *args) -> "bool" :
        """
        Get the third derivatives of the curve at the specified parameter positions. 
        parameters : The array of parameter positions to get the curve third derivative at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        thirdDerivatives : The output array of third derivative vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        Returns true if the third derivatives were successfully returned.
        """
        return _core.CurveEvaluator3D_getThirdDerivatives(self, *args)

    def getThirdDerivative(self, *args) -> "bool" :
        """
        Get the third derivative of the curve at the specified parameter position. 
        parameter : The parameter position to get the curve third derivative at.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        thirdDerivative : The output third derivative vector at the parameter position specified. 
        Returns true if the third derivative was successfully returned.
        """
        return _core.CurveEvaluator3D_getThirdDerivative(self, *args)

    def getStrokes(self, *args) -> "bool" :
        """
        Get a sequence of points between two curve parameter positions.
        The points will be a linear interpolation along the curve between these two
        parameter positions where the maximum deviation between the curve and each line
        segment will not exceed the specified tolerance value. 
        fromParameter : The starting parameter position to interpolate points from.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        toParameter : The ending parameter position to interpolate points to.
        The parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        tolerance : The maximum distance tolerance between the curve and the linear interpolation. 
        vertexCoordinates : The output array of linear interpolation points. 
        Returns true if the interpolation points were successfully returned.
        """
        return _core.CurveEvaluator3D_getStrokes(self, *args)

    def getTangents(self, *args) -> "bool" :
        """
        Get the tangent to the curve at a number of parameter positions on the curve. 
        parameters : The array of parameter positions to return the tangent at.
        Each parameter value must be within the range of the parameter extents as provided by getParameterExtents. 
        tangents : The output array of tangent vectors for each position on the curve.
        The length of this array will be the same as the length of the parameters array provided. 
        Returns true if the tangents were successfully returned.
        """
        return _core.CurveEvaluator3D_getTangents(self, *args)

    def getTangent(self, *args) -> "bool" :
        """
        Get the tangent to the curve at a parameter position on the curve. 
        parameter : The parameter position to return the tangent at.
        This value must be within the range of the parameter extents as provided by getParameterExtents. 
        tangent : The output tangent vector at the curve position. 
        Returns true if the tangent was successfully returned.
        """
        return _core.CurveEvaluator3D_getTangent(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.CurveEvaluator3D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.CurveEvaluator3D__get_isValid(self)
CurveEvaluator3D_swigregister = _core.CurveEvaluator3D_swigregister
CurveEvaluator3D_swigregister(CurveEvaluator3D)

def CurveEvaluator3D_classType() -> "char const *" :
  return _core.CurveEvaluator3D_classType()
CurveEvaluator3D_classType = _core.CurveEvaluator3D_classType

CurveEvaluator3D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CurveEvaluator3D) else None
CurveEvaluator3D.cast = lambda arg: arg if isinstance(arg, CurveEvaluator3D) else None

class CustomEventHandler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomEventHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CustomEventHandler, name)
    __repr__ = _swig_repr
    def notify(self, *args) -> "void" : return _core.CustomEventHandler_notify(self, *args)
    def __init__(self): 
        if self.__class__ == CustomEventHandler:
            _self = None
        else:
            _self = self
        this = _core.new_CustomEventHandler(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_CustomEventHandler
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _core.disown_CustomEventHandler(self)
        return weakref_proxy(self)
CustomEventHandler_swigregister = _core.CustomEventHandler_swigregister
CustomEventHandler_swigregister(CustomEventHandler)

CustomEventHandler.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomEventHandler) else None
CustomEventHandler.cast = lambda arg: arg if isinstance(arg, CustomEventHandler) else None

class Data(Base):
    """The Data class provides access to data files"""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Data, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Data, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Data *" : return _core.Data___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Data___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Data___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Data_classType
    if _newclass:classType = staticmethod(_core.Data_classType)
    __swig_destroy__ = _core.delete_Data
    __del__ = lambda self : None;
    def _get_activeProject(self) -> "adsk::core::Ptr< adsk::core::DataProject >" :
        """Gets and sets the active DataProject. This is the project currently displayed in the Fusion 360 Data Panel."""
        return _core.Data__get_activeProject(self)

    def _set_activeProject(self, *args) -> "bool" :
        """Gets and sets the active DataProject. This is the project currently displayed in the Fusion 360 Data Panel."""
        return _core.Data__set_activeProject(self, *args)

    def _get_dataProjects(self) -> "adsk::core::Ptr< adsk::core::DataProjects >" :
        """Gets the collection of DataProjects associated with the active Hub."""
        return _core.Data__get_dataProjects(self)

    def _get_dataHubs(self) -> "adsk::core::Ptr< adsk::core::DataHubs >" :
        """Returns a collection of accessible hubs for the current user. A DataHub represents an A360 Team or Personal hub."""
        return _core.Data__get_dataHubs(self)

    def _get_activeHub(self) -> "adsk::core::Ptr< adsk::core::DataHub >" :
        """Gets the active DataHub."""
        return _core.Data__get_activeHub(self)

    def _set_activeHub(self, *args) -> "bool" :
        """Gets the active DataHub."""
        return _core.Data__set_activeHub(self, *args)

    def refreshDataPanel(self) -> "bool" :
        """
        Refreshes the contents of the data panel to ensure what is displayed reflects the latest state. 
        Returns true if the refresh was successful.
        """
        return _core.Data_refreshDataPanel(self)

    def _get_isDataPanelVisible(self) -> "bool" :
        """Gets and sets if the data panel is visible within Fusion 360."""
        return _core.Data__get_isDataPanelVisible(self)

    def _set_isDataPanelVisible(self, *args) -> "bool" :
        """Gets and sets if the data panel is visible within Fusion 360."""
        return _core.Data__set_isDataPanelVisible(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Data__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Data__get_isValid(self)
Data_swigregister = _core.Data_swigregister
Data_swigregister(Data)

def Data_classType() -> "char const *" :
  return _core.Data_classType()
Data_classType = _core.Data_classType

Data.__swig_getmethods__["activeProject"] = Data._get_activeProject
Data.__swig_setmethods__["activeProject"] = Data._set_activeProject
Data.activeProject = property(Data._get_activeProject, Data._set_activeProject, doc="Gets and sets the active DataProject. This is the project currently displayed in the Fusion 360 Data Panel.")

Data.__swig_getmethods__["dataProjects"] = Data._get_dataProjects
Data.dataProjects = property(Data._get_dataProjects, doc="Gets the collection of DataProjects associated with the active Hub.")

Data.__swig_getmethods__["dataHubs"] = Data._get_dataHubs
Data.dataHubs = property(Data._get_dataHubs, doc="Returns a collection of accessible hubs for the current user. A DataHub represents an A360 Team or Personal hub.")

Data.__swig_getmethods__["activeHub"] = Data._get_activeHub
Data.__swig_setmethods__["activeHub"] = Data._set_activeHub
Data.activeHub = property(Data._get_activeHub, Data._set_activeHub, doc="Gets the active DataHub.")

Data.__swig_getmethods__["isDataPanelVisible"] = Data._get_isDataPanelVisible
Data.__swig_setmethods__["isDataPanelVisible"] = Data._set_isDataPanelVisible
Data.isDataPanelVisible = property(Data._get_isDataPanelVisible, Data._set_isDataPanelVisible, doc="Gets and sets if the data panel is visible within Fusion 360.")

Data.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Data) else None
Data.cast = lambda arg: arg if isinstance(arg, Data) else None

class DataFile(Base):
    """A data file in a data folder."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataFile, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DataFile, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DataFile *" : return _core.DataFile___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DataFile___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DataFile___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DataFile_classType
    if _newclass:classType = staticmethod(_core.DataFile_classType)
    __swig_destroy__ = _core.delete_DataFile
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Gets and sets the displayed name of this item."""
        return _core.DataFile__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Gets and sets the displayed name of this item."""
        return _core.DataFile__set_name(self, *args)

    def _get_description(self) -> "std::string" :
        """Gets and sets the description information associated with this item."""
        return _core.DataFile__get_description(self)

    def _get_parentFolder(self) -> "adsk::core::Ptr< adsk::core::DataFolder >" :
        """Returns the parent folder this item is contained within."""
        return _core.DataFile__get_parentFolder(self)

    def _get_parentProject(self) -> "adsk::core::Ptr< adsk::core::DataProject >" :
        """Returns the parent project that this item is in."""
        return _core.DataFile__get_parentProject(self)

    def _get_id(self) -> "std::string" :
        """
        Returns the unique ID for this DataFile. This is the same id used in the
        Forge Data Management API for an Item and is in the unencoded form and will
        look similar to this: 'urn:adsk.wipprod:dm.lineage:hC6k4hndRWaeIVhIjvHu8w'
        """
        return _core.DataFile__get_id(self)

    def _get_versionNumber(self) -> "int" :
        """Gets the version number of this DataFile."""
        return _core.DataFile__get_versionNumber(self)

    def _get_versions(self) -> "adsk::core::Ptr< adsk::core::DataFiles >" :
        """Gets the other version of this item."""
        return _core.DataFile__get_versions(self)

    def _get_latestVersionNumber(self) -> "int" :
        """Gets the latest version number for this DataFile."""
        return _core.DataFile__get_latestVersionNumber(self)

    def _get_latestVersion(self) -> "adsk::core::Ptr< adsk::core::DataFile >" :
        """
        Returns the latest version of the DataFile. It can return a reference
        to the same DataFile is this DataFile is the latest version.
        """
        return _core.DataFile__get_latestVersion(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes this DataFile. This can fail if this file is referenced by another file or is currently open. 
        Returns true if the deletion was successful.
        """
        return _core.DataFile_deleteMe(self)

    def move(self, *args) -> "bool" :
        """
        Moves this DataFile to the specified folder. 
        targetFolder : The folder to move this DataFile to. 
        Returns true if the move was successful.
        """
        return _core.DataFile_move(self, *args)

    def copy(self, *args) -> "adsk::core::Ptr< adsk::core::DataFile >" :
        """
        Copies this DataFile to the specified folder. 
        targetFolder : The folder to copy this DataFile to. 
        Returns the copied DataFile if the copy was successful.
        """
        return _core.DataFile_copy(self, *args)

    def promote(self) -> "bool" :
        """
        Promotes this version to be the latest version. If this is the latest version, nothing happens. 
        Returns true if successful.
        """
        return _core.DataFile_promote(self)

    def _get_fileExtension(self) -> "std::string" :
        """Gets the file extension for this data file. The file type can be inferred from this."""
        return _core.DataFile__get_fileExtension(self)

    def _get_isInUse(self) -> "bool" :
        """Gets if this DataFile is currently in use (opened for edit) by any other user."""
        return _core.DataFile__get_isInUse(self)

    def _get_inUseBy(self) -> "std::vector< adsk::core::Ptr< adsk::core::User >,std::allocator< adsk::core::Ptr< adsk::core::User > > >" :
        """Returns the array of users that are currently using (have open for edit) this data file."""
        return _core.DataFile__get_inUseBy(self)

    def _get_createdBy(self) -> "adsk::core::Ptr< adsk::core::User >" :
        """Returns the User that created this data file."""
        return _core.DataFile__get_createdBy(self)

    def _get_lastUpdatedBy(self) -> "adsk::core::Ptr< adsk::core::User >" :
        """Returns the User that last updated this data file"""
        return _core.DataFile__get_lastUpdatedBy(self)

    def _get_hasOutofDateChildReferences(self) -> "bool" :
        """Gets if this datafile has Children (referenced components) that are out of date (not the latest version)."""
        return _core.DataFile__get_hasOutofDateChildReferences(self)

    def _get_hasChildReferences(self) -> "bool" :
        """Gets if this datafile has children, (i.e. a Fusion 360 Design containing referenced components)."""
        return _core.DataFile__get_hasChildReferences(self)

    def _get_hasParentReferences(self) -> "bool" :
        """Gets if this datafile has parents, (i.e. this is a child being referenced in another Fusion 360 design)."""
        return _core.DataFile__get_hasParentReferences(self)

    def _get_childReferences(self) -> "adsk::core::Ptr< adsk::core::DataFiles >" :
        """Returns a collection of DataFiles that are the children (referenced designs) this datafile references."""
        return _core.DataFile__get_childReferences(self)

    def _get_parentReferences(self) -> "adsk::core::Ptr< adsk::core::DataFiles >" :
        """Returns a collection DataFiles collection that are the parents (designs that reference) this datafile."""
        return _core.DataFile__get_parentReferences(self)

    def _get_publicLink(self) -> "std::string" :
        """Returns a short url of this data file which can be shared with others."""
        return _core.DataFile__get_publicLink(self)

    def _get_objectType(self) -> "char const *" : return _core.DataFile__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DataFile__get_isValid(self)
DataFile_swigregister = _core.DataFile_swigregister
DataFile_swigregister(DataFile)

def DataFile_classType() -> "char const *" :
  return _core.DataFile_classType()
DataFile_classType = _core.DataFile_classType

DataFile.__swig_getmethods__["name"] = DataFile._get_name
DataFile.__swig_setmethods__["name"] = DataFile._set_name
DataFile.name = property(DataFile._get_name, DataFile._set_name, doc="Gets and sets the displayed name of this item.")

DataFile.__swig_getmethods__["description"] = DataFile._get_description
DataFile.description = property(DataFile._get_description, doc="Gets and sets the description information associated with this item.")

DataFile.__swig_getmethods__["parentFolder"] = DataFile._get_parentFolder
DataFile.parentFolder = property(DataFile._get_parentFolder, doc="Returns the parent folder this item is contained within.")

DataFile.__swig_getmethods__["parentProject"] = DataFile._get_parentProject
DataFile.parentProject = property(DataFile._get_parentProject, doc="Returns the parent project that this item is in.")

DataFile.__swig_getmethods__["id"] = DataFile._get_id
DataFile.id = property(DataFile._get_id, doc="Returns the unique ID for this DataFile. This is the same id used in the\nForge Data Management API for an Item and is in the unencoded form and will\nlook similar to this: 'urn:adsk.wipprod:dm.lineage:hC6k4hndRWaeIVhIjvHu8w'")

DataFile.__swig_getmethods__["versionNumber"] = DataFile._get_versionNumber
DataFile.versionNumber = property(DataFile._get_versionNumber, doc="Gets the version number of this DataFile.")

DataFile.__swig_getmethods__["versions"] = DataFile._get_versions
DataFile.versions = property(DataFile._get_versions, doc="Gets the other version of this item.")

DataFile.__swig_getmethods__["latestVersionNumber"] = DataFile._get_latestVersionNumber
DataFile.latestVersionNumber = property(DataFile._get_latestVersionNumber, doc="Gets the latest version number for this DataFile.")

DataFile.__swig_getmethods__["latestVersion"] = DataFile._get_latestVersion
DataFile.latestVersion = property(DataFile._get_latestVersion, doc="Returns the latest version of the DataFile. It can return a reference\nto the same DataFile is this DataFile is the latest version.")

DataFile.__swig_getmethods__["fileExtension"] = DataFile._get_fileExtension
DataFile.fileExtension = property(DataFile._get_fileExtension, doc="Gets the file extension for this data file. The file type can be inferred from this.")

DataFile.__swig_getmethods__["isInUse"] = DataFile._get_isInUse
DataFile.isInUse = property(DataFile._get_isInUse, doc="Gets if this DataFile is currently in use (opened for edit) by any other user.")

DataFile.__swig_getmethods__["inUseBy"] = DataFile._get_inUseBy
DataFile.inUseBy = property(DataFile._get_inUseBy, doc="Returns the array of users that are currently using (have open for edit) this data file.")

DataFile.__swig_getmethods__["createdBy"] = DataFile._get_createdBy
DataFile.createdBy = property(DataFile._get_createdBy, doc="Returns the User that created this data file.")

DataFile.__swig_getmethods__["lastUpdatedBy"] = DataFile._get_lastUpdatedBy
DataFile.lastUpdatedBy = property(DataFile._get_lastUpdatedBy, doc="Returns the User that last updated this data file")

DataFile.__swig_getmethods__["hasOutofDateChildReferences"] = DataFile._get_hasOutofDateChildReferences
DataFile.hasOutofDateChildReferences = property(DataFile._get_hasOutofDateChildReferences, doc="Gets if this datafile has Children (referenced components) that are out of date (not the latest version).")

DataFile.__swig_getmethods__["hasChildReferences"] = DataFile._get_hasChildReferences
DataFile.hasChildReferences = property(DataFile._get_hasChildReferences, doc="Gets if this datafile has children, (i.e. a Fusion 360 Design containing referenced components).")

DataFile.__swig_getmethods__["hasParentReferences"] = DataFile._get_hasParentReferences
DataFile.hasParentReferences = property(DataFile._get_hasParentReferences, doc="Gets if this datafile has parents, (i.e. this is a child being referenced in another Fusion 360 design).")

DataFile.__swig_getmethods__["childReferences"] = DataFile._get_childReferences
DataFile.childReferences = property(DataFile._get_childReferences, doc="Returns a collection of DataFiles that are the children (referenced designs) this datafile references.")

DataFile.__swig_getmethods__["parentReferences"] = DataFile._get_parentReferences
DataFile.parentReferences = property(DataFile._get_parentReferences, doc="Returns a collection DataFiles collection that are the parents (designs that reference) this datafile.")

DataFile.__swig_getmethods__["publicLink"] = DataFile._get_publicLink
DataFile.publicLink = property(DataFile._get_publicLink, doc="Returns a short url of this data file which can be shared with others.")

DataFile.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DataFile) else None
DataFile.cast = lambda arg: arg if isinstance(arg, DataFile) else None

class DataFileFuture(Base):
    """Used to check the state and get back the results of a file upload."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataFileFuture, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DataFileFuture, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DataFileFuture *" : return _core.DataFileFuture___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DataFileFuture___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DataFileFuture___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DataFileFuture_classType
    if _newclass:classType = staticmethod(_core.DataFileFuture_classType)
    __swig_destroy__ = _core.delete_DataFileFuture
    __del__ = lambda self : None;
    def _get_dataFile(self) -> "adsk::core::Ptr< adsk::core::DataFile >" :
        """
        Returns the DataFile when the upload is complete (uplodeState returns UploadFinished).
        Returns null if the upload is still running or has failed.
        """
        return _core.DataFileFuture__get_dataFile(self)

    def _get_uploadState(self) -> "adsk::core::UploadStates" :
        """Returns the current state of the upload."""
        return _core.DataFileFuture__get_uploadState(self)

    def _get_objectType(self) -> "char const *" : return _core.DataFileFuture__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DataFileFuture__get_isValid(self)
DataFileFuture_swigregister = _core.DataFileFuture_swigregister
DataFileFuture_swigregister(DataFileFuture)

def DataFileFuture_classType() -> "char const *" :
  return _core.DataFileFuture_classType()
DataFileFuture_classType = _core.DataFileFuture_classType

DataFileFuture.__swig_getmethods__["dataFile"] = DataFileFuture._get_dataFile
DataFileFuture.dataFile = property(DataFileFuture._get_dataFile, doc="Returns the DataFile when the upload is complete (uplodeState returns UploadFinished).\nReturns null if the upload is still running or has failed.")

DataFileFuture.__swig_getmethods__["uploadState"] = DataFileFuture._get_uploadState
DataFileFuture.uploadState = property(DataFileFuture._get_uploadState, doc="Returns the current state of the upload.")

DataFileFuture.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DataFileFuture) else None
DataFileFuture.cast = lambda arg: arg if isinstance(arg, DataFileFuture) else None

class DataFiles(Base):
    """Returns the items within a folder. This includes everything in a folder except for other folders."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataFiles, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DataFiles, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DataFiles *" : return _core.DataFiles___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DataFiles___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DataFiles___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.DataFiles___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::DataFile >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.DataFiles___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DataFiles_classType
    if _newclass:classType = staticmethod(_core.DataFiles_classType)
    __swig_destroy__ = _core.delete_DataFiles
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::DataFile >" :
        """
        Returns the specified data file. 
        index : The index of the file to return. The first file in the list has an index of 0. 
        Returns the specified file or null if an invalid index was specified.
        """
        return _core.DataFiles_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of data items in this collection."""
        return _core.DataFiles__get_count(self)

    def _get_objectType(self) -> "char const *" : return _core.DataFiles__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DataFiles__get_isValid(self)
DataFiles_swigregister = _core.DataFiles_swigregister
DataFiles_swigregister(DataFiles)

def DataFiles_classType() -> "char const *" :
  return _core.DataFiles_classType()
DataFiles_classType = _core.DataFiles_classType

DataFiles.__swig_getmethods__["count"] = DataFiles._get_count
DataFiles.count = property(DataFiles._get_count, doc="The number of data items in this collection.")

DataFiles.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DataFiles) else None
DataFiles.cast = lambda arg: arg if isinstance(arg, DataFiles) else None

class DataFolder(Base):
    """A data folder that contains a collection of data items."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataFolder, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DataFolder, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DataFolder *" : return _core.DataFolder___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DataFolder___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DataFolder___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DataFolder_classType
    if _newclass:classType = staticmethod(_core.DataFolder_classType)
    __swig_destroy__ = _core.delete_DataFolder
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Gets and sets the displayed name of this folder."""
        return _core.DataFolder__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Gets and sets the displayed name of this folder."""
        return _core.DataFolder__set_name(self, *args)

    def _get_dataFiles(self) -> "adsk::core::Ptr< adsk::core::DataFiles >" :
        """
        Returns a collection containing all of the items within this folder, excluding folders.
        Use the dataFolders property to get the folders.
        """
        return _core.DataFolder__get_dataFiles(self)

    def _get_dataFolders(self) -> "adsk::core::Ptr< adsk::core::DataFolders >" :
        """Returns a collection containing all of the folders within this folder."""
        return _core.DataFolder__get_dataFolders(self)

    def _get_parentFolder(self) -> "adsk::core::Ptr< adsk::core::DataFolder >" :
        """
        Returns the parent folder this folder is contained within. Returns null
        if this is the project's root folder.
        """
        return _core.DataFolder__get_parentFolder(self)

    def _get_parentProject(self) -> "adsk::core::Ptr< adsk::core::DataProject >" :
        """Returns the parent project that owns this folder."""
        return _core.DataFolder__get_parentProject(self)

    def _get_isRoot(self) -> "bool" :
        """Indicates if this folder is the root folder within the parent project."""
        return _core.DataFolder__get_isRoot(self)

    def uploadFile(self, *args) -> "adsk::core::Ptr< adsk::core::DataFileFuture >" :
        """
        Uploads a single file to this directory. 
        filename : The full filename of the file to upload. 
        The upload process is asynchronous which means that this method
        will return before the upload process had completed. The returned
        DataFileFuture object can be used to check on the current state of the
        upload to determine if it is still uploading, is complete, or has failed.
        If it is complete the final DataFinal can be retrieved through the
        DataFileFuture object.
        """
        return _core.DataFolder_uploadFile(self, *args)

    def uploadAssembly(self, *args) -> "adsk::core::Ptr< adsk::core::DataFileFuture >" :
        """
        Uploads a set of files that represent an assembly There should only
        be a single top-level assembly file but there can be any number of other
        files that represent subassemblies. 
        filenames : An array of strings that contains the list of all of the files that
        are part of the assembly. The name of the the top-level assembly file
        must be the first file in the array. 
        The upload process is asynchronous which means that this method
        will return before the upload process had completed. The returned
        DataFileFuture object can be used to check on the current state of the
        upload to determine if it is still uploading, is complete, or has failed.
        If it is complete the final DataFinal can be retrieved through the
        DataFileFuture object.
        """
        return _core.DataFolder_uploadAssembly(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this folder item. 
        Returns true if the deletion was successful.
        """
        return _core.DataFolder_deleteMe(self)

    def _get_id(self) -> "std::string" :
        """
        Returns the unique ID for this folder. This is the same id used in the
        Forge Data Management API.
        """
        return _core.DataFolder__get_id(self)

    def _get_objectType(self) -> "char const *" : return _core.DataFolder__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DataFolder__get_isValid(self)
DataFolder_swigregister = _core.DataFolder_swigregister
DataFolder_swigregister(DataFolder)

def DataFolder_classType() -> "char const *" :
  return _core.DataFolder_classType()
DataFolder_classType = _core.DataFolder_classType

DataFolder.__swig_getmethods__["name"] = DataFolder._get_name
DataFolder.__swig_setmethods__["name"] = DataFolder._set_name
DataFolder.name = property(DataFolder._get_name, DataFolder._set_name, doc="Gets and sets the displayed name of this folder.")

DataFolder.__swig_getmethods__["dataFiles"] = DataFolder._get_dataFiles
DataFolder.dataFiles = property(DataFolder._get_dataFiles, doc="Returns a collection containing all of the items within this folder, excluding folders.\nUse the dataFolders property to get the folders.")

DataFolder.__swig_getmethods__["dataFolders"] = DataFolder._get_dataFolders
DataFolder.dataFolders = property(DataFolder._get_dataFolders, doc="Returns a collection containing all of the folders within this folder.")

DataFolder.__swig_getmethods__["parentFolder"] = DataFolder._get_parentFolder
DataFolder.parentFolder = property(DataFolder._get_parentFolder, doc="Returns the parent folder this folder is contained within. Returns null\nif this is the project's root folder.")

DataFolder.__swig_getmethods__["parentProject"] = DataFolder._get_parentProject
DataFolder.parentProject = property(DataFolder._get_parentProject, doc="Returns the parent project that owns this folder.")

DataFolder.__swig_getmethods__["isRoot"] = DataFolder._get_isRoot
DataFolder.isRoot = property(DataFolder._get_isRoot, doc="Indicates if this folder is the root folder within the parent project.")

DataFolder.__swig_getmethods__["id"] = DataFolder._get_id
DataFolder.id = property(DataFolder._get_id, doc="Returns the unique ID for this folder. This is the same id used in the\nForge Data Management API.")

DataFolder.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DataFolder) else None
DataFolder.cast = lambda arg: arg if isinstance(arg, DataFolder) else None

class DataFolders(Base):
    """Collection object the provides a list of data folders."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataFolders, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DataFolders, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DataFolders *" : return _core.DataFolders___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DataFolders___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DataFolders___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.DataFolders___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::DataFolder >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.DataFolders___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DataFolders_classType
    if _newclass:classType = staticmethod(_core.DataFolders_classType)
    __swig_destroy__ = _core.delete_DataFolders
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::DataFolder >" :
        """
        Returns the specified folder. 
        index : The index of the folder to return. The first folder in the list has an index of 0. 
        Returns the item or null if an invalid index was specified.
        """
        return _core.DataFolders_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::core::DataFolder >" :
        """
        Returns the folder specified using the name of the folder. 
        name : The name of the folder to return. 
        Returns the folder or null if a folder of the specified name is not found.
        """
        return _core.DataFolders_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of folders in this collection."""
        return _core.DataFolders__get_count(self)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::DataFolder >" :
        """
        Returns the folder specified using the ID of the folder. 
        id : The ID of the folder to return. This is the same ID used by
        the Forge Data Management API. 
        Returns the folder or null if a folder with the specified ID is not found.
        """
        return _core.DataFolders_itemById(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::core::DataFolder >" :
        """
        Creates a new folder within the parent folder. 
        name : The name of the folder. This must be unique with respect to the other folders within the parent folder. 
        Returns the created DataFolder or null if the creation failed.
        """
        return _core.DataFolders_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.DataFolders__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DataFolders__get_isValid(self)
DataFolders_swigregister = _core.DataFolders_swigregister
DataFolders_swigregister(DataFolders)

def DataFolders_classType() -> "char const *" :
  return _core.DataFolders_classType()
DataFolders_classType = _core.DataFolders_classType

DataFolders.__swig_getmethods__["count"] = DataFolders._get_count
DataFolders.count = property(DataFolders._get_count, doc="The number of folders in this collection.")

DataFolders.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DataFolders) else None
DataFolders.cast = lambda arg: arg if isinstance(arg, DataFolders) else None

class DataHub(Base):
    """Represents a hub within the data."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataHub, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DataHub, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DataHub *" : return _core.DataHub___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DataHub___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DataHub___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DataHub_classType
    if _newclass:classType = staticmethod(_core.DataHub_classType)
    __swig_destroy__ = _core.delete_DataHub
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Returns the name of the hub."""
        return _core.DataHub__get_name(self)

    def _get_dataProjects(self) -> "adsk::core::Ptr< adsk::core::DataProjects >" :
        """Returns the projects within this hub."""
        return _core.DataHub__get_dataProjects(self)

    def _get_hubType(self) -> "adsk::core::HubTypes" :
        """Gets if this hub is a Personal (PersonalHubType) or Team (TeamHubType) type hub."""
        return _core.DataHub__get_hubType(self)

    def _get_objectType(self) -> "char const *" : return _core.DataHub__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DataHub__get_isValid(self)
DataHub_swigregister = _core.DataHub_swigregister
DataHub_swigregister(DataHub)

def DataHub_classType() -> "char const *" :
  return _core.DataHub_classType()
DataHub_classType = _core.DataHub_classType

DataHub.__swig_getmethods__["name"] = DataHub._get_name
DataHub.name = property(DataHub._get_name, doc="Returns the name of the hub.")

DataHub.__swig_getmethods__["dataProjects"] = DataHub._get_dataProjects
DataHub.dataProjects = property(DataHub._get_dataProjects, doc="Returns the projects within this hub.")

DataHub.__swig_getmethods__["hubType"] = DataHub._get_hubType
DataHub.hubType = property(DataHub._get_hubType, doc="Gets if this hub is a Personal (PersonalHubType) or Team (TeamHubType) type hub.")

DataHub.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DataHub) else None
DataHub.cast = lambda arg: arg if isinstance(arg, DataHub) else None

class DataHubs(Base):
    """Collection object that provides a list of all available hubs."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataHubs, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DataHubs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DataHubs *" : return _core.DataHubs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DataHubs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DataHubs___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.DataHubs___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::DataHub >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.DataHubs___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DataHubs_classType
    if _newclass:classType = staticmethod(_core.DataHubs_classType)
    __swig_destroy__ = _core.delete_DataHubs
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::DataHub >" :
        """
        Returns the specified hub. 
        index : The index of the hub to return. The first hub in the list has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.DataHubs_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of hubs in this collection."""
        return _core.DataHubs__get_count(self)

    def _get_objectType(self) -> "char const *" : return _core.DataHubs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DataHubs__get_isValid(self)
DataHubs_swigregister = _core.DataHubs_swigregister
DataHubs_swigregister(DataHubs)

def DataHubs_classType() -> "char const *" :
  return _core.DataHubs_classType()
DataHubs_classType = _core.DataHubs_classType

DataHubs.__swig_getmethods__["count"] = DataHubs._get_count
DataHubs.count = property(DataHubs._get_count, doc="The number of hubs in this collection.")

DataHubs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DataHubs) else None
DataHubs.cast = lambda arg: arg if isinstance(arg, DataHubs) else None

class DataProject(Base):
    """Represents the master branch project within a hub."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataProject, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DataProject, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DataProject *" : return _core.DataProject___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DataProject___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DataProject___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DataProject_classType
    if _newclass:classType = staticmethod(_core.DataProject_classType)
    __swig_destroy__ = _core.delete_DataProject
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Gets and sets the name of the project."""
        return _core.DataProject__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Gets and sets the name of the project."""
        return _core.DataProject__set_name(self, *args)

    def _get_rootFolder(self) -> "adsk::core::Ptr< adsk::core::DataFolder >" :
        """
        Returns the project's root folder. This provides access to all of the 
        folders and the files in the top level of the project.
        """
        return _core.DataProject__get_rootFolder(self)

    def _get_id(self) -> "std::string" :
        """
        Returns the unique ID for this project. This is the same id used in the
        Forge Data Management API in an unencoded form and will look something like
        this: 'a.45637'.
        """
        return _core.DataProject__get_id(self)

    def _get_parentHub(self) -> "adsk::core::Ptr< adsk::core::DataHub >" :
        """Returns the parent DataHub of this project."""
        return _core.DataProject__get_parentHub(self)

    def _get_objectType(self) -> "char const *" : return _core.DataProject__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DataProject__get_isValid(self)
DataProject_swigregister = _core.DataProject_swigregister
DataProject_swigregister(DataProject)

def DataProject_classType() -> "char const *" :
  return _core.DataProject_classType()
DataProject_classType = _core.DataProject_classType

DataProject.__swig_getmethods__["name"] = DataProject._get_name
DataProject.__swig_setmethods__["name"] = DataProject._set_name
DataProject.name = property(DataProject._get_name, DataProject._set_name, doc="Gets and sets the name of the project.")

DataProject.__swig_getmethods__["rootFolder"] = DataProject._get_rootFolder
DataProject.rootFolder = property(DataProject._get_rootFolder, doc="Returns the project's root folder. This provides access to all of the\nfolders and the files in the top level of the project.")

DataProject.__swig_getmethods__["id"] = DataProject._get_id
DataProject.id = property(DataProject._get_id, doc="Returns the unique ID for this project. This is the same id used in the\nForge Data Management API in an unencoded form and will look something like\nthis: 'a.45637'.")

DataProject.__swig_getmethods__["parentHub"] = DataProject._get_parentHub
DataProject.parentHub = property(DataProject._get_parentHub, doc="Returns the parent DataHub of this project.")

DataProject.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DataProject) else None
DataProject.cast = lambda arg: arg if isinstance(arg, DataProject) else None

class DataProjects(Base):
    """Collection object that provides a list of all available projects."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataProjects, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DataProjects, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DataProjects *" : return _core.DataProjects___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DataProjects___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DataProjects___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.DataProjects___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::DataProject >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.DataProjects___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DataProjects_classType
    if _newclass:classType = staticmethod(_core.DataProjects_classType)
    __swig_destroy__ = _core.delete_DataProjects
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::DataProject >" :
        """
        Returns the specified project. 
        index : The index of the project to return. The first project in the list has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.DataProjects_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of projects in this collection."""
        return _core.DataProjects__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::core::DataProject >" :
        """
        Creates a new project in the parent hub. 
        name : The name of the project. This is the name visible to the user. 
        purpose : Optional description of the purpose of the project. An empty string can be used to not specify a purpose. 
        contributors : Optional list of contributors where the list consists of email addresses separated by a comma. 
        An empty string can be used to not specify any contributors. 
        Returns the created DataProject object or null if the creation failed.
        """
        return _core.DataProjects_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.DataProjects__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DataProjects__get_isValid(self)
DataProjects_swigregister = _core.DataProjects_swigregister
DataProjects_swigregister(DataProjects)

def DataProjects_classType() -> "char const *" :
  return _core.DataProjects_classType()
DataProjects_classType = _core.DataProjects_classType

DataProjects.__swig_getmethods__["count"] = DataProjects._get_count
DataProjects.count = property(DataProjects._get_count, doc="The number of projects in this collection.")

DataProjects.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DataProjects) else None
DataProjects.cast = lambda arg: arg if isinstance(arg, DataProjects) else None

class DefaultUnitsPreferences(Base):
    """
    The base class for the default units preference. There is a derived class
    supported by each product where the specific preference values are exposed.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DefaultUnitsPreferences, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DefaultUnitsPreferences, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DefaultUnitsPreferences *" : return _core.DefaultUnitsPreferences___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DefaultUnitsPreferences___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DefaultUnitsPreferences___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DefaultUnitsPreferences_classType
    if _newclass:classType = staticmethod(_core.DefaultUnitsPreferences_classType)
    __swig_destroy__ = _core.delete_DefaultUnitsPreferences
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Returns the name of this DefaultUnitPreferences object."""
        return _core.DefaultUnitsPreferences__get_name(self)

    def _get_objectType(self) -> "char const *" : return _core.DefaultUnitsPreferences__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DefaultUnitsPreferences__get_isValid(self)
DefaultUnitsPreferences_swigregister = _core.DefaultUnitsPreferences_swigregister
DefaultUnitsPreferences_swigregister(DefaultUnitsPreferences)

def DefaultUnitsPreferences_classType() -> "char const *" :
  return _core.DefaultUnitsPreferences_classType()
DefaultUnitsPreferences_classType = _core.DefaultUnitsPreferences_classType

DefaultUnitsPreferences.__swig_getmethods__["name"] = DefaultUnitsPreferences._get_name
DefaultUnitsPreferences.name = property(DefaultUnitsPreferences._get_name, doc="Returns the name of this DefaultUnitPreferences object.")

DefaultUnitsPreferences.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DefaultUnitsPreferences) else None
DefaultUnitsPreferences.cast = lambda arg: arg if isinstance(arg, DefaultUnitsPreferences) else None

class DefaultUnitsPreferencesCollection(Base):
    """A collection that provides access to product specific unit preference objects."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DefaultUnitsPreferencesCollection, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DefaultUnitsPreferencesCollection, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DefaultUnitsPreferencesCollection *" : return _core.DefaultUnitsPreferencesCollection___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DefaultUnitsPreferencesCollection___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DefaultUnitsPreferencesCollection___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.DefaultUnitsPreferencesCollection___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::DefaultUnitsPreferences >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.DefaultUnitsPreferencesCollection___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DefaultUnitsPreferencesCollection_classType
    if _newclass:classType = staticmethod(_core.DefaultUnitsPreferencesCollection_classType)
    __swig_destroy__ = _core.delete_DefaultUnitsPreferencesCollection
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::DefaultUnitsPreferences >" :
        """
        Function that returns the specified DefaultUnitPreferences object using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.DefaultUnitsPreferencesCollection_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::core::DefaultUnitsPreferences >" :
        """
        Returns the DefaultUnitsPreference object with the specified name. 
        name : The name of the DefaultUnitsPreference to return. 
        Returns the DefaultUnitsPreference object or null if if an invalid name was specified.
        """
        return _core.DefaultUnitsPreferencesCollection_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of DefaultUnitsPreference objects."""
        return _core.DefaultUnitsPreferencesCollection__get_count(self)

    def _get_objectType(self) -> "char const *" : return _core.DefaultUnitsPreferencesCollection__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DefaultUnitsPreferencesCollection__get_isValid(self)
DefaultUnitsPreferencesCollection_swigregister = _core.DefaultUnitsPreferencesCollection_swigregister
DefaultUnitsPreferencesCollection_swigregister(DefaultUnitsPreferencesCollection)

def DefaultUnitsPreferencesCollection_classType() -> "char const *" :
  return _core.DefaultUnitsPreferencesCollection_classType()
DefaultUnitsPreferencesCollection_classType = _core.DefaultUnitsPreferencesCollection_classType

DefaultUnitsPreferencesCollection.__swig_getmethods__["count"] = DefaultUnitsPreferencesCollection._get_count
DefaultUnitsPreferencesCollection.count = property(DefaultUnitsPreferencesCollection._get_count, doc="Returns the number of DefaultUnitsPreference objects.")

DefaultUnitsPreferencesCollection.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DefaultUnitsPreferencesCollection) else None
DefaultUnitsPreferencesCollection.cast = lambda arg: arg if isinstance(arg, DefaultUnitsPreferencesCollection) else None

class Document(Base):
    """Object that represents an open document. This is the base class for all document types."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Document, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Document, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Document *" : return _core.Document___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Document___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Document___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Document_classType
    if _newclass:classType = staticmethod(_core.Document_classType)
    __swig_destroy__ = _core.delete_Document
    __del__ = lambda self : None;
    def activate(self) -> "bool" :
        """
        Causes this document to become the active document in the user interface. 
        Returns true if the activation was successful.
        """
        return _core.Document_activate(self)

    def _get_name(self) -> "std::string" :
        """Gets and sets the name of the document."""
        return _core.Document__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Gets and sets the name of the document."""
        return _core.Document__set_name(self, *args)

    def close(self, *args) -> "bool" :
        """
        Closes this document. 
        saveChanges : This argument defines what the behavior of the close is when the document
        has been modified. If the document hasn't been modified then this argument
        is ignored and the document is closed. If the document has been modified
        and this argument is false then Fusion 360 will close the document and lose
        any changes. If the document has been modified and this argument is true then
        it will prompt the user if they want to save the changes or not, just the same
        as if the user was to interactively close the document. 
        Returns true if closing the document was successful.
        """
        return _core.Document_close(self, *args)

    def _get_isModified(self) -> "bool" :
        """Property that indicates if the document has been modified since it was last saved."""
        return _core.Document__get_isModified(self)

    def _get_isSaved(self) -> "bool" :
        """
        Property that indicates if this document has been saved or not. The initial save of
        a document requires that the name and location be specified and requires the saveAs method
        to be used. If the document has been saved then the save method can be used to save changes made.
        """
        return _core.Document__get_isSaved(self)

    def save(self, *args) -> "bool" :
        """
        Saves a version of the current document. You must use the SaveAs method the first
        time a document is saved. You can determine if a document has been saved by checking
        the value of the isSaved property. 
        description : The version description for this document 
        Returns true if saving the document was successful.
        """
        return _core.Document_save(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Application >" :
        """Returns the parent Application object."""
        return _core.Document__get_parent(self)

    def saveAs(self, *args) -> "bool" :
        """
        Performs a Save As on this document. This saves the currently open document to the specified
        location and this document becomes the saved document. If this is a new document that has 
        never been saved you must use the SaveAs method in order to specify the location and name. You
        can determine if the document has been saved by checking the value of the isSaved property. 
        name : The name to use for this document. If this is an empty string, Fusion 360 will use the default name
        assigned when the document was created. 
        dataFolder : The data folder to save this document to. 
        description : The description string of the document. This can be an empty string. 
        tag : The tag string of the document. This can be an empty string. 
        Returns true if the save as was successful.
        """
        return _core.Document_saveAs(self, *args)

    def _get_products(self) -> "adsk::core::Ptr< adsk::core::Products >" :
        """Returns the products associated with this document."""
        return _core.Document__get_products(self)

    def _get_isActive(self) -> "bool" :
        """Gets if this document is the active document in the user interface."""
        return _core.Document__get_isActive(self)

    def _get_isVisible(self) -> "bool" :
        """Gets if a currently open document is open as visible."""
        return _core.Document__get_isVisible(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this document."""
        return _core.Document__get_attributes(self)

    def _get_dataFile(self) -> "adsk::core::Ptr< adsk::core::DataFile >" :
        """Gets the DataFile that represents this document in A360."""
        return _core.Document__get_dataFile(self)

    def _get_version(self) -> "std::string" :
        """Returns the Fusion 360 version this document was last saved with."""
        return _core.Document__get_version(self)

    def _get_documentReferences(self) -> "adsk::core::Ptr< adsk::core::DocumentReferences >" :
        """
        Returns a collection containing the documents directly referenced
        by this document.
        """
        return _core.Document__get_documentReferences(self)

    def _get_isUpToDate(self) -> "bool" :
        """
        Indicates if any references in the assembly are out of date. This is the API 
        equivalent to the 'Out of Date' notification displayed in the Quick Access Toolbar.
        """
        return _core.Document__get_isUpToDate(self)

    def _get_allDocumentReferences(self) -> "adsk::core::Ptr< adsk::core::DocumentReferences >" :
        """
        Returns a collection containing all of the documents referenced directly
        by this document and those referenced by all sub-assemblies.
        """
        return _core.Document__get_allDocumentReferences(self)

    def _get_objectType(self) -> "char const *" : return _core.Document__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Document__get_isValid(self)
Document_swigregister = _core.Document_swigregister
Document_swigregister(Document)

def Document_classType() -> "char const *" :
  return _core.Document_classType()
Document_classType = _core.Document_classType

Document.__swig_getmethods__["name"] = Document._get_name
Document.__swig_setmethods__["name"] = Document._set_name
Document.name = property(Document._get_name, Document._set_name, doc="Gets and sets the name of the document.")

Document.__swig_getmethods__["isModified"] = Document._get_isModified
Document.isModified = property(Document._get_isModified, doc="Property that indicates if the document has been modified since it was last saved.")

Document.__swig_getmethods__["isSaved"] = Document._get_isSaved
Document.isSaved = property(Document._get_isSaved, doc="Property that indicates if this document has been saved or not. The initial save of\na document requires that the name and location be specified and requires the saveAs method\nto be used. If the document has been saved then the save method can be used to save changes made.")

Document.__swig_getmethods__["parent"] = Document._get_parent
Document.parent = property(Document._get_parent, doc="Returns the parent Application object.")

Document.__swig_getmethods__["products"] = Document._get_products
Document.products = property(Document._get_products, doc="Returns the products associated with this document.")

Document.__swig_getmethods__["isActive"] = Document._get_isActive
Document.isActive = property(Document._get_isActive, doc="Gets if this document is the active document in the user interface.")

Document.__swig_getmethods__["isVisible"] = Document._get_isVisible
Document.isVisible = property(Document._get_isVisible, doc="Gets if a currently open document is open as visible.")

Document.__swig_getmethods__["attributes"] = Document._get_attributes
Document.attributes = property(Document._get_attributes, doc="Returns the collection of attributes associated with this document.")

Document.__swig_getmethods__["dataFile"] = Document._get_dataFile
Document.dataFile = property(Document._get_dataFile, doc="Gets the DataFile that represents this document in A360.")

Document.__swig_getmethods__["version"] = Document._get_version
Document.version = property(Document._get_version, doc="Returns the Fusion 360 version this document was last saved with.")

Document.__swig_getmethods__["documentReferences"] = Document._get_documentReferences
Document.documentReferences = property(Document._get_documentReferences, doc="Returns a collection containing the documents directly referenced\nby this document.")

Document.__swig_getmethods__["isUpToDate"] = Document._get_isUpToDate
Document.isUpToDate = property(Document._get_isUpToDate, doc="Indicates if any references in the assembly are out of date. This is the API\nequivalent to the 'Out of Date' notification displayed in the Quick Access Toolbar.")

Document.__swig_getmethods__["allDocumentReferences"] = Document._get_allDocumentReferences
Document.allDocumentReferences = property(Document._get_allDocumentReferences, doc="Returns a collection containing all of the documents referenced directly\nby this document and those referenced by all sub-assemblies.")

Document.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Document) else None
Document.cast = lambda arg: arg if isinstance(arg, Document) else None

class DocumentEventHandler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DocumentEventHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DocumentEventHandler, name)
    __repr__ = _swig_repr
    def notify(self, *args) -> "void" : return _core.DocumentEventHandler_notify(self, *args)
    def __init__(self): 
        if self.__class__ == DocumentEventHandler:
            _self = None
        else:
            _self = self
        this = _core.new_DocumentEventHandler(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_DocumentEventHandler
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _core.disown_DocumentEventHandler(self)
        return weakref_proxy(self)
DocumentEventHandler_swigregister = _core.DocumentEventHandler_swigregister
DocumentEventHandler_swigregister(DocumentEventHandler)

DocumentEventHandler.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DocumentEventHandler) else None
DocumentEventHandler.cast = lambda arg: arg if isinstance(arg, DocumentEventHandler) else None

class DocumentReference(Base):
    """Represents a reference to a document from another document."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DocumentReference, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DocumentReference, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DocumentReference *" : return _core.DocumentReference___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DocumentReference___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DocumentReference___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DocumentReference_classType
    if _newclass:classType = staticmethod(_core.DocumentReference_classType)
    __swig_destroy__ = _core.delete_DocumentReference
    __del__ = lambda self : None;
    def _get_dataFile(self) -> "adsk::core::Ptr< adsk::core::DataFile >" :
        """The dataFile on A360 that this object references."""
        return _core.DocumentReference__get_dataFile(self)

    def _get_referencedDocument(self) -> "adsk::core::Ptr< adsk::core::Document >" :
        """The document currently open in Fusion 360 that this object references."""
        return _core.DocumentReference__get_referencedDocument(self)

    def _get_version(self) -> "int" :
        """
        Gets and sets the version of the dataFile on A360 that this document currently represents.
        Setting this property will cause all occuurences referencing this document to update to
        that version.
        """
        return _core.DocumentReference__get_version(self)

    def _set_version(self, *args) -> "bool" :
        """
        Gets and sets the version of the dataFile on A360 that this document currently represents.
        Setting this property will cause all occuurences referencing this document to update to
        that version.
        """
        return _core.DocumentReference__set_version(self, *args)

    def _get_parentDocument(self) -> "adsk::core::Ptr< adsk::core::Document >" :
        """The document that is doing the referencing and owns this reference."""
        return _core.DocumentReference__get_parentDocument(self)

    def _get_isOutOfDate(self) -> "bool" :
        """
        Indicates if this reference is out of date, meaning that the reference
        is not referencing the latest version.
        """
        return _core.DocumentReference__get_isOutOfDate(self)

    def getLatestVersion(self) -> "bool" :
        """
        Updates the reference to use the latest version. This is only useful
        when the isOutOfDate property is true. 
        Returns true if getting the latest version was successful.
        """
        return _core.DocumentReference_getLatestVersion(self)

    def _get_objectType(self) -> "char const *" : return _core.DocumentReference__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DocumentReference__get_isValid(self)
DocumentReference_swigregister = _core.DocumentReference_swigregister
DocumentReference_swigregister(DocumentReference)

def DocumentReference_classType() -> "char const *" :
  return _core.DocumentReference_classType()
DocumentReference_classType = _core.DocumentReference_classType

DocumentReference.__swig_getmethods__["dataFile"] = DocumentReference._get_dataFile
DocumentReference.dataFile = property(DocumentReference._get_dataFile, doc="The dataFile on A360 that this object references.")

DocumentReference.__swig_getmethods__["referencedDocument"] = DocumentReference._get_referencedDocument
DocumentReference.referencedDocument = property(DocumentReference._get_referencedDocument, doc="The document currently open in Fusion 360 that this object references.")

DocumentReference.__swig_getmethods__["version"] = DocumentReference._get_version
DocumentReference.__swig_setmethods__["version"] = DocumentReference._set_version
DocumentReference.version = property(DocumentReference._get_version, DocumentReference._set_version, doc="Gets and sets the version of the dataFile on A360 that this document currently represents.\nSetting this property will cause all occuurences referencing this document to update to\nthat version.")

DocumentReference.__swig_getmethods__["parentDocument"] = DocumentReference._get_parentDocument
DocumentReference.parentDocument = property(DocumentReference._get_parentDocument, doc="The document that is doing the referencing and owns this reference.")

DocumentReference.__swig_getmethods__["isOutOfDate"] = DocumentReference._get_isOutOfDate
DocumentReference.isOutOfDate = property(DocumentReference._get_isOutOfDate, doc="Indicates if this reference is out of date, meaning that the reference\nis not referencing the latest version.")

DocumentReference.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DocumentReference) else None
DocumentReference.cast = lambda arg: arg if isinstance(arg, DocumentReference) else None

class DocumentReferences(Base):
    """Provides access to the list of documents referenced from a document."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DocumentReferences, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DocumentReferences, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DocumentReferences *" : return _core.DocumentReferences___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DocumentReferences___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DocumentReferences___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.DocumentReferences___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::DocumentReference >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.DocumentReferences___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DocumentReferences_classType
    if _newclass:classType = staticmethod(_core.DocumentReferences_classType)
    __swig_destroy__ = _core.delete_DocumentReferences
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::DocumentReference >" :
        """
        Returns the specified DocumentReference. 
        index : The index of the object to return where the first one in the collection has an index of 0. 
        Returns the specified DocumentReference or null if an invalid index was specified.
        """
        return _core.DocumentReferences_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of DocumentReference objects in this collection."""
        return _core.DocumentReferences__get_count(self)

    def _get_objectType(self) -> "char const *" : return _core.DocumentReferences__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DocumentReferences__get_isValid(self)
DocumentReferences_swigregister = _core.DocumentReferences_swigregister
DocumentReferences_swigregister(DocumentReferences)

def DocumentReferences_classType() -> "char const *" :
  return _core.DocumentReferences_classType()
DocumentReferences_classType = _core.DocumentReferences_classType

DocumentReferences.__swig_getmethods__["count"] = DocumentReferences._get_count
DocumentReferences.count = property(DocumentReferences._get_count, doc="The number of DocumentReference objects in this collection.")

DocumentReferences.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DocumentReferences) else None
DocumentReferences.cast = lambda arg: arg if isinstance(arg, DocumentReferences) else None

class Documents(Base):
    """
    The Documents object provides access to all of the currently open documents and
    provides methods to create and open documents.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Documents, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Documents, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Documents *" : return _core.Documents___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Documents___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Documents___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.Documents___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::Document >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.Documents___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Documents_classType
    if _newclass:classType = staticmethod(_core.Documents_classType)
    __swig_destroy__ = _core.delete_Documents
    __del__ = lambda self : None;
    def add(self, *args) -> "adsk::core::Ptr< adsk::core::Document >" :
        """
        Creates and opens a new document of the specified type. 
        documentType : A value from the DocumentTypes enum that specifies the type of document to create. 
        visible : Optional argument specifying is the document should be visible or not. Currently, documents can only
        be created visibly so this argument must always be true. 
        options : Various options that are supported that are specific to the document type. See the documentation
        for the DocumentTypes enum for information about the options supported for the various types. 
        Returns the created document
        """
        return _core.Documents_add(self, *args)

    def item(self, *args) -> "adsk::core::Ptr< adsk::core::Document >" :
        """
        Function that returns the specified document using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.Documents_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of currently open files."""
        return _core.Documents__get_count(self)

    def open(self, *args) -> "adsk::core::Ptr< adsk::core::Document >" :
        """
        Opens an item that has previously been saved. 
        dataFile : The item to open. 
        visible : Specifies if the document should be opened visibly or not. Currently, documents can only
        be opened visibly so this argument must always be true. 
        Returns the open document or null if the open failed.
        """
        return _core.Documents_open(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Documents__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Documents__get_isValid(self)
Documents_swigregister = _core.Documents_swigregister
Documents_swigregister(Documents)

def Documents_classType() -> "char const *" :
  return _core.Documents_classType()
Documents_classType = _core.Documents_classType

Documents.__swig_getmethods__["count"] = Documents._get_count
Documents.count = property(Documents._get_count, doc="Returns the number of currently open files.")

Documents.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Documents) else None
Documents.cast = lambda arg: arg if isinstance(arg, Documents) else None

class Event(Base):
    """
    Objects can have several Event properties that fire when
    some 'event' occurs. Clients can attach EventHandlers
    to one or more Events and they get notified when the 'event' occurs.
    This is a base class - classes like DocumentEvent add type safety
    (i.e. only allow the correct type of handler to be added to them).
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Event, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Event, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Event *" : return _core.Event___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Event___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Event___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Event_classType
    if _newclass:classType = staticmethod(_core.Event_classType)
    __swig_destroy__ = _core.delete_Event
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """The name of the event - e.g. 'DocumentOpening'"""
        return _core.Event__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.Event__get_sender(self)

    def _get_objectType(self) -> "char const *" : return _core.Event__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Event__get_isValid(self)
Event_swigregister = _core.Event_swigregister
Event_swigregister(Event)

def Event_classType() -> "char const *" :
  return _core.Event_classType()
Event_classType = _core.Event_classType

Event.__swig_getmethods__["name"] = Event._get_name
Event.name = property(Event._get_name, doc="The name of the event - e.g. 'DocumentOpening'")

Event.__swig_getmethods__["sender"] = Event._get_sender
Event.sender = property(Event._get_sender, doc="The object that is firing the event. For example, in the case of a command\ninput event this will return the command.")

Event.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Event) else None
Event.cast = lambda arg: arg if isinstance(arg, Event) else None

class EventArgs(Base):
    """
    When an event handler is called, it is passed 
    an EventArgs object that describes the 'event'.
    This is a base class - classes like DocumentEventArgs add more information on
    the 'event'.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EventArgs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::EventArgs *" : return _core.EventArgs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.EventArgs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.EventArgs___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.EventArgs_classType
    if _newclass:classType = staticmethod(_core.EventArgs_classType)
    __swig_destroy__ = _core.delete_EventArgs
    __del__ = lambda self : None;
    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >" :
        """The event that the firing is in response to."""
        return _core.EventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *" : return _core.EventArgs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.EventArgs__get_isValid(self)
EventArgs_swigregister = _core.EventArgs_swigregister
EventArgs_swigregister(EventArgs)

def EventArgs_classType() -> "char const *" :
  return _core.EventArgs_classType()
EventArgs_classType = _core.EventArgs_classType

EventArgs.__swig_getmethods__["firingEvent"] = EventArgs._get_firingEvent
EventArgs.firingEvent = property(EventArgs._get_firingEvent, doc="The event that the firing is in response to.")

EventArgs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, EventArgs) else None
EventArgs.cast = lambda arg: arg if isinstance(arg, EventArgs) else None

class FavoriteAppearances(Base):
    """Collection of the favorite appearances."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FavoriteAppearances, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FavoriteAppearances, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::FavoriteAppearances *" : return _core.FavoriteAppearances___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.FavoriteAppearances___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.FavoriteAppearances___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.FavoriteAppearances___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::Appearance >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.FavoriteAppearances___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.FavoriteAppearances_classType
    if _newclass:classType = staticmethod(_core.FavoriteAppearances_classType)
    __swig_destroy__ = _core.delete_FavoriteAppearances
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::Appearance >" :
        """
        Returns the specified Appearance using an index into the collection. 
        index : The index of the appearance to return where the first item in the collection is 0. 
        Returns the specified appearance or null if an invalid index is specified.
        """
        return _core.FavoriteAppearances_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of Appearances in the collection."""
        return _core.FavoriteAppearances__get_count(self)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::core::Appearance >" :
        """
        Returns the specified appearance using the name as seen in the user interface. This often isn't
        a reliable way of accessing a specific appearance because appearances are not required to be unique. 
        name : The name of the appearance to return,. 
        Returns the specified appearance or null if there isn't a matching name.
        """
        return _core.FavoriteAppearances_itemByName(self, *args)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::Appearance >" :
        """
        Returns the Appearance by it's internal unique ID. 
        id : The ID of the appearance to return. 
        Returns the specified appearance or null if there isn't a matching ID.
        """
        return _core.FavoriteAppearances_itemById(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::core::Appearance >" :
        """
        Adds an existing appearance to the Favorites list 
        appearance : The appearance to be added to the favorites list. This can come from a Library or from a Design. 
        Returns the Appearance added to the favorites list or null if the operation failed.
        """
        return _core.FavoriteAppearances_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.FavoriteAppearances__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.FavoriteAppearances__get_isValid(self)
FavoriteAppearances_swigregister = _core.FavoriteAppearances_swigregister
FavoriteAppearances_swigregister(FavoriteAppearances)

def FavoriteAppearances_classType() -> "char const *" :
  return _core.FavoriteAppearances_classType()
FavoriteAppearances_classType = _core.FavoriteAppearances_classType

FavoriteAppearances.__swig_getmethods__["count"] = FavoriteAppearances._get_count
FavoriteAppearances.count = property(FavoriteAppearances._get_count, doc="The number of Appearances in the collection.")

FavoriteAppearances.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FavoriteAppearances) else None
FavoriteAppearances.cast = lambda arg: arg if isinstance(arg, FavoriteAppearances) else None

class FavoriteMaterials(Base):
    """Collection of the favorite materials."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FavoriteMaterials, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FavoriteMaterials, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::FavoriteMaterials *" : return _core.FavoriteMaterials___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.FavoriteMaterials___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.FavoriteMaterials___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.FavoriteMaterials___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::Material >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.FavoriteMaterials___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.FavoriteMaterials_classType
    if _newclass:classType = staticmethod(_core.FavoriteMaterials_classType)
    __swig_destroy__ = _core.delete_FavoriteMaterials
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::Material >" :
        """
        Returns the specified Material using an index into the collection. 
        index : The index of the material to return where the first item in the collection is 0. 
        Returns the specified material or null if an invalid index is specified.
        """
        return _core.FavoriteMaterials_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of Materials in the collection."""
        return _core.FavoriteMaterials__get_count(self)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::core::Material >" :
        """
        Returns the specified Material using the name as seen in the user interface. This often isn't
        a reliable way of accessing a specific material because materials are not required to be unique. 
        name : The name of the material to return,. 
        Returns the specified material or null if there isn't a matching name.
        """
        return _core.FavoriteMaterials_itemByName(self, *args)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::Material >" :
        """
        Returns the Material by it's internal unique ID. 
        id : The ID of the material to return. 
        Returns the specified material or null if there isn't a matching ID.
        """
        return _core.FavoriteMaterials_itemById(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::core::Material >" :
        """
        Adds an existing material to the Favorites list 
        material : The material to be added to the favorites list. This can come from a Library or from a Design. 
        Returns the Material added to the favorites list or null if the operation failed.
        """
        return _core.FavoriteMaterials_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.FavoriteMaterials__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.FavoriteMaterials__get_isValid(self)
FavoriteMaterials_swigregister = _core.FavoriteMaterials_swigregister
FavoriteMaterials_swigregister(FavoriteMaterials)

def FavoriteMaterials_classType() -> "char const *" :
  return _core.FavoriteMaterials_classType()
FavoriteMaterials_classType = _core.FavoriteMaterials_classType

FavoriteMaterials.__swig_getmethods__["count"] = FavoriteMaterials._get_count
FavoriteMaterials.count = property(FavoriteMaterials._get_count, doc="The number of Materials in the collection.")

FavoriteMaterials.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FavoriteMaterials) else None
FavoriteMaterials.cast = lambda arg: arg if isinstance(arg, FavoriteMaterials) else None

class FileDialog(Base):
    """
    Provides access to a file dialog. A file dialog can be used to prompt the user
    for file names to open or save to.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileDialog, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FileDialog, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::FileDialog *" : return _core.FileDialog___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.FileDialog___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.FileDialog___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.FileDialog_classType
    if _newclass:classType = staticmethod(_core.FileDialog_classType)
    __swig_destroy__ = _core.delete_FileDialog
    __del__ = lambda self : None;
    def _get_title(self) -> "std::string" :
        """Gets or sets the title displayed on the dialog."""
        return _core.FileDialog__get_title(self)

    def _set_title(self, *args) -> "bool" :
        """Gets or sets the title displayed on the dialog."""
        return _core.FileDialog__set_title(self, *args)

    def _get_filename(self) -> "std::string" :
        """
        Gets the filename specified by the user in the dialog. This property is 
        used after the ShowOpen or ShowSave methods have been called to retrieve
        the filename specified by the user. The file name includes both the 
        file path and the extension.
        If ShowOpen was used and IsMultiSelectEnabled is true, then this property will
        only display the first filename selected and the Filenames property should be
        used instead to retrieved the full list. Is ShowSave was used, then only a
        single file name is ever returned.
        """
        return _core.FileDialog__get_filename(self)

    def _get_filenames(self) -> "std::vector< std::string,std::allocator< std::string > >" :
        """
        Gets the filenames specified by the user in the dialog. This property is 
        used after the ShowOpen or ShowSave methods have been called to retrieve
        the filenames specified by the user. Each file name includes both the 
        file path and the extension.
        If ShowOpen is used and IsMultiSelectEnabled is true, the user is able to select
        more than one file. This property returns all of the files that were selected. If
        ShowSave is used or IsMultiSelectEnabled is false then this array will contain
        the single file name.
        """
        return _core.FileDialog__get_filenames(self)

    def _get_filter(self) -> "std::string" :
        """
        Gets or sets the current file name filter string, which determines the choices 
        that appear in the 'Save as file type' or 'Files of type' box in the dialog box.
        For each filtering option, the filter string contains a description of the filter 
        and the filter pattern as specified in parentheses and seperated by semi-colons. Multiple
        filters are seperated by a double semi-colon. These are illustrated below.
        The following is an example of a filter string: 
        Text files (*.txt);;All files (*.*) 
        You can add several filter patterns to a filter by separating the file types with semicolons, for example: 
        Image Files (*.BMP;*.JPG;*.GIF);;All files (*.*)
        """
        return _core.FileDialog__get_filter(self)

    def _set_filter(self, *args) -> "bool" :
        """
        Gets or sets the current file name filter string, which determines the choices 
        that appear in the 'Save as file type' or 'Files of type' box in the dialog box.
        For each filtering option, the filter string contains a description of the filter 
        and the filter pattern as specified in parentheses and seperated by semi-colons. Multiple
        filters are seperated by a double semi-colon. These are illustrated below.
        The following is an example of a filter string: 
        Text files (*.txt);;All files (*.*) 
        You can add several filter patterns to a filter by separating the file types with semicolons, for example: 
        Image Files (*.BMP;*.JPG;*.GIF);;All files (*.*)
        """
        return _core.FileDialog__set_filter(self, *args)

    def _get_filterIndex(self) -> "int" :
        """
        Gets or sets the index of the filter currently selected in the file dialog box. Use the FilterIndex 
        property to set which filtering option is shown first to the user. You can also use the value of 
        FilterIndex after showing the file dialog to perform special file operations depending upon the filter chosen.
        The first item in the filter list is index 0.
        """
        return _core.FileDialog__get_filterIndex(self)

    def _set_filterIndex(self, *args) -> "bool" :
        """
        Gets or sets the index of the filter currently selected in the file dialog box. Use the FilterIndex 
        property to set which filtering option is shown first to the user. You can also use the value of 
        FilterIndex after showing the file dialog to perform special file operations depending upon the filter chosen.
        The first item in the filter list is index 0.
        """
        return _core.FileDialog__set_filterIndex(self, *args)

    def _get_initialDirectory(self) -> "std::string" :
        """Gets or sets the initial directory displayed by the file dialog box."""
        return _core.FileDialog__get_initialDirectory(self)

    def _set_initialDirectory(self, *args) -> "bool" :
        """Gets or sets the initial directory displayed by the file dialog box."""
        return _core.FileDialog__set_initialDirectory(self, *args)

    def _get_isMultiSelectEnabled(self) -> "bool" :
        """Gets or sets a value indicating whether the dialog box allows multiple files to be selected."""
        return _core.FileDialog__get_isMultiSelectEnabled(self)

    def _set_isMultiSelectEnabled(self, *args) -> "bool" :
        """Gets or sets a value indicating whether the dialog box allows multiple files to be selected."""
        return _core.FileDialog__set_isMultiSelectEnabled(self, *args)

    def showOpen(self) -> "adsk::core::DialogResults" :
        """
        Displays a modal open dialog, allowing the user to select one or more files. The return value
        can be used to determine if the dialog was cancelled without selecting a file. The Filename
        and Filenames properties can be used to get the selected files. 
        Returns an enum value indicating which button was clicked on the dialog.
        """
        return _core.FileDialog_showOpen(self)

    def showSave(self) -> "adsk::core::DialogResults" :
        """
        Displays a modal save dialog, allowing the user to specify a file. The return value
        can be used to determine if the dialog was cancelled without selecting a file. The Filename
        and Filenames properties can be used to get the selected files. 
        Returns an enum value indicating which button was clicked on the dialog.
        """
        return _core.FileDialog_showSave(self)

    def _get_initialFilename(self) -> "std::string" :
        """
        Gets or sets the initial filename displayed when the dialog is first displayed.
        When a new FileDialog object is created this defaults to an empty string so no
        initial filename is specified. 
        If the showOpen option is used, the file must 
        already exist in the directory specified by the initialDirectory property. If 
        it doesn't exist, the initial filename will not be used.
        """
        return _core.FileDialog__get_initialFilename(self)

    def _set_initialFilename(self, *args) -> "bool" :
        """
        Gets or sets the initial filename displayed when the dialog is first displayed.
        When a new FileDialog object is created this defaults to an empty string so no
        initial filename is specified. 
        If the showOpen option is used, the file must 
        already exist in the directory specified by the initialDirectory property. If 
        it doesn't exist, the initial filename will not be used.
        """
        return _core.FileDialog__set_initialFilename(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.FileDialog__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.FileDialog__get_isValid(self)
FileDialog_swigregister = _core.FileDialog_swigregister
FileDialog_swigregister(FileDialog)

def FileDialog_classType() -> "char const *" :
  return _core.FileDialog_classType()
FileDialog_classType = _core.FileDialog_classType

FileDialog.__swig_getmethods__["title"] = FileDialog._get_title
FileDialog.__swig_setmethods__["title"] = FileDialog._set_title
FileDialog.title = property(FileDialog._get_title, FileDialog._set_title, doc="Gets or sets the title displayed on the dialog.")

FileDialog.__swig_getmethods__["filename"] = FileDialog._get_filename
FileDialog.filename = property(FileDialog._get_filename, doc="Gets the filename specified by the user in the dialog. This property is\nused after the ShowOpen or ShowSave methods have been called to retrieve\nthe filename specified by the user. The file name includes both the\nfile path and the extension.\nIf ShowOpen was used and IsMultiSelectEnabled is true, then this property will\nonly display the first filename selected and the Filenames property should be\nused instead to retrieved the full list. Is ShowSave was used, then only a\nsingle file name is ever returned.")

FileDialog.__swig_getmethods__["filenames"] = FileDialog._get_filenames
FileDialog.filenames = property(FileDialog._get_filenames, doc="Gets the filenames specified by the user in the dialog. This property is\nused after the ShowOpen or ShowSave methods have been called to retrieve\nthe filenames specified by the user. Each file name includes both the\nfile path and the extension.\nIf ShowOpen is used and IsMultiSelectEnabled is true, the user is able to select\nmore than one file. This property returns all of the files that were selected. If\nShowSave is used or IsMultiSelectEnabled is false then this array will contain\nthe single file name.")

FileDialog.__swig_getmethods__["filter"] = FileDialog._get_filter
FileDialog.__swig_setmethods__["filter"] = FileDialog._set_filter
FileDialog.filter = property(FileDialog._get_filter, FileDialog._set_filter, doc="Gets or sets the current file name filter string, which determines the choices\nthat appear in the 'Save as file type' or 'Files of type' box in the dialog box.\nFor each filtering option, the filter string contains a description of the filter\nand the filter pattern as specified in parentheses and seperated by semi-colons. Multiple\nfilters are seperated by a double semi-colon. These are illustrated below.\nThe following is an example of a filter string:\nText files (*.txt);;All files (*.*)\nYou can add several filter patterns to a filter by separating the file types with semicolons, for example:\nImage Files (*.BMP;*.JPG;*.GIF);;All files (*.*)")

FileDialog.__swig_getmethods__["filterIndex"] = FileDialog._get_filterIndex
FileDialog.__swig_setmethods__["filterIndex"] = FileDialog._set_filterIndex
FileDialog.filterIndex = property(FileDialog._get_filterIndex, FileDialog._set_filterIndex, doc="Gets or sets the index of the filter currently selected in the file dialog box. Use the FilterIndex\nproperty to set which filtering option is shown first to the user. You can also use the value of\nFilterIndex after showing the file dialog to perform special file operations depending upon the filter chosen.\nThe first item in the filter list is index 0.")

FileDialog.__swig_getmethods__["initialDirectory"] = FileDialog._get_initialDirectory
FileDialog.__swig_setmethods__["initialDirectory"] = FileDialog._set_initialDirectory
FileDialog.initialDirectory = property(FileDialog._get_initialDirectory, FileDialog._set_initialDirectory, doc="Gets or sets the initial directory displayed by the file dialog box.")

FileDialog.__swig_getmethods__["isMultiSelectEnabled"] = FileDialog._get_isMultiSelectEnabled
FileDialog.__swig_setmethods__["isMultiSelectEnabled"] = FileDialog._set_isMultiSelectEnabled
FileDialog.isMultiSelectEnabled = property(FileDialog._get_isMultiSelectEnabled, FileDialog._set_isMultiSelectEnabled, doc="Gets or sets a value indicating whether the dialog box allows multiple files to be selected.")

FileDialog.__swig_getmethods__["initialFilename"] = FileDialog._get_initialFilename
FileDialog.__swig_setmethods__["initialFilename"] = FileDialog._set_initialFilename
FileDialog.initialFilename = property(FileDialog._get_initialFilename, FileDialog._set_initialFilename, doc="Gets or sets the initial filename displayed when the dialog is first displayed.\nWhen a new FileDialog object is created this defaults to an empty string so no\ninitial filename is specified.\nIf the showOpen option is used, the file must\nalready exist in the directory specified by the initialDirectory property. If\nit doesn't exist, the initial filename will not be used.")

FileDialog.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FileDialog) else None
FileDialog.cast = lambda arg: arg if isinstance(arg, FileDialog) else None

class FolderDialog(Base):
    """Provides access to a folder selection dialog to allow the user to select a folder."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FolderDialog, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FolderDialog, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::FolderDialog *" : return _core.FolderDialog___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.FolderDialog___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.FolderDialog___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.FolderDialog_classType
    if _newclass:classType = staticmethod(_core.FolderDialog_classType)
    __swig_destroy__ = _core.delete_FolderDialog
    __del__ = lambda self : None;
    def _get_title(self) -> "std::string" :
        """Gets or sets the title displayed on the dialog."""
        return _core.FolderDialog__get_title(self)

    def _set_title(self, *args) -> "bool" :
        """Gets or sets the title displayed on the dialog."""
        return _core.FolderDialog__set_title(self, *args)

    def _get_folder(self) -> "std::string" :
        """
        Gets the folder selected by the user in the dialog. This property is 
        used after the ShowDialog method has been called to retrieve the folder
        specified by the user.
        """
        return _core.FolderDialog__get_folder(self)

    def _get_initialDirectory(self) -> "std::string" :
        """Gets or sets the initial directory displayed by the file dialog box."""
        return _core.FolderDialog__get_initialDirectory(self)

    def _set_initialDirectory(self, *args) -> "bool" :
        """Gets or sets the initial directory displayed by the file dialog box."""
        return _core.FolderDialog__set_initialDirectory(self, *args)

    def showDialog(self) -> "adsk::core::DialogResults" :
        """
        Displays a modal dialog allowing the user to select a folder. The return value
        can be used to determine if the dialog was cancelled without selecting a foldre. 
        the folder property can be used to get the selected folder. 
        Returns an enum value indicating which button was clicked on the dialog.
        """
        return _core.FolderDialog_showDialog(self)

    def _get_objectType(self) -> "char const *" : return _core.FolderDialog__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.FolderDialog__get_isValid(self)
FolderDialog_swigregister = _core.FolderDialog_swigregister
FolderDialog_swigregister(FolderDialog)

def FolderDialog_classType() -> "char const *" :
  return _core.FolderDialog_classType()
FolderDialog_classType = _core.FolderDialog_classType

FolderDialog.__swig_getmethods__["title"] = FolderDialog._get_title
FolderDialog.__swig_setmethods__["title"] = FolderDialog._set_title
FolderDialog.title = property(FolderDialog._get_title, FolderDialog._set_title, doc="Gets or sets the title displayed on the dialog.")

FolderDialog.__swig_getmethods__["folder"] = FolderDialog._get_folder
FolderDialog.folder = property(FolderDialog._get_folder, doc="Gets the folder selected by the user in the dialog. This property is\nused after the ShowDialog method has been called to retrieve the folder\nspecified by the user.")

FolderDialog.__swig_getmethods__["initialDirectory"] = FolderDialog._get_initialDirectory
FolderDialog.__swig_setmethods__["initialDirectory"] = FolderDialog._set_initialDirectory
FolderDialog.initialDirectory = property(FolderDialog._get_initialDirectory, FolderDialog._set_initialDirectory, doc="Gets or sets the initial directory displayed by the file dialog box.")

FolderDialog.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FolderDialog) else None
FolderDialog.cast = lambda arg: arg if isinstance(arg, FolderDialog) else None

class GeneralPreferences(Base):
    """Provides access to the general preferences."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GeneralPreferences, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GeneralPreferences, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::GeneralPreferences *" : return _core.GeneralPreferences___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.GeneralPreferences___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.GeneralPreferences___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.GeneralPreferences_classType
    if _newclass:classType = staticmethod(_core.GeneralPreferences_classType)
    __swig_destroy__ = _core.delete_GeneralPreferences
    __del__ = lambda self : None;
    def _get_userLanguage(self) -> "adsk::core::UserLanguages" :
        """
        Gets and sets the current language. Setting the language does not
        take effect until the next time Fusion 360 is started.
        """
        return _core.GeneralPreferences__get_userLanguage(self)

    def _set_userLanguage(self, *args) -> "bool" :
        """
        Gets and sets the current language. Setting the language does not
        take effect until the next time Fusion 360 is started.
        """
        return _core.GeneralPreferences__set_userLanguage(self, *args)

    def _get_offlineCachePeriod(self) -> "double" :
        """Gets and sets the length of time, in days, that the offline cache of a document will remain."""
        return _core.GeneralPreferences__get_offlineCachePeriod(self)

    def _set_offlineCachePeriod(self, *args) -> "bool" :
        """Gets and sets the length of time, in days, that the offline cache of a document will remain."""
        return _core.GeneralPreferences__set_offlineCachePeriod(self, *args)

    def _get_graphicsDriver(self) -> "adsk::core::GraphicsDrivers" :
        """Gets and sets the graphics driver used to display the graphics."""
        return _core.GeneralPreferences__get_graphicsDriver(self)

    def _set_graphicsDriver(self, *args) -> "bool" :
        """Gets and sets the graphics driver used to display the graphics."""
        return _core.GeneralPreferences__set_graphicsDriver(self, *args)

    def _get_isAutomaticSaveOnCloseEnabled(self) -> "bool" :
        """Gets and sets if the file is automatically saved on close."""
        return _core.GeneralPreferences__get_isAutomaticSaveOnCloseEnabled(self)

    def _set_isAutomaticSaveOnCloseEnabled(self, *args) -> "bool" :
        """Gets and sets if the file is automatically saved on close."""
        return _core.GeneralPreferences__set_isAutomaticSaveOnCloseEnabled(self, *args)

    def _get_isAutomaticVersioningEnabled(self) -> "bool" :
        """Gets and sets if a version of the file is automatically saved using a background thread."""
        return _core.GeneralPreferences__get_isAutomaticVersioningEnabled(self)

    def _set_isAutomaticVersioningEnabled(self, *args) -> "bool" :
        """Gets and sets if a version of the file is automatically saved using a background thread."""
        return _core.GeneralPreferences__set_isAutomaticVersioningEnabled(self, *args)

    def _get_automateVersioningTimeInterval(self) -> "int" :
        """Gets and sets the interval, in minutes, for automatic versioning."""
        return _core.GeneralPreferences__get_automateVersioningTimeInterval(self)

    def _set_automateVersioningTimeInterval(self, *args) -> "bool" :
        """Gets and sets the interval, in minutes, for automatic versioning."""
        return _core.GeneralPreferences__set_automateVersioningTimeInterval(self, *args)

    def _get_defaultModelingOrientation(self) -> "adsk::core::DefaultModelingOrientations" :
        """Gets and sets the default for which direction is considered 'up'."""
        return _core.GeneralPreferences__get_defaultModelingOrientation(self)

    def _set_defaultModelingOrientation(self, *args) -> "bool" :
        """Gets and sets the default for which direction is considered 'up'."""
        return _core.GeneralPreferences__set_defaultModelingOrientation(self, *args)

    def _get_areTooltipsShown(self) -> "bool" :
        """Gets and sets if tooltips are shown."""
        return _core.GeneralPreferences__get_areTooltipsShown(self)

    def _set_areTooltipsShown(self, *args) -> "bool" :
        """Gets and sets if tooltips are shown."""
        return _core.GeneralPreferences__set_areTooltipsShown(self, *args)

    def _get_isCommandPromptShown(self) -> "bool" :
        """Gets and sets if the command prompt is shown."""
        return _core.GeneralPreferences__get_isCommandPromptShown(self)

    def _set_isCommandPromptShown(self, *args) -> "bool" :
        """Gets and sets if the command prompt is shown."""
        return _core.GeneralPreferences__set_isCommandPromptShown(self, *args)

    def _get_areTipsAndTricksShown(self) -> "bool" :
        """Gets and sets if in command tips and tricks are shown."""
        return _core.GeneralPreferences__get_areTipsAndTricksShown(self)

    def _set_areTipsAndTricksShown(self, *args) -> "bool" :
        """Gets and sets if in command tips and tricks are shown."""
        return _core.GeneralPreferences__set_areTipsAndTricksShown(self, *args)

    def _get_areInCommandErrorsAndWarningsShown(self) -> "bool" :
        """Gets and sets if in command errors and warnings are shown."""
        return _core.GeneralPreferences__get_areInCommandErrorsAndWarningsShown(self)

    def _set_areInCommandErrorsAndWarningsShown(self, *args) -> "bool" :
        """Gets and sets if in command errors and warnings are shown."""
        return _core.GeneralPreferences__set_areInCommandErrorsAndWarningsShown(self, *args)

    def _get_areAutodesk360NotificationsShown(self) -> "bool" :
        """Gets and sets if Autodesk 360 notifications are shown."""
        return _core.GeneralPreferences__get_areAutodesk360NotificationsShown(self)

    def _set_areAutodesk360NotificationsShown(self, *args) -> "bool" :
        """Gets and sets if Autodesk 360 notifications are shown."""
        return _core.GeneralPreferences__set_areAutodesk360NotificationsShown(self, *args)

    def _get_isGestureBasedViewNavigationUsed(self) -> "bool" :
        """Gets and sets if gesture based view navigation is used."""
        return _core.GeneralPreferences__get_isGestureBasedViewNavigationUsed(self)

    def _set_isGestureBasedViewNavigationUsed(self, *args) -> "bool" :
        """Gets and sets if gesture based view navigation is used."""
        return _core.GeneralPreferences__set_isGestureBasedViewNavigationUsed(self, *args)

    def _get_isZoomDirectionReversed(self) -> "bool" :
        """Gets and sets if the direction of the zoom is reversed."""
        return _core.GeneralPreferences__get_isZoomDirectionReversed(self)

    def _set_isZoomDirectionReversed(self, *args) -> "bool" :
        """Gets and sets if the direction of the zoom is reversed."""
        return _core.GeneralPreferences__set_isZoomDirectionReversed(self, *args)

    def _get_isCameraPivotEnabled(self) -> "bool" :
        """Gets and sets if zoom and orbit commands use camera pivot point for transition."""
        return _core.GeneralPreferences__get_isCameraPivotEnabled(self)

    def _set_isCameraPivotEnabled(self, *args) -> "bool" :
        """Gets and sets if zoom and orbit commands use camera pivot point for transition."""
        return _core.GeneralPreferences__set_isCameraPivotEnabled(self, *args)

    def _get_defaultOrbit(self) -> "adsk::core::DefaultOrbits" :
        """Get and sets the type of orbit."""
        return _core.GeneralPreferences__get_defaultOrbit(self)

    def _set_defaultOrbit(self, *args) -> "bool" :
        """Get and sets the type of orbit."""
        return _core.GeneralPreferences__set_defaultOrbit(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.GeneralPreferences__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.GeneralPreferences__get_isValid(self)
GeneralPreferences_swigregister = _core.GeneralPreferences_swigregister
GeneralPreferences_swigregister(GeneralPreferences)

def GeneralPreferences_classType() -> "char const *" :
  return _core.GeneralPreferences_classType()
GeneralPreferences_classType = _core.GeneralPreferences_classType

GeneralPreferences.__swig_getmethods__["userLanguage"] = GeneralPreferences._get_userLanguage
GeneralPreferences.__swig_setmethods__["userLanguage"] = GeneralPreferences._set_userLanguage
GeneralPreferences.userLanguage = property(GeneralPreferences._get_userLanguage, GeneralPreferences._set_userLanguage, doc="Gets and sets the current language. Setting the language does not\ntake effect until the next time Fusion 360 is started.")

GeneralPreferences.__swig_getmethods__["offlineCachePeriod"] = GeneralPreferences._get_offlineCachePeriod
GeneralPreferences.__swig_setmethods__["offlineCachePeriod"] = GeneralPreferences._set_offlineCachePeriod
GeneralPreferences.offlineCachePeriod = property(GeneralPreferences._get_offlineCachePeriod, GeneralPreferences._set_offlineCachePeriod, doc="Gets and sets the length of time, in days, that the offline cache of a document will remain.")

GeneralPreferences.__swig_getmethods__["graphicsDriver"] = GeneralPreferences._get_graphicsDriver
GeneralPreferences.__swig_setmethods__["graphicsDriver"] = GeneralPreferences._set_graphicsDriver
GeneralPreferences.graphicsDriver = property(GeneralPreferences._get_graphicsDriver, GeneralPreferences._set_graphicsDriver, doc="Gets and sets the graphics driver used to display the graphics.")

GeneralPreferences.__swig_getmethods__["isAutomaticSaveOnCloseEnabled"] = GeneralPreferences._get_isAutomaticSaveOnCloseEnabled
GeneralPreferences.__swig_setmethods__["isAutomaticSaveOnCloseEnabled"] = GeneralPreferences._set_isAutomaticSaveOnCloseEnabled
GeneralPreferences.isAutomaticSaveOnCloseEnabled = property(GeneralPreferences._get_isAutomaticSaveOnCloseEnabled, GeneralPreferences._set_isAutomaticSaveOnCloseEnabled, doc="Gets and sets if the file is automatically saved on close.")

GeneralPreferences.__swig_getmethods__["isAutomaticVersioningEnabled"] = GeneralPreferences._get_isAutomaticVersioningEnabled
GeneralPreferences.__swig_setmethods__["isAutomaticVersioningEnabled"] = GeneralPreferences._set_isAutomaticVersioningEnabled
GeneralPreferences.isAutomaticVersioningEnabled = property(GeneralPreferences._get_isAutomaticVersioningEnabled, GeneralPreferences._set_isAutomaticVersioningEnabled, doc="Gets and sets if a version of the file is automatically saved using a background thread.")

GeneralPreferences.__swig_getmethods__["automateVersioningTimeInterval"] = GeneralPreferences._get_automateVersioningTimeInterval
GeneralPreferences.__swig_setmethods__["automateVersioningTimeInterval"] = GeneralPreferences._set_automateVersioningTimeInterval
GeneralPreferences.automateVersioningTimeInterval = property(GeneralPreferences._get_automateVersioningTimeInterval, GeneralPreferences._set_automateVersioningTimeInterval, doc="Gets and sets the interval, in minutes, for automatic versioning.")

GeneralPreferences.__swig_getmethods__["defaultModelingOrientation"] = GeneralPreferences._get_defaultModelingOrientation
GeneralPreferences.__swig_setmethods__["defaultModelingOrientation"] = GeneralPreferences._set_defaultModelingOrientation
GeneralPreferences.defaultModelingOrientation = property(GeneralPreferences._get_defaultModelingOrientation, GeneralPreferences._set_defaultModelingOrientation, doc="Gets and sets the default for which direction is considered 'up'.")

GeneralPreferences.__swig_getmethods__["areTooltipsShown"] = GeneralPreferences._get_areTooltipsShown
GeneralPreferences.__swig_setmethods__["areTooltipsShown"] = GeneralPreferences._set_areTooltipsShown
GeneralPreferences.areTooltipsShown = property(GeneralPreferences._get_areTooltipsShown, GeneralPreferences._set_areTooltipsShown, doc="Gets and sets if tooltips are shown.")

GeneralPreferences.__swig_getmethods__["isCommandPromptShown"] = GeneralPreferences._get_isCommandPromptShown
GeneralPreferences.__swig_setmethods__["isCommandPromptShown"] = GeneralPreferences._set_isCommandPromptShown
GeneralPreferences.isCommandPromptShown = property(GeneralPreferences._get_isCommandPromptShown, GeneralPreferences._set_isCommandPromptShown, doc="Gets and sets if the command prompt is shown.")

GeneralPreferences.__swig_getmethods__["areTipsAndTricksShown"] = GeneralPreferences._get_areTipsAndTricksShown
GeneralPreferences.__swig_setmethods__["areTipsAndTricksShown"] = GeneralPreferences._set_areTipsAndTricksShown
GeneralPreferences.areTipsAndTricksShown = property(GeneralPreferences._get_areTipsAndTricksShown, GeneralPreferences._set_areTipsAndTricksShown, doc="Gets and sets if in command tips and tricks are shown.")

GeneralPreferences.__swig_getmethods__["areInCommandErrorsAndWarningsShown"] = GeneralPreferences._get_areInCommandErrorsAndWarningsShown
GeneralPreferences.__swig_setmethods__["areInCommandErrorsAndWarningsShown"] = GeneralPreferences._set_areInCommandErrorsAndWarningsShown
GeneralPreferences.areInCommandErrorsAndWarningsShown = property(GeneralPreferences._get_areInCommandErrorsAndWarningsShown, GeneralPreferences._set_areInCommandErrorsAndWarningsShown, doc="Gets and sets if in command errors and warnings are shown.")

GeneralPreferences.__swig_getmethods__["areAutodesk360NotificationsShown"] = GeneralPreferences._get_areAutodesk360NotificationsShown
GeneralPreferences.__swig_setmethods__["areAutodesk360NotificationsShown"] = GeneralPreferences._set_areAutodesk360NotificationsShown
GeneralPreferences.areAutodesk360NotificationsShown = property(GeneralPreferences._get_areAutodesk360NotificationsShown, GeneralPreferences._set_areAutodesk360NotificationsShown, doc="Gets and sets if Autodesk 360 notifications are shown.")

GeneralPreferences.__swig_getmethods__["isGestureBasedViewNavigationUsed"] = GeneralPreferences._get_isGestureBasedViewNavigationUsed
GeneralPreferences.__swig_setmethods__["isGestureBasedViewNavigationUsed"] = GeneralPreferences._set_isGestureBasedViewNavigationUsed
GeneralPreferences.isGestureBasedViewNavigationUsed = property(GeneralPreferences._get_isGestureBasedViewNavigationUsed, GeneralPreferences._set_isGestureBasedViewNavigationUsed, doc="Gets and sets if gesture based view navigation is used.")

GeneralPreferences.__swig_getmethods__["isZoomDirectionReversed"] = GeneralPreferences._get_isZoomDirectionReversed
GeneralPreferences.__swig_setmethods__["isZoomDirectionReversed"] = GeneralPreferences._set_isZoomDirectionReversed
GeneralPreferences.isZoomDirectionReversed = property(GeneralPreferences._get_isZoomDirectionReversed, GeneralPreferences._set_isZoomDirectionReversed, doc="Gets and sets if the direction of the zoom is reversed.")

GeneralPreferences.__swig_getmethods__["isCameraPivotEnabled"] = GeneralPreferences._get_isCameraPivotEnabled
GeneralPreferences.__swig_setmethods__["isCameraPivotEnabled"] = GeneralPreferences._set_isCameraPivotEnabled
GeneralPreferences.isCameraPivotEnabled = property(GeneralPreferences._get_isCameraPivotEnabled, GeneralPreferences._set_isCameraPivotEnabled, doc="Gets and sets if zoom and orbit commands use camera pivot point for transition.")

GeneralPreferences.__swig_getmethods__["defaultOrbit"] = GeneralPreferences._get_defaultOrbit
GeneralPreferences.__swig_setmethods__["defaultOrbit"] = GeneralPreferences._set_defaultOrbit
GeneralPreferences.defaultOrbit = property(GeneralPreferences._get_defaultOrbit, GeneralPreferences._set_defaultOrbit, doc="Get and sets the type of orbit.")

GeneralPreferences.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, GeneralPreferences) else None
GeneralPreferences.cast = lambda arg: arg if isinstance(arg, GeneralPreferences) else None

class GraphicsPreferences(Base):
    """The GraphicsPreferences object provides access to the various graphics related preferences."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GraphicsPreferences, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GraphicsPreferences, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::GraphicsPreferences *" : return _core.GraphicsPreferences___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.GraphicsPreferences___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.GraphicsPreferences___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.GraphicsPreferences_classType
    if _newclass:classType = staticmethod(_core.GraphicsPreferences_classType)
    __swig_destroy__ = _core.delete_GraphicsPreferences
    __del__ = lambda self : None;
    def _get_minimumFramesPerSecond(self) -> "double" :
        """Gets and sets the minimum frames per second."""
        return _core.GraphicsPreferences__get_minimumFramesPerSecond(self)

    def _set_minimumFramesPerSecond(self, *args) -> "bool" :
        """Gets and sets the minimum frames per second."""
        return _core.GraphicsPreferences__set_minimumFramesPerSecond(self, *args)

    def _get_selectionDisplayStyle(self) -> "adsk::core::SelectionDisplayStyles" :
        """Gets and sets the style of display to use for selections."""
        return _core.GraphicsPreferences__get_selectionDisplayStyle(self)

    def _set_selectionDisplayStyle(self, *args) -> "bool" :
        """Gets and sets the style of display to use for selections."""
        return _core.GraphicsPreferences__set_selectionDisplayStyle(self, *args)

    def _get_degradedSelectionDisplayStyle(self) -> "adsk::core::DegradedSelectionDisplayStyles" :
        """Gets and sets the style of display for degraded selections."""
        return _core.GraphicsPreferences__get_degradedSelectionDisplayStyle(self)

    def _set_degradedSelectionDisplayStyle(self, *args) -> "bool" :
        """Gets and sets the style of display for degraded selections."""
        return _core.GraphicsPreferences__set_degradedSelectionDisplayStyle(self, *args)

    def _get_transparencyEffects(self) -> "adsk::core::TransparencyDisplayEffects" :
        """Gets and sets the style of display for transparency effects."""
        return _core.GraphicsPreferences__get_transparencyEffects(self)

    def _set_transparencyEffects(self, *args) -> "bool" :
        """Gets and sets the style of display for transparency effects."""
        return _core.GraphicsPreferences__set_transparencyEffects(self, *args)

    def _get_autoThrottleEffects(self) -> "bool" :
        """Gets and sets if automatically disable or degrade visual effects to keep the video memory pressure under a safe threshold."""
        return _core.GraphicsPreferences__get_autoThrottleEffects(self)

    def _set_autoThrottleEffects(self, *args) -> "bool" :
        """Gets and sets if automatically disable or degrade visual effects to keep the video memory pressure under a safe threshold."""
        return _core.GraphicsPreferences__set_autoThrottleEffects(self, *args)

    def _get_hiddenEdgeDimming(self) -> "int" :
        """
        Gets and sets the dimming percentage to use for hidden edges.
        the value is a percentage expressed by a value between 0 and 100.
        """
        return _core.GraphicsPreferences__get_hiddenEdgeDimming(self)

    def _set_hiddenEdgeDimming(self, *args) -> "bool" :
        """
        Gets and sets the dimming percentage to use for hidden edges.
        the value is a percentage expressed by a value between 0 and 100.
        """
        return _core.GraphicsPreferences__set_hiddenEdgeDimming(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.GraphicsPreferences__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.GraphicsPreferences__get_isValid(self)
GraphicsPreferences_swigregister = _core.GraphicsPreferences_swigregister
GraphicsPreferences_swigregister(GraphicsPreferences)

def GraphicsPreferences_classType() -> "char const *" :
  return _core.GraphicsPreferences_classType()
GraphicsPreferences_classType = _core.GraphicsPreferences_classType

GraphicsPreferences.__swig_getmethods__["minimumFramesPerSecond"] = GraphicsPreferences._get_minimumFramesPerSecond
GraphicsPreferences.__swig_setmethods__["minimumFramesPerSecond"] = GraphicsPreferences._set_minimumFramesPerSecond
GraphicsPreferences.minimumFramesPerSecond = property(GraphicsPreferences._get_minimumFramesPerSecond, GraphicsPreferences._set_minimumFramesPerSecond, doc="Gets and sets the minimum frames per second.")

GraphicsPreferences.__swig_getmethods__["selectionDisplayStyle"] = GraphicsPreferences._get_selectionDisplayStyle
GraphicsPreferences.__swig_setmethods__["selectionDisplayStyle"] = GraphicsPreferences._set_selectionDisplayStyle
GraphicsPreferences.selectionDisplayStyle = property(GraphicsPreferences._get_selectionDisplayStyle, GraphicsPreferences._set_selectionDisplayStyle, doc="Gets and sets the style of display to use for selections.")

GraphicsPreferences.__swig_getmethods__["degradedSelectionDisplayStyle"] = GraphicsPreferences._get_degradedSelectionDisplayStyle
GraphicsPreferences.__swig_setmethods__["degradedSelectionDisplayStyle"] = GraphicsPreferences._set_degradedSelectionDisplayStyle
GraphicsPreferences.degradedSelectionDisplayStyle = property(GraphicsPreferences._get_degradedSelectionDisplayStyle, GraphicsPreferences._set_degradedSelectionDisplayStyle, doc="Gets and sets the style of display for degraded selections.")

GraphicsPreferences.__swig_getmethods__["transparencyEffects"] = GraphicsPreferences._get_transparencyEffects
GraphicsPreferences.__swig_setmethods__["transparencyEffects"] = GraphicsPreferences._set_transparencyEffects
GraphicsPreferences.transparencyEffects = property(GraphicsPreferences._get_transparencyEffects, GraphicsPreferences._set_transparencyEffects, doc="Gets and sets the style of display for transparency effects.")

GraphicsPreferences.__swig_getmethods__["autoThrottleEffects"] = GraphicsPreferences._get_autoThrottleEffects
GraphicsPreferences.__swig_setmethods__["autoThrottleEffects"] = GraphicsPreferences._set_autoThrottleEffects
GraphicsPreferences.autoThrottleEffects = property(GraphicsPreferences._get_autoThrottleEffects, GraphicsPreferences._set_autoThrottleEffects, doc="Gets and sets if automatically disable or degrade visual effects to keep the video memory pressure under a safe threshold.")

GraphicsPreferences.__swig_getmethods__["hiddenEdgeDimming"] = GraphicsPreferences._get_hiddenEdgeDimming
GraphicsPreferences.__swig_setmethods__["hiddenEdgeDimming"] = GraphicsPreferences._set_hiddenEdgeDimming
GraphicsPreferences.hiddenEdgeDimming = property(GraphicsPreferences._get_hiddenEdgeDimming, GraphicsPreferences._set_hiddenEdgeDimming, doc="Gets and sets the dimming percentage to use for hidden edges.\nthe value is a percentage expressed by a value between 0 and 100.")

GraphicsPreferences.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, GraphicsPreferences) else None
GraphicsPreferences.cast = lambda arg: arg if isinstance(arg, GraphicsPreferences) else None

class GridPreferences(Base):
    """The GridPreferences object provides access to grid related preferences."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GridPreferences, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GridPreferences, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::GridPreferences *" : return _core.GridPreferences___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.GridPreferences___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.GridPreferences___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.GridPreferences_classType
    if _newclass:classType = staticmethod(_core.GridPreferences_classType)
    __swig_destroy__ = _core.delete_GridPreferences
    __del__ = lambda self : None;
    def _get_isLayoutGridLockEnabled(self) -> "bool" :
        """Gets and sets if the layout grid lock is enabled."""
        return _core.GridPreferences__get_isLayoutGridLockEnabled(self)

    def _set_isLayoutGridLockEnabled(self, *args) -> "bool" :
        """Gets and sets if the layout grid lock is enabled."""
        return _core.GridPreferences__set_isLayoutGridLockEnabled(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.GridPreferences__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.GridPreferences__get_isValid(self)
GridPreferences_swigregister = _core.GridPreferences_swigregister
GridPreferences_swigregister(GridPreferences)

def GridPreferences_classType() -> "char const *" :
  return _core.GridPreferences_classType()
GridPreferences_classType = _core.GridPreferences_classType

GridPreferences.__swig_getmethods__["isLayoutGridLockEnabled"] = GridPreferences._get_isLayoutGridLockEnabled
GridPreferences.__swig_setmethods__["isLayoutGridLockEnabled"] = GridPreferences._set_isLayoutGridLockEnabled
GridPreferences.isLayoutGridLockEnabled = property(GridPreferences._get_isLayoutGridLockEnabled, GridPreferences._set_isLayoutGridLockEnabled, doc="Gets and sets if the layout grid lock is enabled.")

GridPreferences.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, GridPreferences) else None
GridPreferences.cast = lambda arg: arg if isinstance(arg, GridPreferences) else None

class HTMLEventHandler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTMLEventHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HTMLEventHandler, name)
    __repr__ = _swig_repr
    def notify(self, *args) -> "void" : return _core.HTMLEventHandler_notify(self, *args)
    def __init__(self): 
        if self.__class__ == HTMLEventHandler:
            _self = None
        else:
            _self = self
        this = _core.new_HTMLEventHandler(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_HTMLEventHandler
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _core.disown_HTMLEventHandler(self)
        return weakref_proxy(self)
HTMLEventHandler_swigregister = _core.HTMLEventHandler_swigregister
HTMLEventHandler_swigregister(HTMLEventHandler)

HTMLEventHandler.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, HTMLEventHandler) else None
HTMLEventHandler.cast = lambda arg: arg if isinstance(arg, HTMLEventHandler) else None

class ImportManager(Base):
    """Provides access to functionality to support importing various modeling formats into Fusion 360."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImportManager, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImportManager, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ImportManager *" : return _core.ImportManager___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ImportManager___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ImportManager___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ImportManager_classType
    if _newclass:classType = staticmethod(_core.ImportManager_classType)
    __swig_destroy__ = _core.delete_ImportManager
    __del__ = lambda self : None;
    def createIGESImportOptions(self, *args) -> "adsk::core::Ptr< adsk::core::IGESImportOptions >" :
        """
        Creates an IGESImportOptions object that is used to import a design from IGES format. Creation
        of the IGESImportOptions object does not perform the import. You must pass this object to one of the
        ImportManager import methods to perform the import. The IGESImportOptions supports any available
        options when importing from IGES format. 
        filename : The filename or url of the IGES file to be imported. 
        The created IGESImportOptions object or null if the creation failed.
        """
        return _core.ImportManager_createIGESImportOptions(self, *args)

    def createSTEPImportOptions(self, *args) -> "adsk::core::Ptr< adsk::core::STEPImportOptions >" :
        """
        Creates an STEPImportOptions object that's used to import a design from STEP format. Creation
        of the STEPImportOptions object does not perform the import. You must pass this object to one of the
        ImportManager import methods to perform the import. The STEPImportOptions supports any available
        options when importing from STEP format. 
        filename : The filename or url of the STEP file to be imported. 
        The created STEPImportOptions object or null if the creation failed.
        """
        return _core.ImportManager_createSTEPImportOptions(self, *args)

    def createSATImportOptions(self, *args) -> "adsk::core::Ptr< adsk::core::SATImportOptions >" :
        """
        Creates an SATImportOptions object that's used to import a design from SAT format. Creation
        of the SATImportOptions object does not perform the import. You must pass this object to one of the
        ImportManager import methods to perform the import. The SATImportOptions supports any available
        options when importing from SAT format. 
        filename : The filename or url of the SAT file to be imported. 
        The created SATImportOptions object or null if the creation failed.
        """
        return _core.ImportManager_createSATImportOptions(self, *args)

    def createSMTImportOptions(self, *args) -> "adsk::core::Ptr< adsk::core::SMTImportOptions >" :
        """
        Creates an SMTImportOptions object that's used to import a design from SMT format. Creation
        of the SMTImportOptions object does not perform the import. You must pass this object to one of the
        ImportManager import methods to perform the import. The SMTImportOptions supports any available
        options when importing from SMT format. 
        filename : The filename or url of the SMT file to be imported. 
        The created SMTImportOptions object or null if the creation failed.
        """
        return _core.ImportManager_createSMTImportOptions(self, *args)

    def createFusionArchiveImportOptions(self, *args) -> "adsk::core::Ptr< adsk::core::FusionArchiveImportOptions >" :
        """
        Creates an FusionArchiveImportOptions object that is used to import a design from a Fusion 360 archive format. Creation
        of the FusionArchiveImportOptions object does not perform the import. You must pass this object to one of the
        ImportManager import methods to perform the import. The FusionArchiveImportOptions supports any available
        options when importing from Fusion 360 archive format. 
        filename : The filename or url of the Fusion 360 archive file to be imported. 
        .f3z files and .f3d files containing externally referenced designs are currently not supported. 
        The created FusionArchiveImportOptions object or null if the creation failed.
        """
        return _core.ImportManager_createFusionArchiveImportOptions(self, *args)

    def importToNewDocument(self, *args) -> "adsk::core::Ptr< adsk::core::Document >" :
        """
        Executes the import operation to import a file (of the format specified by the input ImportOptions object) 
        to a new document.
        ***This method does not currently support the DXF2DImportOptions ImportOptions object.*** 
        importOptions : An ImportOptions object that is created using one of the create methods on the ImportManager object. This
        defines the type of file and any available options supported for that file type. 
        Returns the newly created Document object or null if the creation failed.
        A new unnamed, unsaved document will be opened in Fusion 360 as a result.
        """
        return _core.ImportManager_importToNewDocument(self, *args)

    def importToTarget(self, *args) -> "bool" :
        """
        Executes the import operation to import a file (of the format specified by the input ImportOptions object) 
        into an existing component in an existing design. 
        importOptions : An ImportOptions object that is created using one of the create methods on the ImportManager object. This
        defines the type of file and any available options supported for that file type.
        Supplying a DXF2DImportOptions object will result in the creation of one or more sketches 
        (depending on the layers in the DXF file) in the target component. 
        target : Currently supports importing to a Fusion 360 Component. 
        Returns true if the import was successful.
        """
        return _core.ImportManager_importToTarget(self, *args)

    def createDXF2DImportOptions(self, *args) -> "adsk::core::Ptr< adsk::core::DXF2DImportOptions >" :
        """
        Creates a DXF2DImportOptions object that is used to import 2D data to create sketches. Creation
        of the createDXF2DImportOptions object does not perform the import. You must pass this object to the
        ImportManager.importToTarget method to perform the import. The sketches created as a result of
        the import are available through the 'results' property of the DXF2DImportOptions. 
        filename : The filename of the DXF file to be imported. 
        planarEntity : The construction plane or planar face that defines the plane that the resulting sketches will
        be created on. 
        The created DXF2DImportOptions object or null if the creation failed.
        """
        return _core.ImportManager_createDXF2DImportOptions(self, *args)

    def importToTarget2(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Executes the import operation to import a file (of the format specified by the input ImportOptions object) 
        into an existing component in an existing design and returns the imported objects. 
        importOptions : An ImportOptions object that is created using one of the create methods on the ImportManager object. This
        defines the type of file and any available options supported for that file type.
        Supplying a DXF2DImportOptions object will result in the creation of one or more sketches 
        (depending on the layers in the DXF file) in the target component. 
        target : Currently supports importing to a Fusion 360 Component. 
        Returns an ObjectCollection containing the results of whatever was created as a result of the import.
        null is returned in the case of failure.
        """
        return _core.ImportManager_importToTarget2(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.ImportManager__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ImportManager__get_isValid(self)
ImportManager_swigregister = _core.ImportManager_swigregister
ImportManager_swigregister(ImportManager)

def ImportManager_classType() -> "char const *" :
  return _core.ImportManager_classType()
ImportManager_classType = _core.ImportManager_classType

ImportManager.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ImportManager) else None
ImportManager.cast = lambda arg: arg if isinstance(arg, ImportManager) else None

class ImportOptions(Base):
    """
    The base class for the different import types. This class is never directly used
    in an import because you need the specific import type to specify the type of
    import to be performed.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImportOptions, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImportOptions, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ImportOptions *" : return _core.ImportOptions___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ImportOptions___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ImportOptions___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ImportOptions_classType
    if _newclass:classType = staticmethod(_core.ImportOptions_classType)
    __swig_destroy__ = _core.delete_ImportOptions
    __del__ = lambda self : None;
    def _get_filename(self) -> "std::string" :
        """Gets and sets the filename or url of the file to be imported."""
        return _core.ImportOptions__get_filename(self)

    def _set_filename(self, *args) -> "bool" :
        """Gets and sets the filename or url of the file to be imported."""
        return _core.ImportOptions__set_filename(self, *args)

    def _get_isViewFit(self) -> "bool" :
        """
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.ImportOptions__get_isViewFit(self)

    def _set_isViewFit(self, *args) -> "bool" :
        """
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.ImportOptions__set_isViewFit(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.ImportOptions__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ImportOptions__get_isValid(self)
ImportOptions_swigregister = _core.ImportOptions_swigregister
ImportOptions_swigregister(ImportOptions)

def ImportOptions_classType() -> "char const *" :
  return _core.ImportOptions_classType()
ImportOptions_classType = _core.ImportOptions_classType

ImportOptions.__swig_getmethods__["filename"] = ImportOptions._get_filename
ImportOptions.__swig_setmethods__["filename"] = ImportOptions._set_filename
ImportOptions.filename = property(ImportOptions._get_filename, ImportOptions._set_filename, doc="Gets and sets the filename or url of the file to be imported.")

ImportOptions.__swig_getmethods__["isViewFit"] = ImportOptions._get_isViewFit
ImportOptions.__swig_setmethods__["isViewFit"] = ImportOptions._set_isViewFit
ImportOptions.isViewFit = property(ImportOptions._get_isViewFit, ImportOptions._set_isViewFit, doc="Specifies if the camera should be adjusted to fit the geometry of the import.\nThis defaults to true, which will cause a change in the current view. Setting this\nto false will leave the view as-is and just import the geometry.")

ImportOptions.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ImportOptions) else None
ImportOptions.cast = lambda arg: arg if isinstance(arg, ImportOptions) else None

class InputChangedEventHandler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InputChangedEventHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InputChangedEventHandler, name)
    __repr__ = _swig_repr
    def notify(self, *args) -> "void" : return _core.InputChangedEventHandler_notify(self, *args)
    def __init__(self): 
        if self.__class__ == InputChangedEventHandler:
            _self = None
        else:
            _self = self
        this = _core.new_InputChangedEventHandler(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_InputChangedEventHandler
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _core.disown_InputChangedEventHandler(self)
        return weakref_proxy(self)
InputChangedEventHandler_swigregister = _core.InputChangedEventHandler_swigregister
InputChangedEventHandler_swigregister(InputChangedEventHandler)

InputChangedEventHandler.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, InputChangedEventHandler) else None
InputChangedEventHandler.cast = lambda arg: arg if isinstance(arg, InputChangedEventHandler) else None

class KeyboardEventHandler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, KeyboardEventHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, KeyboardEventHandler, name)
    __repr__ = _swig_repr
    def notify(self, *args) -> "void" : return _core.KeyboardEventHandler_notify(self, *args)
    def __init__(self): 
        if self.__class__ == KeyboardEventHandler:
            _self = None
        else:
            _self = self
        this = _core.new_KeyboardEventHandler(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_KeyboardEventHandler
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _core.disown_KeyboardEventHandler(self)
        return weakref_proxy(self)
KeyboardEventHandler_swigregister = _core.KeyboardEventHandler_swigregister
KeyboardEventHandler_swigregister(KeyboardEventHandler)

KeyboardEventHandler.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, KeyboardEventHandler) else None
KeyboardEventHandler.cast = lambda arg: arg if isinstance(arg, KeyboardEventHandler) else None

class LinearMarkingMenu(Base):
    """
    Represents the linear marking menu which is the vertical menu that's displayed when the user right-clicks
    within Fusion 360. This supports customizing the contents of the context menu.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinearMarkingMenu, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LinearMarkingMenu, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::LinearMarkingMenu *" : return _core.LinearMarkingMenu___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.LinearMarkingMenu___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.LinearMarkingMenu___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.LinearMarkingMenu_classType
    if _newclass:classType = staticmethod(_core.LinearMarkingMenu_classType)
    __swig_destroy__ = _core.delete_LinearMarkingMenu
    __del__ = lambda self : None;
    def _get_controls(self) -> "adsk::core::Ptr< adsk::core::ToolbarControls >" :
        """
        Return the collection of top-level controls in the context menu. It's possible to have 
        drop-down controls (fly-outs) that provide access to additional conrols. You can 
        remove and add controls to customize the contents of the context menu.
        """
        return _core.LinearMarkingMenu__get_controls(self)

    def clear(self) -> "bool" :
        """
        Completely clears the contents of the context menu. If left in this state, the
        context menu will not be displayed. 
        Returns true if the clear was successful.
        """
        return _core.LinearMarkingMenu_clear(self)

    def _get_objectType(self) -> "char const *" : return _core.LinearMarkingMenu__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.LinearMarkingMenu__get_isValid(self)
LinearMarkingMenu_swigregister = _core.LinearMarkingMenu_swigregister
LinearMarkingMenu_swigregister(LinearMarkingMenu)

def LinearMarkingMenu_classType() -> "char const *" :
  return _core.LinearMarkingMenu_classType()
LinearMarkingMenu_classType = _core.LinearMarkingMenu_classType

LinearMarkingMenu.__swig_getmethods__["controls"] = LinearMarkingMenu._get_controls
LinearMarkingMenu.controls = property(LinearMarkingMenu._get_controls, doc="Return the collection of top-level controls in the context menu. It's possible to have\ndrop-down controls (fly-outs) that provide access to additional conrols. You can\nremove and add controls to customize the contents of the context menu.")

LinearMarkingMenu.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, LinearMarkingMenu) else None
LinearMarkingMenu.cast = lambda arg: arg if isinstance(arg, LinearMarkingMenu) else None

class ListItem(Base):
    """Represents a single item in a check box list or a drop-down command input."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListItem, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListItem, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ListItem *" : return _core.ListItem___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ListItem___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ListItem___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ListItem_classType
    if _newclass:classType = staticmethod(_core.ListItem_classType)
    __swig_destroy__ = _core.delete_ListItem
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """
        Gets or sets the name of this item as displayed in the list. If
        this control is a separator (isSeparator is true) or it's a button row, 
        setting this property is ignored and getting it will return an empty string.
        """
        return _core.ListItem__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """
        Gets or sets the name of this item as displayed in the list. If
        this control is a separator (isSeparator is true) or it's a button row, 
        setting this property is ignored and getting it will return an empty string.
        """
        return _core.ListItem__set_name(self, *args)

    def _get_icon(self) -> "std::string" :
        """
        Gets or sets the location for the icon file used for this item in the list.
        This is the path to a directory that contains the image files associated 
        with this item. This is only valid when this is a standard list or button row and is
        ignored for check box lists, radio control lists, and radio button groups.
        """
        return _core.ListItem__get_icon(self)

    def _set_icon(self, *args) -> "bool" :
        """
        Gets or sets the location for the icon file used for this item in the list.
        This is the path to a directory that contains the image files associated 
        with this item. This is only valid when this is a standard list or button row and is
        ignored for check box lists, radio control lists, and radio button groups.
        """
        return _core.ListItem__set_icon(self, *args)

    def _get_isSelected(self) -> "bool" :
        """
        Gets or sets whether this item is selected. If the item is
        being displayed as a check box, this controls whether it is 
        checked or not. If it's a drop-down list or button row it controls whether
        this is the single selected item. Setting a drop-down list, button row item, or radio button 
        from a group to be selected will unselect the currently selected item.
        For a standard list, this will get or set the single item currently
        selected. For a separator, setting this property is ignored and
        it will always return false.
        """
        return _core.ListItem__get_isSelected(self)

    def _set_isSelected(self, *args) -> "bool" :
        """
        Gets or sets whether this item is selected. If the item is
        being displayed as a check box, this controls whether it is 
        checked or not. If it's a drop-down list or button row it controls whether
        this is the single selected item. Setting a drop-down list, button row item, or radio button 
        from a group to be selected will unselect the currently selected item.
        For a standard list, this will get or set the single item currently
        selected. For a separator, setting this property is ignored and
        it will always return false.
        """
        return _core.ListItem__set_isSelected(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this item from the list. 
        Returns true if the delete was successful.
        """
        return _core.ListItem_deleteMe(self)

    def _get_index(self) -> "int" :
        """Gets the index position within the list of this item."""
        return _core.ListItem__get_index(self)

    def _get_parentList(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets the parent CheckBoxListControlDefinition or object."""
        return _core.ListItem__get_parentList(self)

    def _get_isSeparator(self) -> "bool" :
        """Gets if this control is a separator."""
        return _core.ListItem__get_isSeparator(self)

    def _get_objectType(self) -> "char const *" : return _core.ListItem__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ListItem__get_isValid(self)
ListItem_swigregister = _core.ListItem_swigregister
ListItem_swigregister(ListItem)

def ListItem_classType() -> "char const *" :
  return _core.ListItem_classType()
ListItem_classType = _core.ListItem_classType

ListItem.__swig_getmethods__["name"] = ListItem._get_name
ListItem.__swig_setmethods__["name"] = ListItem._set_name
ListItem.name = property(ListItem._get_name, ListItem._set_name, doc="Gets or sets the name of this item as displayed in the list. If\nthis control is a separator (isSeparator is true) or it's a button row,\nsetting this property is ignored and getting it will return an empty string.")

ListItem.__swig_getmethods__["icon"] = ListItem._get_icon
ListItem.__swig_setmethods__["icon"] = ListItem._set_icon
ListItem.icon = property(ListItem._get_icon, ListItem._set_icon, doc="Gets or sets the location for the icon file used for this item in the list.\nThis is the path to a directory that contains the image files associated\nwith this item. This is only valid when this is a standard list or button row and is\nignored for check box lists, radio control lists, and radio button groups.")

ListItem.__swig_getmethods__["isSelected"] = ListItem._get_isSelected
ListItem.__swig_setmethods__["isSelected"] = ListItem._set_isSelected
ListItem.isSelected = property(ListItem._get_isSelected, ListItem._set_isSelected, doc="Gets or sets whether this item is selected. If the item is\nbeing displayed as a check box, this controls whether it is\nchecked or not. If it's a drop-down list or button row it controls whether\nthis is the single selected item. Setting a drop-down list, button row item, or radio button\nfrom a group to be selected will unselect the currently selected item.\nFor a standard list, this will get or set the single item currently\nselected. For a separator, setting this property is ignored and\nit will always return false.")

ListItem.__swig_getmethods__["index"] = ListItem._get_index
ListItem.index = property(ListItem._get_index, doc="Gets the index position within the list of this item.")

ListItem.__swig_getmethods__["parentList"] = ListItem._get_parentList
ListItem.parentList = property(ListItem._get_parentList, doc="Gets the parent CheckBoxListControlDefinition or object.")

ListItem.__swig_getmethods__["isSeparator"] = ListItem._get_isSeparator
ListItem.isSeparator = property(ListItem._get_isSeparator, doc="Gets if this control is a separator.")

ListItem.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ListItem) else None
ListItem.cast = lambda arg: arg if isinstance(arg, ListItem) else None

class ListItems(Base):
    """
    Provides access to the list of items in a check box list. This object supports the ability to add
    items to the list and iterate through the existing items.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListItems, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListItems, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ListItems *" : return _core.ListItems___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ListItems___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ListItems___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.ListItems___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::ListItem >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.ListItems___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ListItems_classType
    if _newclass:classType = staticmethod(_core.ListItems_classType)
    __swig_destroy__ = _core.delete_ListItems
    __del__ = lambda self : None;
    def add(self, *args) -> "adsk::core::Ptr< adsk::core::ListItem >" :
        """
        Adds a new item to the list. 
        name : The name of this item as it is displayed in the list. 
        isSelected : Sets whether this item is selected or not. If this list is associated with a control
        or input that can only have one item selected any other selected items will be unselected
        and this one will be the only selected item. 
        icon : The path to the icon directory. 
        beforeIndex : The position of the item within the list. This value indicates the index of the current
        item to insert this new item just before. For example, a value of 0 will insert it before
        the first item in the list. An index of -1 will position the button at the bottom of the list. 
        Returns the new ListControlItem or null in the case of a failure.
        """
        return _core.ListItems_add(self, *args)

    def addSeparator(self, *args) -> "adsk::core::Ptr< adsk::core::ListItem >" :
        """
        Adds a separator to the list. This is not supported for button rows. 
        beforeIndex : The position of the item within the list. This value indicates the index of the current
        item to insert this new item just before. For example, a value of 0 will insert it before
        the first item in the list. An index of -1 will position the button at the bottom of the list. 
        Returns the new ListControlItem or null in the case of a failure.
        """
        return _core.ListItems_addSeparator(self, *args)

    def item(self, *args) -> "adsk::core::Ptr< adsk::core::ListItem >" :
        """
        Returns the specified check box list item using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.ListItems_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Gets the number of items in the collection."""
        return _core.ListItems__get_count(self)

    def clear(self) -> "bool" :
        """
        Clears all of the items from the list. 
        Returns true if successful.
        """
        return _core.ListItems_clear(self)

    def _get_objectType(self) -> "char const *" : return _core.ListItems__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ListItems__get_isValid(self)
ListItems_swigregister = _core.ListItems_swigregister
ListItems_swigregister(ListItems)

def ListItems_classType() -> "char const *" :
  return _core.ListItems_classType()
ListItems_classType = _core.ListItems_classType

ListItems.__swig_getmethods__["count"] = ListItems._get_count
ListItems.count = property(ListItems._get_count, doc="Gets the number of items in the collection.")

ListItems.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ListItems) else None
ListItems.cast = lambda arg: arg if isinstance(arg, ListItems) else None

class MarkingMenuEventHandler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MarkingMenuEventHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MarkingMenuEventHandler, name)
    __repr__ = _swig_repr
    def notify(self, *args) -> "void" : return _core.MarkingMenuEventHandler_notify(self, *args)
    def __init__(self): 
        if self.__class__ == MarkingMenuEventHandler:
            _self = None
        else:
            _self = self
        this = _core.new_MarkingMenuEventHandler(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_MarkingMenuEventHandler
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _core.disown_MarkingMenuEventHandler(self)
        return weakref_proxy(self)
MarkingMenuEventHandler_swigregister = _core.MarkingMenuEventHandler_swigregister
MarkingMenuEventHandler_swigregister(MarkingMenuEventHandler)

MarkingMenuEventHandler.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MarkingMenuEventHandler) else None
MarkingMenuEventHandler.cast = lambda arg: arg if isinstance(arg, MarkingMenuEventHandler) else None

class Material(Base):
    """A material."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Material, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Material, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Material *" : return _core.Material___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Material___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Material___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Material_classType
    if _newclass:classType = staticmethod(_core.Material_classType)
    __swig_destroy__ = _core.delete_Material
    __del__ = lambda self : None;
    def _get_appearance(self) -> "adsk::core::Ptr< adsk::core::Appearance >" :
        """Gets the Appearance of this material."""
        return _core.Material__get_appearance(self)

    def _get_id(self) -> "std::string" :
        """Returns the unique internal ID of this material."""
        return _core.Material__get_id(self)

    def _get_isUsed(self) -> "bool" :
        """Returns true if this material is used in the Design"""
        return _core.Material__get_isUsed(self)

    def _get_materialProperties(self) -> "adsk::core::Ptr< adsk::core::Properties >" :
        """Returns the collection of material properties associated with this material."""
        return _core.Material__get_materialProperties(self)

    def _get_name(self) -> "std::string" :
        """
        Returns the name of this Material. This is the name of the material as seen in the user interface.
        The name can only be edited if the material is in a Design or the favorites list.
        """
        return _core.Material__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """
        Returns the name of this Material. This is the name of the material as seen in the user interface.
        The name can only be edited if the material is in a Design or the favorites list.
        """
        return _core.Material__set_name(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the Parent object (a Library or a Design)."""
        return _core.Material__get_parent(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the material from the Design. This method only applies to materials
        in a Design that are unused 
        Returns true if the delete was successful.
        """
        return _core.Material_deleteMe(self)

    def copyTo(self, *args) -> "adsk::core::Ptr< adsk::core::Material >" :
        """
        Copies this material to the specified target.
        ***Depricated Method: Use the addByCopyMethod on the Materials object instead, where you can rename the copied Material*** 
        target : The target can be a Design or MaterialFavorites object. 
        Returns the new copy of the material or null if the copy failed.
        """
        return _core.Material_copyTo(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Material__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Material__get_isValid(self)
Material_swigregister = _core.Material_swigregister
Material_swigregister(Material)

def Material_classType() -> "char const *" :
  return _core.Material_classType()
Material_classType = _core.Material_classType

Material.__swig_getmethods__["appearance"] = Material._get_appearance
Material.appearance = property(Material._get_appearance, doc="Gets the Appearance of this material.")

Material.__swig_getmethods__["id"] = Material._get_id
Material.id = property(Material._get_id, doc="Returns the unique internal ID of this material.")

Material.__swig_getmethods__["isUsed"] = Material._get_isUsed
Material.isUsed = property(Material._get_isUsed, doc="Returns true if this material is used in the Design")

Material.__swig_getmethods__["materialProperties"] = Material._get_materialProperties
Material.materialProperties = property(Material._get_materialProperties, doc="Returns the collection of material properties associated with this material.")

Material.__swig_getmethods__["name"] = Material._get_name
Material.__swig_setmethods__["name"] = Material._set_name
Material.name = property(Material._get_name, Material._set_name, doc="Returns the name of this Material. This is the name of the material as seen in the user interface.\nThe name can only be edited if the material is in a Design or the favorites list.")

Material.__swig_getmethods__["parent"] = Material._get_parent
Material.parent = property(Material._get_parent, doc="Returns the Parent object (a Library or a Design).")

Material.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Material) else None
Material.cast = lambda arg: arg if isinstance(arg, Material) else None

class MaterialLibraries(Base):
    """
    The MaterialLibraries collection object provides access to 
    currently loaded Material and Appearance libraries
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MaterialLibraries, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MaterialLibraries, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::MaterialLibraries *" : return _core.MaterialLibraries___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.MaterialLibraries___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.MaterialLibraries___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.MaterialLibraries___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::MaterialLibrary >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.MaterialLibraries___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.MaterialLibraries_classType
    if _newclass:classType = staticmethod(_core.MaterialLibraries_classType)
    __swig_destroy__ = _core.delete_MaterialLibraries
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::MaterialLibrary >" :
        """
        Method that returns the specified Material Library using an index into the collection. 
        index : The index of the item within the collection. The first item has an index of 0. 
        Returns the specified material library or null if an invalid index was specified.
        """
        return _core.MaterialLibraries_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of Material Libraries in the collection."""
        return _core.MaterialLibraries__get_count(self)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::core::MaterialLibrary >" :
        """
        Returns the specified Material Library using the name as seen in the user interface. 
        name : The name of the library to return. 
        Returns the specified material library or null if there's no match on the name.
        """
        return _core.MaterialLibraries_itemByName(self, *args)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::MaterialLibrary >" :
        """
        Returns the Material Library at the specified ID. 
        id : The ID of the library to return. 
        Returns the specified material library or null if there's no match on the ID.
        """
        return _core.MaterialLibraries_itemById(self, *args)

    def load(self, *args) -> "adsk::core::Ptr< adsk::core::MaterialLibrary >" :
        """
        Loads the specified existing local material library. Fusion 360 remembers which libraries have
        been loaded from one session to the next so you should check to see if the local library
        is already loaded or not before loading it again. 
        filename : The full filename of the .adsklib material file. 
        Returns the MaterialLibrary object representing the opened library or null in the case of failure.
        """
        return _core.MaterialLibraries_load(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.MaterialLibraries__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.MaterialLibraries__get_isValid(self)
MaterialLibraries_swigregister = _core.MaterialLibraries_swigregister
MaterialLibraries_swigregister(MaterialLibraries)

def MaterialLibraries_classType() -> "char const *" :
  return _core.MaterialLibraries_classType()
MaterialLibraries_classType = _core.MaterialLibraries_classType

MaterialLibraries.__swig_getmethods__["count"] = MaterialLibraries._get_count
MaterialLibraries.count = property(MaterialLibraries._get_count, doc="The number of Material Libraries in the collection.")

MaterialLibraries.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MaterialLibraries) else None
MaterialLibraries.cast = lambda arg: arg if isinstance(arg, MaterialLibraries) else None

class MaterialLibrary(Base):
    """A material library."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MaterialLibrary, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MaterialLibrary, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::MaterialLibrary *" : return _core.MaterialLibrary___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.MaterialLibrary___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.MaterialLibrary___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.MaterialLibrary_classType
    if _newclass:classType = staticmethod(_core.MaterialLibrary_classType)
    __swig_destroy__ = _core.delete_MaterialLibrary
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """
        Property that gets the name of this Library. This is the localized name
        shown in the user interface.
        """
        return _core.MaterialLibrary__get_name(self)

    def _get_id(self) -> "std::string" :
        """The unique internal ID of this Library."""
        return _core.MaterialLibrary__get_id(self)

    def _get_appearances(self) -> "adsk::core::Ptr< adsk::core::Appearances >" :
        """Returns the appearances defined within this library."""
        return _core.MaterialLibrary__get_appearances(self)

    def _get_materials(self) -> "adsk::core::Ptr< adsk::core::Materials >" :
        """Returns the materials defined within this library."""
        return _core.MaterialLibrary__get_materials(self)

    def _get_isNative(self) -> "bool" :
        """
        Gets if this is a native material library. Native libraries are
        those that are delivered with Fusion 360 and are always available. And
        non-native libraries are user created. If This returns True then there 
        are some limitations to what can be done with the library. For example, 
        if this is a native material library it cannot be unloaded.
        """
        return _core.MaterialLibrary__get_isNative(self)

    def unload(self) -> "bool" :
        """
        Unloads this material from Fusion 360. Only non-native material libraries
        can be unloaded. You can determine this by checking the isNative property. 
        Returns True if the library was successfully unloaded.
        """
        return _core.MaterialLibrary_unload(self)

    def _get_objectType(self) -> "char const *" : return _core.MaterialLibrary__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.MaterialLibrary__get_isValid(self)
MaterialLibrary_swigregister = _core.MaterialLibrary_swigregister
MaterialLibrary_swigregister(MaterialLibrary)

def MaterialLibrary_classType() -> "char const *" :
  return _core.MaterialLibrary_classType()
MaterialLibrary_classType = _core.MaterialLibrary_classType

MaterialLibrary.__swig_getmethods__["name"] = MaterialLibrary._get_name
MaterialLibrary.name = property(MaterialLibrary._get_name, doc="Property that gets the name of this Library. This is the localized name\nshown in the user interface.")

MaterialLibrary.__swig_getmethods__["id"] = MaterialLibrary._get_id
MaterialLibrary.id = property(MaterialLibrary._get_id, doc="The unique internal ID of this Library.")

MaterialLibrary.__swig_getmethods__["appearances"] = MaterialLibrary._get_appearances
MaterialLibrary.appearances = property(MaterialLibrary._get_appearances, doc="Returns the appearances defined within this library.")

MaterialLibrary.__swig_getmethods__["materials"] = MaterialLibrary._get_materials
MaterialLibrary.materials = property(MaterialLibrary._get_materials, doc="Returns the materials defined within this library.")

MaterialLibrary.__swig_getmethods__["isNative"] = MaterialLibrary._get_isNative
MaterialLibrary.isNative = property(MaterialLibrary._get_isNative, doc="Gets if this is a native material library. Native libraries are\nthose that are delivered with Fusion 360 and are always available. And\nnon-native libraries are user created. If This returns True then there\nare some limitations to what can be done with the library. For example,\nif this is a native material library it cannot be unloaded.")

MaterialLibrary.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MaterialLibrary) else None
MaterialLibrary.cast = lambda arg: arg if isinstance(arg, MaterialLibrary) else None

class MaterialPreferences(Base):
    """Provides access to the material related preferences."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MaterialPreferences, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MaterialPreferences, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::MaterialPreferences *" : return _core.MaterialPreferences___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.MaterialPreferences___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.MaterialPreferences___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.MaterialPreferences_classType
    if _newclass:classType = staticmethod(_core.MaterialPreferences_classType)
    __swig_destroy__ = _core.delete_MaterialPreferences
    __del__ = lambda self : None;
    def _get_defaultMaterial(self) -> "adsk::core::Ptr< adsk::core::Material >" :
        """Gets and sets the default material."""
        return _core.MaterialPreferences__get_defaultMaterial(self)

    def _set_defaultMaterial(self, *args) -> "bool" :
        """Gets and sets the default material."""
        return _core.MaterialPreferences__set_defaultMaterial(self, *args)

    def _get_appearanceOverride(self) -> "adsk::core::Ptr< adsk::core::Appearance >" :
        """
        Gets and sets an appearance override.
        This property return null indicating that there is no override, or be set to null to remove
        the current appearance override.
        """
        return _core.MaterialPreferences__get_appearanceOverride(self)

    def _set_appearanceOverride(self, *args) -> "bool" :
        """
        Gets and sets an appearance override.
        This property return null indicating that there is no override, or be set to null to remove
        the current appearance override.
        """
        return _core.MaterialPreferences__set_appearanceOverride(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.MaterialPreferences__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.MaterialPreferences__get_isValid(self)
MaterialPreferences_swigregister = _core.MaterialPreferences_swigregister
MaterialPreferences_swigregister(MaterialPreferences)

def MaterialPreferences_classType() -> "char const *" :
  return _core.MaterialPreferences_classType()
MaterialPreferences_classType = _core.MaterialPreferences_classType

MaterialPreferences.__swig_getmethods__["defaultMaterial"] = MaterialPreferences._get_defaultMaterial
MaterialPreferences.__swig_setmethods__["defaultMaterial"] = MaterialPreferences._set_defaultMaterial
MaterialPreferences.defaultMaterial = property(MaterialPreferences._get_defaultMaterial, MaterialPreferences._set_defaultMaterial, doc="Gets and sets the default material.")

MaterialPreferences.__swig_getmethods__["appearanceOverride"] = MaterialPreferences._get_appearanceOverride
MaterialPreferences.__swig_setmethods__["appearanceOverride"] = MaterialPreferences._set_appearanceOverride
MaterialPreferences.appearanceOverride = property(MaterialPreferences._get_appearanceOverride, MaterialPreferences._set_appearanceOverride, doc="Gets and sets an appearance override.\nThis property return null indicating that there is no override, or be set to null to remove\nthe current appearance override.")

MaterialPreferences.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MaterialPreferences) else None
MaterialPreferences.cast = lambda arg: arg if isinstance(arg, MaterialPreferences) else None

class Materials(Base):
    """Collection of materials within a Library or Design."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Materials, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Materials, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Materials *" : return _core.Materials___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Materials___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Materials___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.Materials___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::Material >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.Materials___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Materials_classType
    if _newclass:classType = staticmethod(_core.Materials_classType)
    __swig_destroy__ = _core.delete_Materials
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::Material >" :
        """
        Returns the specified Material using an index into the collection. 
        index : The index of the material to return where the first item in the collection is 0. 
        Returns the specified material or null if an invalid index is specified.
        """
        return _core.Materials_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of Materials in the collection."""
        return _core.Materials__get_count(self)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::core::Material >" :
        """
        Returns the specified Material using the name as seen in the user interface. This often isn't
        a reliable way of accessing a specific material because materials are not required to be unique. 
        name : The name of the material to return,. 
        Returns the specified material or null if there isn't a matching name.
        """
        return _core.Materials_itemByName(self, *args)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::Material >" :
        """
        Returns the Material by it's internal unique ID. 
        id : The ID of the material to return. 
        Returns the specified material or null if there isn't a matching ID.
        """
        return _core.Materials_itemById(self, *args)

    def addByCopy(self, *args) -> "adsk::core::Ptr< adsk::core::Material >" :
        """
        Add a Material to a Design by copying an existing Material from Favorites, a Library or from the 
        Materials stored in the Design. This method currently only applies to the Materials collection from a Design and 
        cannot be used to copy a Material to a library. 
        materialToCopy : The Material you want to copy. The Material to copy can be from Favorites, a Library or from the 
        materials stored in the Design. 
        name : The Material name to apply to the copy. 
        Returns the newly created Material or null if the copy operation failed.
        """
        return _core.Materials_addByCopy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Materials__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Materials__get_isValid(self)
Materials_swigregister = _core.Materials_swigregister
Materials_swigregister(Materials)

def Materials_classType() -> "char const *" :
  return _core.Materials_classType()
Materials_classType = _core.Materials_classType

Materials.__swig_getmethods__["count"] = Materials._get_count
Materials.count = property(Materials._get_count, doc="The number of Materials in the collection.")

Materials.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Materials) else None
Materials.cast = lambda arg: arg if isinstance(arg, Materials) else None

class Matrix2D(Base):
    """
    Transient 2D 3x3 matrix. This object is a wrapper over 2D matrix data and is used as way to pass matrix data
    in and out of the API and as a convenience when operating on matrix data.
    They are created statically using the create method of the Matrix2D class.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix2D, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix2D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Matrix2D *" : return _core.Matrix2D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Matrix2D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Matrix2D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Matrix2D_classType
    if _newclass:classType = staticmethod(_core.Matrix2D_classType)
    __swig_getmethods__["create"] = lambda x: _core.Matrix2D_create
    if _newclass:create = staticmethod(_core.Matrix2D_create)
    __swig_destroy__ = _core.delete_Matrix2D
    __del__ = lambda self : None;
    def setToIdentity(self) -> "bool" :
        """
        Resets this matrix to be an identity matrix. 
        Returns true if successful.
        """
        return _core.Matrix2D_setToIdentity(self)

    def invert(self) -> "bool" :
        """
        Invert this matrix. 
        Returns true if successful.
        """
        return _core.Matrix2D_invert(self)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Matrix2D >" :
        """
        Creates an independent copy of this matrix. 
        Returns the new matrix copy.
        """
        return _core.Matrix2D_copy(self)

    def _get_determinant(self) -> "double" :
        """
        Returns the determinant of the matrix. 
        Returns the determinant value of this matrix.
        """
        return _core.Matrix2D__get_determinant(self)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms this matrix using the input matrix. 
        matrix : The transformation matrix. 
        Returns true if successful.
        """
        return _core.Matrix2D_transformBy(self, *args)

    def getCell(self, *args) -> "double" :
        """
        Gets the value of the specified cell in the 3x3 matrix. 
        row : The index of the row. The first row has in index of 0 
        column : The index of the column. The first column has an index of 0 
        Returns the value at [row][column].
        """
        return _core.Matrix2D_getCell(self, *args)

    def setCell(self, *args) -> "bool" :
        """
        Sets the specified cell in the 3x3 matrix to the specified value. 
        row : The index of the row. The first row has in index of 0 
        column : The index of the column. The first column has an index of 0 
        value : The new value of the cell. 
        Returns true if successful.
        """
        return _core.Matrix2D_setCell(self, *args)

    def getAsCoordinateSystem(self) -> "void" :
        """
        Gets the matrix data as the components that define a coordinate system. 
        origin : The output origin point of the coordinate system. 
        xAxis : The output x axis direction of the coordinate system. 
        yAxis : The output y axis direction of the coordinate system.
        """
        return _core.Matrix2D_getAsCoordinateSystem(self)

    def asArray(self) -> "std::vector< double,std::allocator< double > >" :
        """
        Returns the contents of the matrix as a 9 element array. 
        Returns the array of matrix values.
        """
        return _core.Matrix2D_asArray(self)

    def setWithCoordinateSystem(self, *args) -> "bool" :
        """
        Reset this matrix to align with a specific coordinate system. 
        origin : The origin point of the coordinate system. 
        xAxis : The x axis direction of the coordinate system. 
        yAxis : The y axis direction of the coordinate system. 
        Returns true if successful.
        """
        return _core.Matrix2D_setWithCoordinateSystem(self, *args)

    def setWithArray(self, *args) -> "bool" :
        """
        Sets the contents of the array using a 9 element array. 
        cells : The array of cell values. 
        Returns true if successful.
        """
        return _core.Matrix2D_setWithArray(self, *args)

    def isEqualTo(self, *args) -> "bool" :
        """
        Compares this matrix with another matrix and returns True if they're identical. 
        matrix : The matrix to compare to. 
        Returns true if the matrix is equal to this matrix.
        """
        return _core.Matrix2D_isEqualTo(self, *args)

    def setToAlignCoordinateSystems(self, *args) -> "bool" :
        """
        Sets this matrix to be the matrix that maps from the 'from' coordinate system to the 'to' coordinate system. 
        fromOrigin : The origin point of the from coordinate system. 
        fromXAxis : The x axis direction of the from coordinate system. 
        fromYAxis : The y axis direction of the from coordinate system. 
        toOrigin : The origin point of the to coordinate system. 
        toXAxis : The x axis direction of the to coordinate system. 
        toYAxis : The y axis direction of the to coordinate system. 
        Returns true if successful.
        """
        return _core.Matrix2D_setToAlignCoordinateSystems(self, *args)

    def setToRotateTo(self, *args) -> "bool" :
        """
        Sets to the matrix of rotation that would align the 'from' vector with the 'to' vector. 
        from : The from vector. 
        to : The to vector. 
        Returns true if successful.
        """
        return _core.Matrix2D_setToRotateTo(self, *args)

    def setToRotation(self, *args) -> "bool" :
        """
        Sets this matrix to the matrix of rotation by the specified angle, through the specified origin. 
        angle : The rotation angle in radians. 
        origin : The origin point of the rotation. 
        Returns true if successful.
        """
        return _core.Matrix2D_setToRotation(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Matrix2D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Matrix2D__get_isValid(self)
Matrix2D_swigregister = _core.Matrix2D_swigregister
Matrix2D_swigregister(Matrix2D)

def Matrix2D_classType() -> "char const *" :
  return _core.Matrix2D_classType()
Matrix2D_classType = _core.Matrix2D_classType

def Matrix2D_create() -> "adsk::core::Ptr< adsk::core::Matrix2D >" :
  return _core.Matrix2D_create()
Matrix2D_create = _core.Matrix2D_create

Matrix2D.__swig_getmethods__["determinant"] = Matrix2D._get_determinant
Matrix2D.determinant = property(Matrix2D._get_determinant, doc="Returns the determinant of the matrix.\nReturns the determinant value of this matrix.")

Matrix2D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Matrix2D) else None
Matrix2D.cast = lambda arg: arg if isinstance(arg, Matrix2D) else None

class Matrix3D(Base):
    """
    Transient 3D 4x4 matrix. This object is a wrapper over 3D matrix data and is used as way to pass matrix data
    in and out of the API and as a convenience when operating on matrix data.
    They are created statically using the create method of the Matrix3D class.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix3D, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix3D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Matrix3D *" : return _core.Matrix3D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Matrix3D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Matrix3D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Matrix3D_classType
    if _newclass:classType = staticmethod(_core.Matrix3D_classType)
    __swig_getmethods__["create"] = lambda x: _core.Matrix3D_create
    if _newclass:create = staticmethod(_core.Matrix3D_create)
    __swig_destroy__ = _core.delete_Matrix3D
    __del__ = lambda self : None;
    def setToIdentity(self) -> "bool" :
        """
        Resets this matrix to an identify matrix. 
        Returns true if successful.
        """
        return _core.Matrix3D_setToIdentity(self)

    def invert(self) -> "bool" :
        """
        Inverts this matrix. 
        Returns true if successful.
        """
        return _core.Matrix3D_invert(self)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >" :
        """
        Creates an independent copy of this matrix. 
        Returns the new matrix copy.
        """
        return _core.Matrix3D_copy(self)

    def _get_determinant(self) -> "double" :
        """Returns the determinant of the matrix."""
        return _core.Matrix3D__get_determinant(self)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms this matrix using the input matrix. 
        matrix : The transformation matrix. 
        Returns true if successful.
        """
        return _core.Matrix3D_transformBy(self, *args)

    def getAsCoordinateSystem(self) -> "void" :
        """
        Gets the matrix data as the components that define a coordinate system. 
        origin : The output origin point of the coordinate system. 
        xAxis : The output x axis direction of the coordinate system. 
        yAxis : The output y axis direction of the coordinate system. 
        zAxis : The output z axis direction of the coordinate system.
        """
        return _core.Matrix3D_getAsCoordinateSystem(self)

    def setWithCoordinateSystem(self, *args) -> "bool" :
        """
        Sets the matrix based on the components of a coordinate system. 
        origin : The origin point of the coordinate system. 
        xAxis : The x axis direction of the coordinate system. 
        yAxis : The y axis direction of the coordinate system. 
        zAxis : The z axis direction of the coordinate system. 
        Returns true if successful.
        """
        return _core.Matrix3D_setWithCoordinateSystem(self, *args)

    def getCell(self, *args) -> "double" :
        """
        Gets the value of the specified cell in the 4x4 matrix. 
        row : The index of the row. The first row has in index of 0 
        column : The index of the column. The first column has an index of 0 
        The cell value at [row][column].
        """
        return _core.Matrix3D_getCell(self, *args)

    def setCell(self, *args) -> "bool" :
        """
        Sets the specified cell in the 4x4 matrix to the specified value. 
        row : The index of the row. The first row has in index of 0 
        column : The index of the column. The first column has an index of 0 
        value : The new cell value. 
        Returns true if successful.
        """
        return _core.Matrix3D_setCell(self, *args)

    def asArray(self) -> "std::vector< double,std::allocator< double > >" :
        """
        Returns the contents of the matrix as a 16 element array. 
        Returns the array of cell values.
        """
        return _core.Matrix3D_asArray(self)

    def setWithArray(self, *args) -> "bool" :
        """
        Sets the contents of the array using a 16 element array. 
        cells : The array of cell values. 
        Returns true if successful.
        """
        return _core.Matrix3D_setWithArray(self, *args)

    def isEqualTo(self, *args) -> "bool" :
        """
        Compares this matrix with another matrix and returns True if they're identical. 
        matrix : The matrix to compare this matrix to. 
        Returns true if the matrices are equal.
        """
        return _core.Matrix3D_isEqualTo(self, *args)

    def _get_translation(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Gets and sets the translation component of the matrix."""
        return _core.Matrix3D__get_translation(self)

    def _set_translation(self, *args) -> "bool" :
        """Gets and sets the translation component of the matrix."""
        return _core.Matrix3D__set_translation(self, *args)

    def setToAlignCoordinateSystems(self, *args) -> "bool" :
        """
        Sets this matrix to be the matrix that maps from the 'from' coordinate system to the 'to' coordinate system. 
        fromOrigin : The origin point of the from coordinate system. 
        fromXAxis : The x axis direction of the from coordinate system. 
        fromYAxis : The y axis direction of the from coordinate system. 
        fromZAxis : The z axis direction of the from coordinate system. 
        toOrigin : The origin point of the to coordinate system. 
        toXAxis : The x axis direction of the to coordinate system. 
        toYAxis : The y axis direction of the to coordinate system. 
        toZAxis : The z axis direction of the to coordinate system. 
        Returns true if successful.
        """
        return _core.Matrix3D_setToAlignCoordinateSystems(self, *args)

    def setToRotateTo(self, *args) -> "bool" :
        """
        Sets to the matrix of rotation that would align the 'from' vector with the 'to' vector. The optional 
        axis argument may be used when the two vectors are perpendicular and in opposite directions to 
        specify a specific solution, but is otherwise ignored 
        from : The vector to rotate from. 
        to : The vector to rotate to. 
        axis : The optional axis vector to disambiguate the rotation axis. 
        Returns true if successful.
        """
        return _core.Matrix3D_setToRotateTo(self, *args)

    def setToRotation(self, *args) -> "bool" :
        """
        Sets this matrix to the matrix of rotation by the specified angle, through the specified origin, around the specified axis 
        angle : The rotation angle in radians. 
        axis : The axis of rotation. 
        origin : The origin point of the axis of rotation. 
        Returns true if successful.
        """
        return _core.Matrix3D_setToRotation(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Matrix3D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Matrix3D__get_isValid(self)
Matrix3D_swigregister = _core.Matrix3D_swigregister
Matrix3D_swigregister(Matrix3D)

def Matrix3D_classType() -> "char const *" :
  return _core.Matrix3D_classType()
Matrix3D_classType = _core.Matrix3D_classType

def Matrix3D_create() -> "adsk::core::Ptr< adsk::core::Matrix3D >" :
  return _core.Matrix3D_create()
Matrix3D_create = _core.Matrix3D_create

Matrix3D.__swig_getmethods__["determinant"] = Matrix3D._get_determinant
Matrix3D.determinant = property(Matrix3D._get_determinant, doc="Returns the determinant of the matrix.")

Matrix3D.__swig_getmethods__["translation"] = Matrix3D._get_translation
Matrix3D.__swig_setmethods__["translation"] = Matrix3D._set_translation
Matrix3D.translation = property(Matrix3D._get_translation, Matrix3D._set_translation, doc="Gets and sets the translation component of the matrix.")

Matrix3D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Matrix3D) else None
Matrix3D.cast = lambda arg: arg if isinstance(arg, Matrix3D) else None

class MeasureManager(Base):
    """
    The MeasurementManager class provides some generic measurement utilities that
    can be used for most entity types.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MeasureManager, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MeasureManager, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::MeasureManager *" : return _core.MeasureManager___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.MeasureManager___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.MeasureManager___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.MeasureManager_classType
    if _newclass:classType = staticmethod(_core.MeasureManager_classType)
    __swig_destroy__ = _core.delete_MeasureManager
    __del__ = lambda self : None;
    def getOrientedBoundingBox(self, *args) -> "adsk::core::Ptr< adsk::core::OrientedBoundingBox3D >" :
        """
        Calculates an oriented bounding box for the input geometry. The bounding box is tight fitting
        to the input geometry and is particularly useful when you want to calculate a bounding box that 
        is not oriented to be parallel to the model x-y-z plane.
        The height direction is automatically determined using the length and width directions. 
        geometry : The geometry to calculate the bounding box for. This can be any of the B-Rep related entities. 
        lengthVector : The direction the length of the oriented bounding box will be measured in. The magnitude of the vector
        is ignored and only the direction is used. 
        widthVector : The direction the width of the oriented bounding box will be measured in. The magnitude of the vector
        is ignored and only the direction is used. This must be perpendicular to the length vector. 
        Returns an OrientedBoundingBox3D object which provides the information that defines an oriented bounding box.
        """
        return _core.MeasureManager_getOrientedBoundingBox(self, *args)

    def measureMinimumDistance(self, *args) -> "adsk::core::Ptr< adsk::core::MeasureResults >" :
        """
        Measures the minimum distance between the two input geometries. 
        geometryOne : The first geometry to measure from. This can be an Occurrence, any B-Rep entity (BRepBody, BRepFace, BRepEdge, BRepVertex, etc.), 
        any construction geometry, any sketch entities, and any temporary 3D geometry (Cylinder, Plane, Line3D, etc.). 
        geometryTwo : The second geometry to measure to. This can be an Occurrence, any B-Rep entity (BRepBody, BRepFace, BRepEdge, BRepVertex, etc.), 
        any construction geometry, any sketch entities, and any temporary 3D geometry (Cylinder, Plane, Line3D, etc.). 
        A MeasureResults object that contains the distance and the two points on the geometry that the distance that
        was measured between them in centimeters.
        """
        return _core.MeasureManager_measureMinimumDistance(self, *args)

    def measureAngle(self, *args) -> "adsk::core::Ptr< adsk::core::MeasureResults >" :
        """
        Measures the angle between the input geometry. 
        geometryOne : The first geometry to measure the angle to. This can be any 3D point geometry (Construction Point, Vertex, SketchPoint, or Point3D),
        any 3D linear geometry (Construction Axis, linear BRepEdge, SketchLine, Line3D, or InfiniteLine3D), or any planar geometry (Construction Plane, planar BRepFace, or Plane). 
        geometryTwo : The second geometry to measure the angle to. This can be any 3D point geometry (Construction Point, Vertex, SketchPoint, or Point3D),
        any 3D linear geometry (Construction Axis, linear BRepEdge, SketchLine, Line3D, or InfiniteLine3D), or any planar geometry (Construction Plane, planar BRepFace, or Plane). 
        geometryThree : The optional third geometry to measure the angle to. This is only used when the first two geometries
        are points and this defines the third point. When three points define a triangle, the apex of the
        triangle is defined by the second point. A point can be defined by a Cosntruction Point, Vertex, SketchPoint, or Point3D object. 
        A MeasureResults object that contains the angle and the two points on the geometry that the angle
        that was measured between them in radians.
        """
        return _core.MeasureManager_measureAngle(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.MeasureManager__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.MeasureManager__get_isValid(self)
MeasureManager_swigregister = _core.MeasureManager_swigregister
MeasureManager_swigregister(MeasureManager)

def MeasureManager_classType() -> "char const *" :
  return _core.MeasureManager_classType()
MeasureManager_classType = _core.MeasureManager_classType

MeasureManager.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MeasureManager) else None
MeasureManager.cast = lambda arg: arg if isinstance(arg, MeasureManager) else None

class MeasureResults(Base):
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MeasureResults, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MeasureResults, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::MeasureResults *" : return _core.MeasureResults___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.MeasureResults___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.MeasureResults___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.MeasureResults_classType
    if _newclass:classType = staticmethod(_core.MeasureResults_classType)
    __swig_destroy__ = _core.delete_MeasureResults
    __del__ = lambda self : None;
    def _get_value(self) -> "double" :
        """
        The measurement value. If the measurement is a distance this value will be in centimeters.
        If it's an angle then it will be in radians.
        """
        return _core.MeasureResults__get_value(self)

    def _get_positionOne(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        For a distance measurement, this is the point on the first entity where the measurement was made from.
        For an angle measurement this is one of the three points defining the angle.
        """
        return _core.MeasureResults__get_positionOne(self)

    def _get_positionTwo(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        For a distance measurement, this is the point on the second entity where the measurement was made to.
        For an angle measurement this is one of the three points defining the angle.
        """
        return _core.MeasureResults__get_positionTwo(self)

    def _get_positionThree(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """This point is only used for angle measurements and is one of the three points defining the angle."""
        return _core.MeasureResults__get_positionThree(self)

    def _get_objectType(self) -> "char const *" : return _core.MeasureResults__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.MeasureResults__get_isValid(self)
MeasureResults_swigregister = _core.MeasureResults_swigregister
MeasureResults_swigregister(MeasureResults)

def MeasureResults_classType() -> "char const *" :
  return _core.MeasureResults_classType()
MeasureResults_classType = _core.MeasureResults_classType

MeasureResults.__swig_getmethods__["value"] = MeasureResults._get_value
MeasureResults.value = property(MeasureResults._get_value, doc="The measurement value. If the measurement is a distance this value will be in centimeters.\nIf it's an angle then it will be in radians.")

MeasureResults.__swig_getmethods__["positionOne"] = MeasureResults._get_positionOne
MeasureResults.positionOne = property(MeasureResults._get_positionOne, doc="For a distance measurement, this is the point on the first entity where the measurement was made from.\nFor an angle measurement this is one of the three points defining the angle.")

MeasureResults.__swig_getmethods__["positionTwo"] = MeasureResults._get_positionTwo
MeasureResults.positionTwo = property(MeasureResults._get_positionTwo, doc="For a distance measurement, this is the point on the second entity where the measurement was made to.\nFor an angle measurement this is one of the three points defining the angle.")

MeasureResults.__swig_getmethods__["positionThree"] = MeasureResults._get_positionThree
MeasureResults.positionThree = property(MeasureResults._get_positionThree, doc="This point is only used for angle measurements and is one of the three points defining the angle.")

MeasureResults.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MeasureResults) else None
MeasureResults.cast = lambda arg: arg if isinstance(arg, MeasureResults) else None

class MouseEventHandler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MouseEventHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MouseEventHandler, name)
    __repr__ = _swig_repr
    def notify(self, *args) -> "void" : return _core.MouseEventHandler_notify(self, *args)
    def __init__(self): 
        if self.__class__ == MouseEventHandler:
            _self = None
        else:
            _self = self
        this = _core.new_MouseEventHandler(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_MouseEventHandler
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _core.disown_MouseEventHandler(self)
        return weakref_proxy(self)
MouseEventHandler_swigregister = _core.MouseEventHandler_swigregister
MouseEventHandler_swigregister(MouseEventHandler)

MouseEventHandler.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MouseEventHandler) else None
MouseEventHandler.cast = lambda arg: arg if isinstance(arg, MouseEventHandler) else None

class NamedValues(Base):
    """Wraps a list of named values."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NamedValues, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NamedValues, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::NamedValues *" : return _core.NamedValues___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.NamedValues___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.NamedValues___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.NamedValues___len__(self)
    __swig_getmethods__["classType"] = lambda x: _core.NamedValues_classType
    if _newclass:classType = staticmethod(_core.NamedValues_classType)
    __swig_getmethods__["create"] = lambda x: _core.NamedValues_create
    if _newclass:create = staticmethod(_core.NamedValues_create)
    __swig_destroy__ = _core.delete_NamedValues
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Adds a name value pair to the NamedValues object 
        name : A name for the name value pair 
        value : A ValueInput object that defines the value of the name value pair 
        Returns true if the name value pair is added successfully.
        """
        return _core.NamedValues_add(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of name value pairs in this object."""
        return _core.NamedValues__get_count(self)

    def getByIndex(self, *args) -> "bool" :
        """
        Function that returns the name and ValueInput object of a name value pair
        by specifying an index number 
        index : The index of the name value pair to return. The first pair in the collection 
        has an index of 0. 
        name : The name 
        value : The ValueInput object 
        Returns true if successful
        """
        return _core.NamedValues_getByIndex(self, *args)

    def getValueByName(self, *args) -> "bool" :
        """
        Function that returns the ValueInput object of a name value pair
        by specifying its name 
        name : The name of the name value pair to return the ValueInput object from 
        value : The ValueInput object 
        Returns true if successful
        """
        return _core.NamedValues_getValueByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.NamedValues__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.NamedValues__get_isValid(self)
NamedValues_swigregister = _core.NamedValues_swigregister
NamedValues_swigregister(NamedValues)

def NamedValues_classType() -> "char const *" :
  return _core.NamedValues_classType()
NamedValues_classType = _core.NamedValues_classType

def NamedValues_create() -> "adsk::core::Ptr< adsk::core::NamedValues >" :
  return _core.NamedValues_create()
NamedValues_create = _core.NamedValues_create

NamedValues.__swig_getmethods__["count"] = NamedValues._get_count
NamedValues.count = property(NamedValues._get_count, doc="Returns the number of name value pairs in this object.")

NamedValues.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, NamedValues) else None
NamedValues.cast = lambda arg: arg if isinstance(arg, NamedValues) else None

class NetworkPreferences(Base):
    """The NetworkPreferences object provides access to network related preferences."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NetworkPreferences, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NetworkPreferences, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::NetworkPreferences *" : return _core.NetworkPreferences___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.NetworkPreferences___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.NetworkPreferences___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.NetworkPreferences_classType
    if _newclass:classType = staticmethod(_core.NetworkPreferences_classType)
    __swig_destroy__ = _core.delete_NetworkPreferences
    __del__ = lambda self : None;
    def _get_networkProxySetting(self) -> "adsk::core::NetworkProxySettings" :
        """Gets and sets the network proxy setting."""
        return _core.NetworkPreferences__get_networkProxySetting(self)

    def _set_networkProxySetting(self, *args) -> "bool" :
        """Gets and sets the network proxy setting."""
        return _core.NetworkPreferences__set_networkProxySetting(self, *args)

    def _get_proxyHost(self) -> "std::string" :
        """Gets and sets the proxy host."""
        return _core.NetworkPreferences__get_proxyHost(self)

    def _set_proxyHost(self, *args) -> "bool" :
        """Gets and sets the proxy host."""
        return _core.NetworkPreferences__set_proxyHost(self, *args)

    def _get_proxyPort(self) -> "int" :
        """Gets and sets the proxy host."""
        return _core.NetworkPreferences__get_proxyPort(self)

    def _set_proxyPort(self, *args) -> "bool" :
        """Gets and sets the proxy host."""
        return _core.NetworkPreferences__set_proxyPort(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.NetworkPreferences__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.NetworkPreferences__get_isValid(self)
NetworkPreferences_swigregister = _core.NetworkPreferences_swigregister
NetworkPreferences_swigregister(NetworkPreferences)

def NetworkPreferences_classType() -> "char const *" :
  return _core.NetworkPreferences_classType()
NetworkPreferences_classType = _core.NetworkPreferences_classType

NetworkPreferences.__swig_getmethods__["networkProxySetting"] = NetworkPreferences._get_networkProxySetting
NetworkPreferences.__swig_setmethods__["networkProxySetting"] = NetworkPreferences._set_networkProxySetting
NetworkPreferences.networkProxySetting = property(NetworkPreferences._get_networkProxySetting, NetworkPreferences._set_networkProxySetting, doc="Gets and sets the network proxy setting.")

NetworkPreferences.__swig_getmethods__["proxyHost"] = NetworkPreferences._get_proxyHost
NetworkPreferences.__swig_setmethods__["proxyHost"] = NetworkPreferences._set_proxyHost
NetworkPreferences.proxyHost = property(NetworkPreferences._get_proxyHost, NetworkPreferences._set_proxyHost, doc="Gets and sets the proxy host.")

NetworkPreferences.__swig_getmethods__["proxyPort"] = NetworkPreferences._get_proxyPort
NetworkPreferences.__swig_setmethods__["proxyPort"] = NetworkPreferences._set_proxyPort
NetworkPreferences.proxyPort = property(NetworkPreferences._get_proxyPort, NetworkPreferences._set_proxyPort, doc="Gets and sets the proxy host.")

NetworkPreferences.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, NetworkPreferences) else None
NetworkPreferences.cast = lambda arg: arg if isinstance(arg, NetworkPreferences) else None

class ObjectCollection(Base):
    """Generic collection used to handle lists of any object type."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ObjectCollection, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ObjectCollection, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ObjectCollection *" : return _core.ObjectCollection___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ObjectCollection___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ObjectCollection___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.ObjectCollection___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::Base >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.ObjectCollection___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ObjectCollection_classType
    if _newclass:classType = staticmethod(_core.ObjectCollection_classType)
    __swig_getmethods__["create"] = lambda x: _core.ObjectCollection_create
    if _newclass:create = staticmethod(_core.ObjectCollection_create)
    __swig_destroy__ = _core.delete_ObjectCollection
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Function that returns the specified object using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.ObjectCollection_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of occurrences in the collection."""
        return _core.ObjectCollection__get_count(self)

    def add(self, *args) -> "bool" :
        """
        Adds an object to the end of the collection. 
        Duplicates can be added to the collection. 
        item : The item to add to the list. 
        Returns false if the item was not added.
        """
        return _core.ObjectCollection_add(self, *args)

    def removeByItem(self, *args) -> "bool" :
        """
        Function that removes an item from the collection. 
        item : The object to remove from the collection. 
        Returns true if the removal was successful.
        """
        return _core.ObjectCollection_removeByItem(self, *args)

    def removeByIndex(self, *args) -> "bool" :
        """
        Function that removes an item from the list. 
        Will fail if the list is read only. 
        index : The index of the item to remove from the collection. The first item has an index of 0. 
        Returns true if the removal was successful.
        """
        return _core.ObjectCollection_removeByIndex(self, *args)

    def find(self, *args) -> "int" :
        """
        Finds the specified component in the collection. 
        item : The item to search for within the collection. 
        startIndex : The index to begin the search. 
        Returns the index of the found item. If not found, -1 is returned.
        """
        return _core.ObjectCollection_find(self, *args)

    def contains(self, *args) -> "bool" :
        """
        Returns whether the specified object exists within the collection. 
        item : The item to look for in the collection. 
        Returns true if the specified item is found in the collection.
        """
        return _core.ObjectCollection_contains(self, *args)

    def clear(self) -> "bool" :
        """
        Clears the entire contents of the collection. 
        Returns true if successful.
        """
        return _core.ObjectCollection_clear(self)

    def _get_objectType(self) -> "char const *" : return _core.ObjectCollection__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ObjectCollection__get_isValid(self)
ObjectCollection_swigregister = _core.ObjectCollection_swigregister
ObjectCollection_swigregister(ObjectCollection)

def ObjectCollection_classType() -> "char const *" :
  return _core.ObjectCollection_classType()
ObjectCollection_classType = _core.ObjectCollection_classType

def ObjectCollection_create() -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
  return _core.ObjectCollection_create()
ObjectCollection_create = _core.ObjectCollection_create

ObjectCollection.__swig_getmethods__["count"] = ObjectCollection._get_count
ObjectCollection.count = property(ObjectCollection._get_count, doc="Returns the number of occurrences in the collection.")

ObjectCollection.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ObjectCollection) else None
ObjectCollection.cast = lambda arg: arg if isinstance(arg, ObjectCollection) else None

class OrientedBoundingBox3D(Base):
    """
    Transient object that represents an oriented 3D bounding box. An oriented 3D bounding box is a rectangular box that
    can be in any orientation in model space. They are created statically using the create method of the OrientedBoundingBox3D class
    and are used by some functions to return oriented box information.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OrientedBoundingBox3D, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OrientedBoundingBox3D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::OrientedBoundingBox3D *" : return _core.OrientedBoundingBox3D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.OrientedBoundingBox3D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.OrientedBoundingBox3D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.OrientedBoundingBox3D_classType
    if _newclass:classType = staticmethod(_core.OrientedBoundingBox3D_classType)
    __swig_getmethods__["create"] = lambda x: _core.OrientedBoundingBox3D_create
    if _newclass:create = staticmethod(_core.OrientedBoundingBox3D_create)
    __swig_destroy__ = _core.delete_OrientedBoundingBox3D
    __del__ = lambda self : None;
    def _get_centerPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets the centerPoint point of the oriented box."""
        return _core.OrientedBoundingBox3D__get_centerPoint(self)

    def _set_centerPoint(self, *args) -> "bool" :
        """Gets and sets the centerPoint point of the oriented box."""
        return _core.OrientedBoundingBox3D__set_centerPoint(self, *args)

    def setOrientation(self, *args) -> "bool" :
        """
        Sets the orientation of the oriented bouding box. 
        lengthDirection : A Vector3D object that defines the direction of the length of the oriented bounding box. The magnitude of
        the vector is ignored and just the direction is used. 
        widthDirection : A Vector3D object that defines the direction of the width of the oriented bounding box. The magnitude of
        the vector is ignored and just the direction is used. The width direction must be perpendicular to
        the length direction.
        """
        return _core.OrientedBoundingBox3D_setOrientation(self, *args)

    def _get_lengthDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Gets the direction of the length of the oriented bounding box.
        A unit vector is always returned.
        """
        return _core.OrientedBoundingBox3D__get_lengthDirection(self)

    def _get_length(self) -> "double" :
        """Gets and sets the length of the oriented bounding box in centimeters."""
        return _core.OrientedBoundingBox3D__get_length(self)

    def _set_length(self, *args) -> "bool" :
        """Gets and sets the length of the oriented bounding box in centimeters."""
        return _core.OrientedBoundingBox3D__set_length(self, *args)

    def _get_widthDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Gets the direction of the width of the oriented bounding box.
        A unit vector is always returned.
        """
        return _core.OrientedBoundingBox3D__get_widthDirection(self)

    def _get_width(self) -> "double" :
        """Gets and sets the width of the oriented bounding box in centimeters."""
        return _core.OrientedBoundingBox3D__get_width(self)

    def _set_width(self, *args) -> "bool" :
        """Gets and sets the width of the oriented bounding box in centimeters."""
        return _core.OrientedBoundingBox3D__set_width(self, *args)

    def _get_heightDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Gets the direction of the height of the oriented bounding box.
        A unit vector is always returned.
        """
        return _core.OrientedBoundingBox3D__get_heightDirection(self)

    def _get_height(self) -> "double" :
        """Gets and sets the height of the oriented bounding box in centimeters."""
        return _core.OrientedBoundingBox3D__get_height(self)

    def _set_height(self, *args) -> "bool" :
        """Gets and sets the height of the oriented bounding box in centimeters."""
        return _core.OrientedBoundingBox3D__set_height(self, *args)

    def contains(self, *args) -> "bool" :
        """
        Determines if the specified point lies within the oriented bounding box. 
        point : The point to test containment with. 
        Returns true if the point lies within the bounding box.
        """
        return _core.OrientedBoundingBox3D_contains(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::OrientedBoundingBox3D >" :
        """
        Create a copy of this oriented bounding box. 
        Returns the new oriented bounding box copy.
        """
        return _core.OrientedBoundingBox3D_copy(self)

    def _get_objectType(self) -> "char const *" : return _core.OrientedBoundingBox3D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.OrientedBoundingBox3D__get_isValid(self)
OrientedBoundingBox3D_swigregister = _core.OrientedBoundingBox3D_swigregister
OrientedBoundingBox3D_swigregister(OrientedBoundingBox3D)

def OrientedBoundingBox3D_classType() -> "char const *" :
  return _core.OrientedBoundingBox3D_classType()
OrientedBoundingBox3D_classType = _core.OrientedBoundingBox3D_classType

def OrientedBoundingBox3D_create(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &" :
  return _core.OrientedBoundingBox3D_create(*args)
OrientedBoundingBox3D_create = _core.OrientedBoundingBox3D_create

OrientedBoundingBox3D.__swig_getmethods__["centerPoint"] = OrientedBoundingBox3D._get_centerPoint
OrientedBoundingBox3D.__swig_setmethods__["centerPoint"] = OrientedBoundingBox3D._set_centerPoint
OrientedBoundingBox3D.centerPoint = property(OrientedBoundingBox3D._get_centerPoint, OrientedBoundingBox3D._set_centerPoint, doc="Gets and sets the centerPoint point of the oriented box.")

OrientedBoundingBox3D.__swig_getmethods__["lengthDirection"] = OrientedBoundingBox3D._get_lengthDirection
OrientedBoundingBox3D.lengthDirection = property(OrientedBoundingBox3D._get_lengthDirection, doc="Gets the direction of the length of the oriented bounding box.\nA unit vector is always returned.")

OrientedBoundingBox3D.__swig_getmethods__["length"] = OrientedBoundingBox3D._get_length
OrientedBoundingBox3D.__swig_setmethods__["length"] = OrientedBoundingBox3D._set_length
OrientedBoundingBox3D.length = property(OrientedBoundingBox3D._get_length, OrientedBoundingBox3D._set_length, doc="Gets and sets the length of the oriented bounding box in centimeters.")

OrientedBoundingBox3D.__swig_getmethods__["widthDirection"] = OrientedBoundingBox3D._get_widthDirection
OrientedBoundingBox3D.widthDirection = property(OrientedBoundingBox3D._get_widthDirection, doc="Gets the direction of the width of the oriented bounding box.\nA unit vector is always returned.")

OrientedBoundingBox3D.__swig_getmethods__["width"] = OrientedBoundingBox3D._get_width
OrientedBoundingBox3D.__swig_setmethods__["width"] = OrientedBoundingBox3D._set_width
OrientedBoundingBox3D.width = property(OrientedBoundingBox3D._get_width, OrientedBoundingBox3D._set_width, doc="Gets and sets the width of the oriented bounding box in centimeters.")

OrientedBoundingBox3D.__swig_getmethods__["heightDirection"] = OrientedBoundingBox3D._get_heightDirection
OrientedBoundingBox3D.heightDirection = property(OrientedBoundingBox3D._get_heightDirection, doc="Gets the direction of the height of the oriented bounding box.\nA unit vector is always returned.")

OrientedBoundingBox3D.__swig_getmethods__["height"] = OrientedBoundingBox3D._get_height
OrientedBoundingBox3D.__swig_setmethods__["height"] = OrientedBoundingBox3D._set_height
OrientedBoundingBox3D.height = property(OrientedBoundingBox3D._get_height, OrientedBoundingBox3D._set_height, doc="Gets and sets the height of the oriented bounding box in centimeters.")

OrientedBoundingBox3D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, OrientedBoundingBox3D) else None
OrientedBoundingBox3D.cast = lambda arg: arg if isinstance(arg, OrientedBoundingBox3D) else None

class Palette(Base):
    """
    A Palette is a floating or docked dialog in Fusion 360. The browser is an
    example of a built-in palette. The contents of a custom palette are
    created by displaying an html file.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Palette, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Palette, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Palette *" : return _core.Palette___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Palette___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Palette___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Palette_classType
    if _newclass:classType = staticmethod(_core.Palette_classType)
    __swig_destroy__ = _core.delete_Palette
    __del__ = lambda self : None;
    def _get_id(self) -> "std::string" :
        """Gets The unique, language independent, ID of this palette."""
        return _core.Palette__get_id(self)

    def _get_isVisible(self) -> "bool" :
        """Gets and sets whether this palette is currently being displayed in the user interface."""
        return _core.Palette__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets and sets whether this palette is currently being displayed in the user interface."""
        return _core.Palette__set_isVisible(self, *args)

    def _get_htmlFileURL(self) -> "std::string" :
        """Gets and sets the URL to the html file currently being displayed. This can be local or on the web."""
        return _core.Palette__get_htmlFileURL(self)

    def _set_htmlFileURL(self, *args) -> "bool" :
        """Gets and sets the URL to the html file currently being displayed. This can be local or on the web."""
        return _core.Palette__set_htmlFileURL(self, *args)

    def sendInfoToHTML(self, *args) -> "std::string" :
        """
        <p>Sends the string to the JavaScript associated with the loaded HTML. A variation of the
        event handler below should be implemented in the JavaScript associated with the HTML to
        receive the data. The event will be triggered by Fusion 360 whenever the sendInfoToHTML method 
        is called.</p>
        <pre class='api-code'>window.fusionJavaScriptHandler = {
        handle: function(actionString, dataString){
        confirm('Action from Fusion: ' + actionString);
        confirm('Data from Fusion: ' + dataString);
        // Build up JSON return string.
        var result = {};
        result.status = 'OK';
        var response = JSON.stringify(result);
        return response;
        }
        };</pre> 
        <p>Your JavaScript code should always return something in response because an empty string
        response is assumed to be a failure.</p> 
        action : The 'action' string to pass to the JavaScript associated with the HTML. This string can be 
        anything but will typically be JSON formatted information. 
        data : The 'data' string to pass to the JavaScript associated with the HTML. This string can be 
        anything but will typically be JSON formatted information. 
        Returns a string that can be anything that your JavaScript code generates. The JavaScript
        should always return some content because an empty string is used to indicate a failure.
        If useNewWebBrowser flag is set to true while creating palette control then this API call
        would be asynchronous and empty string is returned. Response would come in data field of HTMLEvent with action
        equal to 'response'
        """
        return _core.Palette_sendInfoToHTML(self, *args)

    def _get_incomingFromHTML(self) -> "adsk::core::Ptr< adsk::core::HTMLEvent >" :
        """
        This event is fired when the JavaScript associated with the HTML calls the 
        adsk.fusionSendData function. This allows the HTML to communicate with the add-in by
        passing information to the add-in.
        """
        return _core.Palette__get_incomingFromHTML(self)

    def _get_closed(self) -> "adsk::core::Ptr< adsk::core::UserInterfaceGeneralEvent >" :
        """
        This event is fired when the user clicks the 'Close' button on the palette. You can choose
        if the 'Close' button is available or not when you initially create the palette. When a
        palette is closed, it still exists but is change to invisible so you can still interact with it and
        retrieve any needed information and can make it visible again. Use the deleteMe method to
        delete the palette.
        """
        return _core.Palette__get_closed(self)

    def _get_name(self) -> "std::string" :
        """
        Gets and set the name of the palette as seen in the user interface. The name of native palletes
        cannot be set.
        """
        return _core.Palette__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """
        Gets and set the name of the palette as seen in the user interface. The name of native palletes
        cannot be set.
        """
        return _core.Palette__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this palette. Fusion 360 native palettes cannot be deleted. Use the
        isNative property to determine if this is a native or API created palette. 
        Returns true if the delete was successful.
        """
        return _core.Palette_deleteMe(self)

    def _get_isNative(self) -> "bool" :
        """
        Indicates if this is one of the standard Fusion 360 palettes or a custom palette
        created through the API. If true, it is a standard Fusion 360 palette and will
        have some restrictions on changing its properties and cannot be deleted.
        """
        return _core.Palette__get_isNative(self)

    def _get_dockingOption(self) -> "adsk::core::PaletteDockingOptions" :
        """Defines the docking behavior for this palette. This controls how the user is allowed to dock the palette."""
        return _core.Palette__get_dockingOption(self)

    def _set_dockingOption(self, *args) -> "bool" :
        """Defines the docking behavior for this palette. This controls how the user is allowed to dock the palette."""
        return _core.Palette__set_dockingOption(self, *args)

    def _get_dockingState(self) -> "adsk::core::PaletteDockingStates" :
        """Gets and sets how the palette is currented docked."""
        return _core.Palette__get_dockingState(self)

    def _set_dockingState(self, *args) -> "bool" :
        """Gets and sets how the palette is currented docked."""
        return _core.Palette__set_dockingState(self, *args)

    def _get_width(self) -> "int" :
        """
        Gets and sets the width of the palette. Setting this property may not always set the width. Depending on
        how the palette is docked or snapped, the width may not be editable.
        """
        return _core.Palette__get_width(self)

    def _set_width(self, *args) -> "bool" :
        """
        Gets and sets the width of the palette. Setting this property may not always set the width. Depending on
        how the palette is docked or snapped, the width may not be editable.
        """
        return _core.Palette__set_width(self, *args)

    def _get_height(self) -> "int" :
        """
        Gets and sets the height of the palette. Setting this property may not always set the height. Depending on
        how the palette is docked or snapped, the height may not be editable.
        """
        return _core.Palette__get_height(self)

    def _set_height(self, *args) -> "bool" :
        """
        Gets and sets the height of the palette. Setting this property may not always set the height. Depending on
        how the palette is docked or snapped, the height may not be editable.
        """
        return _core.Palette__set_height(self, *args)

    def setPosition(self, *args) -> "bool" :
        """
        Sets the position of the palette. If the palette is docked or snapped, this will result in changing it
        to be floating. 
        left : The position of the left side of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the left side of the screen and not the 
        Fusion 360 window. 
        top : The position of the top of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the top of the screen and not the 
        Fusion 360 window. 
        Returns true if setting the position was successful.
        """
        return _core.Palette_setPosition(self, *args)

    def setSize(self, *args) -> "bool" :
        """
        Sets the size of the palette. This is best used for a floating palette because either the width or
        height can be locked when a palette is docked. 
        width : Specifies the width of the palette. Depending on how the palette is docked or snapped, the width 
        may not be editable. 
        height : Specifies the height of the palette. Depending on how the palette is docked or snapped, the height 
        may not be editable. 
        Returns true if the sizing was succesful. It is still considered a success even if the width or
        height could not be changed because of how the palette is docked or snapped.
        """
        return _core.Palette_setSize(self, *args)

    def _get_left(self) -> "int" :
        """
        Gets and sets the left side of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the left side of the screen and not the 
        Fusion 360 window.
        """
        return _core.Palette__get_left(self)

    def _set_left(self, *args) -> "bool" :
        """
        Gets and sets the left side of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the left side of the screen and not the 
        Fusion 360 window.
        """
        return _core.Palette__set_left(self, *args)

    def _get_top(self) -> "int" :
        """
        Gets and sets the top of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the top of the screen and not the 
        Fusion 360 window.
        """
        return _core.Palette__get_top(self)

    def _set_top(self, *args) -> "bool" :
        """
        Gets and sets the top of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the top of the screen and not the 
        Fusion 360 window.
        """
        return _core.Palette__set_top(self, *args)

    def snapTo(self, *args) -> "bool" :
        """
        Snaps this palette to another palette. 
        palette : Specifies the palette to snap to. 
        snapOption : Specifies how this palette should be snapped to the other palette. 
        Returns true if the palette was successfully snapped to the other palette.
        """
        return _core.Palette_snapTo(self, *args)

    def setMinimumSize(self, *args) -> "bool" :
        """
        Sets the minimum size of the palette. The user cannot resize it to be smaller than
        this size. This does not change the current size of the palette unless the palette
        is already smaller than this size.
        Calling this method and setting the width and height to zero, removes the minimum
        size restriction. 
        width : Specifies the minimum width of the palette. 
        height : Specifies the minimum height of the palette. 
        Returns true if setting the minimum size was succesful.
        """
        return _core.Palette_setMinimumSize(self, *args)

    def setMaximumSize(self, *args) -> "bool" :
        """
        Sets the maximum size of the palette. The user cannot resize it to be larger than
        this size. This does not change the current size of the palette unless the palette
        is already larger than this size.
        Calling this method and setting the width and height to zero, removes the maximum
        size restriction. 
        width : Specifies the maximum width of the palette. 
        height : Specifies the maximum height of the palette. 
        Returns true if setting the maximum size was succesful.
        """
        return _core.Palette_setMaximumSize(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Palette__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Palette__get_isValid(self)
Palette_swigregister = _core.Palette_swigregister
Palette_swigregister(Palette)

def Palette_classType() -> "char const *" :
  return _core.Palette_classType()
Palette_classType = _core.Palette_classType

Palette.__swig_getmethods__["id"] = Palette._get_id
Palette.id = property(Palette._get_id, doc="Gets The unique, language independent, ID of this palette.")

Palette.__swig_getmethods__["isVisible"] = Palette._get_isVisible
Palette.__swig_setmethods__["isVisible"] = Palette._set_isVisible
Palette.isVisible = property(Palette._get_isVisible, Palette._set_isVisible, doc="Gets and sets whether this palette is currently being displayed in the user interface.")

Palette.__swig_getmethods__["htmlFileURL"] = Palette._get_htmlFileURL
Palette.__swig_setmethods__["htmlFileURL"] = Palette._set_htmlFileURL
Palette.htmlFileURL = property(Palette._get_htmlFileURL, Palette._set_htmlFileURL, doc="Gets and sets the URL to the html file currently being displayed. This can be local or on the web.")

Palette.__swig_getmethods__["incomingFromHTML"] = Palette._get_incomingFromHTML
Palette.incomingFromHTML = property(Palette._get_incomingFromHTML, doc="This event is fired when the JavaScript associated with the HTML calls the\nadsk.fusionSendData function. This allows the HTML to communicate with the add-in by\npassing information to the add-in.")

Palette.__swig_getmethods__["closed"] = Palette._get_closed
Palette.closed = property(Palette._get_closed, doc="This event is fired when the user clicks the 'Close' button on the palette. You can choose\nif the 'Close' button is available or not when you initially create the palette. When a\npalette is closed, it still exists but is change to invisible so you can still interact with it and\nretrieve any needed information and can make it visible again. Use the deleteMe method to\ndelete the palette.")

Palette.__swig_getmethods__["name"] = Palette._get_name
Palette.__swig_setmethods__["name"] = Palette._set_name
Palette.name = property(Palette._get_name, Palette._set_name, doc="Gets and set the name of the palette as seen in the user interface. The name of native palletes\ncannot be set.")

Palette.__swig_getmethods__["isNative"] = Palette._get_isNative
Palette.isNative = property(Palette._get_isNative, doc="Indicates if this is one of the standard Fusion 360 palettes or a custom palette\ncreated through the API. If true, it is a standard Fusion 360 palette and will\nhave some restrictions on changing its properties and cannot be deleted.")

Palette.__swig_getmethods__["dockingOption"] = Palette._get_dockingOption
Palette.__swig_setmethods__["dockingOption"] = Palette._set_dockingOption
Palette.dockingOption = property(Palette._get_dockingOption, Palette._set_dockingOption, doc="Defines the docking behavior for this palette. This controls how the user is allowed to dock the palette.")

Palette.__swig_getmethods__["dockingState"] = Palette._get_dockingState
Palette.__swig_setmethods__["dockingState"] = Palette._set_dockingState
Palette.dockingState = property(Palette._get_dockingState, Palette._set_dockingState, doc="Gets and sets how the palette is currented docked.")

Palette.__swig_getmethods__["width"] = Palette._get_width
Palette.__swig_setmethods__["width"] = Palette._set_width
Palette.width = property(Palette._get_width, Palette._set_width, doc="Gets and sets the width of the palette. Setting this property may not always set the width. Depending on\nhow the palette is docked or snapped, the width may not be editable.")

Palette.__swig_getmethods__["height"] = Palette._get_height
Palette.__swig_setmethods__["height"] = Palette._set_height
Palette.height = property(Palette._get_height, Palette._set_height, doc="Gets and sets the height of the palette. Setting this property may not always set the height. Depending on\nhow the palette is docked or snapped, the height may not be editable.")

Palette.__swig_getmethods__["left"] = Palette._get_left
Palette.__swig_setmethods__["left"] = Palette._set_left
Palette.left = property(Palette._get_left, Palette._set_left, doc="Gets and sets the left side of the palette relative to screen space and in pixels. Because palettes can be\npositioned outside of the Fusion 360 window, a value of zero indicates the left side of the screen and not the\nFusion 360 window.")

Palette.__swig_getmethods__["top"] = Palette._get_top
Palette.__swig_setmethods__["top"] = Palette._set_top
Palette.top = property(Palette._get_top, Palette._set_top, doc="Gets and sets the top of the palette relative to screen space and in pixels. Because palettes can be\npositioned outside of the Fusion 360 window, a value of zero indicates the top of the screen and not the\nFusion 360 window.")

Palette.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Palette) else None
Palette.cast = lambda arg: arg if isinstance(arg, Palette) else None

class Palettes(Base):
    """Provides access to a set of palettes, which are docked or floating windows that display html."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Palettes, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Palettes, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Palettes *" : return _core.Palettes___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Palettes___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Palettes___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.Palettes___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::Palette >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.Palettes___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Palettes_classType
    if _newclass:classType = staticmethod(_core.Palettes_classType)
    __swig_destroy__ = _core.delete_Palettes
    __del__ = lambda self : None;
    def add(self, *args) -> "adsk::core::Ptr< adsk::core::Palette >" :
        """
        Creates a new Palette. 
        id : The unique id for this palette. The id must be unique with respect to all of the palettes. 
        name : The displayed name of this palette. This is the name visible in the user interface. 
        htmlFileURL : Specifies the url to the HTML file that will be displayed in the pallete. This can be a local file or on the web. 
        isVisible : Specifies if the palette is initially visible or not. It's useful to create it invisisibly, change other desired
        properties and then use the isVisible property to finally make it visible to the user. 
        showCloseButton : Specifies if a 'Close' button should be displayed on the palette to allow the user to easily close it. 
        isResizable : Specifies if the palette can be resized by the user or not. 
        width : Specifies the width of the palette in pixels. If no width is specified a default width will be used. 
        height : Specifies the height of the palette in pixels. If no height is specified a default height will be used. 
        useNewWebBrowser : Specifies true to use new browser in the palette. This is false by default to support existing clients.
        Support for old browser is deprecated and will be taken out soon. 
        Returns the newly created palette or null in the case the creation failed.
        """
        return _core.Palettes_add(self, *args)

    def item(self, *args) -> "adsk::core::Ptr< adsk::core::Palette >" :
        """
        Returns the specified palette using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.Palettes_item(self, *args)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::Palette >" :
        """
        Returns the palette at the specified ID. 
        id : The Id of the palette within the collection to return. 
        Returns the palette of the specified id or null if no palette has the specified id.
        """
        return _core.Palettes_itemById(self, *args)

    def _get_count(self) -> "size_t" :
        """Gets the number of Palettes."""
        return _core.Palettes__get_count(self)

    def _get_objectType(self) -> "char const *" : return _core.Palettes__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Palettes__get_isValid(self)
Palettes_swigregister = _core.Palettes_swigregister
Palettes_swigregister(Palettes)

def Palettes_classType() -> "char const *" :
  return _core.Palettes_classType()
Palettes_classType = _core.Palettes_classType

Palettes.__swig_getmethods__["count"] = Palettes._get_count
Palettes.count = property(Palettes._get_count, doc="Gets the number of Palettes.")

Palettes.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Palettes) else None
Palettes.cast = lambda arg: arg if isinstance(arg, Palettes) else None

class Point2D(Base):
    """
    Transient 2D point. A transient point is not displayed or saved in a document.
    Transient 2D points are used as a wrapper to work with raw 2D point information.
    They are created statically using the create methods of the Point2D class.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Point2D, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Point2D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Point2D *" : return _core.Point2D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Point2D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Point2D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Point2D_classType
    if _newclass:classType = staticmethod(_core.Point2D_classType)
    __swig_getmethods__["create"] = lambda x: _core.Point2D_create
    if _newclass:create = staticmethod(_core.Point2D_create)
    __swig_destroy__ = _core.delete_Point2D
    __del__ = lambda self : None;
    def _get_x(self) -> "double" :
        """Gets and sets the X coordinate of the point."""
        return _core.Point2D__get_x(self)

    def _set_x(self, *args) -> "bool" :
        """Gets and sets the X coordinate of the point."""
        return _core.Point2D__set_x(self, *args)

    def _get_y(self) -> "double" :
        """Gets and sets the Y coordinate of the point."""
        return _core.Point2D__get_y(self)

    def _set_y(self, *args) -> "bool" :
        """Gets and sets the Y coordinate of the point."""
        return _core.Point2D__set_y(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """
        Creates and returns a copy of this point object. 
        Returns an independent copy of this point object.
        """
        return _core.Point2D_copy(self)

    def getData(self) -> "bool" :
        """
        Gets the data defining the point. 
        x : The output x coordinate of the point. 
        y : The output y coordinate of the point. 
        Returns true if successful.
        """
        return _core.Point2D_getData(self)

    def distanceTo(self, *args) -> "double" :
        """
        Returns the distance from this point to another point. 
        point : The point to measure the distance to 
        Returns the distance to the point.
        """
        return _core.Point2D_distanceTo(self, *args)

    def asArray(self) -> "std::vector< double,std::allocator< double > >" :
        """
        Get coordinate data of the point 
        Returns the coordinate data of the point as an array
        """
        return _core.Point2D_asArray(self)

    def isEqualTo(self, *args) -> "bool" :
        """
        Checks to see if this point and another point are equal (have identical coordinates).
        The comparison is done within the modeling tolerance which can be found with the
        Application.pointTolerance property. If you want to compare two points with any other
        tolerance you can use the isEqualToByTolerance method. 
        point : The point to compare for equality 
        Returns true if the points are equal. (have identical coordinates)
        """
        return _core.Point2D_isEqualTo(self, *args)

    def setWithArray(self, *args) -> "bool" :
        """
        Sets the coordinates of the point using an array as input. 
        coordinates : An array that defines the coordinates of the point 
        Returns true if successful
        """
        return _core.Point2D_setWithArray(self, *args)

    def set(self, *args) -> "bool" :
        """
        Sets the coordinates of the point by specifying the x, y coordinates. 
        x : The x coordinate of the point. 
        y : The y coordinate of the point. 
        Returns true if successful
        """
        return _core.Point2D_set(self, *args)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms the point using the provided matrix. 
        matrix : The Matrix2D object that defines the transformation 
        Returns true if successful
        """
        return _core.Point2D_transformBy(self, *args)

    def asVector(self) -> "adsk::core::Ptr< adsk::core::Vector2D >" :
        """
        Defines a vector using the coordinates of the point. 
        Returns a Vector2D object
        """
        return _core.Point2D_asVector(self)

    def translateBy(self, *args) -> "bool" :
        """
        Translates the point using the provided vector. 
        vector : The vector to use to translate the point 
        Returns true if successful
        """
        return _core.Point2D_translateBy(self, *args)

    def vectorTo(self, *args) -> "adsk::core::Ptr< adsk::core::Vector2D >" :
        """
        Returns a vector from this point to another point. 
        point : The other point to use to create the vector 
        Returns a Vector2D object
        """
        return _core.Point2D_vectorTo(self, *args)

    def isEqualToByTolerance(self, *args) -> "bool" :
        """
        Checks to see if this point and another point are equal within the specified tolerance. 
        point : The point to compare for equality. 
        tolerance : The tolerance, in centimeters, to use when comparing the two points. 
        Returns true if the points are equal (have identical coordinates).
        """
        return _core.Point2D_isEqualToByTolerance(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Point2D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Point2D__get_isValid(self)
Point2D_swigregister = _core.Point2D_swigregister
Point2D_swigregister(Point2D)

def Point2D_classType() -> "char const *" :
  return _core.Point2D_classType()
Point2D_classType = _core.Point2D_classType

def Point2D_create(x : 'double'=0, y : 'double'=0) -> "adsk::core::Ptr< adsk::core::Point2D >" :
  return _core.Point2D_create(x, y)
Point2D_create = _core.Point2D_create

Point2D.__swig_getmethods__["x"] = Point2D._get_x
Point2D.__swig_setmethods__["x"] = Point2D._set_x
Point2D.x = property(Point2D._get_x, Point2D._set_x, doc="Gets and sets the X coordinate of the point.")

Point2D.__swig_getmethods__["y"] = Point2D._get_y
Point2D.__swig_setmethods__["y"] = Point2D._set_y
Point2D.y = property(Point2D._get_y, Point2D._set_y, doc="Gets and sets the Y coordinate of the point.")

Point2D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Point2D) else None
Point2D.cast = lambda arg: arg if isinstance(arg, Point2D) else None

class Point3D(Base):
    """
    Transient 3D point. A transient point is not displayed or saved in a document. 
    Transient 3D points are used as a wrapper to work with raw 3D point information.
    They are created statically using the create method of the Point3D class.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Point3D, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Point3D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Point3D *" : return _core.Point3D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Point3D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Point3D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Point3D_classType
    if _newclass:classType = staticmethod(_core.Point3D_classType)
    __swig_getmethods__["create"] = lambda x: _core.Point3D_create
    if _newclass:create = staticmethod(_core.Point3D_create)
    __swig_destroy__ = _core.delete_Point3D
    __del__ = lambda self : None;
    def distanceTo(self, *args) -> "double" :
        """
        Returns the distance from this point to another point. 
        point : The point to measure the distance to. 
        Returns the distance to the point.
        """
        return _core.Point3D_distanceTo(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        Creates and returns a copy of this point object. 
        Returns an independent copy of this point object.
        """
        return _core.Point3D_copy(self)

    def asArray(self) -> "std::vector< double,std::allocator< double > >" :
        """
        Get coordinate data of the point. 
        Returns the coordinate data of the point as an array [x, y, z].
        """
        return _core.Point3D_asArray(self)

    def isEqualTo(self, *args) -> "bool" :
        """
        Checks to see if this point and another point are equal (have identical coordinates).
        The comparison is done within the modeling tolerance which can be found with the
        Application.pointTolerance property. If you want to compare two points with any other
        tolerance you can use the isEqualToByTolerance method. 
        point : The point to compare for equality. 
        Returns true if the points are equal (have identical coordinates).
        """
        return _core.Point3D_isEqualTo(self, *args)

    def setWithArray(self, *args) -> "bool" :
        """
        Sets the coordinates of the point using an array as input. 
        coordinates : An array that defines the coordinates of the point [x, y, z]. 
        Returns true if successful.
        """
        return _core.Point3D_setWithArray(self, *args)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms the point using the provided matrix. 
        matrix : The Matrix3D object that defines the transformation. 
        Returns true if successful.
        """
        return _core.Point3D_transformBy(self, *args)

    def _get_x(self) -> "double" :
        """Gets and sets the X coordinate of the point."""
        return _core.Point3D__get_x(self)

    def _set_x(self, *args) -> "bool" :
        """Gets and sets the X coordinate of the point."""
        return _core.Point3D__set_x(self, *args)

    def _get_y(self) -> "double" :
        """Gets and sets the Y coordinate of the point."""
        return _core.Point3D__get_y(self)

    def _set_y(self, *args) -> "bool" :
        """Gets and sets the Y coordinate of the point."""
        return _core.Point3D__set_y(self, *args)

    def _get_z(self) -> "double" :
        """Gets and sets the Z coordinate of the point."""
        return _core.Point3D__get_z(self)

    def _set_z(self, *args) -> "bool" :
        """Gets and sets the Z coordinate of the point."""
        return _core.Point3D__set_z(self, *args)

    def asVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Defines a vector using the coordinates of the point. 
        Returns a Vector2D object.
        """
        return _core.Point3D_asVector(self)

    def translateBy(self, *args) -> "bool" :
        """
        Translates the point using the provided vector. 
        vector : The vector to use to translate the point. 
        Returns true if successful.
        """
        return _core.Point3D_translateBy(self, *args)

    def getData(self) -> "bool" :
        """
        Gets the data defining the point. 
        x : The output x coordinate of the point. 
        y : The output y coordinate of the point. 
        z : The output z coordinate of the point. 
        Returns true if successful.
        """
        return _core.Point3D_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets the data defining the point. 
        x : The x coordinate of the point. 
        y : The y coordinate of the point. 
        z : The z coordinate of the point. 
        Returns true if successful.
        """
        return _core.Point3D_set(self, *args)

    def vectorTo(self, *args) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Returns a vector from this point to another point. 
        point : The other point to use to create the vector. 
        Returns a Vector3D object.
        """
        return _core.Point3D_vectorTo(self, *args)

    def isEqualToByTolerance(self, *args) -> "bool" :
        """
        Checks to see if this point and another point are equal within the specified tolerance. 
        point : The point to compare for equality. 
        tolerance : The tolerance, in centimeters, to use when comparing the two points. 
        Returns true if the points are equal (have identical coordinates).
        """
        return _core.Point3D_isEqualToByTolerance(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Point3D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Point3D__get_isValid(self)
Point3D_swigregister = _core.Point3D_swigregister
Point3D_swigregister(Point3D)

def Point3D_classType() -> "char const *" :
  return _core.Point3D_classType()
Point3D_classType = _core.Point3D_classType

def Point3D_create(x : 'double'=0, y : 'double'=0, z : 'double'=0) -> "adsk::core::Ptr< adsk::core::Point3D >" :
  return _core.Point3D_create(x, y, z)
Point3D_create = _core.Point3D_create

Point3D.__swig_getmethods__["x"] = Point3D._get_x
Point3D.__swig_setmethods__["x"] = Point3D._set_x
Point3D.x = property(Point3D._get_x, Point3D._set_x, doc="Gets and sets the X coordinate of the point.")

Point3D.__swig_getmethods__["y"] = Point3D._get_y
Point3D.__swig_setmethods__["y"] = Point3D._set_y
Point3D.y = property(Point3D._get_y, Point3D._set_y, doc="Gets and sets the Y coordinate of the point.")

Point3D.__swig_getmethods__["z"] = Point3D._get_z
Point3D.__swig_setmethods__["z"] = Point3D._set_z
Point3D.z = property(Point3D._get_z, Point3D._set_z, doc="Gets and sets the Z coordinate of the point.")

Point3D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Point3D) else None
Point3D.cast = lambda arg: arg if isinstance(arg, Point3D) else None

class Preferences(Base):
    """
    The Preferences object provides access to the various preference related objects
    for getting and setting the various preference values.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Preferences, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Preferences, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Preferences *" : return _core.Preferences___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Preferences___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Preferences___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Preferences_classType
    if _newclass:classType = staticmethod(_core.Preferences_classType)
    __swig_destroy__ = _core.delete_Preferences
    __del__ = lambda self : None;
    def _get_generalPreferences(self) -> "adsk::core::Ptr< adsk::core::GeneralPreferences >" :
        """Gets the GeneralPreferences object."""
        return _core.Preferences__get_generalPreferences(self)

    def _get_materialPreferences(self) -> "adsk::core::Ptr< adsk::core::MaterialPreferences >" :
        """Gets the MaterialPreferences object."""
        return _core.Preferences__get_materialPreferences(self)

    def _get_graphicsPreferences(self) -> "adsk::core::Ptr< adsk::core::GraphicsPreferences >" :
        """Gets the GraphicsPreferences object."""
        return _core.Preferences__get_graphicsPreferences(self)

    def _get_networkPreferences(self) -> "adsk::core::Ptr< adsk::core::NetworkPreferences >" :
        """Gets the NetworkPreferences object."""
        return _core.Preferences__get_networkPreferences(self)

    def _get_unitAndValuePreferences(self) -> "adsk::core::Ptr< adsk::core::UnitAndValuePreferences >" :
        """Gets the UnitAndValuePreferences object."""
        return _core.Preferences__get_unitAndValuePreferences(self)

    def _get_defaultUnitsPreferences(self) -> "adsk::core::Ptr< adsk::core::DefaultUnitsPreferencesCollection >" :
        """Gets the DefaultUnitsPreferences object."""
        return _core.Preferences__get_defaultUnitsPreferences(self)

    def _get_productPreferences(self) -> "adsk::core::Ptr< adsk::core::ProductPreferencesCollection >" :
        """Gets the ProductPreferences object."""
        return _core.Preferences__get_productPreferences(self)

    def _get_gridPreferences(self) -> "adsk::core::Ptr< adsk::core::GridPreferences >" :
        """Gets the GridPreferences object."""
        return _core.Preferences__get_gridPreferences(self)

    def _get_productUsageData(self) -> "adsk::core::Ptr< adsk::core::ProductUsageData >" :
        """Gets the ProductUsageData object."""
        return _core.Preferences__get_productUsageData(self)

    def _get_objectType(self) -> "char const *" : return _core.Preferences__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Preferences__get_isValid(self)
Preferences_swigregister = _core.Preferences_swigregister
Preferences_swigregister(Preferences)

def Preferences_classType() -> "char const *" :
  return _core.Preferences_classType()
Preferences_classType = _core.Preferences_classType

Preferences.__swig_getmethods__["generalPreferences"] = Preferences._get_generalPreferences
Preferences.generalPreferences = property(Preferences._get_generalPreferences, doc="Gets the GeneralPreferences object.")

Preferences.__swig_getmethods__["materialPreferences"] = Preferences._get_materialPreferences
Preferences.materialPreferences = property(Preferences._get_materialPreferences, doc="Gets the MaterialPreferences object.")

Preferences.__swig_getmethods__["graphicsPreferences"] = Preferences._get_graphicsPreferences
Preferences.graphicsPreferences = property(Preferences._get_graphicsPreferences, doc="Gets the GraphicsPreferences object.")

Preferences.__swig_getmethods__["networkPreferences"] = Preferences._get_networkPreferences
Preferences.networkPreferences = property(Preferences._get_networkPreferences, doc="Gets the NetworkPreferences object.")

Preferences.__swig_getmethods__["unitAndValuePreferences"] = Preferences._get_unitAndValuePreferences
Preferences.unitAndValuePreferences = property(Preferences._get_unitAndValuePreferences, doc="Gets the UnitAndValuePreferences object.")

Preferences.__swig_getmethods__["defaultUnitsPreferences"] = Preferences._get_defaultUnitsPreferences
Preferences.defaultUnitsPreferences = property(Preferences._get_defaultUnitsPreferences, doc="Gets the DefaultUnitsPreferences object.")

Preferences.__swig_getmethods__["productPreferences"] = Preferences._get_productPreferences
Preferences.productPreferences = property(Preferences._get_productPreferences, doc="Gets the ProductPreferences object.")

Preferences.__swig_getmethods__["gridPreferences"] = Preferences._get_gridPreferences
Preferences.gridPreferences = property(Preferences._get_gridPreferences, doc="Gets the GridPreferences object.")

Preferences.__swig_getmethods__["productUsageData"] = Preferences._get_productUsageData
Preferences.productUsageData = property(Preferences._get_productUsageData, doc="Gets the ProductUsageData object.")

Preferences.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Preferences) else None
Preferences.cast = lambda arg: arg if isinstance(arg, Preferences) else None

class Product(Base):
    """
    The base class for the various product specific containers. For
    Fusion 360 this is the Design object. For manufacturing this is a CAM object.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Product, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Product, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Product *" : return _core.Product___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Product___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Product___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Product_classType
    if _newclass:classType = staticmethod(_core.Product_classType)
    __swig_destroy__ = _core.delete_Product
    __del__ = lambda self : None;
    def _get_parentDocument(self) -> "adsk::core::Ptr< adsk::core::Document >" :
        """Returns the parent Document object."""
        return _core.Product__get_parentDocument(self)

    def _get_unitsManager(self) -> "adsk::core::Ptr< adsk::core::UnitsManager >" :
        """Returns the UnitsManager object associated with this product."""
        return _core.Product__get_unitsManager(self)

    def _get_workspaces(self) -> "adsk::core::Ptr< adsk::core::WorkspaceList >" :
        """Returns the workspaces associated with this product."""
        return _core.Product__get_workspaces(self)

    def _get_productType(self) -> "std::string" :
        """
        Returns the product type name of this product. A list of all of
        the possible product types can be obtained by using the 
        Application.supportedProductTypes property.
        """
        return _core.Product__get_productType(self)

    def findAttributes(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute >,std::allocator< adsk::core::Ptr< adsk::core::Attribute > > >" :
        """
        Find attributes attached to objects in this product that match the group and or attribute name.
        This does not find attributes attached directly to the Product or Document objects but finds the
        attributes attached to entities within the product.
        The search string for both the groupName and attributeName arguments can be either an absolute 
        name value, or a regular expression. With an absolute name, the search string must match the
        entire groupName or attributeName, including case. An empty string will match everything.
        For example if you have an attribute group named 'MyStuff' that contains the attribute 'Length1', 
        using the search string 'MyStuff' as the group name and 'Length1' as the attribute name will 
        find the attributes with those names. Searching for 'MyStuff' as the group name and '' as the
        attribute name will find all attributes that have 'MyStuff' as the group name.
        Regular expressions provide a more flexibile way of searching. To use a regular expression, 
        prefix the input string for the groupName or attributeName arguments with 're:'. The regular
        expression much match the entire group or attribute name. For example if you have a group that
        contains attributes named 'Length1', 'Length2', 'Width1', and 'Width2' and want to find any 
        of the length attributes you can use a regular expression using the string 're:Length.*'. For more
        information on attributes see the Attributes topic in the user manual. 
        groupName : The search string for the group name. See above for more details. 
        attributeName : The search string for the attribute name. See above for more details. 
        An array of Attribute objects that were found. An empty array is returned if no attributes were found.
        """
        return _core.Product_findAttributes(self, *args)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this product."""
        return _core.Product__get_attributes(self)

    def deleteEntities(self, *args) -> "bool" :
        """
        Deletes the specified set of entities that are associated with this product. 
        entities : An ObjectCollection containing the list of entities to delete. 
        Returns True if any of the entities provided in the list were deleted. If
        entities were specified that can't be deleted or aren't owned by this product,
        they are ignored.
        """
        return _core.Product_deleteEntities(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Product__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Product__get_isValid(self)
Product_swigregister = _core.Product_swigregister
Product_swigregister(Product)

def Product_classType() -> "char const *" :
  return _core.Product_classType()
Product_classType = _core.Product_classType

Product.__swig_getmethods__["parentDocument"] = Product._get_parentDocument
Product.parentDocument = property(Product._get_parentDocument, doc="Returns the parent Document object.")

Product.__swig_getmethods__["unitsManager"] = Product._get_unitsManager
Product.unitsManager = property(Product._get_unitsManager, doc="Returns the UnitsManager object associated with this product.")

Product.__swig_getmethods__["workspaces"] = Product._get_workspaces
Product.workspaces = property(Product._get_workspaces, doc="Returns the workspaces associated with this product.")

Product.__swig_getmethods__["productType"] = Product._get_productType
Product.productType = property(Product._get_productType, doc="Returns the product type name of this product. A list of all of\nthe possible product types can be obtained by using the\nApplication.supportedProductTypes property.")

Product.__swig_getmethods__["attributes"] = Product._get_attributes
Product.attributes = property(Product._get_attributes, doc="Returns the collection of attributes associated with this product.")

Product.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Product) else None
Product.cast = lambda arg: arg if isinstance(arg, Product) else None

class ProductPreferences(Base):
    """
    The base class for the general product preferences. There is a derived class
    for each product where the specific preference values are exposed.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProductPreferences, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ProductPreferences, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ProductPreferences *" : return _core.ProductPreferences___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ProductPreferences___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ProductPreferences___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ProductPreferences_classType
    if _newclass:classType = staticmethod(_core.ProductPreferences_classType)
    __swig_destroy__ = _core.delete_ProductPreferences
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Returns the name of this ProductPreferences object."""
        return _core.ProductPreferences__get_name(self)

    def _get_objectType(self) -> "char const *" : return _core.ProductPreferences__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ProductPreferences__get_isValid(self)
ProductPreferences_swigregister = _core.ProductPreferences_swigregister
ProductPreferences_swigregister(ProductPreferences)

def ProductPreferences_classType() -> "char const *" :
  return _core.ProductPreferences_classType()
ProductPreferences_classType = _core.ProductPreferences_classType

ProductPreferences.__swig_getmethods__["name"] = ProductPreferences._get_name
ProductPreferences.name = property(ProductPreferences._get_name, doc="Returns the name of this ProductPreferences object.")

ProductPreferences.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ProductPreferences) else None
ProductPreferences.cast = lambda arg: arg if isinstance(arg, ProductPreferences) else None

class ProductPreferencesCollection(Base):
    """A collection that provides access to product specific preference objects."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProductPreferencesCollection, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ProductPreferencesCollection, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ProductPreferencesCollection *" : return _core.ProductPreferencesCollection___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ProductPreferencesCollection___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ProductPreferencesCollection___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.ProductPreferencesCollection___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::ProductPreferences >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.ProductPreferencesCollection___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ProductPreferencesCollection_classType
    if _newclass:classType = staticmethod(_core.ProductPreferencesCollection_classType)
    __swig_destroy__ = _core.delete_ProductPreferencesCollection
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::ProductPreferences >" :
        """
        Function that returns the specified ProfductPreferences object using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.ProductPreferencesCollection_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::core::ProductPreferences >" :
        """
        Returns the ProductPreference object with the specified name. 
        name : The name of the ProductPreferences to return. 
        Returns the ProductPreferences object or null if if an invalid name was specified.
        """
        return _core.ProductPreferencesCollection_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of ProductPreference objects."""
        return _core.ProductPreferencesCollection__get_count(self)

    def _get_objectType(self) -> "char const *" : return _core.ProductPreferencesCollection__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ProductPreferencesCollection__get_isValid(self)
ProductPreferencesCollection_swigregister = _core.ProductPreferencesCollection_swigregister
ProductPreferencesCollection_swigregister(ProductPreferencesCollection)

def ProductPreferencesCollection_classType() -> "char const *" :
  return _core.ProductPreferencesCollection_classType()
ProductPreferencesCollection_classType = _core.ProductPreferencesCollection_classType

ProductPreferencesCollection.__swig_getmethods__["count"] = ProductPreferencesCollection._get_count
ProductPreferencesCollection.count = property(ProductPreferencesCollection._get_count, doc="Returns the number of ProductPreference objects.")

ProductPreferencesCollection.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ProductPreferencesCollection) else None
ProductPreferencesCollection.cast = lambda arg: arg if isinstance(arg, ProductPreferencesCollection) else None

class Products(Base):
    """The Products object provides access to all of the products that exist in the document."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Products, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Products, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Products *" : return _core.Products___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Products___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Products___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.Products___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::Product >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.Products___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Products_classType
    if _newclass:classType = staticmethod(_core.Products_classType)
    __swig_destroy__ = _core.delete_Products
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::Product >" :
        """
        Function that returns the specified product using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.Products_item(self, *args)

    def itemByProductType(self, *args) -> "adsk::core::Ptr< adsk::core::Product >" :
        """
        Returns the specified product, if it exists within this document. 
        productType : The product type string. For example, to get the product that represents the design data
        you use 'DesignProductType' or to get the product that represent the CAM data you use 'CAMProductType'.
        A complete list of available products can be obtained by using the Application.supportedProductTypes property. 
        Returns the specified item or null if the specified productType does not exist within this document.
        """
        return _core.Products_itemByProductType(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of products within the collection."""
        return _core.Products__get_count(self)

    def _get_objectType(self) -> "char const *" : return _core.Products__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Products__get_isValid(self)
Products_swigregister = _core.Products_swigregister
Products_swigregister(Products)

def Products_classType() -> "char const *" :
  return _core.Products_classType()
Products_classType = _core.Products_classType

Products.__swig_getmethods__["count"] = Products._get_count
Products.count = property(Products._get_count, doc="Returns the number of products within the collection.")

Products.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Products) else None
Products.cast = lambda arg: arg if isinstance(arg, Products) else None

class ProductUsageData(Base):
    """Provides access to the product usage data settings."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProductUsageData, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ProductUsageData, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ProductUsageData *" : return _core.ProductUsageData___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ProductUsageData___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ProductUsageData___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ProductUsageData_classType
    if _newclass:classType = staticmethod(_core.ProductUsageData_classType)
    __swig_destroy__ = _core.delete_ProductUsageData
    __del__ = lambda self : None;
    def _get_isTrackingToImproveSoftwareEnabled(self) -> "bool" :
        """Gets and sets if tracking to improve the software is enabled."""
        return _core.ProductUsageData__get_isTrackingToImproveSoftwareEnabled(self)

    def _set_isTrackingToImproveSoftwareEnabled(self, *args) -> "bool" :
        """Gets and sets if tracking to improve the software is enabled."""
        return _core.ProductUsageData__set_isTrackingToImproveSoftwareEnabled(self, *args)

    def _get_isTrackingToImproveCommunicationEnabled(self) -> "bool" :
        """Gets and sets if tracking to improve communication is enabled."""
        return _core.ProductUsageData__get_isTrackingToImproveCommunicationEnabled(self)

    def _set_isTrackingToImproveCommunicationEnabled(self, *args) -> "bool" :
        """Gets and sets if tracking to improve communication is enabled."""
        return _core.ProductUsageData__set_isTrackingToImproveCommunicationEnabled(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.ProductUsageData__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ProductUsageData__get_isValid(self)
ProductUsageData_swigregister = _core.ProductUsageData_swigregister
ProductUsageData_swigregister(ProductUsageData)

def ProductUsageData_classType() -> "char const *" :
  return _core.ProductUsageData_classType()
ProductUsageData_classType = _core.ProductUsageData_classType

ProductUsageData.__swig_getmethods__["isTrackingToImproveSoftwareEnabled"] = ProductUsageData._get_isTrackingToImproveSoftwareEnabled
ProductUsageData.__swig_setmethods__["isTrackingToImproveSoftwareEnabled"] = ProductUsageData._set_isTrackingToImproveSoftwareEnabled
ProductUsageData.isTrackingToImproveSoftwareEnabled = property(ProductUsageData._get_isTrackingToImproveSoftwareEnabled, ProductUsageData._set_isTrackingToImproveSoftwareEnabled, doc="Gets and sets if tracking to improve the software is enabled.")

ProductUsageData.__swig_getmethods__["isTrackingToImproveCommunicationEnabled"] = ProductUsageData._get_isTrackingToImproveCommunicationEnabled
ProductUsageData.__swig_setmethods__["isTrackingToImproveCommunicationEnabled"] = ProductUsageData._set_isTrackingToImproveCommunicationEnabled
ProductUsageData.isTrackingToImproveCommunicationEnabled = property(ProductUsageData._get_isTrackingToImproveCommunicationEnabled, ProductUsageData._set_isTrackingToImproveCommunicationEnabled, doc="Gets and sets if tracking to improve communication is enabled.")

ProductUsageData.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ProductUsageData) else None
ProductUsageData.cast = lambda arg: arg if isinstance(arg, ProductUsageData) else None

class ProgressDialog(Base):
    """Provides access to the progress dialog."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProgressDialog, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ProgressDialog, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ProgressDialog *" : return _core.ProgressDialog___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ProgressDialog___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ProgressDialog___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ProgressDialog_classType
    if _newclass:classType = staticmethod(_core.ProgressDialog_classType)
    __swig_destroy__ = _core.delete_ProgressDialog
    __del__ = lambda self : None;
    def show(self, *args) -> "bool" :
        """
        Displays the progress dialog that includes a progress bar that can be used to display a continually updated 
        message indicating the progress of a process that will take more than a few seconds. 
        The progress is determined by comparing the current progress value with the minimum and maximum values. 
        title : Sets the title for the progress dialog 
        message : The message to display along with the progress bar. The following symbols can be used
        to display values. '%p' is replaced by the percentage completed. '%v' is replaced
        by the current value. %m is replaced by the total number of steps. For example, the
        message 'Processing section %v of %m.' will result in the message 'Processing section
        1 of 10.' to be displayed if the maximum value is 10 and the current value is 1. 
        minimumValue : The minimum value of the progress bar. This is used along with the maximum value and the 
        progress value to compute the current percentage complete. This is also the initial 
        progress value when the progress bar is first displayed. 
        maximumValue : The maximum value of the progress bar. This is used along with the minimum value and the 
        progress value to compute the current percentage complete. 
        delay : Specifies the time interval in seconds to delay displaying the Progress Dialog. This provides a way to hide 
        the progress dialog before it actually gets displayed, which is useful for cases where the progress of the 
        operation being tracked completes quickly and there is no need to indicate progress to the user. 
        Returns true if successful.
        """
        return _core.ProgressDialog_show(self, *args)

    def hide(self) -> "bool" :
        """
        Hides the progress dialog. This should be used when the process has completed. 
        Returns true if successful.
        """
        return _core.ProgressDialog_hide(self)

    def _get_title(self) -> "std::string" :
        """Gets and sets the title of the progress dialog"""
        return _core.ProgressDialog__get_title(self)

    def _set_title(self, *args) -> "bool" :
        """Gets and sets the title of the progress dialog"""
        return _core.ProgressDialog__set_title(self, *args)

    def _get_message(self) -> "std::string" :
        """
        Gets and sets the message to display along with the progress bar. The following symbols can be used
        to display values. '%p' is replaced by the percentage completed. '%v' is replaced
        by the current value. %m is replaced by the total number of steps. For example, the
        message 'Processing section %v of %m.' will result in the message 'Processing section
        1 of 10.' to be displayed if the maximum value is 10 and the current value is 1.
        Specify an empty string ('') for no message to appear along with the progress panel.
        """
        return _core.ProgressDialog__get_message(self)

    def _set_message(self, *args) -> "bool" :
        """
        Gets and sets the message to display along with the progress bar. The following symbols can be used
        to display values. '%p' is replaced by the percentage completed. '%v' is replaced
        by the current value. %m is replaced by the total number of steps. For example, the
        message 'Processing section %v of %m.' will result in the message 'Processing section
        1 of 10.' to be displayed if the maximum value is 10 and the current value is 1.
        Specify an empty string ('') for no message to appear along with the progress panel.
        """
        return _core.ProgressDialog__set_message(self, *args)

    def _get_minimumValue(self) -> "int" :
        """
        The minimum value of the progress bar. This is used along with the maximum value and the 
        progress value to compute the current percentage complete. This is also the initial 
        progress value when the progress bar is first displayed.
        """
        return _core.ProgressDialog__get_minimumValue(self)

    def _set_minimumValue(self, *args) -> "bool" :
        """
        The minimum value of the progress bar. This is used along with the maximum value and the 
        progress value to compute the current percentage complete. This is also the initial 
        progress value when the progress bar is first displayed.
        """
        return _core.ProgressDialog__set_minimumValue(self, *args)

    def _get_maximumValue(self) -> "int" :
        """
        The maximum value of the progress bar. This is used along with the minimum value and the 
        progress value to compute the current percentage complete.
        """
        return _core.ProgressDialog__get_maximumValue(self)

    def _set_maximumValue(self, *args) -> "bool" :
        """
        The maximum value of the progress bar. This is used along with the minimum value and the 
        progress value to compute the current percentage complete.
        """
        return _core.ProgressDialog__set_maximumValue(self, *args)

    def _get_progressValue(self) -> "int" :
        """
        Gets and sets the current progress bar value. Progress is determined based on this value relative to
        the minimum and maximum values. This will update the values displayed
        in the message string.
        """
        return _core.ProgressDialog__get_progressValue(self)

    def _set_progressValue(self, *args) -> "bool" :
        """
        Gets and sets the current progress bar value. Progress is determined based on this value relative to
        the minimum and maximum values. This will update the values displayed
        in the message string.
        """
        return _core.ProgressDialog__set_progressValue(self, *args)

    def _get_isCancelButtonShown(self) -> "bool" :
        """Gets and sets if the cancel button is included in the dialog. This is false by default."""
        return _core.ProgressDialog__get_isCancelButtonShown(self)

    def _set_isCancelButtonShown(self, *args) -> "bool" :
        """Gets and sets if the cancel button is included in the dialog. This is false by default."""
        return _core.ProgressDialog__set_isCancelButtonShown(self, *args)

    def _get_wasCancelled(self) -> "bool" :
        """Indicates if the cancel button was selected the last time the Progress Dialog was shown."""
        return _core.ProgressDialog__get_wasCancelled(self)

    def _get_cancelButtonText(self) -> "std::string" :
        """Sets the text label on the Cancel button. The default text label is 'Cancel'."""
        return _core.ProgressDialog__get_cancelButtonText(self)

    def _set_cancelButtonText(self, *args) -> "bool" :
        """Sets the text label on the Cancel button. The default text label is 'Cancel'."""
        return _core.ProgressDialog__set_cancelButtonText(self, *args)

    def _get_isBackgroundTranslucent(self) -> "bool" :
        """Gets and sets if the dialog background is translucent. This is false by default"""
        return _core.ProgressDialog__get_isBackgroundTranslucent(self)

    def _set_isBackgroundTranslucent(self, *args) -> "bool" :
        """Gets and sets if the dialog background is translucent. This is false by default"""
        return _core.ProgressDialog__set_isBackgroundTranslucent(self, *args)

    def _get_isShowing(self) -> "bool" :
        """Gets if the Progress Dialog is currently being displayed"""
        return _core.ProgressDialog__get_isShowing(self)

    def reset(self) -> "bool" :
        """
        Method that resets the progress bar. The progress bar 'rewinds' and shows no progress.
        This is the same as setting the progress value to the minimum value. 
        Returns true if successful
        """
        return _core.ProgressDialog_reset(self)

    def _get_objectType(self) -> "char const *" : return _core.ProgressDialog__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ProgressDialog__get_isValid(self)
ProgressDialog_swigregister = _core.ProgressDialog_swigregister
ProgressDialog_swigregister(ProgressDialog)

def ProgressDialog_classType() -> "char const *" :
  return _core.ProgressDialog_classType()
ProgressDialog_classType = _core.ProgressDialog_classType

ProgressDialog.__swig_getmethods__["title"] = ProgressDialog._get_title
ProgressDialog.__swig_setmethods__["title"] = ProgressDialog._set_title
ProgressDialog.title = property(ProgressDialog._get_title, ProgressDialog._set_title, doc="Gets and sets the title of the progress dialog")

ProgressDialog.__swig_getmethods__["message"] = ProgressDialog._get_message
ProgressDialog.__swig_setmethods__["message"] = ProgressDialog._set_message
ProgressDialog.message = property(ProgressDialog._get_message, ProgressDialog._set_message, doc="Gets and sets the message to display along with the progress bar. The following symbols can be used\nto display values. '%p' is replaced by the percentage completed. '%v' is replaced\nby the current value. %m is replaced by the total number of steps. For example, the\nmessage 'Processing section %v of %m.' will result in the message 'Processing section\n1 of 10.' to be displayed if the maximum value is 10 and the current value is 1.\nSpecify an empty string ('') for no message to appear along with the progress panel.")

ProgressDialog.__swig_getmethods__["minimumValue"] = ProgressDialog._get_minimumValue
ProgressDialog.__swig_setmethods__["minimumValue"] = ProgressDialog._set_minimumValue
ProgressDialog.minimumValue = property(ProgressDialog._get_minimumValue, ProgressDialog._set_minimumValue, doc="The minimum value of the progress bar. This is used along with the maximum value and the\nprogress value to compute the current percentage complete. This is also the initial\nprogress value when the progress bar is first displayed.")

ProgressDialog.__swig_getmethods__["maximumValue"] = ProgressDialog._get_maximumValue
ProgressDialog.__swig_setmethods__["maximumValue"] = ProgressDialog._set_maximumValue
ProgressDialog.maximumValue = property(ProgressDialog._get_maximumValue, ProgressDialog._set_maximumValue, doc="The maximum value of the progress bar. This is used along with the minimum value and the\nprogress value to compute the current percentage complete.")

ProgressDialog.__swig_getmethods__["progressValue"] = ProgressDialog._get_progressValue
ProgressDialog.__swig_setmethods__["progressValue"] = ProgressDialog._set_progressValue
ProgressDialog.progressValue = property(ProgressDialog._get_progressValue, ProgressDialog._set_progressValue, doc="Gets and sets the current progress bar value. Progress is determined based on this value relative to\nthe minimum and maximum values. This will update the values displayed\nin the message string.")

ProgressDialog.__swig_getmethods__["isCancelButtonShown"] = ProgressDialog._get_isCancelButtonShown
ProgressDialog.__swig_setmethods__["isCancelButtonShown"] = ProgressDialog._set_isCancelButtonShown
ProgressDialog.isCancelButtonShown = property(ProgressDialog._get_isCancelButtonShown, ProgressDialog._set_isCancelButtonShown, doc="Gets and sets if the cancel button is included in the dialog. This is false by default.")

ProgressDialog.__swig_getmethods__["wasCancelled"] = ProgressDialog._get_wasCancelled
ProgressDialog.wasCancelled = property(ProgressDialog._get_wasCancelled, doc="Indicates if the cancel button was selected the last time the Progress Dialog was shown.")

ProgressDialog.__swig_getmethods__["cancelButtonText"] = ProgressDialog._get_cancelButtonText
ProgressDialog.__swig_setmethods__["cancelButtonText"] = ProgressDialog._set_cancelButtonText
ProgressDialog.cancelButtonText = property(ProgressDialog._get_cancelButtonText, ProgressDialog._set_cancelButtonText, doc="Sets the text label on the Cancel button. The default text label is 'Cancel'.")

ProgressDialog.__swig_getmethods__["isBackgroundTranslucent"] = ProgressDialog._get_isBackgroundTranslucent
ProgressDialog.__swig_setmethods__["isBackgroundTranslucent"] = ProgressDialog._set_isBackgroundTranslucent
ProgressDialog.isBackgroundTranslucent = property(ProgressDialog._get_isBackgroundTranslucent, ProgressDialog._set_isBackgroundTranslucent, doc="Gets and sets if the dialog background is translucent. This is false by default")

ProgressDialog.__swig_getmethods__["isShowing"] = ProgressDialog._get_isShowing
ProgressDialog.isShowing = property(ProgressDialog._get_isShowing, doc="Gets if the Progress Dialog is currently being displayed")

ProgressDialog.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ProgressDialog) else None
ProgressDialog.cast = lambda arg: arg if isinstance(arg, ProgressDialog) else None

class Properties(Base):
    """A collection of properties that are associated with a material or appearance."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Properties, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Properties, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Properties *" : return _core.Properties___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Properties___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Properties___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.Properties___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::Property >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.Properties___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Properties_classType
    if _newclass:classType = staticmethod(_core.Properties_classType)
    __swig_destroy__ = _core.delete_Properties
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::Property >" :
        """
        Returns the specified property from the collection using an index into the collection. 
        index : The index of the property within the collection where the first item is 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.Properties_item(self, *args)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::Property >" :
        """
        Returns the specified property from the collection using the unique ID of the property. 
        id : The unique ID of the property. 
        Returns the specified property or null if the ID doesn't match a property within the collection.
        """
        return _core.Properties_itemById(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::core::Property >" :
        """
        Returns the specified Property using the name of the property. 
        name : The name of the property to return. This is the name as seen in the user interface. 
        Returns the specified property or null if the name doesn't match a property within the collection.
        """
        return _core.Properties_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of properties within the collection."""
        return _core.Properties__get_count(self)

    def _get_objectType(self) -> "char const *" : return _core.Properties__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Properties__get_isValid(self)
Properties_swigregister = _core.Properties_swigregister
Properties_swigregister(Properties)

def Properties_classType() -> "char const *" :
  return _core.Properties_classType()
Properties_classType = _core.Properties_classType

Properties.__swig_getmethods__["count"] = Properties._get_count
Properties.count = property(Properties._get_count, doc="Returns the number of properties within the collection.")

Properties.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Properties) else None
Properties.cast = lambda arg: arg if isinstance(arg, Properties) else None

class Property(Base):
    """The base class for the specific property types used by materials and appearances."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Property, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Property, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Property *" : return _core.Property___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Property___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Property___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Property_classType
    if _newclass:classType = staticmethod(_core.Property_classType)
    __swig_destroy__ = _core.delete_Property
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """
        Returns the name of this property as seen in the user interface. This name is localized
        and can change based on the current language
        """
        return _core.Property__get_name(self)

    def _get_isReadOnly(self) -> "bool" :
        """Indicates if this property is read-only. If True any attempted edits will fail."""
        return _core.Property__get_isReadOnly(self)

    def _get_id(self) -> "std::string" :
        """Returns the unique ID of this property."""
        return _core.Property__get_id(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the parent of this property."""
        return _core.Property__get_parent(self)

    def _get_objectType(self) -> "char const *" : return _core.Property__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Property__get_isValid(self)
Property_swigregister = _core.Property_swigregister
Property_swigregister(Property)

def Property_classType() -> "char const *" :
  return _core.Property_classType()
Property_classType = _core.Property_classType

Property.__swig_getmethods__["name"] = Property._get_name
Property.name = property(Property._get_name, doc="Returns the name of this property as seen in the user interface. This name is localized\nand can change based on the current language")

Property.__swig_getmethods__["isReadOnly"] = Property._get_isReadOnly
Property.isReadOnly = property(Property._get_isReadOnly, doc="Indicates if this property is read-only. If True any attempted edits will fail.")

Property.__swig_getmethods__["id"] = Property._get_id
Property.id = property(Property._get_id, doc="Returns the unique ID of this property.")

Property.__swig_getmethods__["parent"] = Property._get_parent
Property.parent = property(Property._get_parent, doc="Returns the parent of this property.")

Property.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Property) else None
Property.cast = lambda arg: arg if isinstance(arg, Property) else None

class RadialMarkingMenu(Base):
    """
    Represents the marking menu which is the round menu that's displayed when the user right-clicks
    within Fusion 360. This supports customizing the contents of the marking menu.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadialMarkingMenu, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RadialMarkingMenu, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::RadialMarkingMenu *" : return _core.RadialMarkingMenu___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.RadialMarkingMenu___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.RadialMarkingMenu___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.RadialMarkingMenu_classType
    if _newclass:classType = staticmethod(_core.RadialMarkingMenu_classType)
    __swig_destroy__ = _core.delete_RadialMarkingMenu
    __del__ = lambda self : None;
    def create(self, *args) -> "adsk::core::Ptr< adsk::core::RadialMarkingMenu >" :
        """
        This is used to create a sub-menu in a marking menu. This method creates a new, 
        empty marking menu which can then be assigned to a position in the displayed
        marking menu to define the sub-menu. 
        text : The text that will be displayed in the parent menu to access this menu. 
        Returns the newly created marking menu or null in the case of a failure.
        """
        return _core.RadialMarkingMenu_create(self, *args)

    def _get_text(self) -> "std::string" :
        """
        Gets and sets the text that is displayed in the parent marking menu to access a 
        sub marking menu. This property is not used for the main marking menu and will
        return an empty string and setting it will have no effect.
        """
        return _core.RadialMarkingMenu__get_text(self)

    def _set_text(self, *args) -> "bool" :
        """
        Gets and sets the text that is displayed in the parent marking menu to access a 
        sub marking menu. This property is not used for the main marking menu and will
        return an empty string and setting it will have no effect.
        """
        return _core.RadialMarkingMenu__set_text(self, *args)

    def clear(self) -> "bool" :
        """
        Completely clears the contents of the marking menu. If left in this state, the
        marking menu will not be displayed. 
        Returns true if the clear was successful.
        """
        return _core.RadialMarkingMenu_clear(self)

    def _get_eastCommand(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the command definition that's displayed in the East position (right) of
        the marking menu. Setting this to null indicates that the East position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__get_eastCommand(self)

    def _set_eastCommand(self, *args) -> "bool" :
        """
        Gets and sets the command definition that's displayed in the East position (right) of
        the marking menu. Setting this to null indicates that the East position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__set_eastCommand(self, *args)

    def _get_northCommand(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the command definition that's displayed in the North position (top) of the
        marking menu. Setting this to null indicates that the North position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__get_northCommand(self)

    def _set_northCommand(self, *args) -> "bool" :
        """
        Gets and sets the command definition that's displayed in the North position (top) of the
        marking menu. Setting this to null indicates that the North position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__set_northCommand(self, *args)

    def _get_northeastCommand(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the command definition that's displayed in the Northeast position (top-right) of
        the marking menu. Setting this to null indicates that the Northeast position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__get_northeastCommand(self)

    def _set_northeastCommand(self, *args) -> "bool" :
        """
        Gets and sets the command definition that's displayed in the Northeast position (top-right) of
        the marking menu. Setting this to null indicates that the Northeast position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__set_northeastCommand(self, *args)

    def _get_westCommand(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the command definition that's displayed in the West position (left) of 
        the marking menu. Setting this to null indicates that the West position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__get_westCommand(self)

    def _set_westCommand(self, *args) -> "bool" :
        """
        Gets and sets the command definition that's displayed in the West position (left) of 
        the marking menu. Setting this to null indicates that the West position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__set_westCommand(self, *args)

    def _get_northwestCommand(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the command definition that's displayed in the Northwest position (upper-left) of
        the marking menu. Setting this to null indicates that the Northwest position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__get_northwestCommand(self)

    def _set_northwestCommand(self, *args) -> "bool" :
        """
        Gets and sets the command definition that's displayed in the Northwest position (upper-left) of
        the marking menu. Setting this to null indicates that the Northwest position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__set_northwestCommand(self, *args)

    def _get_southwestCommand(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the command definition that's displayed in the Southwest position (bottom-left) of
        the marking menu. Setting this to null indicates that the Southwest position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__get_southwestCommand(self)

    def _set_southwestCommand(self, *args) -> "bool" :
        """
        Gets and sets the command definition that's displayed in the Southwest position (bottom-left) of
        the marking menu. Setting this to null indicates that the Southwest position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__set_southwestCommand(self, *args)

    def _get_southCommand(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the command definition that's displayed in the South position (bottom) of
        the marking menu. Setting this to null indicates that the South position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__get_southCommand(self)

    def _set_southCommand(self, *args) -> "bool" :
        """
        Gets and sets the command definition that's displayed in the South position (bottom) of
        the marking menu. Setting this to null indicates that the South position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__set_southCommand(self, *args)

    def _get_southeastCommand(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the command definition that's displayed in the Southeast position (bottom-right) of
        the marking menu. Setting this to null indicates that the Southeast position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__get_southeastCommand(self)

    def _set_southeastCommand(self, *args) -> "bool" :
        """
        Gets and sets the command definition that's displayed in the Southeast position (bottom-right) of
        the marking menu. Setting this to null indicates that the Southeast position should be empty.
        This can also return or be set with a MarkingMenu object which is used to have a sub-menu. 
        New marking menus can be created using the create method and then assigned
        to the desired position in the marking menu.
        """
        return _core.RadialMarkingMenu__set_southeastCommand(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.RadialMarkingMenu__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.RadialMarkingMenu__get_isValid(self)
RadialMarkingMenu_swigregister = _core.RadialMarkingMenu_swigregister
RadialMarkingMenu_swigregister(RadialMarkingMenu)

def RadialMarkingMenu_classType() -> "char const *" :
  return _core.RadialMarkingMenu_classType()
RadialMarkingMenu_classType = _core.RadialMarkingMenu_classType

RadialMarkingMenu.__swig_getmethods__["text"] = RadialMarkingMenu._get_text
RadialMarkingMenu.__swig_setmethods__["text"] = RadialMarkingMenu._set_text
RadialMarkingMenu.text = property(RadialMarkingMenu._get_text, RadialMarkingMenu._set_text, doc="Gets and sets the text that is displayed in the parent marking menu to access a\nsub marking menu. This property is not used for the main marking menu and will\nreturn an empty string and setting it will have no effect.")

RadialMarkingMenu.__swig_getmethods__["eastCommand"] = RadialMarkingMenu._get_eastCommand
RadialMarkingMenu.__swig_setmethods__["eastCommand"] = RadialMarkingMenu._set_eastCommand
RadialMarkingMenu.eastCommand = property(RadialMarkingMenu._get_eastCommand, RadialMarkingMenu._set_eastCommand, doc="Gets and sets the command definition that's displayed in the East position (right) of\nthe marking menu. Setting this to null indicates that the East position should be empty.\nThis can also return or be set with a MarkingMenu object which is used to have a sub-menu.\nNew marking menus can be created using the create method and then assigned\nto the desired position in the marking menu.")

RadialMarkingMenu.__swig_getmethods__["northCommand"] = RadialMarkingMenu._get_northCommand
RadialMarkingMenu.__swig_setmethods__["northCommand"] = RadialMarkingMenu._set_northCommand
RadialMarkingMenu.northCommand = property(RadialMarkingMenu._get_northCommand, RadialMarkingMenu._set_northCommand, doc="Gets and sets the command definition that's displayed in the North position (top) of the\nmarking menu. Setting this to null indicates that the North position should be empty.\nThis can also return or be set with a MarkingMenu object which is used to have a sub-menu.\nNew marking menus can be created using the create method and then assigned\nto the desired position in the marking menu.")

RadialMarkingMenu.__swig_getmethods__["northeastCommand"] = RadialMarkingMenu._get_northeastCommand
RadialMarkingMenu.__swig_setmethods__["northeastCommand"] = RadialMarkingMenu._set_northeastCommand
RadialMarkingMenu.northeastCommand = property(RadialMarkingMenu._get_northeastCommand, RadialMarkingMenu._set_northeastCommand, doc="Gets and sets the command definition that's displayed in the Northeast position (top-right) of\nthe marking menu. Setting this to null indicates that the Northeast position should be empty.\nThis can also return or be set with a MarkingMenu object which is used to have a sub-menu.\nNew marking menus can be created using the create method and then assigned\nto the desired position in the marking menu.")

RadialMarkingMenu.__swig_getmethods__["westCommand"] = RadialMarkingMenu._get_westCommand
RadialMarkingMenu.__swig_setmethods__["westCommand"] = RadialMarkingMenu._set_westCommand
RadialMarkingMenu.westCommand = property(RadialMarkingMenu._get_westCommand, RadialMarkingMenu._set_westCommand, doc="Gets and sets the command definition that's displayed in the West position (left) of\nthe marking menu. Setting this to null indicates that the West position should be empty.\nThis can also return or be set with a MarkingMenu object which is used to have a sub-menu.\nNew marking menus can be created using the create method and then assigned\nto the desired position in the marking menu.")

RadialMarkingMenu.__swig_getmethods__["northwestCommand"] = RadialMarkingMenu._get_northwestCommand
RadialMarkingMenu.__swig_setmethods__["northwestCommand"] = RadialMarkingMenu._set_northwestCommand
RadialMarkingMenu.northwestCommand = property(RadialMarkingMenu._get_northwestCommand, RadialMarkingMenu._set_northwestCommand, doc="Gets and sets the command definition that's displayed in the Northwest position (upper-left) of\nthe marking menu. Setting this to null indicates that the Northwest position should be empty.\nThis can also return or be set with a MarkingMenu object which is used to have a sub-menu.\nNew marking menus can be created using the create method and then assigned\nto the desired position in the marking menu.")

RadialMarkingMenu.__swig_getmethods__["southwestCommand"] = RadialMarkingMenu._get_southwestCommand
RadialMarkingMenu.__swig_setmethods__["southwestCommand"] = RadialMarkingMenu._set_southwestCommand
RadialMarkingMenu.southwestCommand = property(RadialMarkingMenu._get_southwestCommand, RadialMarkingMenu._set_southwestCommand, doc="Gets and sets the command definition that's displayed in the Southwest position (bottom-left) of\nthe marking menu. Setting this to null indicates that the Southwest position should be empty.\nThis can also return or be set with a MarkingMenu object which is used to have a sub-menu.\nNew marking menus can be created using the create method and then assigned\nto the desired position in the marking menu.")

RadialMarkingMenu.__swig_getmethods__["southCommand"] = RadialMarkingMenu._get_southCommand
RadialMarkingMenu.__swig_setmethods__["southCommand"] = RadialMarkingMenu._set_southCommand
RadialMarkingMenu.southCommand = property(RadialMarkingMenu._get_southCommand, RadialMarkingMenu._set_southCommand, doc="Gets and sets the command definition that's displayed in the South position (bottom) of\nthe marking menu. Setting this to null indicates that the South position should be empty.\nThis can also return or be set with a MarkingMenu object which is used to have a sub-menu.\nNew marking menus can be created using the create method and then assigned\nto the desired position in the marking menu.")

RadialMarkingMenu.__swig_getmethods__["southeastCommand"] = RadialMarkingMenu._get_southeastCommand
RadialMarkingMenu.__swig_setmethods__["southeastCommand"] = RadialMarkingMenu._set_southeastCommand
RadialMarkingMenu.southeastCommand = property(RadialMarkingMenu._get_southeastCommand, RadialMarkingMenu._set_southeastCommand, doc="Gets and sets the command definition that's displayed in the Southeast position (bottom-right) of\nthe marking menu. Setting this to null indicates that the Southeast position should be empty.\nThis can also return or be set with a MarkingMenu object which is used to have a sub-menu.\nNew marking menus can be created using the create method and then assigned\nto the desired position in the marking menu.")

RadialMarkingMenu.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RadialMarkingMenu) else None
RadialMarkingMenu.cast = lambda arg: arg if isinstance(arg, RadialMarkingMenu) else None

class Selection(Base):
    """Provides access to a selection of an entity in the user interface."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Selection, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Selection, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Selection *" : return _core.Selection___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Selection___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Selection___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Selection_classType
    if _newclass:classType = staticmethod(_core.Selection_classType)
    __swig_destroy__ = _core.delete_Selection
    __del__ = lambda self : None;
    def _get_entity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets the selected entity."""
        return _core.Selection__get_entity(self)

    def _get_point(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets the selection point on the object."""
        return _core.Selection__get_point(self)

    def _get_objectType(self) -> "char const *" : return _core.Selection__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Selection__get_isValid(self)
Selection_swigregister = _core.Selection_swigregister
Selection_swigregister(Selection)

def Selection_classType() -> "char const *" :
  return _core.Selection_classType()
Selection_classType = _core.Selection_classType

Selection.__swig_getmethods__["entity"] = Selection._get_entity
Selection.entity = property(Selection._get_entity, doc="Gets the selected entity.")

Selection.__swig_getmethods__["point"] = Selection._get_point
Selection.point = property(Selection._get_point, doc="Gets the selection point on the object.")

Selection.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Selection) else None
Selection.cast = lambda arg: arg if isinstance(arg, Selection) else None

class SelectionEventHandler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SelectionEventHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SelectionEventHandler, name)
    __repr__ = _swig_repr
    def notify(self, *args) -> "void" : return _core.SelectionEventHandler_notify(self, *args)
    def __init__(self): 
        if self.__class__ == SelectionEventHandler:
            _self = None
        else:
            _self = self
        this = _core.new_SelectionEventHandler(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_SelectionEventHandler
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _core.disown_SelectionEventHandler(self)
        return weakref_proxy(self)
SelectionEventHandler_swigregister = _core.SelectionEventHandler_swigregister
SelectionEventHandler_swigregister(SelectionEventHandler)

SelectionEventHandler.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SelectionEventHandler) else None
SelectionEventHandler.cast = lambda arg: arg if isinstance(arg, SelectionEventHandler) else None

class Selections(Base):
    """Provides access to and control over the set of selected entities in the user interface."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Selections, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Selections, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Selections *" : return _core.Selections___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Selections___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Selections___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.Selections___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::Selection >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.Selections___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Selections_classType
    if _newclass:classType = staticmethod(_core.Selections_classType)
    __swig_destroy__ = _core.delete_Selections
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::Selection >" :
        """
        Returns the specified selection using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.Selections_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Gets the number of entities currently selected."""
        return _core.Selections__get_count(self)

    def _get_all(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """Gets or sets all entities currently selected."""
        return _core.Selections__get_all(self)

    def _set_all(self, *args) -> "bool" :
        """Gets or sets all entities currently selected."""
        return _core.Selections__set_all(self, *args)

    def add(self, *args) -> "bool" :
        """
        Adds the entity to the set of currently selected entities.
        The user will see the entity become selected in the user interface. 
        entity : The entity to select and add to this selection set. 
        Returns true if successful.
        """
        return _core.Selections_add(self, *args)

    def clear(self) -> "bool" :
        """
        Clears the selection set so no entities are currently selected. 
        Returns true if successful.
        """
        return _core.Selections_clear(self)

    def removeBySelection(self, *args) -> "bool" :
        """
        Removes the specified selection from the set of selected entities. 
        selection : The selection to remove. 
        Returns true if the item was removed or not currently selected.
        """
        return _core.Selections_removeBySelection(self, *args)

    def removeByEntity(self, *args) -> "bool" :
        """
        Removes the selections that are associated with the specified entity from the set of selected entities. 
        entity : The entity to remove selections of. 
        Returns true if the item was removed or not currently selected.
        """
        return _core.Selections_removeByEntity(self, *args)

    def removeByIndex(self, *args) -> "bool" :
        """
        Removes an item from the set of selected entities. 
        index : The index of the selection to remove. 
        Returns true if the item was removed successfully.
        """
        return _core.Selections_removeByIndex(self, *args)

    def asArray(self) -> "std::vector< adsk::core::Ptr< adsk::core::Selection >,std::allocator< adsk::core::Ptr< adsk::core::Selection > > >" :
        """
        Returns an array containing all of the current selections. This is
        useful in cases where you need to iterate over the set of selected entities but need
        to create or edit data as you process each one. Selections are fragile and creation and
        edit operations will clear the selections so you won't have access to the complete list 
        after processing the first one. 
        Returns an array of all of the current selections. Selection objects are returned so
        you'll need to call their entity properties to get the actual selected entity.
        """
        return _core.Selections_asArray(self)

    def _get_objectType(self) -> "char const *" : return _core.Selections__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Selections__get_isValid(self)
Selections_swigregister = _core.Selections_swigregister
Selections_swigregister(Selections)

def Selections_classType() -> "char const *" :
  return _core.Selections_classType()
Selections_classType = _core.Selections_classType

Selections.__swig_getmethods__["count"] = Selections._get_count
Selections.count = property(Selections._get_count, doc="Gets the number of entities currently selected.")

Selections.__swig_getmethods__["all"] = Selections._get_all
Selections.__swig_setmethods__["all"] = Selections._set_all
Selections.all = property(Selections._get_all, Selections._set_all, doc="Gets or sets all entities currently selected.")

Selections.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Selections) else None
Selections.cast = lambda arg: arg if isinstance(arg, Selections) else None

class Surface(Base):
    """
    Describes a two-dimensional topological, manifold in three-dimensional space. 
    It is used as the underlying geometry for a BRepFace.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Surface, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Surface, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Surface *" : return _core.Surface___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Surface___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Surface___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Surface_classType
    if _newclass:classType = staticmethod(_core.Surface_classType)
    __swig_destroy__ = _core.delete_Surface
    __del__ = lambda self : None;
    def _get_surfaceType(self) -> "adsk::core::SurfaceTypes" :
        """Returns the surface type."""
        return _core.Surface__get_surfaceType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >" :
        """Returns the surface evaluator."""
        return _core.Surface__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Updates this surface by transforming it with a given input matrix. 
        matrix : A 3D matrix that defines the transform to apply to the surface. 
        Returns true if the transform was successful.
        """
        return _core.Surface_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Surface__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Surface__get_isValid(self)
Surface_swigregister = _core.Surface_swigregister
Surface_swigregister(Surface)

def Surface_classType() -> "char const *" :
  return _core.Surface_classType()
Surface_classType = _core.Surface_classType

Surface.__swig_getmethods__["surfaceType"] = Surface._get_surfaceType
Surface.surfaceType = property(Surface._get_surfaceType, doc="Returns the surface type.")

Surface.__swig_getmethods__["evaluator"] = Surface._get_evaluator
Surface.evaluator = property(Surface._get_evaluator, doc="Returns the surface evaluator.")

Surface.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Surface) else None
Surface.cast = lambda arg: arg if isinstance(arg, Surface) else None

class SurfaceEvaluator(Base):
    """
    Surface evaluator that is obtained from a transient surface and allows you to perform
    various evaluations on the surface.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SurfaceEvaluator, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SurfaceEvaluator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::SurfaceEvaluator *" : return _core.SurfaceEvaluator___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.SurfaceEvaluator___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.SurfaceEvaluator___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.SurfaceEvaluator_classType
    if _newclass:classType = staticmethod(_core.SurfaceEvaluator_classType)
    __swig_destroy__ = _core.delete_SurfaceEvaluator
    __del__ = lambda self : None;
    def _get_isClosedInU(self) -> "bool" :
        """Indicates if the surface is closed (forms a loop) in the U direction"""
        return _core.SurfaceEvaluator__get_isClosedInU(self)

    def _get_isClosedInV(self) -> "bool" :
        """Indicates if the surface is closed (forms a loop) in the V direction"""
        return _core.SurfaceEvaluator__get_isClosedInV(self)

    def getModelCurveFromParametricCurve(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Creates the 3D equivalent curve in model space, of a 2D curve defined in the 
        parametric space of the surface. 
        parametricCurve : The parameter space curve to map into this surface's parameter space. 
        Returns an ObjectCollection containing one or more curves. 
        When the SufaceEvaluatior is obtained from a face, and the curve cuts across internal 
        boundaries of the face, multiple curves are returned. The returned curves are trimmed 
        to the boundaries of the face. 
        If the SurfaceEvaluator is obtained from a geometry object, a single curve returned 
        because there are no boundaries with which to trim the curve. 
        The type of curve(s) returned depends on the shape of the input curve and surface.
        """
        return _core.SurfaceEvaluator_getModelCurveFromParametricCurve(self, *args)

    def getIsoCurve(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets (by extraction) a curve that follows a constant u or v parameter along the surface. 
        The curve will have the same properties as the surface in the direction of the extraction. 
        For example, when a curve is extracted from the periodic direction of a surface, the extracted 
        curve will also be periodic. 
        The type of curve returned is dependent on the shape the surface. 
        parameter : The parameter at which to extract the curve 
        isUDirection : A bool that indicates whether to extract the curve from the U or V direction 
        Returns an ObjectCollection that contains one or more curves. 
        Multiple curves are returned when the SurfaceEvaluator is obtained from a Face 
        and the curve cuts across internal boundaries. The resulting curves are trimmed to the 
        boundaries of the Face. 
        When the SurfaceEvaluator is obtained from a geometry object, a single curve is returned 
        because there are no boundaries to trim the curve. 
        The type of curve(s) returned is dependent on the shape of the surface.
        """
        return _core.SurfaceEvaluator_getIsoCurve(self, *args)

    def getCurvatures(self, *args) -> "bool" :
        """
        Get the curvature values at a number of parameter positions on the surface. 
        parameters : The array of parameter positions to return curvature information at.
        Each parameter position must be with the range of the parameter extents as verified by isParameterOnFace. 
        maxTangents : The output array of directions of maximum curvature at each position on the surface.
        The length of this array will be the same as the length of the parameters array provided. 
        maxCurvatures : The output array of the magnitude of the maximum curvature at each position on the surface.
        The length of this array will be the same as the length of the parameters array provided. 
        minCurvatures : The output array of the magnitude of the minimum curvature at each position on the surface.
        The minimum curvature direction is perpendicular to the maximum curvature tangent directions.
        The length of this array will be the same as the length of the parameters array provided. 
        Returns true if the curvatures were successfully returned.
        """
        return _core.SurfaceEvaluator_getCurvatures(self, *args)

    def getCurvature(self, *args) -> "bool" :
        """
        Get the curvature values at a parameter positions on the surface. 
        parameter : The parameter positions to return curvature information at. 
        maxTangent : The output directions of maximum curvature at the position on the surface. 
        maxCurvature : The output magnitude of the maximum curvature at the position on the surface. 
        minCurvature : The output magnitude of the minimum curvature at the position on the surface.
        The minimum curvature direction is perpendicular to the maximum curvature tangent directions. 
        Returns true if the curvature was successfully returned.
        """
        return _core.SurfaceEvaluator_getCurvature(self, *args)

    def getNormalsAtParameters(self, *args) -> "bool" :
        """
        Gets the surface normal at a number of parameter positions on the surface. 
        parameters : The array of parameter positions to return the normal at.
        Each parameter position must be with the range of the parameter extents as verified by isParameterOnFace. 
        normals : The output array of normals for each parameter position on the surface.
        The length of this array will be the same as the length of the parameters array provided. 
        Returns true if the normals were successfully returned.
        """
        return _core.SurfaceEvaluator_getNormalsAtParameters(self, *args)

    def getNormalAtParameter(self, *args) -> "bool" :
        """
        Gets the surface normal at a parameter position on the surface. 
        parameter : The parameter position to return the normal at.
        The parameter position must be with the range of the parameter extents as verified by isParameterOnFace. 
        normal : The output normal for the parameter position on the surface. 
        Returns true if the normal was successfully returned.
        """
        return _core.SurfaceEvaluator_getNormalAtParameter(self, *args)

    def getNormalsAtPoints(self, *args) -> "bool" :
        """
        Gets the surface normal at a number of positions on the surface. 
        points : The array of points to return the normal at.
        For reliable results each point should lie on the surface. 
        normals : The output array of normals for each point on the surface.
        The length of this array will be the same as the length of the points array provided. 
        Returns true if the normals were successfully returned.
        """
        return _core.SurfaceEvaluator_getNormalsAtPoints(self, *args)

    def getNormalAtPoint(self, *args) -> "bool" :
        """
        Gets the surface normal at a point on the surface. 
        point : The point to return the normal at.
        For reliable results the point should lie on the surface. 
        normal : The output normal for the point on the surface. 
        Returns true if the normal was successfully returned.
        """
        return _core.SurfaceEvaluator_getNormalAtPoint(self, *args)

    def getParametersAtPoints(self, *args) -> "bool" :
        """
        Get the parameter positions that correspond to a set of points on the surface.
        For reliable results, the points should lie on the surface within model tolerance.
        If the points do not lie on the surface, the parameter of the nearest point on the surface will generally be returned. 
        points : An array of points to get the surface parameter values at. 
        parameters : The output array of parameter positions corresponding to the set of points.
        The length of this array will be equal to the length of the points array specified. 
        Returns true if the parameters were successfully returned.
        """
        return _core.SurfaceEvaluator_getParametersAtPoints(self, *args)

    def getParameterAtPoint(self, *args) -> "bool" :
        """
        Get the parameter position that correspond to a point on the surface.
        For reliable results, the point should lie on the surface within model tolerance.
        If the point does not lie on the surface, the parameter of the nearest point on the surface will generally be returned. 
        point : The point to get the curve parameter value at. 
        parameter : The output parameter position corresponding to the point. 
        Returns true of the parameter was successfully returned.
        """
        return _core.SurfaceEvaluator_getParameterAtPoint(self, *args)

    def getPointsAtParameters(self, *args) -> "bool" :
        """
        Get the points on the surface that correspond to evaluating a set of parameter positions on the surface. 
        parameters : The array of parameter positions to evaluate the surface position at.
        Each parameter position must be within the range of the parameter extents as verified by isParameterOnFace. 
        points : The output array of points corresponding to evaluating the curve at that parameter position.
        The length of this array will be equal to the length of the parameters array specified. 
        Returns true if the points were successfully returned.
        """
        return _core.SurfaceEvaluator_getPointsAtParameters(self, *args)

    def getPointAtParameter(self, *args) -> "bool" :
        """
        Get the point on the surface that correspond to evaluating a parameter position on the surface. 
        parameter : The parameter positions to evaluate the surface position at.
        The parameter position must be within the range of the parameter extents as verified by isParameterOnFace. 
        point : The output point corresponding to evaluating the curve at that parameter position. 
        Returns true if the point was successfully returned.
        """
        return _core.SurfaceEvaluator_getPointAtParameter(self, *args)

    def getParamAnomaly(self) -> "bool" :
        """
        Gets details about anomalies in parameter space of the surface.
        This includes information about periodic intervals, singularities, or unbounded parameter ranges. 
        periodicityU : The output array with information about the period of the surface in U.
        periodicityU[0] will contain the period of the surface in U.
        If periodicityU[0] is 0, the surface is not periodic in U.
        If the surface is periodic in U, peridocityU[1] will contain the parameter value at the start of the principle period. 
        periodicityV : The output array with information about the period of the surface in V.
        periodicityV[0] will contain the period of the surface in V.
        If periodicityV[0] is 0, the surface is not periodic in V.
        If the surface is periodic in V, peridocityV[1] will contain the parameter value at the start of the principle period. 
        singularitiesU : The output array parameter values of singularities in U.
        If this array is empty, there are no singularities in U. 
        singularitiesV : The output array parameter values of singularities in V.
        If this array is empty, there are no singularities in V. 
        unboundedParameters : The output array that indicates if the parameter range is unbounded in U or V.
        unboundedParameters[0] will be true if U is unbounded.
        unboundedParameters[1] will be true if V is unbounded. 
        Returns true if the parameter anomalies were successfully returned.
        """
        return _core.SurfaceEvaluator_getParamAnomaly(self)

    def getFirstDerivatives(self, *args) -> "bool" :
        """
        Get the first derivatives of the surface at the specified parameter positions. 
        parameters : The array of parameter positions to get the surface first derivative at.
        Each parameter position must be within the range of the parameter extents as verified by isParameterOnFace. 
        partialsU : The output array of first derivative U partial vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        partialsV : The output array of first derivative V partial vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        Returns true if the first derivatives were successfully returned.
        """
        return _core.SurfaceEvaluator_getFirstDerivatives(self, *args)

    def getFirstDerivative(self, *args) -> "bool" :
        """
        Get the first derivative of the surface at the specified parameter position. 
        parameter : The parameter positions to get the surface first derivative at.
        The parameter position must be within the range of the parameter extents as verified by isParameterOnFace. 
        partialU : The output first derivative U partial vector at the parameter position specified. 
        partialV : The output first derivative V partial vector at the parameter position specified. 
        Returns true if the first derivative was successfully returned.
        """
        return _core.SurfaceEvaluator_getFirstDerivative(self, *args)

    def getSecondDerivatives(self, *args) -> "bool" :
        """
        Get the second derivatives of the surface at the specified parameter positions. 
        parameters : The array of parameter positions to get the surface second derivative at.
        Each parameter position must be within the range of the parameter extents as verified by isParameterOnFace. 
        partialsUU : The output array of second derivative UU partial vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        partialsUV : The output array of second derivative UV mixed partial vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        partialsVV : The output array of second derivative VV partial vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        Returns true if the second derivatives were successfully returned.
        """
        return _core.SurfaceEvaluator_getSecondDerivatives(self, *args)

    def getSecondDerivative(self, *args) -> "bool" :
        """
        Get the second derivative of the surface at the specified parameter position. 
        parameter : The parameter position to get the surface second derivative at.
        The parameter position must be within the range of the parameter extents as verified by isParameterOnFace. 
        partialUU : The output second derivative UU partial vector at each parameter position specified. 
        partialUV : The output second derivative UV mixed partial vector at each parameter position specified. 
        partialVV : The output second derivative VV partial vector at each parameter position specified. 
        Returns true if the second derivative was successfully returned.
        """
        return _core.SurfaceEvaluator_getSecondDerivative(self, *args)

    def getThirdDerivatives(self, *args) -> "bool" :
        """
        Get the third derivatives of the surface at the specified parameter positions. 
        parameters : The array of parameter positions to get the surface third derivative at.
        Each parameter position must be within the range of the parameter extents as verified by isParameterOnFace. 
        partialsUUU : The output array of third derivative UUU partial vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        partialsVVV : The output array of third derivative VVV partial vectors at each parameter position specified.
        The length of this array is equal to the length of the parameters array specified. 
        Returns true if the third derivatives were successfully returned.
        """
        return _core.SurfaceEvaluator_getThirdDerivatives(self, *args)

    def getThirdDerivative(self, *args) -> "bool" :
        """
        Get the third derivative of the surface at the specified parameter position. 
        parameter : The parameter position to get the surface third derivative at.
        The parameter position must be within the range of the parameter extents as verified by isParameterOnFace. 
        partialUUU : The output third derivative UUU partial vector at each parameter position specified. 
        partialVVV : The output third derivative VVV partial vector at each parameter position specified. 
        Returns true if the third derivative was successfully returned.
        """
        return _core.SurfaceEvaluator_getThirdDerivative(self, *args)

    def isParameterOnFace(self, *args) -> "bool" :
        """
        Determines if the specified parameter position lies with the parametric range of the surface. 
        parameter : The parameter position to test. 
        Returns true if the parameter position lies within the valid parametric range of the surface.
        """
        return _core.SurfaceEvaluator_isParameterOnFace(self, *args)

    def parametricRange(self) -> "adsk::core::Ptr< adsk::core::BoundingBox2D >" :
        """
        Returns the parametric range of the surface.
        If the surface is periodic in a direction, the range is set to the principle period's range.
        If the surface is only upper bounded in a direction, the lower bound is set to -double-max.
        If the surface is only lower bounded in a direction, the upper bound is set to double-max.
        If the surface is unbounded in a direction, the lower bound and upper bound of the range will both be zero. 
        Returns the bounding box with the parameter extents, with the X value being the U range, and the Y value being the V range.
        """
        return _core.SurfaceEvaluator_parametricRange(self)

    def _get_area(self) -> "double" :
        """
        Returns the area of the surface. This is typically used when the SurfaceEvaluator is associated
        with a BRepFace object where it is always valid. This can fail in the case where the SurfaceEvaluator is
        associated with one of the geometry classes, (Plane, Cylinder, Cone, EllipticalCone, or EllipticalCylinder 
        object), because these surfaces are unbounded. A BRepFace, even one of these shapes, is bounded by its 
        edges and has a well-defined area.
        """
        return _core.SurfaceEvaluator__get_area(self)

    def _get_objectType(self) -> "char const *" : return _core.SurfaceEvaluator__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.SurfaceEvaluator__get_isValid(self)
SurfaceEvaluator_swigregister = _core.SurfaceEvaluator_swigregister
SurfaceEvaluator_swigregister(SurfaceEvaluator)

def SurfaceEvaluator_classType() -> "char const *" :
  return _core.SurfaceEvaluator_classType()
SurfaceEvaluator_classType = _core.SurfaceEvaluator_classType

SurfaceEvaluator.__swig_getmethods__["isClosedInU"] = SurfaceEvaluator._get_isClosedInU
SurfaceEvaluator.isClosedInU = property(SurfaceEvaluator._get_isClosedInU, doc="Indicates if the surface is closed (forms a loop) in the U direction")

SurfaceEvaluator.__swig_getmethods__["isClosedInV"] = SurfaceEvaluator._get_isClosedInV
SurfaceEvaluator.isClosedInV = property(SurfaceEvaluator._get_isClosedInV, doc="Indicates if the surface is closed (forms a loop) in the V direction")

SurfaceEvaluator.__swig_getmethods__["area"] = SurfaceEvaluator._get_area
SurfaceEvaluator.area = property(SurfaceEvaluator._get_area, doc="Returns the area of the surface. This is typically used when the SurfaceEvaluator is associated\nwith a BRepFace object where it is always valid. This can fail in the case where the SurfaceEvaluator is\nassociated with one of the geometry classes, (Plane, Cylinder, Cone, EllipticalCone, or EllipticalCylinder\nobject), because these surfaces are unbounded. A BRepFace, even one of these shapes, is bounded by its\nedges and has a well-defined area.")

SurfaceEvaluator.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SurfaceEvaluator) else None
SurfaceEvaluator.cast = lambda arg: arg if isinstance(arg, SurfaceEvaluator) else None

class Toolbar(Base):
    """Provides access to a toolbar in the user interface. A toolbar is a collection of toolbar controls."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Toolbar, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Toolbar, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Toolbar *" : return _core.Toolbar___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Toolbar___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Toolbar___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Toolbar_classType
    if _newclass:classType = staticmethod(_core.Toolbar_classType)
    __swig_destroy__ = _core.delete_Toolbar
    __del__ = lambda self : None;
    def _get_id(self) -> "std::string" :
        """
        Gets the unique ID of the toolbar that can be used programmatically
        to find a specific toolbar.
        """
        return _core.Toolbar__get_id(self)

    def _get_parentUserInterface(self) -> "adsk::core::Ptr< adsk::core::UserInterface >" :
        """Gets the owning UserInterface object."""
        return _core.Toolbar__get_parentUserInterface(self)

    def _get_controls(self) -> "adsk::core::Ptr< adsk::core::ToolbarControls >" :
        """Gets the controls in this toolbar."""
        return _core.Toolbar__get_controls(self)

    def _get_objectType(self) -> "char const *" : return _core.Toolbar__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Toolbar__get_isValid(self)
Toolbar_swigregister = _core.Toolbar_swigregister
Toolbar_swigregister(Toolbar)

def Toolbar_classType() -> "char const *" :
  return _core.Toolbar_classType()
Toolbar_classType = _core.Toolbar_classType

Toolbar.__swig_getmethods__["id"] = Toolbar._get_id
Toolbar.id = property(Toolbar._get_id, doc="Gets the unique ID of the toolbar that can be used programmatically\nto find a specific toolbar.")

Toolbar.__swig_getmethods__["parentUserInterface"] = Toolbar._get_parentUserInterface
Toolbar.parentUserInterface = property(Toolbar._get_parentUserInterface, doc="Gets the owning UserInterface object.")

Toolbar.__swig_getmethods__["controls"] = Toolbar._get_controls
Toolbar.controls = property(Toolbar._get_controls, doc="Gets the controls in this toolbar.")

Toolbar.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Toolbar) else None
Toolbar.cast = lambda arg: arg if isinstance(arg, Toolbar) else None

class ToolbarControl(Base):
    """The base class for all toolbar controls."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ToolbarControl, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ToolbarControl, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ToolbarControl *" : return _core.ToolbarControl___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ToolbarControl___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ToolbarControl___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ToolbarControl_classType
    if _newclass:classType = staticmethod(_core.ToolbarControl_classType)
    __swig_destroy__ = _core.delete_ToolbarControl
    __del__ = lambda self : None;
    def _get_id(self) -> "std::string" :
        """
        Gets the unique ID of this control. The ID is unique with respect to the other
        controls within the same panel, toolbar, or drop-down control.
        """
        return _core.ToolbarControl__get_id(self)

    def _get_index(self) -> "size_t" :
        """Gets the position of this control within the list of controls within the panel, toolbar, or drop-down control."""
        return _core.ToolbarControl__get_index(self)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this control is currently visible."""
        return _core.ToolbarControl__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this control is currently visible."""
        return _core.ToolbarControl__set_isVisible(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the Parent object. When associated with a toolbar (right or left QAT or the Nav Bar) this
        returns the parent Toolbar object. When associated with a panel it returns the parent ToolbarPanel object.
        When associated with a control (DropDownControl) it returns the parent control.
        """
        return _core.ToolbarControl__get_parent(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the ToolbarControl 
        Returns a boolean indicating if the deletion was successful.
        """
        return _core.ToolbarControl_deleteMe(self)

    def _get_objectType(self) -> "char const *" : return _core.ToolbarControl__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ToolbarControl__get_isValid(self)
ToolbarControl_swigregister = _core.ToolbarControl_swigregister
ToolbarControl_swigregister(ToolbarControl)

def ToolbarControl_classType() -> "char const *" :
  return _core.ToolbarControl_classType()
ToolbarControl_classType = _core.ToolbarControl_classType

ToolbarControl.__swig_getmethods__["id"] = ToolbarControl._get_id
ToolbarControl.id = property(ToolbarControl._get_id, doc="Gets the unique ID of this control. The ID is unique with respect to the other\ncontrols within the same panel, toolbar, or drop-down control.")

ToolbarControl.__swig_getmethods__["index"] = ToolbarControl._get_index
ToolbarControl.index = property(ToolbarControl._get_index, doc="Gets the position of this control within the list of controls within the panel, toolbar, or drop-down control.")

ToolbarControl.__swig_getmethods__["isVisible"] = ToolbarControl._get_isVisible
ToolbarControl.__swig_setmethods__["isVisible"] = ToolbarControl._set_isVisible
ToolbarControl.isVisible = property(ToolbarControl._get_isVisible, ToolbarControl._set_isVisible, doc="Gets or sets if this control is currently visible.")

ToolbarControl.__swig_getmethods__["parent"] = ToolbarControl._get_parent
ToolbarControl.parent = property(ToolbarControl._get_parent, doc="Gets the Parent object. When associated with a toolbar (right or left QAT or the Nav Bar) this\nreturns the parent Toolbar object. When associated with a panel it returns the parent ToolbarPanel object.\nWhen associated with a control (DropDownControl) it returns the parent control.")

ToolbarControl.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ToolbarControl) else None
ToolbarControl.cast = lambda arg: arg if isinstance(arg, ToolbarControl) else None

class ToolbarControlList(Base):
    """Provides access to a list of toolbar controls."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ToolbarControlList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ToolbarControlList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ToolbarControlList *" : return _core.ToolbarControlList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ToolbarControlList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ToolbarControlList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.ToolbarControlList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarControl >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.ToolbarControlList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ToolbarControlList_classType
    if _newclass:classType = staticmethod(_core.ToolbarControlList_classType)
    __swig_destroy__ = _core.delete_ToolbarControlList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarControl >" :
        """
        Returns the ToolbarControl at the specified index.
        When iterating by index, the controls are returned
        in the same order as they are shown in the user interface. 
        index : The index of the control within the collection to return. The first item in the
        collection has in index of 0. 
        Returns the ToolbarControl at the specified index or null if an invalid index was specified.
        """
        return _core.ToolbarControlList_item(self, *args)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarControl >" :
        """
        Returns the ToolbarControl at the specified ID. 
        id : The ID of the control within the collection to return. 
        Returns the ToolbarControl with the specified ID or null if no control has this ID.
        """
        return _core.ToolbarControlList_itemById(self, *args)

    def _get_count(self) -> "size_t" :
        """Gets the number of toolbar controls."""
        return _core.ToolbarControlList__get_count(self)

    def _get_objectType(self) -> "char const *" : return _core.ToolbarControlList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ToolbarControlList__get_isValid(self)
ToolbarControlList_swigregister = _core.ToolbarControlList_swigregister
ToolbarControlList_swigregister(ToolbarControlList)

def ToolbarControlList_classType() -> "char const *" :
  return _core.ToolbarControlList_classType()
ToolbarControlList_classType = _core.ToolbarControlList_classType

ToolbarControlList.__swig_getmethods__["count"] = ToolbarControlList._get_count
ToolbarControlList.count = property(ToolbarControlList._get_count, doc="Gets the number of toolbar controls.")

ToolbarControlList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ToolbarControlList) else None
ToolbarControlList.cast = lambda arg: arg if isinstance(arg, ToolbarControlList) else None

class ToolbarControls(Base):
    """ToolbarControls is a collection of ToolbarControl objects displayed in a toolbar or menu."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ToolbarControls, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ToolbarControls, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ToolbarControls *" : return _core.ToolbarControls___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ToolbarControls___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ToolbarControls___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.ToolbarControls___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarControl >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.ToolbarControls___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ToolbarControls_classType
    if _newclass:classType = staticmethod(_core.ToolbarControls_classType)
    __swig_destroy__ = _core.delete_ToolbarControls
    __del__ = lambda self : None;
    def _get_count(self) -> "size_t" :
        """Gets the number of controls in the collection."""
        return _core.ToolbarControls__get_count(self)

    def item(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarControl >" :
        """
        Returns the ToolbarControl at the specified index.
        When iterating by index, the controls are returned
        in the same order as they are shown in the user interface. 
        index : The index of the control within the collection to return. The first item in the
        collection has in index of 0. 
        Returns the ToolbarControl at the specified index or null if an invalid index was specified.
        """
        return _core.ToolbarControls_item(self, *args)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarControl >" :
        """
        Returns the ToolbarControl at the specified ID. 
        id : The ID of the control within the collection to return. 
        Returns the ToolbarControl with the specified ID or null if no control has this ID.
        """
        return _core.ToolbarControls_itemById(self, *args)

    def addCommand(self, *args) -> "adsk::core::Ptr< adsk::core::CommandControl >" :
        """
        Adds a button to the controls in the toolbar, panel, or drop-down. The ID of the created
        command control is inherited from the associated command definition. 
        commandDefinition : The associated CommandDefinition that defines the resources and receives events related to this control. 
        positionID : Specifies the reference id of the control to position this control relative to.
        Not setting this value indicates that the control will be created at the end of all other controls in toolbar. The isBefore
        parameter specifies whether to place the control before or after the reference control. 
        isBefore : Specifies whether to place the control before or after the reference control specified by the positionID parameter.
        This argument is ignored is positionID is not specified. 
        Returns the newly created CommandControl object or null if the creation fails.
        """
        return _core.ToolbarControls_addCommand(self, *args)

    def addDropDown(self, *args) -> "adsk::core::Ptr< adsk::core::DropDownControl >" :
        """
        Adds a drop-down to the controls in the toolbar, panel, or drop-down. When the drop-down is initially created it will be empty.
        you can get the associated ToolbarControls object from the DropDownControl to add additional controls to the drop-down. 
        text : The text displayed for the drop-down in a menu. For a drop-down in a toolbar this argument is ignored
        because an icon is used. 
        resourceFolder : The resource folder containing the image used for the icon when the drop-down is in a toolbar. 
        id : Optional unique ID for the control. It must be unique with respect to other controls in this collection. 
        If the default empty string is provided, Fusion 360 will create a unique ID. 
        positionID : Specifies the reference id of the control to position this control relative to.
        Not setting this value indicates that the control will be created at the end of all other controls in toolbar. The isBefore
        parameter specifies whether to place the control before or after the reference control. 
        isBefore : Specifies whether to place the control before or after the reference control specified by the positionID parameter.
        This argument is ignored is positionID is not specified. 
        Returns the newly created DropDownControl object or null if the creation fails.
        """
        return _core.ToolbarControls_addDropDown(self, *args)

    def addSeparator(self, id : 'std::string const &'="", positionID : 'std::string const &'="", isBefore : 'bool'=True) -> "adsk::core::Ptr< adsk::core::SeparatorControl >" :
        """
        Adds a separator to the controls in the toolbar, panel, or drop-down. 
        id : Optional unique ID for the control. It must be unique with respect to other controls in this collection. 
        If the default empty string is provided, Fusion 360 will create a unique ID. 
        positionID : Specifies the reference id of the control to position this separator control relative to.
        Not setting this value indicates that the separator control will be created at the end of all other controls in toolbar. 
        The isBefore parameter specifies whether to place the control before or after the reference control. 
        isBefore : Specifies whether to place the separator control before or after the reference control specified by the positionID parameter.
        This argument is ignored is positionID is not specified. 
        Returns the newly created separator controls or null if the creation fails.
        """
        return _core.ToolbarControls_addSeparator(self, id, positionID, isBefore)

    def addSplitButton(self, *args) -> "adsk::core::Ptr< adsk::core::SplitButtonControl >" :
        """
        Adds a split button to the controls in a toolbar. A split button has two active areas that the user can click;
        the main button portion and the drop-down arrow. Clicking the main button, executes the displayed command.
        Clicking the drop-down displays the drop-down with additional commands.
        The split button itself does not fire any events, but the buttons within it will fire events to their associated
        command definitions. 
        defaultDefinition : A command definition that will be used to create the main button. A button will also be created in the drop-down 
        for this definition. 
        additionalDefinitions : A collection of command definitions that will be used to create the buttons on the drop-down. 
        showLastUsed : Specifies if the split button should have the behavior where the command shown on the main button changes 
        to the last executed command. 
        id : Optional unique ID for the control. It must be unique with respect to other controls in this collection. 
        If the default empty string is provided, Fusion 360 will create a unique ID. 
        positionID : Specifies the reference id of the control to position this control relative to.
        Not setting this value indicates that the control will be created at the end of all other controls in toolbar. The isBefore
        parameter specifies whether to place the control before or after the reference control. 
        isBefore : Specifies whether to place the control before or after the reference control specified by the positionID parameter.
        This argument is ignored is positionID is not specified 
        Returns the newly created SplitButtonControl object or null if the creation fails.
        """
        return _core.ToolbarControls_addSplitButton(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.ToolbarControls__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ToolbarControls__get_isValid(self)
ToolbarControls_swigregister = _core.ToolbarControls_swigregister
ToolbarControls_swigregister(ToolbarControls)

def ToolbarControls_classType() -> "char const *" :
  return _core.ToolbarControls_classType()
ToolbarControls_classType = _core.ToolbarControls_classType

ToolbarControls.__swig_getmethods__["count"] = ToolbarControls._get_count
ToolbarControls.count = property(ToolbarControls._get_count, doc="Gets the number of controls in the collection.")

ToolbarControls.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ToolbarControls) else None
ToolbarControls.cast = lambda arg: arg if isinstance(arg, ToolbarControls) else None

class ToolbarPanel(Base):
    """Toolbar panels are the panels shown in the command toolbar."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ToolbarPanel, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ToolbarPanel, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ToolbarPanel *" : return _core.ToolbarPanel___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ToolbarPanel___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ToolbarPanel___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ToolbarPanel_classType
    if _newclass:classType = staticmethod(_core.ToolbarPanel_classType)
    __swig_destroy__ = _core.delete_ToolbarPanel
    __del__ = lambda self : None;
    def _get_id(self) -> "std::string" :
        """Gets The unique, language independent, ID of this panel."""
        return _core.ToolbarPanel__get_id(self)

    def _get_index(self) -> "size_t" :
        """
        Gets the position this panel is in within the toolbar.
        The first panel is at position 0. This value is with respect
        to the complete list of panels so this value could be outside
        of the expected range if you have a collection of panels
        associated with a workspace, which is a subset of the entire
        list of panels.
        """
        return _core.ToolbarPanel__get_index(self)

    def _get_isVisible(self) -> "bool" :
        """
        Gets whether this panel is currently being displayed in the user interface.
        Visibility of a panel is controlled by it being associated with the currently
        active workspace.
        """
        return _core.ToolbarPanel__get_isVisible(self)

    def _get_name(self) -> "std::string" :
        """Gets the name of the panel as seen in the user interface."""
        return _core.ToolbarPanel__get_name(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes this toolbar panel. 
        Returns true if the delete was successful.
        """
        return _core.ToolbarPanel_deleteMe(self)

    def _get_controls(self) -> "adsk::core::Ptr< adsk::core::ToolbarControls >" :
        """
        Gets the controls associated with this panel. These are all in the panel's
        drop-down (assuming their visible property is true) and are selectively shown
        within the panel.
        """
        return _core.ToolbarPanel__get_controls(self)

    def _get_parentUserInterface(self) -> "adsk::core::Ptr< adsk::core::UserInterface >" :
        """Gets the parent UserInterface object."""
        return _core.ToolbarPanel__get_parentUserInterface(self)

    def _get_promotedControls(self) -> "adsk::core::Ptr< adsk::core::ToolbarControlList >" :
        """
        Gets the controls in the panel that have been promoted. Promoted
        controls are the controls that are displayed within the panel.
        """
        return _core.ToolbarPanel__get_promotedControls(self)

    def _get_relatedWorkspaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """Gets or sets the set of workspaces that this panel is displayed for."""
        return _core.ToolbarPanel__get_relatedWorkspaces(self)

    def _set_relatedWorkspaces(self, *args) -> "bool" :
        """Gets or sets the set of workspaces that this panel is displayed for."""
        return _core.ToolbarPanel__set_relatedWorkspaces(self, *args)

    def _get_productType(self) -> "std::string" :
        """Returns the name of the product this toolbar panel is associated with."""
        return _core.ToolbarPanel__get_productType(self)

    def indexWithinTab(self, *args) -> "size_t" :
        """
        Gets the position this panel is in within the toolbar tab.
        The first panel in the tab is at position 0.
        """
        return _core.ToolbarPanel_indexWithinTab(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.ToolbarPanel__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ToolbarPanel__get_isValid(self)
ToolbarPanel_swigregister = _core.ToolbarPanel_swigregister
ToolbarPanel_swigregister(ToolbarPanel)

def ToolbarPanel_classType() -> "char const *" :
  return _core.ToolbarPanel_classType()
ToolbarPanel_classType = _core.ToolbarPanel_classType

ToolbarPanel.__swig_getmethods__["id"] = ToolbarPanel._get_id
ToolbarPanel.id = property(ToolbarPanel._get_id, doc="Gets The unique, language independent, ID of this panel.")

ToolbarPanel.__swig_getmethods__["index"] = ToolbarPanel._get_index
ToolbarPanel.index = property(ToolbarPanel._get_index, doc="Gets the position this panel is in within the toolbar.\nThe first panel is at position 0. This value is with respect\nto the complete list of panels so this value could be outside\nof the expected range if you have a collection of panels\nassociated with a workspace, which is a subset of the entire\nlist of panels.")

ToolbarPanel.__swig_getmethods__["isVisible"] = ToolbarPanel._get_isVisible
ToolbarPanel.isVisible = property(ToolbarPanel._get_isVisible, doc="Gets whether this panel is currently being displayed in the user interface.\nVisibility of a panel is controlled by it being associated with the currently\nactive workspace.")

ToolbarPanel.__swig_getmethods__["name"] = ToolbarPanel._get_name
ToolbarPanel.name = property(ToolbarPanel._get_name, doc="Gets the name of the panel as seen in the user interface.")

ToolbarPanel.__swig_getmethods__["controls"] = ToolbarPanel._get_controls
ToolbarPanel.controls = property(ToolbarPanel._get_controls, doc="Gets the controls associated with this panel. These are all in the panel's\ndrop-down (assuming their visible property is true) and are selectively shown\nwithin the panel.")

ToolbarPanel.__swig_getmethods__["parentUserInterface"] = ToolbarPanel._get_parentUserInterface
ToolbarPanel.parentUserInterface = property(ToolbarPanel._get_parentUserInterface, doc="Gets the parent UserInterface object.")

ToolbarPanel.__swig_getmethods__["promotedControls"] = ToolbarPanel._get_promotedControls
ToolbarPanel.promotedControls = property(ToolbarPanel._get_promotedControls, doc="Gets the controls in the panel that have been promoted. Promoted\ncontrols are the controls that are displayed within the panel.")

ToolbarPanel.__swig_getmethods__["relatedWorkspaces"] = ToolbarPanel._get_relatedWorkspaces
ToolbarPanel.__swig_setmethods__["relatedWorkspaces"] = ToolbarPanel._set_relatedWorkspaces
ToolbarPanel.relatedWorkspaces = property(ToolbarPanel._get_relatedWorkspaces, ToolbarPanel._set_relatedWorkspaces, doc="Gets or sets the set of workspaces that this panel is displayed for.")

ToolbarPanel.__swig_getmethods__["productType"] = ToolbarPanel._get_productType
ToolbarPanel.productType = property(ToolbarPanel._get_productType, doc="Returns the name of the product this toolbar panel is associated with.")

ToolbarPanel.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ToolbarPanel) else None
ToolbarPanel.cast = lambda arg: arg if isinstance(arg, ToolbarPanel) else None

class ToolbarPanelList(Base):
    """A ToolbarPanelList is a list of ToolbarPanel objects."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ToolbarPanelList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ToolbarPanelList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ToolbarPanelList *" : return _core.ToolbarPanelList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ToolbarPanelList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ToolbarPanelList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.ToolbarPanelList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarPanel >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.ToolbarPanelList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ToolbarPanelList_classType
    if _newclass:classType = staticmethod(_core.ToolbarPanelList_classType)
    __swig_destroy__ = _core.delete_ToolbarPanelList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarPanel >" :
        """
        Returns the specified work space using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.ToolbarPanelList_item(self, *args)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarPanel >" :
        """
        Returns the ToolbarPanel of the specified ID. 
        id : The ID of the ToolbarPanel to get. 
        Returns the specified ToolbarPanel or null in the case where there isn't a ToolbarPanel with the specified ID.
        """
        return _core.ToolbarPanelList_itemById(self, *args)

    def _get_count(self) -> "size_t" :
        """Gets the number of toolbar panels in the collection."""
        return _core.ToolbarPanelList__get_count(self)

    def _get_objectType(self) -> "char const *" : return _core.ToolbarPanelList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ToolbarPanelList__get_isValid(self)
ToolbarPanelList_swigregister = _core.ToolbarPanelList_swigregister
ToolbarPanelList_swigregister(ToolbarPanelList)

def ToolbarPanelList_classType() -> "char const *" :
  return _core.ToolbarPanelList_classType()
ToolbarPanelList_classType = _core.ToolbarPanelList_classType

ToolbarPanelList.__swig_getmethods__["count"] = ToolbarPanelList._get_count
ToolbarPanelList.count = property(ToolbarPanelList._get_count, doc="Gets the number of toolbar panels in the collection.")

ToolbarPanelList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ToolbarPanelList) else None
ToolbarPanelList.cast = lambda arg: arg if isinstance(arg, ToolbarPanelList) else None

class ToolbarPanels(Base):
    """
    Provides access to a set of toolbar panels. There exist many toolbar panels and their
    visibility is determined by the active workspace. A panel can be associated with one
    or more workspaces and when the associated workspace is active, the panel is made visible.
    This collection is associated with a workspace and possibly a tab in the toolbar for that workspace.
    If this collection is from a toolbar tab, the collection order is the left-to-right order
    of panels in the toolbar tab.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ToolbarPanels, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ToolbarPanels, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ToolbarPanels *" : return _core.ToolbarPanels___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ToolbarPanels___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ToolbarPanels___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.ToolbarPanels___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarPanel >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.ToolbarPanels___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ToolbarPanels_classType
    if _newclass:classType = staticmethod(_core.ToolbarPanels_classType)
    __swig_destroy__ = _core.delete_ToolbarPanels
    __del__ = lambda self : None;
    def add(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarPanel >" :
        """
        Creates a new ToolbarPanel. The panel is initially empty.
        Use the associated ToolbarControls collection to add buttons.
        If this collection is associated with a tab, the new panel will be added to that tab.
        If this collection is not associated with a tab, the new panel will be added to the end of the 'Tools' Tab. 
        A 'Tools' tab will be created for you if it does not currently exist for this collections workspace. 
        id : The unique id for this panel. The id must be unique with respect to all of the panels. 
        name : The displayed name of this panel. This is the name visible in the user interface. 
        positionID : Specifies the id of the panel to position this panel relative to.
        Not setting this value indicates that the panel will be created at the end of all other panels. The isBefore
        parameter specifies whether to place the panel before or after this panel. 
        isBefore : Specifies whether to place the panel before or after the panel specified by the positionID argument. 
        This argument is ignored is positionID is not specified 
        Returns the newly created panel or null in the case the creation failed.
        """
        return _core.ToolbarPanels_add(self, *args)

    def item(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarPanel >" :
        """
        Returns the specified toolbar panel using an index into the collection.
        When iterating by index, the panels are returned in the same order as they are shown in the user interface. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.ToolbarPanels_item(self, *args)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarPanel >" :
        """
        Returns the ToolbarPanel at the specified ID. 
        id : The Id of the panel within the collection to return. 
        Returns the ToolbarPanel of the specified id or null no panel has the specified id.
        """
        return _core.ToolbarPanels_itemById(self, *args)

    def _get_count(self) -> "size_t" :
        """Gets the number of ToolbarPanels."""
        return _core.ToolbarPanels__get_count(self)

    def _get_objectType(self) -> "char const *" : return _core.ToolbarPanels__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ToolbarPanels__get_isValid(self)
ToolbarPanels_swigregister = _core.ToolbarPanels_swigregister
ToolbarPanels_swigregister(ToolbarPanels)

def ToolbarPanels_classType() -> "char const *" :
  return _core.ToolbarPanels_classType()
ToolbarPanels_classType = _core.ToolbarPanels_classType

ToolbarPanels.__swig_getmethods__["count"] = ToolbarPanels._get_count
ToolbarPanels.count = property(ToolbarPanels._get_count, doc="Gets the number of ToolbarPanels.")

ToolbarPanels.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ToolbarPanels) else None
ToolbarPanels.cast = lambda arg: arg if isinstance(arg, ToolbarPanels) else None

class Toolbars(Base):
    """Provides access to the toolbars. These are currently the right and left QAT's and the NavBar."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Toolbars, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Toolbars, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Toolbars *" : return _core.Toolbars___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Toolbars___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Toolbars___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.Toolbars___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::Toolbar >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.Toolbars___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Toolbars_classType
    if _newclass:classType = staticmethod(_core.Toolbars_classType)
    __swig_destroy__ = _core.delete_Toolbars
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::Toolbar >" :
        """
        Returns the specified toolbar using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.Toolbars_item(self, *args)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::Toolbar >" :
        """
        Returns the Toolbar of the specified ID. 
        id : The Id of the toolbar to return. 
        Returns the toolbar with the specified ID or null if there's not a toolbar with the specified ID.
        """
        return _core.Toolbars_itemById(self, *args)

    def _get_count(self) -> "size_t" :
        """Gets the number of Toolbar objects in the collection."""
        return _core.Toolbars__get_count(self)

    def _get_objectType(self) -> "char const *" : return _core.Toolbars__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Toolbars__get_isValid(self)
Toolbars_swigregister = _core.Toolbars_swigregister
Toolbars_swigregister(Toolbars)

def Toolbars_classType() -> "char const *" :
  return _core.Toolbars_classType()
Toolbars_classType = _core.Toolbars_classType

Toolbars.__swig_getmethods__["count"] = Toolbars._get_count
Toolbars.count = property(Toolbars._get_count, doc="Gets the number of Toolbar objects in the collection.")

Toolbars.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Toolbars) else None
Toolbars.cast = lambda arg: arg if isinstance(arg, Toolbars) else None

class ToolbarTab(Base):
    """Toolbar tabs are the tabs shown in the command toolbar."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ToolbarTab, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ToolbarTab, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ToolbarTab *" : return _core.ToolbarTab___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ToolbarTab___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ToolbarTab___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ToolbarTab_classType
    if _newclass:classType = staticmethod(_core.ToolbarTab_classType)
    __swig_destroy__ = _core.delete_ToolbarTab
    __del__ = lambda self : None;
    def _get_id(self) -> "std::string" :
        """Gets The unique, language independent, ID of this tab."""
        return _core.ToolbarTab__get_id(self)

    def _get_index(self) -> "size_t" :
        """
        Gets the position this tab is in within the toolbar.
        The first tab is at position 0. This value is with respect
        to the complete list of tabs so this value could be outside
        of the expected range if you have a collection of tabs
        associated with a workspace, which is a subset of the entire
        list of tabs.
        """
        return _core.ToolbarTab__get_index(self)

    def _get_isVisible(self) -> "bool" :
        """Gets whether this tab is currently being displayed in the user interface."""
        return _core.ToolbarTab__get_isVisible(self)

    def _get_name(self) -> "std::string" :
        """Gets the name of the tab as seen in the user interface."""
        return _core.ToolbarTab__get_name(self)

    def _get_toolbarPanels(self) -> "adsk::core::Ptr< adsk::core::ToolbarPanels >" :
        """
        Gets the collection containing the panels associated with this tab.
        It's through this collection that you can add new toolbar panels.
        """
        return _core.ToolbarTab__get_toolbarPanels(self)

    def _get_parentUserInterface(self) -> "adsk::core::Ptr< adsk::core::UserInterface >" :
        """Gets the parent UserInterface object."""
        return _core.ToolbarTab__get_parentUserInterface(self)

    def _get_productType(self) -> "std::string" :
        """Returns the name of the product this toolbar tab is associated with."""
        return _core.ToolbarTab__get_productType(self)

    def _get_isActive(self) -> "bool" :
        """Gets if this toolbar tab is currently active - i.e. displayed."""
        return _core.ToolbarTab__get_isActive(self)

    def activate(self) -> "bool" :
        """
        Activate this toolbar tab. 
        Boolean return that indicates if the activation was successful or not.
        """
        return _core.ToolbarTab_activate(self)

    def _get_isNative(self) -> "bool" :
        """Gets if this tab is native to Fusion 360 or was created via the API."""
        return _core.ToolbarTab__get_isNative(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes this tab. Fusion 360 native tabs cannot be deleted. Use the
        isNative property to determine if this is a native or API created tab. 
        Returns true if the delete was successful.
        """
        return _core.ToolbarTab_deleteMe(self)

    def _get_objectType(self) -> "char const *" : return _core.ToolbarTab__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ToolbarTab__get_isValid(self)
ToolbarTab_swigregister = _core.ToolbarTab_swigregister
ToolbarTab_swigregister(ToolbarTab)

def ToolbarTab_classType() -> "char const *" :
  return _core.ToolbarTab_classType()
ToolbarTab_classType = _core.ToolbarTab_classType

ToolbarTab.__swig_getmethods__["id"] = ToolbarTab._get_id
ToolbarTab.id = property(ToolbarTab._get_id, doc="Gets The unique, language independent, ID of this tab.")

ToolbarTab.__swig_getmethods__["index"] = ToolbarTab._get_index
ToolbarTab.index = property(ToolbarTab._get_index, doc="Gets the position this tab is in within the toolbar.\nThe first tab is at position 0. This value is with respect\nto the complete list of tabs so this value could be outside\nof the expected range if you have a collection of tabs\nassociated with a workspace, which is a subset of the entire\nlist of tabs.")

ToolbarTab.__swig_getmethods__["isVisible"] = ToolbarTab._get_isVisible
ToolbarTab.isVisible = property(ToolbarTab._get_isVisible, doc="Gets whether this tab is currently being displayed in the user interface.")

ToolbarTab.__swig_getmethods__["name"] = ToolbarTab._get_name
ToolbarTab.name = property(ToolbarTab._get_name, doc="Gets the name of the tab as seen in the user interface.")

ToolbarTab.__swig_getmethods__["toolbarPanels"] = ToolbarTab._get_toolbarPanels
ToolbarTab.toolbarPanels = property(ToolbarTab._get_toolbarPanels, doc="Gets the collection containing the panels associated with this tab.\nIt's through this collection that you can add new toolbar panels.")

ToolbarTab.__swig_getmethods__["parentUserInterface"] = ToolbarTab._get_parentUserInterface
ToolbarTab.parentUserInterface = property(ToolbarTab._get_parentUserInterface, doc="Gets the parent UserInterface object.")

ToolbarTab.__swig_getmethods__["productType"] = ToolbarTab._get_productType
ToolbarTab.productType = property(ToolbarTab._get_productType, doc="Returns the name of the product this toolbar tab is associated with.")

ToolbarTab.__swig_getmethods__["isActive"] = ToolbarTab._get_isActive
ToolbarTab.isActive = property(ToolbarTab._get_isActive, doc="Gets if this toolbar tab is currently active - i.e. displayed.")

ToolbarTab.__swig_getmethods__["isNative"] = ToolbarTab._get_isNative
ToolbarTab.isNative = property(ToolbarTab._get_isNative, doc="Gets if this tab is native to Fusion 360 or was created via the API.")

ToolbarTab.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ToolbarTab) else None
ToolbarTab.cast = lambda arg: arg if isinstance(arg, ToolbarTab) else None

class ToolbarTabList(Base):
    """A ToolbarTabList is a list of ToolbarTab objects."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ToolbarTabList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ToolbarTabList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ToolbarTabList *" : return _core.ToolbarTabList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ToolbarTabList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ToolbarTabList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.ToolbarTabList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarTab >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.ToolbarTabList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ToolbarTabList_classType
    if _newclass:classType = staticmethod(_core.ToolbarTabList_classType)
    __swig_destroy__ = _core.delete_ToolbarTabList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarTab >" :
        """
        Returns the specified tab using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.ToolbarTabList_item(self, *args)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarTab >" :
        """
        Returns the ToolbarTab of the specified ID. 
        id : The ID of the ToolbarTab to get. 
        Returns the specified ToolbarTab or null in the case where there isn't a ToolbarTab with the specified ID.
        """
        return _core.ToolbarTabList_itemById(self, *args)

    def _get_count(self) -> "size_t" :
        """Gets the number of toolbar tabs in the collection."""
        return _core.ToolbarTabList__get_count(self)

    def _get_objectType(self) -> "char const *" : return _core.ToolbarTabList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ToolbarTabList__get_isValid(self)
ToolbarTabList_swigregister = _core.ToolbarTabList_swigregister
ToolbarTabList_swigregister(ToolbarTabList)

def ToolbarTabList_classType() -> "char const *" :
  return _core.ToolbarTabList_classType()
ToolbarTabList_classType = _core.ToolbarTabList_classType

ToolbarTabList.__swig_getmethods__["count"] = ToolbarTabList._get_count
ToolbarTabList.count = property(ToolbarTabList._get_count, doc="Gets the number of toolbar tabs in the collection.")

ToolbarTabList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ToolbarTabList) else None
ToolbarTabList.cast = lambda arg: arg if isinstance(arg, ToolbarTabList) else None

class ToolbarTabs(Base):
    """Provides access to a set of toolbar tabs."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ToolbarTabs, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ToolbarTabs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ToolbarTabs *" : return _core.ToolbarTabs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ToolbarTabs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ToolbarTabs___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.ToolbarTabs___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarTab >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.ToolbarTabs___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ToolbarTabs_classType
    if _newclass:classType = staticmethod(_core.ToolbarTabs_classType)
    __swig_destroy__ = _core.delete_ToolbarTabs
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarTab >" :
        """
        Returns the specified toolbar tab using an index into the collection.
        When iterating by index, the tabs are returned in the same order as they are shown in the user interface. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.ToolbarTabs_item(self, *args)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarTab >" :
        """
        Returns the ToolbarTab at the specified ID. 
        id : The Id of the tab within the collection to return. 
        Returns the ToolbarTab of the specified id or null if no tab has the specified id.
        """
        return _core.ToolbarTabs_itemById(self, *args)

    def _get_count(self) -> "size_t" :
        """Gets the number of ToolbarTabs."""
        return _core.ToolbarTabs__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarTab >" :
        """
        Creates a new ToolbarTab. The tab is initially empty.
        This method appends the tab to the end of the collection. 
        id : The unique id for this tab. The id must be unique with respect to all of the tabs. 
        name : The displayed name of this tab. This is the name visible in the user interface. 
        Returns the newly created tab or null in the case the creation failed.
        """
        return _core.ToolbarTabs_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.ToolbarTabs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ToolbarTabs__get_isValid(self)
ToolbarTabs_swigregister = _core.ToolbarTabs_swigregister
ToolbarTabs_swigregister(ToolbarTabs)

def ToolbarTabs_classType() -> "char const *" :
  return _core.ToolbarTabs_classType()
ToolbarTabs_classType = _core.ToolbarTabs_classType

ToolbarTabs.__swig_getmethods__["count"] = ToolbarTabs._get_count
ToolbarTabs.count = property(ToolbarTabs._get_count, doc="Gets the number of ToolbarTabs.")

ToolbarTabs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ToolbarTabs) else None
ToolbarTabs.cast = lambda arg: arg if isinstance(arg, ToolbarTabs) else None

class UnitAndValuePreferences(Base):
    """
    The UnitAndValuePreferences object provides access to unit and value precision
    related preferences.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UnitAndValuePreferences, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UnitAndValuePreferences, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::UnitAndValuePreferences *" : return _core.UnitAndValuePreferences___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.UnitAndValuePreferences___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.UnitAndValuePreferences___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.UnitAndValuePreferences_classType
    if _newclass:classType = staticmethod(_core.UnitAndValuePreferences_classType)
    __swig_destroy__ = _core.delete_UnitAndValuePreferences
    __del__ = lambda self : None;
    def _get_generalPrecision(self) -> "int" :
        """
        Gets and sets the general precision for distance values. This 
        value specifies the number of decimals to display.
        """
        return _core.UnitAndValuePreferences__get_generalPrecision(self)

    def _set_generalPrecision(self, *args) -> "bool" :
        """
        Gets and sets the general precision for distance values. This 
        value specifies the number of decimals to display.
        """
        return _core.UnitAndValuePreferences__set_generalPrecision(self, *args)

    def _get_angularPrecision(self) -> "int" :
        """
        Gets and sets the angular precision. This 
        value specifies the number of decimals to display.
        """
        return _core.UnitAndValuePreferences__get_angularPrecision(self)

    def _set_angularPrecision(self, *args) -> "bool" :
        """
        Gets and sets the angular precision. This 
        value specifies the number of decimals to display.
        """
        return _core.UnitAndValuePreferences__set_angularPrecision(self, *args)

    def _get_scientificNotationPrecision(self) -> "int" :
        """
        Gets and sets the number scientific notation precision. This 
        value specifies the number of decimals to display.
        """
        return _core.UnitAndValuePreferences__get_scientificNotationPrecision(self)

    def _set_scientificNotationPrecision(self, *args) -> "bool" :
        """
        Gets and sets the number scientific notation precision. This 
        value specifies the number of decimals to display.
        """
        return _core.UnitAndValuePreferences__set_scientificNotationPrecision(self, *args)

    def _get_footAndInchDisplayFormat(self) -> "adsk::core::FootAndInchDisplayFormats" :
        """Gets and sets the foot and inch display format."""
        return _core.UnitAndValuePreferences__get_footAndInchDisplayFormat(self)

    def _set_footAndInchDisplayFormat(self, *args) -> "bool" :
        """Gets and sets the foot and inch display format."""
        return _core.UnitAndValuePreferences__set_footAndInchDisplayFormat(self, *args)

    def _get_degreeDisplayFormat(self) -> "adsk::core::DegreeDisplayFormats" :
        """Gets and sets the degree display format."""
        return _core.UnitAndValuePreferences__get_degreeDisplayFormat(self)

    def _set_degreeDisplayFormat(self, *args) -> "bool" :
        """Gets and sets the degree display format."""
        return _core.UnitAndValuePreferences__set_degreeDisplayFormat(self, *args)

    def _get_isPeriodDecimalPoint(self) -> "bool" :
        """Gets and sets if the decimal is a period or comma."""
        return _core.UnitAndValuePreferences__get_isPeriodDecimalPoint(self)

    def _set_isPeriodDecimalPoint(self, *args) -> "bool" :
        """Gets and sets if the decimal is a period or comma."""
        return _core.UnitAndValuePreferences__set_isPeriodDecimalPoint(self, *args)

    def _get_areAbbreviationsForUnitDisplayed(self) -> "bool" :
        """Gets and sets if abbreviations are used for units display."""
        return _core.UnitAndValuePreferences__get_areAbbreviationsForUnitDisplayed(self)

    def _set_areAbbreviationsForUnitDisplayed(self, *args) -> "bool" :
        """Gets and sets if abbreviations are used for units display."""
        return _core.UnitAndValuePreferences__set_areAbbreviationsForUnitDisplayed(self, *args)

    def _get_areSymbolsForUnitDisplayed(self) -> "bool" :
        """Gets and sets if symbols are used for units display."""
        return _core.UnitAndValuePreferences__get_areSymbolsForUnitDisplayed(self)

    def _set_areSymbolsForUnitDisplayed(self, *args) -> "bool" :
        """Gets and sets if symbols are used for units display."""
        return _core.UnitAndValuePreferences__set_areSymbolsForUnitDisplayed(self, *args)

    def _get_isScientificNotationUsed(self) -> "bool" :
        """Gets and sets if scientific notation is used when displaying numbers."""
        return _core.UnitAndValuePreferences__get_isScientificNotationUsed(self)

    def _set_isScientificNotationUsed(self, *args) -> "bool" :
        """Gets and sets if scientific notation is used when displaying numbers."""
        return _core.UnitAndValuePreferences__set_isScientificNotationUsed(self, *args)

    def _get_useScientficNotationAbove(self) -> "int" :
        """
        Gets and sets the number of whole digits that will be displayed before
        switching to scientific notation.
        """
        return _core.UnitAndValuePreferences__get_useScientficNotationAbove(self)

    def _set_useScientficNotationAbove(self, *args) -> "bool" :
        """
        Gets and sets the number of whole digits that will be displayed before
        switching to scientific notation.
        """
        return _core.UnitAndValuePreferences__set_useScientficNotationAbove(self, *args)

    def _get_useScientficNotationBelow(self) -> "int" :
        """
        Gets and sets the number of non zero decimal places that will be 
        displayed before switching to scientific notation.
        """
        return _core.UnitAndValuePreferences__get_useScientficNotationBelow(self)

    def _set_useScientficNotationBelow(self, *args) -> "bool" :
        """
        Gets and sets the number of non zero decimal places that will be 
        displayed before switching to scientific notation.
        """
        return _core.UnitAndValuePreferences__set_useScientficNotationBelow(self, *args)

    def _get_areTrailingZerosHidden(self) -> "bool" :
        """Gets and sets if trailing zeros are hidden when displaying numbers."""
        return _core.UnitAndValuePreferences__get_areTrailingZerosHidden(self)

    def _set_areTrailingZerosHidden(self, *args) -> "bool" :
        """Gets and sets if trailing zeros are hidden when displaying numbers."""
        return _core.UnitAndValuePreferences__set_areTrailingZerosHidden(self, *args)

    def _get_minimumPrecisionWhenHidingZeros(self) -> "int" :
        """
        Gets and sets the minimum number of digits to the right of the decimal to display 
        before hiding trailing zeros.
        """
        return _core.UnitAndValuePreferences__get_minimumPrecisionWhenHidingZeros(self)

    def _set_minimumPrecisionWhenHidingZeros(self, *args) -> "bool" :
        """
        Gets and sets the minimum number of digits to the right of the decimal to display 
        before hiding trailing zeros.
        """
        return _core.UnitAndValuePreferences__set_minimumPrecisionWhenHidingZeros(self, *args)

    def _get_materialDisplayUnit(self) -> "adsk::core::MaterialDisplayUnits" :
        """Gets and sets the units types to use when displaying values."""
        return _core.UnitAndValuePreferences__get_materialDisplayUnit(self)

    def _set_materialDisplayUnit(self, *args) -> "bool" :
        """Gets and sets the units types to use when displaying values."""
        return _core.UnitAndValuePreferences__set_materialDisplayUnit(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.UnitAndValuePreferences__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.UnitAndValuePreferences__get_isValid(self)
UnitAndValuePreferences_swigregister = _core.UnitAndValuePreferences_swigregister
UnitAndValuePreferences_swigregister(UnitAndValuePreferences)

def UnitAndValuePreferences_classType() -> "char const *" :
  return _core.UnitAndValuePreferences_classType()
UnitAndValuePreferences_classType = _core.UnitAndValuePreferences_classType

UnitAndValuePreferences.__swig_getmethods__["generalPrecision"] = UnitAndValuePreferences._get_generalPrecision
UnitAndValuePreferences.__swig_setmethods__["generalPrecision"] = UnitAndValuePreferences._set_generalPrecision
UnitAndValuePreferences.generalPrecision = property(UnitAndValuePreferences._get_generalPrecision, UnitAndValuePreferences._set_generalPrecision, doc="Gets and sets the general precision for distance values. This\nvalue specifies the number of decimals to display.")

UnitAndValuePreferences.__swig_getmethods__["angularPrecision"] = UnitAndValuePreferences._get_angularPrecision
UnitAndValuePreferences.__swig_setmethods__["angularPrecision"] = UnitAndValuePreferences._set_angularPrecision
UnitAndValuePreferences.angularPrecision = property(UnitAndValuePreferences._get_angularPrecision, UnitAndValuePreferences._set_angularPrecision, doc="Gets and sets the angular precision. This\nvalue specifies the number of decimals to display.")

UnitAndValuePreferences.__swig_getmethods__["scientificNotationPrecision"] = UnitAndValuePreferences._get_scientificNotationPrecision
UnitAndValuePreferences.__swig_setmethods__["scientificNotationPrecision"] = UnitAndValuePreferences._set_scientificNotationPrecision
UnitAndValuePreferences.scientificNotationPrecision = property(UnitAndValuePreferences._get_scientificNotationPrecision, UnitAndValuePreferences._set_scientificNotationPrecision, doc="Gets and sets the number scientific notation precision. This\nvalue specifies the number of decimals to display.")

UnitAndValuePreferences.__swig_getmethods__["footAndInchDisplayFormat"] = UnitAndValuePreferences._get_footAndInchDisplayFormat
UnitAndValuePreferences.__swig_setmethods__["footAndInchDisplayFormat"] = UnitAndValuePreferences._set_footAndInchDisplayFormat
UnitAndValuePreferences.footAndInchDisplayFormat = property(UnitAndValuePreferences._get_footAndInchDisplayFormat, UnitAndValuePreferences._set_footAndInchDisplayFormat, doc="Gets and sets the foot and inch display format.")

UnitAndValuePreferences.__swig_getmethods__["degreeDisplayFormat"] = UnitAndValuePreferences._get_degreeDisplayFormat
UnitAndValuePreferences.__swig_setmethods__["degreeDisplayFormat"] = UnitAndValuePreferences._set_degreeDisplayFormat
UnitAndValuePreferences.degreeDisplayFormat = property(UnitAndValuePreferences._get_degreeDisplayFormat, UnitAndValuePreferences._set_degreeDisplayFormat, doc="Gets and sets the degree display format.")

UnitAndValuePreferences.__swig_getmethods__["isPeriodDecimalPoint"] = UnitAndValuePreferences._get_isPeriodDecimalPoint
UnitAndValuePreferences.__swig_setmethods__["isPeriodDecimalPoint"] = UnitAndValuePreferences._set_isPeriodDecimalPoint
UnitAndValuePreferences.isPeriodDecimalPoint = property(UnitAndValuePreferences._get_isPeriodDecimalPoint, UnitAndValuePreferences._set_isPeriodDecimalPoint, doc="Gets and sets if the decimal is a period or comma.")

UnitAndValuePreferences.__swig_getmethods__["areAbbreviationsForUnitDisplayed"] = UnitAndValuePreferences._get_areAbbreviationsForUnitDisplayed
UnitAndValuePreferences.__swig_setmethods__["areAbbreviationsForUnitDisplayed"] = UnitAndValuePreferences._set_areAbbreviationsForUnitDisplayed
UnitAndValuePreferences.areAbbreviationsForUnitDisplayed = property(UnitAndValuePreferences._get_areAbbreviationsForUnitDisplayed, UnitAndValuePreferences._set_areAbbreviationsForUnitDisplayed, doc="Gets and sets if abbreviations are used for units display.")

UnitAndValuePreferences.__swig_getmethods__["areSymbolsForUnitDisplayed"] = UnitAndValuePreferences._get_areSymbolsForUnitDisplayed
UnitAndValuePreferences.__swig_setmethods__["areSymbolsForUnitDisplayed"] = UnitAndValuePreferences._set_areSymbolsForUnitDisplayed
UnitAndValuePreferences.areSymbolsForUnitDisplayed = property(UnitAndValuePreferences._get_areSymbolsForUnitDisplayed, UnitAndValuePreferences._set_areSymbolsForUnitDisplayed, doc="Gets and sets if symbols are used for units display.")

UnitAndValuePreferences.__swig_getmethods__["isScientificNotationUsed"] = UnitAndValuePreferences._get_isScientificNotationUsed
UnitAndValuePreferences.__swig_setmethods__["isScientificNotationUsed"] = UnitAndValuePreferences._set_isScientificNotationUsed
UnitAndValuePreferences.isScientificNotationUsed = property(UnitAndValuePreferences._get_isScientificNotationUsed, UnitAndValuePreferences._set_isScientificNotationUsed, doc="Gets and sets if scientific notation is used when displaying numbers.")

UnitAndValuePreferences.__swig_getmethods__["useScientficNotationAbove"] = UnitAndValuePreferences._get_useScientficNotationAbove
UnitAndValuePreferences.__swig_setmethods__["useScientficNotationAbove"] = UnitAndValuePreferences._set_useScientficNotationAbove
UnitAndValuePreferences.useScientficNotationAbove = property(UnitAndValuePreferences._get_useScientficNotationAbove, UnitAndValuePreferences._set_useScientficNotationAbove, doc="Gets and sets the number of whole digits that will be displayed before\nswitching to scientific notation.")

UnitAndValuePreferences.__swig_getmethods__["useScientficNotationBelow"] = UnitAndValuePreferences._get_useScientficNotationBelow
UnitAndValuePreferences.__swig_setmethods__["useScientficNotationBelow"] = UnitAndValuePreferences._set_useScientficNotationBelow
UnitAndValuePreferences.useScientficNotationBelow = property(UnitAndValuePreferences._get_useScientficNotationBelow, UnitAndValuePreferences._set_useScientficNotationBelow, doc="Gets and sets the number of non zero decimal places that will be\ndisplayed before switching to scientific notation.")

UnitAndValuePreferences.__swig_getmethods__["areTrailingZerosHidden"] = UnitAndValuePreferences._get_areTrailingZerosHidden
UnitAndValuePreferences.__swig_setmethods__["areTrailingZerosHidden"] = UnitAndValuePreferences._set_areTrailingZerosHidden
UnitAndValuePreferences.areTrailingZerosHidden = property(UnitAndValuePreferences._get_areTrailingZerosHidden, UnitAndValuePreferences._set_areTrailingZerosHidden, doc="Gets and sets if trailing zeros are hidden when displaying numbers.")

UnitAndValuePreferences.__swig_getmethods__["minimumPrecisionWhenHidingZeros"] = UnitAndValuePreferences._get_minimumPrecisionWhenHidingZeros
UnitAndValuePreferences.__swig_setmethods__["minimumPrecisionWhenHidingZeros"] = UnitAndValuePreferences._set_minimumPrecisionWhenHidingZeros
UnitAndValuePreferences.minimumPrecisionWhenHidingZeros = property(UnitAndValuePreferences._get_minimumPrecisionWhenHidingZeros, UnitAndValuePreferences._set_minimumPrecisionWhenHidingZeros, doc="Gets and sets the minimum number of digits to the right of the decimal to display\nbefore hiding trailing zeros.")

UnitAndValuePreferences.__swig_getmethods__["materialDisplayUnit"] = UnitAndValuePreferences._get_materialDisplayUnit
UnitAndValuePreferences.__swig_setmethods__["materialDisplayUnit"] = UnitAndValuePreferences._set_materialDisplayUnit
UnitAndValuePreferences.materialDisplayUnit = property(UnitAndValuePreferences._get_materialDisplayUnit, UnitAndValuePreferences._set_materialDisplayUnit, doc="Gets and sets the units types to use when displaying values.")

UnitAndValuePreferences.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, UnitAndValuePreferences) else None
UnitAndValuePreferences.cast = lambda arg: arg if isinstance(arg, UnitAndValuePreferences) else None

class UnitsManager(Base):
    """
    Utility class used to work with Values and control default units. 
    Internal values are held in SI units (e.g. seconds, radians, kg for time, angle, mass) 
    with the exception that all lengths are in cm rather than meter and this affects derived 
    units (e.g. velocity is cm/s, volume is cm^3).
    Units are specified flexibility via strings (e.g. 'cm', 'in', 'inch', 'cm^3', 'cm*cm*cm', 'mph', 'mps' 'm/s').
    Units like length can be defaulted based on the design settings if the user does not explicitly 
    specify units - so '3' can be 3 inches, mm or cm depending on what the design
    settings are.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UnitsManager, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UnitsManager, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::UnitsManager *" : return _core.UnitsManager___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.UnitsManager___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.UnitsManager___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.UnitsManager_classType
    if _newclass:classType = staticmethod(_core.UnitsManager_classType)
    __swig_destroy__ = _core.delete_UnitsManager
    __del__ = lambda self : None;
    def _get_product(self) -> "adsk::core::Ptr< adsk::core::Product >" :
        """Returns the parent Product."""
        return _core.UnitsManager__get_product(self)

    def isValidExpression(self, *args) -> "bool" :
        """
        Checks to see if the given expression is valid. 
        expression : 
        units : The units to use when validating the expression. 
        Returns True if it is a valid expression.
        """
        return _core.UnitsManager_isValidExpression(self, *args)

    def evaluateExpression(self, *args) -> "double" :
        """
        Gets the value (in internal units) of the expression. 
        expression : EvaluateExpression('1cm + 1in') -> 3.54
        EvaluateExpression('1') -> -> depends on the DistanceUnits, with 'mm' it gives 0.1 
        units : If not supplied the units will default to the default length specified in the preferences. 
        Returns -1 AND GetLastError will return ExpressionError in the event of an error.
        """
        return _core.UnitsManager_evaluateExpression(self, *args)

    def convert(self, *args) -> "double" :
        """
        Converts a value from one unit to another. The input and output unit specifiers must be compatible.
        For example, 'in' (inches) and 'cm' (centimeters) will work because they both define length. 
        So Convert(1.5, 'in', 'ft') -> 0.125
        Convert(1.5, unitsManager.defaultLengthUnits, 'cm') -> depends on the current default distance units, with 'mm' it gives 0.15
        So Convert(1.5, 'in', 'kg') -> -1 and GetLastError returns ExpressionError (to denote error)
        So Convert(1, 'in', 'internalUnits') -> 2.54
        So Convert(1, 'internalUnits', 'in') -> 0.3937... 
        valueInInputUnits : The value to convert 
        inputUnits : The units of the value to convert 
        outputUnits : The units to convert the value to 
        Returns -1 AND GetLastError returns ExpressionError in the event of an error.
        """
        return _core.UnitsManager_convert(self, *args)

    def formatInternalValue(self, *args) -> "std::string" :
        """
        Formats the internal value as a string. The output string is formatted using the current 
        unit settings in preferences. The preferences control the number of decimal places, whether 
        units are abbreviated and several other things.
        FormatInternalValue(1.5, 'in') -> '0.591 in'
        FormatInternalValue(1.5, 'in', false) -> '0.591'
        FormatInternalValue(1.5, 'mm', true) -> '15.00 mm'
        FormatInternalValue(1.5) -> depends on DistanceUnits, might be '15.0 mm' 
        internalValue : The internal value to format. 
        displayUnits : The units to display the value in. If not supplied the units will default to the default length specified in the preferences. 
        showUnits : Specify false to exclude units from the format. The default is true. 
        Returns an empty string if the units are incorrectly specified.
        """
        return _core.UnitsManager_formatInternalValue(self, *args)

    def formatUnits(self, *args) -> "std::string" :
        """
        Formats the unit according to the user preferences
        'centimeter' -> 'cm'
        'inch' -> 'in'
        'cm* cm *cm / s' -> , 'cm^3 / s' 
        units : The unit to use when converting the value into a string. 
        Returns an empty string and GetLastError returns ExpressionError in the event of an error.
        """
        return _core.UnitsManager_formatUnits(self, *args)

    def standardizeExpression(self, *args) -> "std::string" :
        """
        Standardizes the expression in terms of spacing and user preferences. 
        StandardizeExpression('1.5') -> depends on distance units, but with mmight be '1.5 mm'
        StandardizeExpression('1.5', 'in') -> '1.5 in'
        StandardizeExpression('1.5 cm + 1.50001 centimeter') -> '1.5 cm + 1.50001 cm'
        StandardizeExpression('1.5', 'm * m * m / s') -> '1.5 m^3 /s' 
        expression : The expression to standardize 
        units : The units to apply to the standardized expression. If not supplied the units will default to the default length specified in the preferences. 
        Returns an empty string AND GetLastError returns ExpressionError in the event of an error.
        """
        return _core.UnitsManager_standardizeExpression(self, *args)

    def _get_internalUnits(self) -> "std::string" :
        """
        Returns a string that represents internal units - i.e. 'internalUnits'. 
        This can be used when performing conversions via Convert.
        """
        return _core.UnitsManager__get_internalUnits(self)

    def _get_defaultLengthUnits(self) -> "std::string" :
        """
        Returns the unit strings for the current default length unit as specified in preferences. - e.g. 'cm' or 'in'
        This is the string that is being used by Fusion 360 to represent the current length unit and is affected
        by the preference settings that let the user choose whether abbrevations and symbols can be used. This means
        that inch length units can be returned as inch, in, or '. If you need a consistent way of determing the current
        length unit, the distanceDisplayUnits of the FusionUnitsManager object returns an enum value.
        """
        return _core.UnitsManager__get_defaultLengthUnits(self)

    def _get_objectType(self) -> "char const *" : return _core.UnitsManager__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.UnitsManager__get_isValid(self)
UnitsManager_swigregister = _core.UnitsManager_swigregister
UnitsManager_swigregister(UnitsManager)

def UnitsManager_classType() -> "char const *" :
  return _core.UnitsManager_classType()
UnitsManager_classType = _core.UnitsManager_classType

UnitsManager.__swig_getmethods__["product"] = UnitsManager._get_product
UnitsManager.product = property(UnitsManager._get_product, doc="Returns the parent Product.")

UnitsManager.__swig_getmethods__["internalUnits"] = UnitsManager._get_internalUnits
UnitsManager.internalUnits = property(UnitsManager._get_internalUnits, doc="Returns a string that represents internal units - i.e. 'internalUnits'.\nThis can be used when performing conversions via Convert.")

UnitsManager.__swig_getmethods__["defaultLengthUnits"] = UnitsManager._get_defaultLengthUnits
UnitsManager.defaultLengthUnits = property(UnitsManager._get_defaultLengthUnits, doc="Returns the unit strings for the current default length unit as specified in preferences. - e.g. 'cm' or 'in'\nThis is the string that is being used by Fusion 360 to represent the current length unit and is affected\nby the preference settings that let the user choose whether abbrevations and symbols can be used. This means\nthat inch length units can be returned as inch, in, or '. If you need a consistent way of determing the current\nlength unit, the distanceDisplayUnits of the FusionUnitsManager object returns an enum value.")

UnitsManager.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, UnitsManager) else None
UnitsManager.cast = lambda arg: arg if isinstance(arg, UnitsManager) else None

class User(Base):
    """A class that represents a Fusion 360 User"""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, User, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, User, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::User *" : return _core.User___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.User___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.User___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.User_classType
    if _newclass:classType = staticmethod(_core.User_classType)
    __swig_destroy__ = _core.delete_User
    __del__ = lambda self : None;
    def _get_userName(self) -> "std::string" :
        """Returns the Username associated with this user's Autodesk account"""
        return _core.User__get_userName(self)

    def _get_displayName(self) -> "std::string" :
        """Returns display name of the user. (i.e. the name that shows up in the Fusion 360 UI)"""
        return _core.User__get_displayName(self)

    def _get_userId(self) -> "std::string" :
        """
        Returns the user's internal Autodesk account name.
        This can be used by applications sold through the Autodesk Exchange Store to verify that the user has in 
        fact purchased the product.
        """
        return _core.User__get_userId(self)

    def _get_email(self) -> "std::string" :
        """Get the email associated with this users Fusion 360 account"""
        return _core.User__get_email(self)

    def _get_objectType(self) -> "char const *" : return _core.User__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.User__get_isValid(self)
User_swigregister = _core.User_swigregister
User_swigregister(User)

def User_classType() -> "char const *" :
  return _core.User_classType()
User_classType = _core.User_classType

User.__swig_getmethods__["userName"] = User._get_userName
User.userName = property(User._get_userName, doc="Returns the Username associated with this user's Autodesk account")

User.__swig_getmethods__["displayName"] = User._get_displayName
User.displayName = property(User._get_displayName, doc="Returns display name of the user. (i.e. the name that shows up in the Fusion 360 UI)")

User.__swig_getmethods__["userId"] = User._get_userId
User.userId = property(User._get_userId, doc="Returns the user's internal Autodesk account name.\nThis can be used by applications sold through the Autodesk Exchange Store to verify that the user has in\nfact purchased the product.")

User.__swig_getmethods__["email"] = User._get_email
User.email = property(User._get_email, doc="Get the email associated with this users Fusion 360 account")

User.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, User) else None
User.cast = lambda arg: arg if isinstance(arg, User) else None

class UserInterface(Base):
    """Provides access to the user-interface related objects and functionality."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UserInterface, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UserInterface, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::UserInterface *" : return _core.UserInterface___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.UserInterface___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.UserInterface___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.UserInterface_classType
    if _newclass:classType = staticmethod(_core.UserInterface_classType)
    __swig_destroy__ = _core.delete_UserInterface
    __del__ = lambda self : None;
    def messageBox(self, *args) -> "adsk::core::DialogResults" :
        """
        Display a modal message box with the provided text. 
        text : The message text to display in the dialog. 
        title : If the optional title argument is provided, it sets the title for the dialog, otherwise the default product name is used. 
        buttons : The optional buttons array can be used to specify which buttons to display on the dialog.
        The first button provided is the default action.
        If buttons are not specified, the dialog will default to a single OK button. 
        icon : The optional icon argument can be used to specify which icon to display, otherwise the default of no icon is used. 
        The button pressed to dismiss the dialog is returned.
        """
        return _core.UserInterface_messageBox(self, *args)

    def inputBox(self, *args) -> "std::string" :
        """
        Displays a modal dialog to get string input from the user. 
        prompt : The message text to display in the dialog. 
        cancelled : Indicates if the dialog was cancelled. 
        title : Sets the title for the dialog if specified, otherwise the default product name is used. 
        defaultValue : The default string that's shown when the dialog is initially displayed, otherwise the input box is empty. 
        Returns the string entered by the user but because the user can click Cancel, the cancelled argument should be tested before using the string.
        """
        return _core.UserInterface_inputBox(self, *args)

    def selectEntity(self, *args) -> "adsk::core::Ptr< adsk::core::Selection >" :
        """
        Supports the selection of a single entity. This provides a simple way to prompt
        the user for a selection in a script. If you need more control over the selection a command
        should be created and a SelectionCommandInput used. 
        prompt : The prompt displayed to the user during the selection. 
        filter : A string defining the types of entities valid for selection. The valid list of selection filters can be found here: <a href='SelectionFilters_UM.htm'>Selection Filters</a>. 
        You can combine multiple types by using a comma delimiter. For example,
        the string 'PlanarFaces,ConstructionPlanes' will allow the selection of either a planar face or a construction plane. 
        Returns a Selection object that provides access the selected entity through it's 'entity'
        property along with the location in space where the entity was selected. Returns null if the selection was aborted.
        """
        return _core.UserInterface_selectEntity(self, *args)

    def createFileDialog(self) -> "adsk::core::Ptr< adsk::core::FileDialog >" :
        """
        Creates a new FileDialog object which provides the ability to show a standard file selection dialog
        to the user. 
        Returns the created FileDialog object that you can use to define the contents of and display a standard file dialog.
        """
        return _core.UserInterface_createFileDialog(self)

    def _get_activeSelections(self) -> "adsk::core::Ptr< adsk::core::Selections >" :
        """Gets the current set of selected objects."""
        return _core.UserInterface__get_activeSelections(self)

    def _get_activeWorkspace(self) -> "adsk::core::Ptr< adsk::core::Workspace >" :
        """
        Gets the active workspace. The active workspace is the one currently active in the user interface. 
        This can be null if there is no active product.
        """
        return _core.UserInterface__get_activeWorkspace(self)

    def _get_commandDefinitions(self) -> "adsk::core::Ptr< adsk::core::CommandDefinitions >" :
        """
        Gets all of the command definitions currently defined. This is all 
        command definitions both internal and those defined through the API.
        """
        return _core.UserInterface__get_commandDefinitions(self)

    def _get_toolbars(self) -> "adsk::core::Ptr< adsk::core::Toolbars >" :
        """
        Gets a collection that provides access to the toolbars. This includes
        the left and right QAT, and the Navbar.
        """
        return _core.UserInterface__get_toolbars(self)

    def _get_workspaces(self) -> "adsk::core::Ptr< adsk::core::Workspaces >" :
        """Gets all of the workspaces currently available."""
        return _core.UserInterface__get_workspaces(self)

    def workspacesByProductType(self, *args) -> "adsk::core::Ptr< adsk::core::WorkspaceList >" :
        """
        Returns all of the workspaces associated with the specified product. 
        productType : The name of the product that you want the associated workspaces for. The full list
        of available products can be obtained by using the Application.supportedProductTypes property. 
        Returns a list of the associated work spaces.
        """
        return _core.UserInterface_workspacesByProductType(self, *args)

    def _get_allToolbarPanels(self) -> "adsk::core::Ptr< adsk::core::ToolbarPanelList >" :
        """
        Gets all of the toolbar panels. This returns all of the panels
        available, regardless of which workspace or product they're associated with.
        """
        return _core.UserInterface__get_allToolbarPanels(self)

    def _get_workspacePreActivate(self) -> "adsk::core::Ptr< adsk::core::WorkspaceEvent >" :
        """
        The workspacePreActivate event fires at the VERY start of a workspace being activated.
        The client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.
        """
        return _core.UserInterface__get_workspacePreActivate(self)

    def _get_workspaceActivated(self) -> "adsk::core::Ptr< adsk::core::WorkspaceEvent >" :
        """
        The workspaceActivated event fires at the VERY end of a workspace being activated.
        The client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.
        """
        return _core.UserInterface__get_workspaceActivated(self)

    def _get_workspacePreDeactivate(self) -> "adsk::core::Ptr< adsk::core::WorkspaceEvent >" :
        """
        The workspacePreDeactivate event fires at the VERY start of a workspace being deactivated.
        The client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.
        """
        return _core.UserInterface__get_workspacePreDeactivate(self)

    def _get_workspaceDeactivated(self) -> "adsk::core::Ptr< adsk::core::WorkspaceEvent >" :
        """
        The workspaceDeactivated event fires at the VERY end of a workspace being deactivated.
        The client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.
        """
        return _core.UserInterface__get_workspaceDeactivated(self)

    def toolbarPanelsByProductType(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarPanelList >" :
        """
        Gets all of the toolbar panels associated with the specified product. 
        productType : The name of the product that you want the associated workspaces for. The full list
        of available products can be obtained by using the Application.supportedProductTypes property. 
        Returns a list of the toolbars associated with the specified product.
        """
        return _core.UserInterface_toolbarPanelsByProductType(self, *args)

    def _get_activeCommand(self) -> "std::string" :
        """Gets the id of the command definition from the active command (the one that is currently running)"""
        return _core.UserInterface__get_activeCommand(self)

    def terminateActiveCommand(self) -> "bool" :
        """
        Method that causes the currently active (running) command to be terminated 
        Returns true if terminating the active command was successful.
        """
        return _core.UserInterface_terminateActiveCommand(self)

    def _get_commandStarting(self) -> "adsk::core::Ptr< adsk::core::ApplicationCommandEvent >" :
        """
        The commandStarting event fires when a request for a command to be executed has been
        received but before the command is executed. Through this event, it's possible to 
        cancel the command from being executed.
        """
        return _core.UserInterface__get_commandStarting(self)

    def _get_commandCreated(self) -> "adsk::core::Ptr< adsk::core::ApplicationCommandEvent >" :
        """The commandCreated event fires immediately after the command is created."""
        return _core.UserInterface__get_commandCreated(self)

    def _get_commandTerminated(self) -> "adsk::core::Ptr< adsk::core::ApplicationCommandEvent >" :
        """Gets an event that is fired when a command is terminated."""
        return _core.UserInterface__get_commandTerminated(self)

    def createProgressDialog(self) -> "adsk::core::Ptr< adsk::core::ProgressDialog >" :
        """
        Creates a new ProgressDialog object that you can use to display and control a progress dialog. 
        Returns the created ProgressDialog object that you can use to define the contents of and display a progress dialog.
        """
        return _core.UserInterface_createProgressDialog(self)

    def _get_markingMenuDisplaying(self) -> "adsk::core::Ptr< adsk::core::MarkingMenuEvent >" :
        """
        The markingMenuDisplaying event fires just before the marking menu and context menus are displayed. The
        marking menu is the round menu displayed when the user right-clicks the mouse within Fusion 360. The context
        menu is the vertical menu displayed. The event provides both the marking menu and the context menu so you
        can examine and edit the contents of either one or both of them before they are displayed. Fusion 360 will then
        display the marking and context menu that you've customized. If either one is empty it will not be displayed.
        """
        return _core.UserInterface__get_markingMenuDisplaying(self)

    def _get_palettes(self) -> "adsk::core::Ptr< adsk::core::Palettes >" :
        """
        Returns the collection object that provides access to all of the existing
        palettes and provides the functionality to create new custom palettes.
        """
        return _core.UserInterface__get_palettes(self)

    def createFolderDialog(self) -> "adsk::core::Ptr< adsk::core::FolderDialog >" :
        """
        Creates a new FolderDialog object which provides the ability to show a standard folder selection dialog
        to the user. 
        Returns the created FolderDialog object that you can use to define the contents of and display a standard folder dialog.
        """
        return _core.UserInterface_createFolderDialog(self)

    def _get_allToolbarTabs(self) -> "adsk::core::Ptr< adsk::core::ToolbarTabList >" :
        """
        Gets all of the toolbar tabs. This returns all of the tabs
        available, regardless of which workspace or product they're associated with.
        """
        return _core.UserInterface__get_allToolbarTabs(self)

    def toolbarTabsByProductType(self, *args) -> "adsk::core::Ptr< adsk::core::ToolbarTabList >" :
        """
        Gets all of the toolbar tabs associated with the specified product. 
        productType : The name of the product that you want the associated tabs for. The full list
        of available products can be obtained by using the Application.supportedProductTypes property. 
        Returns a list of the tabs associated with the specified product.
        """
        return _core.UserInterface_toolbarTabsByProductType(self, *args)

    def _get_isTabbedToolbarUI(self) -> "bool" :
        """
        Returns true if Tabbed Toolbars are being used. 
        Returns true if using Tabbed Toolbars.
        """
        return _core.UserInterface__get_isTabbedToolbarUI(self)

    def _get_objectType(self) -> "char const *" : return _core.UserInterface__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.UserInterface__get_isValid(self)
UserInterface_swigregister = _core.UserInterface_swigregister
UserInterface_swigregister(UserInterface)

def UserInterface_classType() -> "char const *" :
  return _core.UserInterface_classType()
UserInterface_classType = _core.UserInterface_classType

UserInterface.__swig_getmethods__["activeSelections"] = UserInterface._get_activeSelections
UserInterface.activeSelections = property(UserInterface._get_activeSelections, doc="Gets the current set of selected objects.")

UserInterface.__swig_getmethods__["activeWorkspace"] = UserInterface._get_activeWorkspace
UserInterface.activeWorkspace = property(UserInterface._get_activeWorkspace, doc="Gets the active workspace. The active workspace is the one currently active in the user interface.\nThis can be null if there is no active product.")

UserInterface.__swig_getmethods__["commandDefinitions"] = UserInterface._get_commandDefinitions
UserInterface.commandDefinitions = property(UserInterface._get_commandDefinitions, doc="Gets all of the command definitions currently defined. This is all\ncommand definitions both internal and those defined through the API.")

UserInterface.__swig_getmethods__["toolbars"] = UserInterface._get_toolbars
UserInterface.toolbars = property(UserInterface._get_toolbars, doc="Gets a collection that provides access to the toolbars. This includes\nthe left and right QAT, and the Navbar.")

UserInterface.__swig_getmethods__["workspaces"] = UserInterface._get_workspaces
UserInterface.workspaces = property(UserInterface._get_workspaces, doc="Gets all of the workspaces currently available.")

UserInterface.__swig_getmethods__["allToolbarPanels"] = UserInterface._get_allToolbarPanels
UserInterface.allToolbarPanels = property(UserInterface._get_allToolbarPanels, doc="Gets all of the toolbar panels. This returns all of the panels\navailable, regardless of which workspace or product they're associated with.")

UserInterface.__swig_getmethods__["workspacePreActivate"] = UserInterface._get_workspacePreActivate
UserInterface.workspacePreActivate = property(UserInterface._get_workspacePreActivate, doc="The workspacePreActivate event fires at the VERY start of a workspace being activated.\nThe client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.")

UserInterface.__swig_getmethods__["workspaceActivated"] = UserInterface._get_workspaceActivated
UserInterface.workspaceActivated = property(UserInterface._get_workspaceActivated, doc="The workspaceActivated event fires at the VERY end of a workspace being activated.\nThe client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.")

UserInterface.__swig_getmethods__["workspacePreDeactivate"] = UserInterface._get_workspacePreDeactivate
UserInterface.workspacePreDeactivate = property(UserInterface._get_workspacePreDeactivate, doc="The workspacePreDeactivate event fires at the VERY start of a workspace being deactivated.\nThe client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.")

UserInterface.__swig_getmethods__["workspaceDeactivated"] = UserInterface._get_workspaceDeactivated
UserInterface.workspaceDeactivated = property(UserInterface._get_workspaceDeactivated, doc="The workspaceDeactivated event fires at the VERY end of a workspace being deactivated.\nThe client can add or remove WorkspaceEventHandlers from the WorkspaceEvent.")

UserInterface.__swig_getmethods__["activeCommand"] = UserInterface._get_activeCommand
UserInterface.activeCommand = property(UserInterface._get_activeCommand, doc="Gets the id of the command definition from the active command (the one that is currently running)")

UserInterface.__swig_getmethods__["commandStarting"] = UserInterface._get_commandStarting
UserInterface.commandStarting = property(UserInterface._get_commandStarting, doc="The commandStarting event fires when a request for a command to be executed has been\nreceived but before the command is executed. Through this event, it's possible to\ncancel the command from being executed.")

UserInterface.__swig_getmethods__["commandCreated"] = UserInterface._get_commandCreated
UserInterface.commandCreated = property(UserInterface._get_commandCreated, doc="The commandCreated event fires immediately after the command is created.")

UserInterface.__swig_getmethods__["commandTerminated"] = UserInterface._get_commandTerminated
UserInterface.commandTerminated = property(UserInterface._get_commandTerminated, doc="Gets an event that is fired when a command is terminated.")

UserInterface.__swig_getmethods__["markingMenuDisplaying"] = UserInterface._get_markingMenuDisplaying
UserInterface.markingMenuDisplaying = property(UserInterface._get_markingMenuDisplaying, doc="The markingMenuDisplaying event fires just before the marking menu and context menus are displayed. The\nmarking menu is the round menu displayed when the user right-clicks the mouse within Fusion 360. The context\nmenu is the vertical menu displayed. The event provides both the marking menu and the context menu so you\ncan examine and edit the contents of either one or both of them before they are displayed. Fusion 360 will then\ndisplay the marking and context menu that you've customized. If either one is empty it will not be displayed.")

UserInterface.__swig_getmethods__["palettes"] = UserInterface._get_palettes
UserInterface.palettes = property(UserInterface._get_palettes, doc="Returns the collection object that provides access to all of the existing\npalettes and provides the functionality to create new custom palettes.")

UserInterface.__swig_getmethods__["allToolbarTabs"] = UserInterface._get_allToolbarTabs
UserInterface.allToolbarTabs = property(UserInterface._get_allToolbarTabs, doc="Gets all of the toolbar tabs. This returns all of the tabs\navailable, regardless of which workspace or product they're associated with.")

UserInterface.__swig_getmethods__["isTabbedToolbarUI"] = UserInterface._get_isTabbedToolbarUI
UserInterface.isTabbedToolbarUI = property(UserInterface._get_isTabbedToolbarUI, doc="Returns true if Tabbed Toolbars are being used.\nReturns true if using Tabbed Toolbars.")

UserInterface.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, UserInterface) else None
UserInterface.cast = lambda arg: arg if isinstance(arg, UserInterface) else None

class UserInterfaceGeneralEventHandler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UserInterfaceGeneralEventHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UserInterfaceGeneralEventHandler, name)
    __repr__ = _swig_repr
    def notify(self, *args) -> "void" : return _core.UserInterfaceGeneralEventHandler_notify(self, *args)
    def __init__(self): 
        if self.__class__ == UserInterfaceGeneralEventHandler:
            _self = None
        else:
            _self = self
        this = _core.new_UserInterfaceGeneralEventHandler(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_UserInterfaceGeneralEventHandler
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _core.disown_UserInterfaceGeneralEventHandler(self)
        return weakref_proxy(self)
UserInterfaceGeneralEventHandler_swigregister = _core.UserInterfaceGeneralEventHandler_swigregister
UserInterfaceGeneralEventHandler_swigregister(UserInterfaceGeneralEventHandler)

UserInterfaceGeneralEventHandler.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, UserInterfaceGeneralEventHandler) else None
UserInterfaceGeneralEventHandler.cast = lambda arg: arg if isinstance(arg, UserInterfaceGeneralEventHandler) else None

class ValidateInputsEventHandler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ValidateInputsEventHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ValidateInputsEventHandler, name)
    __repr__ = _swig_repr
    def notify(self, *args) -> "void" : return _core.ValidateInputsEventHandler_notify(self, *args)
    def __init__(self): 
        if self.__class__ == ValidateInputsEventHandler:
            _self = None
        else:
            _self = self
        this = _core.new_ValidateInputsEventHandler(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_ValidateInputsEventHandler
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _core.disown_ValidateInputsEventHandler(self)
        return weakref_proxy(self)
ValidateInputsEventHandler_swigregister = _core.ValidateInputsEventHandler_swigregister
ValidateInputsEventHandler_swigregister(ValidateInputsEventHandler)

ValidateInputsEventHandler.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ValidateInputsEventHandler) else None
ValidateInputsEventHandler.cast = lambda arg: arg if isinstance(arg, ValidateInputsEventHandler) else None

class ValueInput(Base):
    """
    A ValueInput provides a flexible way of specifying a string, a double, a boolean, or object reference.
    No semantics are associated with a ValueInput (e.g. is the string valid, can the string
    be converted to a double) - it is merely a way of supplying information in 
    either string, double, boolean or object reference form as a function parameter. 
    ValueInput objects are typically used to specify things like an extrude depth, or hole dia, etc.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ValueInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ValueInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ValueInput *" : return _core.ValueInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ValueInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ValueInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ValueInput_classType
    if _newclass:classType = staticmethod(_core.ValueInput_classType)
    __swig_getmethods__["createByReal"] = lambda x: _core.ValueInput_createByReal
    if _newclass:createByReal = staticmethod(_core.ValueInput_createByReal)
    __swig_getmethods__["createByString"] = lambda x: _core.ValueInput_createByString
    if _newclass:createByString = staticmethod(_core.ValueInput_createByString)
    __swig_getmethods__["createByObject"] = lambda x: _core.ValueInput_createByObject
    if _newclass:createByObject = staticmethod(_core.ValueInput_createByObject)
    __swig_getmethods__["createByBoolean"] = lambda x: _core.ValueInput_createByBoolean
    if _newclass:createByBoolean = staticmethod(_core.ValueInput_createByBoolean)
    __swig_destroy__ = _core.delete_ValueInput
    __del__ = lambda self : None;
    def _get_realValue(self) -> "double" :
        """
        Gets the real value, if there is one.
        Returns -1 AND GetLastError returns ValueNotOfType if there is no real value.
        You can use the valueType property to determine which value type is currently used.
        """
        return _core.ValueInput__get_realValue(self)

    def _get_stringValue(self) -> "std::string" :
        """
        Gets the string value, if there is one.
        Returns an empty string AND GetLastError returns ValueNotOfType if there is no string value.
        You can use the valueType property to determine which value type is currently used.
        """
        return _core.ValueInput__get_stringValue(self)

    def _get_objectReference(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the object being referenced, if there is one.
        Returns null AND GetLastError returns ValueNotOfType if there is no object reference.
        You can use the valueType property to determine which value type is currently used.
        """
        return _core.ValueInput__get_objectReference(self)

    def _get_valueType(self) -> "adsk::core::ValueTypes" :
        """Returns the type of value this ValueInput currently represents."""
        return _core.ValueInput__get_valueType(self)

    def _get_booleanValue(self) -> "bool" :
        """
        Gets the boolean value, if there is one.
        Returns false AND GetLastError returns ValueNotOfType if there is no boolean value.
        You can use the valueType property to determine which value type is currently used.
        """
        return _core.ValueInput__get_booleanValue(self)

    def _get_objectType(self) -> "char const *" : return _core.ValueInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ValueInput__get_isValid(self)
ValueInput_swigregister = _core.ValueInput_swigregister
ValueInput_swigregister(ValueInput)

def ValueInput_classType() -> "char const *" :
  return _core.ValueInput_classType()
ValueInput_classType = _core.ValueInput_classType

def ValueInput_createByReal(*args) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
  return _core.ValueInput_createByReal(*args)
ValueInput_createByReal = _core.ValueInput_createByReal

def ValueInput_createByString(*args) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
  return _core.ValueInput_createByString(*args)
ValueInput_createByString = _core.ValueInput_createByString

def ValueInput_createByObject(*args) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
  return _core.ValueInput_createByObject(*args)
ValueInput_createByObject = _core.ValueInput_createByObject

def ValueInput_createByBoolean(*args) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
  return _core.ValueInput_createByBoolean(*args)
ValueInput_createByBoolean = _core.ValueInput_createByBoolean

ValueInput.__swig_getmethods__["realValue"] = ValueInput._get_realValue
ValueInput.realValue = property(ValueInput._get_realValue, doc="Gets the real value, if there is one.\nReturns -1 AND GetLastError returns ValueNotOfType if there is no real value.\nYou can use the valueType property to determine which value type is currently used.")

ValueInput.__swig_getmethods__["stringValue"] = ValueInput._get_stringValue
ValueInput.stringValue = property(ValueInput._get_stringValue, doc="Gets the string value, if there is one.\nReturns an empty string AND GetLastError returns ValueNotOfType if there is no string value.\nYou can use the valueType property to determine which value type is currently used.")

ValueInput.__swig_getmethods__["objectReference"] = ValueInput._get_objectReference
ValueInput.objectReference = property(ValueInput._get_objectReference, doc="Gets the object being referenced, if there is one.\nReturns null AND GetLastError returns ValueNotOfType if there is no object reference.\nYou can use the valueType property to determine which value type is currently used.")

ValueInput.__swig_getmethods__["valueType"] = ValueInput._get_valueType
ValueInput.valueType = property(ValueInput._get_valueType, doc="Returns the type of value this ValueInput currently represents.")

ValueInput.__swig_getmethods__["booleanValue"] = ValueInput._get_booleanValue
ValueInput.booleanValue = property(ValueInput._get_booleanValue, doc="Gets the boolean value, if there is one.\nReturns false AND GetLastError returns ValueNotOfType if there is no boolean value.\nYou can use the valueType property to determine which value type is currently used.")

ValueInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ValueInput) else None
ValueInput.cast = lambda arg: arg if isinstance(arg, ValueInput) else None

class Vector2D(Base):
    """
    Transient 2D vector. This object is a wrapper for 2D vector data and is used to 
    pass vector data in and out of the API.
    They are created statically using the create method of the Vector2D class.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector2D, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Vector2D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Vector2D *" : return _core.Vector2D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Vector2D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Vector2D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Vector2D_classType
    if _newclass:classType = staticmethod(_core.Vector2D_classType)
    __swig_getmethods__["create"] = lambda x: _core.Vector2D_create
    if _newclass:create = staticmethod(_core.Vector2D_create)
    __swig_destroy__ = _core.delete_Vector2D
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Add a vector to this vector. 
        vector : The vector to add to this vector. 
        Returns true if successful.
        """
        return _core.Vector2D_add(self, *args)

    def angleTo(self, *args) -> "double" :
        """
        Gets the angle between this vector and another vector. 
        vector : The vector to measure the angle to. 
        Returns the angle in radians.
        """
        return _core.Vector2D_angleTo(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Vector2D >" :
        """
        Creates and returns an independent copy of this Vector2D object. 
        Returns a new Vector2D object that is a copy of this Vector2D object.
        """
        return _core.Vector2D_copy(self)

    def dotProduct(self, *args) -> "double" :
        """
        Calculates the Dot Product of this vector and an input vector. 
        vector : The vector to use in the dot product calculation. 
        Returns the dot product of the two vectors.
        """
        return _core.Vector2D_dotProduct(self, *args)

    def asArray(self) -> "std::vector< double,std::allocator< double > >" :
        """
        Returns the vector values as an array [x, y]. 
        Returns an array of the vector's values [x, y].
        """
        return _core.Vector2D_asArray(self)

    def isEqualTo(self, *args) -> "bool" :
        """
        Compare this vector with another to check for equality. 
        vector : The vector to compare with for equality. 
        Returns true if the vectors are equal.
        """
        return _core.Vector2D_isEqualTo(self, *args)

    def isParallelTo(self, *args) -> "bool" :
        """
        Compare this vector with another to check for parallelism. 
        vector : The vector to compare with for parallelism. 
        Returns true if the vectors are parallel.
        """
        return _core.Vector2D_isParallelTo(self, *args)

    def isPerpendicularTo(self, *args) -> "bool" :
        """
        Compare this vector with another to check for perpendicularity. 
        vector : The vector to compare with for perpendicularity. 
        Returns true if the vectors are perpendicular.
        """
        return _core.Vector2D_isPerpendicularTo(self, *args)

    def _get_length(self) -> "double" :
        """Gets the length of the vector."""
        return _core.Vector2D__get_length(self)

    def normalize(self) -> "bool" :
        """
        Normalizes the vector.
        Normalization makes the vector length equal to one.
        The vector should not be zero length. 
        Returns true if successful.
        """
        return _core.Vector2D_normalize(self)

    def setWithArray(self, *args) -> "bool" :
        """
        Sets the definition of the vector by specifying an array containing the x and y coordinates. 
        coordinates : An array that specifies the values for the x and y coordinates of the vector. 
        Returns true if successful
        """
        return _core.Vector2D_setWithArray(self, *args)

    def scaleBy(self, *args) -> "bool" :
        """
        Scales the vector by specifying a scaling factor. 
        scale : The scale factor to multiple the vector by (i.e. 1.5). 
        Returns true if successful.
        """
        return _core.Vector2D_scaleBy(self, *args)

    def subtract(self, *args) -> "bool" :
        """
        Subtract a vector from this vector. 
        vector : The vector to subtract from this vector. 
        Returns true if successful.
        """
        return _core.Vector2D_subtract(self, *args)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms the vector by specifying a 2D transformation matrix. 
        matrix : The Matrix2D object that defines the transformation. 
        Returns true if successful.
        """
        return _core.Vector2D_transformBy(self, *args)

    def asPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """
        Return a point with the same x and y values as this vector. 
        Returns the new point.
        """
        return _core.Vector2D_asPoint(self)

    def _get_x(self) -> "double" :
        """Gets and sets the X coordinate of the vector."""
        return _core.Vector2D__get_x(self)

    def _set_x(self, *args) -> "bool" :
        """Gets and sets the X coordinate of the vector."""
        return _core.Vector2D__set_x(self, *args)

    def _get_y(self) -> "double" :
        """Gets and sets the Y coordinate of the vector."""
        return _core.Vector2D__get_y(self)

    def _set_y(self, *args) -> "bool" :
        """Gets and sets the Y coordinate of the vector."""
        return _core.Vector2D__set_y(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Vector2D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Vector2D__get_isValid(self)
Vector2D_swigregister = _core.Vector2D_swigregister
Vector2D_swigregister(Vector2D)

def Vector2D_classType() -> "char const *" :
  return _core.Vector2D_classType()
Vector2D_classType = _core.Vector2D_classType

def Vector2D_create(x : 'double'=0, y : 'double'=0) -> "adsk::core::Ptr< adsk::core::Vector2D >" :
  return _core.Vector2D_create(x, y)
Vector2D_create = _core.Vector2D_create

Vector2D.__swig_getmethods__["length"] = Vector2D._get_length
Vector2D.length = property(Vector2D._get_length, doc="Gets the length of the vector.")

Vector2D.__swig_getmethods__["x"] = Vector2D._get_x
Vector2D.__swig_setmethods__["x"] = Vector2D._set_x
Vector2D.x = property(Vector2D._get_x, Vector2D._set_x, doc="Gets and sets the X coordinate of the vector.")

Vector2D.__swig_getmethods__["y"] = Vector2D._get_y
Vector2D.__swig_setmethods__["y"] = Vector2D._set_y
Vector2D.y = property(Vector2D._get_y, Vector2D._set_y, doc="Gets and sets the Y coordinate of the vector.")

Vector2D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Vector2D) else None
Vector2D.cast = lambda arg: arg if isinstance(arg, Vector2D) else None

class Vector3D(Base):
    """
    Transient 3D vector. This object is a wrapper over 3D vector data and is used as way to pass vector data
    in and out of the API and as a convenience when operating on vector data.
    They are created statically using the create method of the Vector3D class.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector3D, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Vector3D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Vector3D *" : return _core.Vector3D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Vector3D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Vector3D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Vector3D_classType
    if _newclass:classType = staticmethod(_core.Vector3D_classType)
    __swig_getmethods__["create"] = lambda x: _core.Vector3D_create
    if _newclass:create = staticmethod(_core.Vector3D_create)
    __swig_destroy__ = _core.delete_Vector3D
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Adds a vector to this vector. 
        vector : The vector to add to this vector. 
        Returns true if successful.
        """
        return _core.Vector3D_add(self, *args)

    def angleTo(self, *args) -> "double" :
        """
        Determines the angle between this vector and the specified vector. 
        vector : The vector to measure the angle to. 
        The angle in radians between this vector and the specified vector.
        """
        return _core.Vector3D_angleTo(self, *args)

    def asPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        Returns a new point with the same coordinate values as this vector. 
        Return the new point.
        """
        return _core.Vector3D_asPoint(self)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Creates a copy of this vector. 
        Returns the new vector copy.
        """
        return _core.Vector3D_copy(self)

    def crossProduct(self, *args) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Returns the cross product between this vector and the specified vector. 
        vector : The vector to take the cross product to. 
        Returns the vector cross product.
        """
        return _core.Vector3D_crossProduct(self, *args)

    def dotProduct(self, *args) -> "double" :
        """
        Returns the dot product between this vector and the specified vector. 
        vector : The vector to take the dot product to. 
        Returns the dot product value.
        """
        return _core.Vector3D_dotProduct(self, *args)

    def asArray(self) -> "std::vector< double,std::allocator< double > >" :
        """
        Returns the vector coordinates as an array [x, y, z]. 
        Returns the array of vector coordinates [x, y, z].
        """
        return _core.Vector3D_asArray(self)

    def isEqualTo(self, *args) -> "bool" :
        """
        Determines if this vector is equal to the specified vector. 
        vector : The vector to test equality to. 
        Returns true if the vectors are equal.
        """
        return _core.Vector3D_isEqualTo(self, *args)

    def isParallelTo(self, *args) -> "bool" :
        """
        Determines if the input vector is parallel with this vector. 
        vector : The vector to test parallelism to. 
        Returns true if the vectors are parallel.
        """
        return _core.Vector3D_isParallelTo(self, *args)

    def isPerpendicularTo(self, *args) -> "bool" :
        """
        Determines if the input vector is perpendicular to this vector. 
        vector : The vector to test perpendicularity to. 
        Returns true if the vectors are perpendicular.
        """
        return _core.Vector3D_isPerpendicularTo(self, *args)

    def _get_length(self) -> "double" :
        """Get the length of this vector."""
        return _core.Vector3D__get_length(self)

    def normalize(self) -> "bool" :
        """
        Makes this vector of unit length.
        This vector should not be zero length. 
        Returns true if successful.
        """
        return _core.Vector3D_normalize(self)

    def setWithArray(self, *args) -> "bool" :
        """
        Reset this vector with the coordinate values in an array [x, y, z]. 
        coordinates : The array of coordinate values. 
        Returns true if successful.
        """
        return _core.Vector3D_setWithArray(self, *args)

    def scaleBy(self, *args) -> "bool" :
        """
        Scale this vector by the specified product. 
        scale : The scale value. 
        Returns true if successful.
        """
        return _core.Vector3D_scaleBy(self, *args)

    def subtract(self, *args) -> "bool" :
        """
        Subtract a vector from this vector. 
        vector : The vector to subtract. 
        Returns true if successful.
        """
        return _core.Vector3D_subtract(self, *args)

    def transformBy(self, *args) -> "bool" :
        """
        Transform this vector by the specified matrix. 
        matrix : The transformation matrix. 
        Returns true if successful.
        """
        return _core.Vector3D_transformBy(self, *args)

    def _get_x(self) -> "double" :
        """The x value."""
        return _core.Vector3D__get_x(self)

    def _set_x(self, *args) -> "bool" :
        """The x value."""
        return _core.Vector3D__set_x(self, *args)

    def _get_y(self) -> "double" :
        """The y value."""
        return _core.Vector3D__get_y(self)

    def _set_y(self, *args) -> "bool" :
        """The y value."""
        return _core.Vector3D__set_y(self, *args)

    def _get_z(self) -> "double" :
        """The z value."""
        return _core.Vector3D__get_z(self)

    def _set_z(self, *args) -> "bool" :
        """The z value."""
        return _core.Vector3D__set_z(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Vector3D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Vector3D__get_isValid(self)
Vector3D_swigregister = _core.Vector3D_swigregister
Vector3D_swigregister(Vector3D)

def Vector3D_classType() -> "char const *" :
  return _core.Vector3D_classType()
Vector3D_classType = _core.Vector3D_classType

def Vector3D_create(x : 'double'=0, y : 'double'=0, z : 'double'=0) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
  return _core.Vector3D_create(x, y, z)
Vector3D_create = _core.Vector3D_create

Vector3D.__swig_getmethods__["length"] = Vector3D._get_length
Vector3D.length = property(Vector3D._get_length, doc="Get the length of this vector.")

Vector3D.__swig_getmethods__["x"] = Vector3D._get_x
Vector3D.__swig_setmethods__["x"] = Vector3D._set_x
Vector3D.x = property(Vector3D._get_x, Vector3D._set_x, doc="The x value.")

Vector3D.__swig_getmethods__["y"] = Vector3D._get_y
Vector3D.__swig_setmethods__["y"] = Vector3D._set_y
Vector3D.y = property(Vector3D._get_y, Vector3D._set_y, doc="The y value.")

Vector3D.__swig_getmethods__["z"] = Vector3D._get_z
Vector3D.__swig_setmethods__["z"] = Vector3D._set_z
Vector3D.z = property(Vector3D._get_z, Vector3D._set_z, doc="The z value.")

Vector3D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Vector3D) else None
Vector3D.cast = lambda arg: arg if isinstance(arg, Vector3D) else None

class Viewport(Base):
    """A viewport within Fusion 360. A viewport is the window where the model is displayed."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Viewport, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Viewport, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Viewport *" : return _core.Viewport___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Viewport___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Viewport___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Viewport_classType
    if _newclass:classType = staticmethod(_core.Viewport_classType)
    __swig_destroy__ = _core.delete_Viewport
    __del__ = lambda self : None;
    def refresh(self) -> "bool" :
        """
        Forces the view to refresh. It is sometimes useful to force a refresh to 
        be able to see edits that have been made using the API. 
        Returns true if the operation was successful.
        """
        return _core.Viewport_refresh(self)

    def _get_camera(self) -> "adsk::core::Ptr< adsk::core::Camera >" :
        """
        Gets and sets the camera associated with the view.
        The camera returned is a copy of the current camera
        settings of the view. Editing the properties of the
        camera will have no affect on the viewport until the 
        camera is assigned back to the viewport.
        """
        return _core.Viewport__get_camera(self)

    def _set_camera(self, *args) -> "bool" :
        """
        Gets and sets the camera associated with the view.
        The camera returned is a copy of the current camera
        settings of the view. Editing the properties of the
        camera will have no affect on the viewport until the 
        camera is assigned back to the viewport.
        """
        return _core.Viewport__set_camera(self, *args)

    def _get_height(self) -> "int" :
        """Returns the height of the viewport in pixels."""
        return _core.Viewport__get_height(self)

    def _get_width(self) -> "int" :
        """Returns the width of the viewport in pixels."""
        return _core.Viewport__get_width(self)

    def _get_isFullScreen(self) -> "bool" :
        """Gets and sets if the view is in full screen mode."""
        return _core.Viewport__get_isFullScreen(self)

    def _set_isFullScreen(self, *args) -> "bool" :
        """Gets and sets if the view is in full screen mode."""
        return _core.Viewport__set_isFullScreen(self, *args)

    def saveAsImageFile(self, *args) -> "bool" :
        """
        Saves the current view to the specified image file. The view is re-rendered to the specified size and not
        just scaled from the existing view. This allows you to generate higher resolution images than you could
        do with just a screen capture. 
        filename : The full filename, including the path, of the image file. The type of image file to be created is inferred from the extension of the filename. 
        width : The width in pixels of the output image. A value of zero indicates that the current width of the viewport is to be used. 
        height : The height in pixels of the output image. A value of zero indicates that the current height of the viewport is to be used. 
        Returns true if the operation was successful.
        """
        return _core.Viewport_saveAsImageFile(self, *args)

    def _get_visualStyle(self) -> "adsk::core::VisualStyles" :
        """Gets and sets the current visual style being used."""
        return _core.Viewport__get_visualStyle(self)

    def _set_visualStyle(self, *args) -> "bool" :
        """Gets and sets the current visual style being used."""
        return _core.Viewport__set_visualStyle(self, *args)

    def fit(self) -> "bool" :
        """
        Forces a camera change so that all of the graphics are visible in the viewport. 
        Returns true if the fit was successful.
        """
        return _core.Viewport_fit(self)

    def modelToViewSpace(self, *args) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """
        A specified point in model space returns the equivalent point in view space. 
        modelCoordinate : A coordinate in model space. 
        Returns the equivalent point in view space.
        """
        return _core.Viewport_modelToViewSpace(self, *args)

    def viewToModelSpace(self, *args) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        A specified point in view space returns the equivalent point in model space.
        Because view space is 2D and model space is 3D, the depth of the point is 
        returned is somewhat arbitrary along the eye to target point direction. 
        viewCoordinate : A coordinate in view space. 
        Returns the equivalent point in model space.
        """
        return _core.Viewport_viewToModelSpace(self, *args)

    def screenToView(self, *args) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """
        Converts a 2D screen point into the equivalent viewport coordinate. 
        screenCoordinate : A 2D coordinate in screen space. 
        (0,0) indicates the upper-left corner of the entire screen. 
        Returns the equivalent point in the viewport. This can return null in the case
        where the input screen point does not lie within the viewport.
        """
        return _core.Viewport_screenToView(self, *args)

    def viewToScreen(self, *args) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """
        Converts a 2D viewPort point into the equivalent screen coordinate. 
        viewCoordinate : A 2D coordinate in the viewport. 
        (0,0) indicates the upper-left corner of the viewport. 
        Returns the equivalent point in the screen. This can return null in the case where
        the input point is outside the bounds of the screen, which also means it's outside
        any viewport.
        """
        return _core.Viewport_viewToScreen(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Viewport__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Viewport__get_isValid(self)
Viewport_swigregister = _core.Viewport_swigregister
Viewport_swigregister(Viewport)

def Viewport_classType() -> "char const *" :
  return _core.Viewport_classType()
Viewport_classType = _core.Viewport_classType

Viewport.__swig_getmethods__["camera"] = Viewport._get_camera
Viewport.__swig_setmethods__["camera"] = Viewport._set_camera
Viewport.camera = property(Viewport._get_camera, Viewport._set_camera, doc="Gets and sets the camera associated with the view.\nThe camera returned is a copy of the current camera\nsettings of the view. Editing the properties of the\ncamera will have no affect on the viewport until the\ncamera is assigned back to the viewport.")

Viewport.__swig_getmethods__["height"] = Viewport._get_height
Viewport.height = property(Viewport._get_height, doc="Returns the height of the viewport in pixels.")

Viewport.__swig_getmethods__["width"] = Viewport._get_width
Viewport.width = property(Viewport._get_width, doc="Returns the width of the viewport in pixels.")

Viewport.__swig_getmethods__["isFullScreen"] = Viewport._get_isFullScreen
Viewport.__swig_setmethods__["isFullScreen"] = Viewport._set_isFullScreen
Viewport.isFullScreen = property(Viewport._get_isFullScreen, Viewport._set_isFullScreen, doc="Gets and sets if the view is in full screen mode.")

Viewport.__swig_getmethods__["visualStyle"] = Viewport._get_visualStyle
Viewport.__swig_setmethods__["visualStyle"] = Viewport._set_visualStyle
Viewport.visualStyle = property(Viewport._get_visualStyle, Viewport._set_visualStyle, doc="Gets and sets the current visual style being used.")

Viewport.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Viewport) else None
Viewport.cast = lambda arg: arg if isinstance(arg, Viewport) else None

class WebRequestEventHandler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WebRequestEventHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WebRequestEventHandler, name)
    __repr__ = _swig_repr
    def notify(self, *args) -> "void" : return _core.WebRequestEventHandler_notify(self, *args)
    def __init__(self): 
        if self.__class__ == WebRequestEventHandler:
            _self = None
        else:
            _self = self
        this = _core.new_WebRequestEventHandler(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_WebRequestEventHandler
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _core.disown_WebRequestEventHandler(self)
        return weakref_proxy(self)
WebRequestEventHandler_swigregister = _core.WebRequestEventHandler_swigregister
WebRequestEventHandler_swigregister(WebRequestEventHandler)

WebRequestEventHandler.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, WebRequestEventHandler) else None
WebRequestEventHandler.cast = lambda arg: arg if isinstance(arg, WebRequestEventHandler) else None

class Workspace(Base):
    """
    A Workspace provides access to a set of panels, which contain commands that
    are relevant for that particular workspace. The user can switch from one 
    workspace to another in a product (e.g. switch from Model to Sculpt in Fusion 360).
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Workspace, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Workspace, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Workspace *" : return _core.Workspace___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Workspace___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Workspace___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Workspace_classType
    if _newclass:classType = staticmethod(_core.Workspace_classType)
    __swig_destroy__ = _core.delete_Workspace
    __del__ = lambda self : None;
    def _get_id(self) -> "std::string" :
        """
        Gets the unique Id of the workspace that can be used programmatically
        to find a specific workspace. It is not affected by the current
        language.
        """
        return _core.Workspace__get_id(self)

    def _get_isActive(self) -> "bool" :
        """Gets if the workspace is currently active - i.e. displayed"""
        return _core.Workspace__get_isActive(self)

    def _get_isNative(self) -> "bool" :
        """Gets if this workspace is native to Fusion 360 or was created via the API."""
        return _core.Workspace__get_isNative(self)

    def _get_name(self) -> "std::string" :
        """
        Gets the visible name of the workspace as seen in the user interface.
        This is the localized name.
        """
        return _core.Workspace__get_name(self)

    def _get_toolbarPanels(self) -> "adsk::core::Ptr< adsk::core::ToolbarPanels >" :
        """
        Gets the collection containing the panels associated with this workspace.
        It's through this collection that you can add new toolbar panels.
        """
        return _core.Workspace__get_toolbarPanels(self)

    def _get_resourceFolder(self) -> "std::string" :
        """Gets or sets the resource folder."""
        return _core.Workspace__get_resourceFolder(self)

    def _set_resourceFolder(self, *args) -> "bool" :
        """Gets or sets the resource folder."""
        return _core.Workspace__set_resourceFolder(self, *args)

    def activate(self) -> "bool" :
        """
        Activate the workspace (assuming it is valid to do so - a SIM workspace can't
        be activated if Fusion 360 is the active product). 
        Boolean return that indicates if the activation was successful or not.
        """
        return _core.Workspace_activate(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes this workspace. Only a workspace added by the API can be deleted, (IsNative is false). 
        Boolean return that indicates if the deletion was successful or not.
        """
        return _core.Workspace_deleteMe(self)

    def _get_productType(self) -> "std::string" :
        """Returns the name of the product this workspace is associated with."""
        return _core.Workspace__get_productType(self)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip. 
        the tool clip is the image shown when the user hovers the mouse over the workspace name in the workspace drop-down.
        """
        return _core.Workspace__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip. 
        the tool clip is the image shown when the user hovers the mouse over the workspace name in the workspace drop-down.
        """
        return _core.Workspace__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the tooltip text displayed for the workspace. This is the first line of text shown when the
        user hovers over the workspace name in the Fusion 360 toolbar drop-down. This is typically the name of the
        workspace. This is different from the name in the that the name is a short name shown in the drop-down.
        The tooltip is only shown when the user hovers over the name and box appears providing more information 
        about the workspace. For example, the name of the model workspace is 'Model' and the tooltip is 'Model Workspace'.
        """
        return _core.Workspace__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the tooltip text displayed for the workspace. This is the first line of text shown when the
        user hovers over the workspace name in the Fusion 360 toolbar drop-down. This is typically the name of the
        workspace. This is different from the name in the that the name is a short name shown in the drop-down.
        The tooltip is only shown when the user hovers over the name and box appears providing more information 
        about the workspace. For example, the name of the model workspace is 'Model' and the tooltip is 'Model Workspace'.
        """
        return _core.Workspace__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets the tooltip description displayed for the workspace. The tooltip description is a longer
        description of the workspace and is only displayed when the user hovers over the workspace name in
        the Fusion 360 toolbar drop-down. The pop-up dialog that appears contains the tooltip, the tooltip
        description, and the toolclip which is a picture.
        """
        return _core.Workspace__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets the tooltip description displayed for the workspace. The tooltip description is a longer
        description of the workspace and is only displayed when the user hovers over the workspace name in
        the Fusion 360 toolbar drop-down. The pop-up dialog that appears contains the tooltip, the tooltip
        description, and the toolclip which is a picture.
        """
        return _core.Workspace__set_tooltipDescription(self, *args)

    def _get_toolbarTabs(self) -> "adsk::core::Ptr< adsk::core::ToolbarTabs >" :
        """Gets the collection containing the tabs associated with this workspace."""
        return _core.Workspace__get_toolbarTabs(self)

    def _get_objectType(self) -> "char const *" : return _core.Workspace__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Workspace__get_isValid(self)
Workspace_swigregister = _core.Workspace_swigregister
Workspace_swigregister(Workspace)

def Workspace_classType() -> "char const *" :
  return _core.Workspace_classType()
Workspace_classType = _core.Workspace_classType

Workspace.__swig_getmethods__["id"] = Workspace._get_id
Workspace.id = property(Workspace._get_id, doc="Gets the unique Id of the workspace that can be used programmatically\nto find a specific workspace. It is not affected by the current\nlanguage.")

Workspace.__swig_getmethods__["isActive"] = Workspace._get_isActive
Workspace.isActive = property(Workspace._get_isActive, doc="Gets if the workspace is currently active - i.e. displayed")

Workspace.__swig_getmethods__["isNative"] = Workspace._get_isNative
Workspace.isNative = property(Workspace._get_isNative, doc="Gets if this workspace is native to Fusion 360 or was created via the API.")

Workspace.__swig_getmethods__["name"] = Workspace._get_name
Workspace.name = property(Workspace._get_name, doc="Gets the visible name of the workspace as seen in the user interface.\nThis is the localized name.")

Workspace.__swig_getmethods__["toolbarPanels"] = Workspace._get_toolbarPanels
Workspace.toolbarPanels = property(Workspace._get_toolbarPanels, doc="Gets the collection containing the panels associated with this workspace.\nIt's through this collection that you can add new toolbar panels.")

Workspace.__swig_getmethods__["resourceFolder"] = Workspace._get_resourceFolder
Workspace.__swig_setmethods__["resourceFolder"] = Workspace._set_resourceFolder
Workspace.resourceFolder = property(Workspace._get_resourceFolder, Workspace._set_resourceFolder, doc="Gets or sets the resource folder.")

Workspace.__swig_getmethods__["productType"] = Workspace._get_productType
Workspace.productType = property(Workspace._get_productType, doc="Returns the name of the product this workspace is associated with.")

Workspace.__swig_getmethods__["toolClipFilename"] = Workspace._get_toolClipFilename
Workspace.__swig_setmethods__["toolClipFilename"] = Workspace._set_toolClipFilename
Workspace.toolClipFilename = property(Workspace._get_toolClipFilename, Workspace._set_toolClipFilename, doc="Gets or sets the full filename of the image file (png) used for the tool clip.\nthe tool clip is the image shown when the user hovers the mouse over the workspace name in the workspace drop-down.")

Workspace.__swig_getmethods__["tooltip"] = Workspace._get_tooltip
Workspace.__swig_setmethods__["tooltip"] = Workspace._set_tooltip
Workspace.tooltip = property(Workspace._get_tooltip, Workspace._set_tooltip, doc="Gets or sets the tooltip text displayed for the workspace. This is the first line of text shown when the\nuser hovers over the workspace name in the Fusion 360 toolbar drop-down. This is typically the name of the\nworkspace. This is different from the name in the that the name is a short name shown in the drop-down.\nThe tooltip is only shown when the user hovers over the name and box appears providing more information\nabout the workspace. For example, the name of the model workspace is 'Model' and the tooltip is 'Model Workspace'.")

Workspace.__swig_getmethods__["tooltipDescription"] = Workspace._get_tooltipDescription
Workspace.__swig_setmethods__["tooltipDescription"] = Workspace._set_tooltipDescription
Workspace.tooltipDescription = property(Workspace._get_tooltipDescription, Workspace._set_tooltipDescription, doc="Gets or sets the tooltip description displayed for the workspace. The tooltip description is a longer\ndescription of the workspace and is only displayed when the user hovers over the workspace name in\nthe Fusion 360 toolbar drop-down. The pop-up dialog that appears contains the tooltip, the tooltip\ndescription, and the toolclip which is a picture.")

Workspace.__swig_getmethods__["toolbarTabs"] = Workspace._get_toolbarTabs
Workspace.toolbarTabs = property(Workspace._get_toolbarTabs, doc="Gets the collection containing the tabs associated with this workspace.")

Workspace.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Workspace) else None
Workspace.cast = lambda arg: arg if isinstance(arg, Workspace) else None

class WorkspaceEventHandler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WorkspaceEventHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WorkspaceEventHandler, name)
    __repr__ = _swig_repr
    def notify(self, *args) -> "void" : return _core.WorkspaceEventHandler_notify(self, *args)
    def __init__(self): 
        if self.__class__ == WorkspaceEventHandler:
            _self = None
        else:
            _self = self
        this = _core.new_WorkspaceEventHandler(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_WorkspaceEventHandler
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _core.disown_WorkspaceEventHandler(self)
        return weakref_proxy(self)
WorkspaceEventHandler_swigregister = _core.WorkspaceEventHandler_swigregister
WorkspaceEventHandler_swigregister(WorkspaceEventHandler)

WorkspaceEventHandler.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, WorkspaceEventHandler) else None
WorkspaceEventHandler.cast = lambda arg: arg if isinstance(arg, WorkspaceEventHandler) else None

class WorkspaceList(Base):
    """A WorkspaceList is a list of Workspaces - e.g. the Workspaces for a given product."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WorkspaceList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WorkspaceList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::WorkspaceList *" : return _core.WorkspaceList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.WorkspaceList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.WorkspaceList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.WorkspaceList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::Workspace >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.WorkspaceList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.WorkspaceList_classType
    if _newclass:classType = staticmethod(_core.WorkspaceList_classType)
    __swig_destroy__ = _core.delete_WorkspaceList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::Workspace >" :
        """
        Returns the specified work space using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.WorkspaceList_item(self, *args)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::Workspace >" :
        """
        Returns the Workspace of the specified ID. 
        id : The ID of the workspace to get. 
        Returns the specified workspace or null in the case where there isn't a workspace with the specified ID.
        """
        return _core.WorkspaceList_itemById(self, *args)

    def _get_count(self) -> "size_t" :
        """Gets the number of workspaces in the collection."""
        return _core.WorkspaceList__get_count(self)

    def _get_objectType(self) -> "char const *" : return _core.WorkspaceList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.WorkspaceList__get_isValid(self)
WorkspaceList_swigregister = _core.WorkspaceList_swigregister
WorkspaceList_swigregister(WorkspaceList)

def WorkspaceList_classType() -> "char const *" :
  return _core.WorkspaceList_classType()
WorkspaceList_classType = _core.WorkspaceList_classType

WorkspaceList.__swig_getmethods__["count"] = WorkspaceList._get_count
WorkspaceList.count = property(WorkspaceList._get_count, doc="Gets the number of workspaces in the collection.")

WorkspaceList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, WorkspaceList) else None
WorkspaceList.cast = lambda arg: arg if isinstance(arg, WorkspaceList) else None

class Workspaces(Base):
    """Provides access to all of the existing workspaces."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Workspaces, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Workspaces, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Workspaces *" : return _core.Workspaces___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Workspaces___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Workspaces___ne__(self, *args)

    def __len__(self) -> "size_t" : return _core.Workspaces___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::core::Workspace >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _core.Workspaces___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Workspaces_classType
    if _newclass:classType = staticmethod(_core.Workspaces_classType)
    __swig_destroy__ = _core.delete_Workspaces
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::core::Workspace >" :
        """
        Returns the specified work space using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _core.Workspaces_item(self, *args)

    def itemById(self, *args) -> "adsk::core::Ptr< adsk::core::Workspace >" :
        """
        Returns the Workspace of the specified ID. 
        id : The ID of the workspace to get. 
        Returns the specified workspace or null in the case where there isn't a workspace with the specified ID.
        """
        return _core.Workspaces_itemById(self, *args)

    def _get_count(self) -> "size_t" :
        """Gets the number of workspaces in the collection."""
        return _core.Workspaces__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::core::Workspace >" :
        """
        Creates a new workspace for a specific product. 
        productType : The name of the product this workspace will be displayed with. You can obtain a list of the available
        products by using the supportedProductTypes property of the Application object. 
        id : The unique ID for this workspace. It must be unique with respect to all other workspaces. 
        name : The displayed name of this workspace. 
        resourceFolder : The resource folder should contain two files; 49X31.png and 98x62.png. The larger is used for the Apple Retina display. 
        Returns the created workspace or null if the creation failed.
        """
        return _core.Workspaces_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Workspaces__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Workspaces__get_isValid(self)
Workspaces_swigregister = _core.Workspaces_swigregister
Workspaces_swigregister(Workspaces)

def Workspaces_classType() -> "char const *" :
  return _core.Workspaces_classType()
Workspaces_classType = _core.Workspaces_classType

Workspaces.__swig_getmethods__["count"] = Workspaces._get_count
Workspaces.count = property(Workspaces._get_count, doc="Gets the number of workspaces in the collection.")

Workspaces.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Workspaces) else None
Workspaces.cast = lambda arg: arg if isinstance(arg, Workspaces) else None

class AngleValueCommandInput(CommandInput):
    """
    Represents a command input that gets an angle from the user. This displays
    an entry in the command dialog where the user can enter a value and also displays
    a manipulator in the graphics window to allow them to graphically set the value.
    The input box is displayed in the dialog when the isVisible property of the command
    input is true. The manipulator is displayed in the graphics when both the isVisible
    and isEnabled properties are true.
    """
    __swig_setmethods__ = {}
    for _s in [CommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AngleValueCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [CommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AngleValueCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::AngleValueCommandInput *" : return _core.AngleValueCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.AngleValueCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.AngleValueCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.AngleValueCommandInput_classType
    if _newclass:classType = staticmethod(_core.AngleValueCommandInput_classType)
    __swig_destroy__ = _core.delete_AngleValueCommandInput
    __del__ = lambda self : None;
    def _get_value(self) -> "double" :
        """
        Gets and sets the current value of the command input. The value is in radians
        but will be displayed to the user in degrees. Setting this value can fail if the input value is 
        not within the minimum and maximum value range.
        The isValidExpression property should be checked before using the value within the command 
        because if the expression can't be evaluated there isn't a valid value. Fusion 360 won't allow 
        the execution of a command that contains ValueCommandInput object with invalid expressions 
        so you can dependably use the value in the execute event of the command.
        """
        return _core.AngleValueCommandInput__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """
        Gets and sets the current value of the command input. The value is in radians
        but will be displayed to the user in degrees. Setting this value can fail if the input value is 
        not within the minimum and maximum value range.
        The isValidExpression property should be checked before using the value within the command 
        because if the expression can't be evaluated there isn't a valid value. Fusion 360 won't allow 
        the execution of a command that contains ValueCommandInput object with invalid expressions 
        so you can dependably use the value in the execute event of the command.
        """
        return _core.AngleValueCommandInput__set_value(self, *args)

    def _get_expression(self) -> "std::string" :
        """
        Gets or sets the expression displayed in the input field. This can contain equations and
        references to parameters but must result in a valid angle expression. If units are not
        specified as part of the expression, the default user units of degrees are used.
        """
        return _core.AngleValueCommandInput__get_expression(self)

    def _set_expression(self, *args) -> "bool" :
        """
        Gets or sets the expression displayed in the input field. This can contain equations and
        references to parameters but must result in a valid angle expression. If units are not
        specified as part of the expression, the default user units of degrees are used.
        """
        return _core.AngleValueCommandInput__set_expression(self, *args)

    def _get_minimumValue(self) -> "double" :
        """
        Gets and sets minimum value, if any, that the value can be. The value is in radians. When getting this
        property you should first check the hasMinimumValue property to see if this property
        applies. Also, the isMinimumValueInclusive indicates if the minimum includes this
        value or will be up to this value.
        Setting this value will change the isMinimumValueInclusive to True and the hasMinimumValue 
        property to True if hasMinimumValue is currently False, otherwise it will just update the value.
        """
        return _core.AngleValueCommandInput__get_minimumValue(self)

    def _set_minimumValue(self, *args) -> "bool" :
        """
        Gets and sets minimum value, if any, that the value can be. The value is in radians. When getting this
        property you should first check the hasMinimumValue property to see if this property
        applies. Also, the isMinimumValueInclusive indicates if the minimum includes this
        value or will be up to this value.
        Setting this value will change the isMinimumValueInclusive to True and the hasMinimumValue 
        property to True if hasMinimumValue is currently False, otherwise it will just update the value.
        """
        return _core.AngleValueCommandInput__set_minimumValue(self, *args)

    def _get_hasMinimumValue(self) -> "bool" :
        """
        Gets and sets if there is a minimum value for this command input. When setting this property, it is only valid
        to set it to False to remove the minimum value. Setting the minimumValue property will result in this property
        being set to True.
        """
        return _core.AngleValueCommandInput__get_hasMinimumValue(self)

    def _set_hasMinimumValue(self, *args) -> "bool" :
        """
        Gets and sets if there is a minimum value for this command input. When setting this property, it is only valid
        to set it to False to remove the minimum value. Setting the minimumValue property will result in this property
        being set to True.
        """
        return _core.AngleValueCommandInput__set_hasMinimumValue(self, *args)

    def _get_isMinimumValueInclusive(self) -> "bool" :
        """
        Gets and sets if the value of the input includes the minimum value or is up to the minimum value. For example,
        if the minimum value is zero and this property is True, the minimum value can be zero. If this is False, the 
        minimum value must be greater than zero. When the minimum value is first defined using the minimumValue property,
        this property is set to True. The value returned by this property is only meaningful when the hasMinimumValue property
        returns True.
        """
        return _core.AngleValueCommandInput__get_isMinimumValueInclusive(self)

    def _set_isMinimumValueInclusive(self, *args) -> "bool" :
        """
        Gets and sets if the value of the input includes the minimum value or is up to the minimum value. For example,
        if the minimum value is zero and this property is True, the minimum value can be zero. If this is False, the 
        minimum value must be greater than zero. When the minimum value is first defined using the minimumValue property,
        this property is set to True. The value returned by this property is only meaningful when the hasMinimumValue property
        returns True.
        """
        return _core.AngleValueCommandInput__set_isMinimumValueInclusive(self, *args)

    def _get_maximumValue(self) -> "double" :
        """
        Gets and sets maximum value, if any, that the value can be. The value is in radians. When getting this
        property you should first check the hasMaximumValue property to see if this property applies. Also, the
        isMaximumValueInclusive indicates if the minimum includes this value or will be up to this value.
        Setting this value will change the isMaximumValueInclusive to True and the hasMaximumValue 
        property to True if hasMaximumValue is currently False, otherwise it will just update the value.
        """
        return _core.AngleValueCommandInput__get_maximumValue(self)

    def _set_maximumValue(self, *args) -> "bool" :
        """
        Gets and sets maximum value, if any, that the value can be. The value is in radians. When getting this
        property you should first check the hasMaximumValue property to see if this property applies. Also, the
        isMaximumValueInclusive indicates if the minimum includes this value or will be up to this value.
        Setting this value will change the isMaximumValueInclusive to True and the hasMaximumValue 
        property to True if hasMaximumValue is currently False, otherwise it will just update the value.
        """
        return _core.AngleValueCommandInput__set_maximumValue(self, *args)

    def _get_hasMaximumValue(self) -> "bool" :
        """
        Gets and sets if there is a maximum value for this command input. When setting this property, it is only valid
        to set it to False to remove the maximum value. Setting the maximumValue property will result in this property
        being set to True.
        """
        return _core.AngleValueCommandInput__get_hasMaximumValue(self)

    def _set_hasMaximumValue(self, *args) -> "bool" :
        """
        Gets and sets if there is a maximum value for this command input. When setting this property, it is only valid
        to set it to False to remove the maximum value. Setting the maximumValue property will result in this property
        being set to True.
        """
        return _core.AngleValueCommandInput__set_hasMaximumValue(self, *args)

    def _get_isMaximumValueInclusive(self) -> "bool" :
        """
        Gets and sets if the value of the input includes the maximum value or is up to the maximum value. For example,
        if the maximum value is the value of pi (180 degrees) and this property is True, the maximum value can be pi. 
        If this is False, the minimum value must be less than pi. When the maximum value is first defined using the 
        maximumValue property, this property is set to True. The value returned by this property is only meaninful 
        when the hasMaximumValue property returns True.
        """
        return _core.AngleValueCommandInput__get_isMaximumValueInclusive(self)

    def _set_isMaximumValueInclusive(self, *args) -> "bool" :
        """
        Gets and sets if the value of the input includes the maximum value or is up to the maximum value. For example,
        if the maximum value is the value of pi (180 degrees) and this property is True, the maximum value can be pi. 
        If this is False, the minimum value must be less than pi. When the maximum value is first defined using the 
        maximumValue property, this property is set to True. The value returned by this property is only meaninful 
        when the hasMaximumValue property returns True.
        """
        return _core.AngleValueCommandInput__set_isMaximumValueInclusive(self, *args)

    def setManipulator(self, *args) -> "bool" :
        """
        Defines the position and orientation of the manipulator. The manipulator is only visible
        when both the isVisible and isEnabled properties are true. If those properties are
        true and the setManipulator has not been called, the manipulator will be displayed in
        a default location (0,0,0) using default directions; x direction (1,0,0) and y direction (0,1,0). 
        Because of that the input is typically set to be invisible and/or disabled and then enabled once 
        enough input has been specified that you can display the manipulator in the desired location. 
        origin : Defines the center position of the manipulator in root component space. 
        xDirection : Defines the X direction of the manipulator in root component space. The X direction is the 0 angle direction. This
        direction, along with the Y direction vector define the plane that the manipulator is displayed on. 
        yDirection : Defines the Y direction of the manipulator in root component space. The X and Y direction vectors define the plane
        the manipulator is displayed one. When the manipulator is rotated from the xDirection vector towards the yDirection
        vector that is the positive direction. 
        Returns true if successful.
        """
        return _core.AngleValueCommandInput_setManipulator(self, *args)

    def _get_manipulatorOrigin(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        Gets the origin point of the manipulator in the model space of the root component.
        To set the origin use the setManipulator method.
        """
        return _core.AngleValueCommandInput__get_manipulatorOrigin(self)

    def _get_manipulatorXDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Gets the X direction of the manipulator in the model space of the root component. The X direction is
        the 0 angle direction. This direction, along with the Y direction vector define the plane that the 
        manipulator is displayed on.
        To set the direction use the setManipulator method.
        """
        return _core.AngleValueCommandInput__get_manipulatorXDirection(self)

    def _get_manipulatorYDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Gets the Y direction of the manipulator in the model space of the root component. The X and Y direction 
        vectors define the plane that the manipulator is displayed on.
        To set the direction use the setManipulator method.
        """
        return _core.AngleValueCommandInput__get_manipulatorYDirection(self)

    def _get_isValidExpression(self) -> "bool" :
        """
        Returns true if the current expression is valid and can be evaluated. If this
        is false, the value returned should be ignored because there currently is
        not a valid value.
        """
        return _core.AngleValueCommandInput__get_isValidExpression(self)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.AngleValueCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.AngleValueCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.AngleValueCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.AngleValueCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.AngleValueCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.AngleValueCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.AngleValueCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.AngleValueCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.AngleValueCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.AngleValueCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.AngleValueCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.AngleValueCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.AngleValueCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.AngleValueCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.AngleValueCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.AngleValueCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.AngleValueCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.AngleValueCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.AngleValueCommandInput__get_isValid(self)
AngleValueCommandInput_swigregister = _core.AngleValueCommandInput_swigregister
AngleValueCommandInput_swigregister(AngleValueCommandInput)

def AngleValueCommandInput_classType() -> "char const *" :
  return _core.AngleValueCommandInput_classType()
AngleValueCommandInput_classType = _core.AngleValueCommandInput_classType

AngleValueCommandInput.__swig_getmethods__["value"] = AngleValueCommandInput._get_value
AngleValueCommandInput.__swig_setmethods__["value"] = AngleValueCommandInput._set_value
AngleValueCommandInput.value = property(AngleValueCommandInput._get_value, AngleValueCommandInput._set_value, doc="Gets and sets the current value of the command input. The value is in radians\nbut will be displayed to the user in degrees. Setting this value can fail if the input value is\nnot within the minimum and maximum value range.\nThe isValidExpression property should be checked before using the value within the command\nbecause if the expression can't be evaluated there isn't a valid value. Fusion 360 won't allow\nthe execution of a command that contains ValueCommandInput object with invalid expressions\nso you can dependably use the value in the execute event of the command.")

AngleValueCommandInput.__swig_getmethods__["expression"] = AngleValueCommandInput._get_expression
AngleValueCommandInput.__swig_setmethods__["expression"] = AngleValueCommandInput._set_expression
AngleValueCommandInput.expression = property(AngleValueCommandInput._get_expression, AngleValueCommandInput._set_expression, doc="Gets or sets the expression displayed in the input field. This can contain equations and\nreferences to parameters but must result in a valid angle expression. If units are not\nspecified as part of the expression, the default user units of degrees are used.")

AngleValueCommandInput.__swig_getmethods__["minimumValue"] = AngleValueCommandInput._get_minimumValue
AngleValueCommandInput.__swig_setmethods__["minimumValue"] = AngleValueCommandInput._set_minimumValue
AngleValueCommandInput.minimumValue = property(AngleValueCommandInput._get_minimumValue, AngleValueCommandInput._set_minimumValue, doc="Gets and sets minimum value, if any, that the value can be. The value is in radians. When getting this\nproperty you should first check the hasMinimumValue property to see if this property\napplies. Also, the isMinimumValueInclusive indicates if the minimum includes this\nvalue or will be up to this value.\nSetting this value will change the isMinimumValueInclusive to True and the hasMinimumValue\nproperty to True if hasMinimumValue is currently False, otherwise it will just update the value.")

AngleValueCommandInput.__swig_getmethods__["hasMinimumValue"] = AngleValueCommandInput._get_hasMinimumValue
AngleValueCommandInput.__swig_setmethods__["hasMinimumValue"] = AngleValueCommandInput._set_hasMinimumValue
AngleValueCommandInput.hasMinimumValue = property(AngleValueCommandInput._get_hasMinimumValue, AngleValueCommandInput._set_hasMinimumValue, doc="Gets and sets if there is a minimum value for this command input. When setting this property, it is only valid\nto set it to False to remove the minimum value. Setting the minimumValue property will result in this property\nbeing set to True.")

AngleValueCommandInput.__swig_getmethods__["isMinimumValueInclusive"] = AngleValueCommandInput._get_isMinimumValueInclusive
AngleValueCommandInput.__swig_setmethods__["isMinimumValueInclusive"] = AngleValueCommandInput._set_isMinimumValueInclusive
AngleValueCommandInput.isMinimumValueInclusive = property(AngleValueCommandInput._get_isMinimumValueInclusive, AngleValueCommandInput._set_isMinimumValueInclusive, doc="Gets and sets if the value of the input includes the minimum value or is up to the minimum value. For example,\nif the minimum value is zero and this property is True, the minimum value can be zero. If this is False, the\nminimum value must be greater than zero. When the minimum value is first defined using the minimumValue property,\nthis property is set to True. The value returned by this property is only meaningful when the hasMinimumValue property\nreturns True.")

AngleValueCommandInput.__swig_getmethods__["maximumValue"] = AngleValueCommandInput._get_maximumValue
AngleValueCommandInput.__swig_setmethods__["maximumValue"] = AngleValueCommandInput._set_maximumValue
AngleValueCommandInput.maximumValue = property(AngleValueCommandInput._get_maximumValue, AngleValueCommandInput._set_maximumValue, doc="Gets and sets maximum value, if any, that the value can be. The value is in radians. When getting this\nproperty you should first check the hasMaximumValue property to see if this property applies. Also, the\nisMaximumValueInclusive indicates if the minimum includes this value or will be up to this value.\nSetting this value will change the isMaximumValueInclusive to True and the hasMaximumValue\nproperty to True if hasMaximumValue is currently False, otherwise it will just update the value.")

AngleValueCommandInput.__swig_getmethods__["hasMaximumValue"] = AngleValueCommandInput._get_hasMaximumValue
AngleValueCommandInput.__swig_setmethods__["hasMaximumValue"] = AngleValueCommandInput._set_hasMaximumValue
AngleValueCommandInput.hasMaximumValue = property(AngleValueCommandInput._get_hasMaximumValue, AngleValueCommandInput._set_hasMaximumValue, doc="Gets and sets if there is a maximum value for this command input. When setting this property, it is only valid\nto set it to False to remove the maximum value. Setting the maximumValue property will result in this property\nbeing set to True.")

AngleValueCommandInput.__swig_getmethods__["isMaximumValueInclusive"] = AngleValueCommandInput._get_isMaximumValueInclusive
AngleValueCommandInput.__swig_setmethods__["isMaximumValueInclusive"] = AngleValueCommandInput._set_isMaximumValueInclusive
AngleValueCommandInput.isMaximumValueInclusive = property(AngleValueCommandInput._get_isMaximumValueInclusive, AngleValueCommandInput._set_isMaximumValueInclusive, doc="Gets and sets if the value of the input includes the maximum value or is up to the maximum value. For example,\nif the maximum value is the value of pi (180 degrees) and this property is True, the maximum value can be pi.\nIf this is False, the minimum value must be less than pi. When the maximum value is first defined using the\nmaximumValue property, this property is set to True. The value returned by this property is only meaninful\nwhen the hasMaximumValue property returns True.")

AngleValueCommandInput.__swig_getmethods__["manipulatorOrigin"] = AngleValueCommandInput._get_manipulatorOrigin
AngleValueCommandInput.manipulatorOrigin = property(AngleValueCommandInput._get_manipulatorOrigin, doc="Gets the origin point of the manipulator in the model space of the root component.\nTo set the origin use the setManipulator method.")

AngleValueCommandInput.__swig_getmethods__["manipulatorXDirection"] = AngleValueCommandInput._get_manipulatorXDirection
AngleValueCommandInput.manipulatorXDirection = property(AngleValueCommandInput._get_manipulatorXDirection, doc="Gets the X direction of the manipulator in the model space of the root component. The X direction is\nthe 0 angle direction. This direction, along with the Y direction vector define the plane that the\nmanipulator is displayed on.\nTo set the direction use the setManipulator method.")

AngleValueCommandInput.__swig_getmethods__["manipulatorYDirection"] = AngleValueCommandInput._get_manipulatorYDirection
AngleValueCommandInput.manipulatorYDirection = property(AngleValueCommandInput._get_manipulatorYDirection, doc="Gets the Y direction of the manipulator in the model space of the root component. The X and Y direction\nvectors define the plane that the manipulator is displayed on.\nTo set the direction use the setManipulator method.")

AngleValueCommandInput.__swig_getmethods__["isValidExpression"] = AngleValueCommandInput._get_isValidExpression
AngleValueCommandInput.isValidExpression = property(AngleValueCommandInput._get_isValidExpression, doc="Returns true if the current expression is valid and can be evaluated. If this\nis false, the value returned should be ignored because there currently is\nnot a valid value.")

AngleValueCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, AngleValueCommandInput) else None
AngleValueCommandInput.cast = lambda arg: arg if isinstance(arg, AngleValueCommandInput) else None

class AppearanceTextureProperty(Property):
    """A texture value property associated with a material or appearance."""
    __swig_setmethods__ = {}
    for _s in [Property]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppearanceTextureProperty, name, value)
    __swig_getmethods__ = {}
    for _s in [Property]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AppearanceTextureProperty, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::AppearanceTextureProperty *" : return _core.AppearanceTextureProperty___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.AppearanceTextureProperty___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.AppearanceTextureProperty___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.AppearanceTextureProperty_classType
    if _newclass:classType = staticmethod(_core.AppearanceTextureProperty_classType)
    __swig_destroy__ = _core.delete_AppearanceTextureProperty
    __del__ = lambda self : None;
    def _get_value(self) -> "adsk::core::Ptr< adsk::core::AppearanceTexture >" :
        """Gets and sets this property value."""
        return _core.AppearanceTextureProperty__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """Gets and sets this property value."""
        return _core.AppearanceTextureProperty__set_value(self, *args)

    def _get_isUsed(self) -> "bool" :
        """
        Specifies if this AppearanceTexture is being used. This is the equivalent of the 
        check box in the Appearance dialog to enable the use of a text for an appearance or not.
        if this is False, then the value property should not be used because there isn't an associated.
        AppearanceTexture.
        """
        return _core.AppearanceTextureProperty__get_isUsed(self)

    def _get_name(self) -> "std::string" :
        """
        Returns the name of this property as seen in the user interface. This name is localized
        and can change based on the current language
        """
        return _core.AppearanceTextureProperty__get_name(self)

    def _get_isReadOnly(self) -> "bool" :
        """Indicates if this property is read-only. If True any attempted edits will fail."""
        return _core.AppearanceTextureProperty__get_isReadOnly(self)

    def _get_id(self) -> "std::string" :
        """Returns the unique ID of this property."""
        return _core.AppearanceTextureProperty__get_id(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the parent of this property."""
        return _core.AppearanceTextureProperty__get_parent(self)

    def _get_objectType(self) -> "char const *" : return _core.AppearanceTextureProperty__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.AppearanceTextureProperty__get_isValid(self)
AppearanceTextureProperty_swigregister = _core.AppearanceTextureProperty_swigregister
AppearanceTextureProperty_swigregister(AppearanceTextureProperty)

def AppearanceTextureProperty_classType() -> "char const *" :
  return _core.AppearanceTextureProperty_classType()
AppearanceTextureProperty_classType = _core.AppearanceTextureProperty_classType

AppearanceTextureProperty.__swig_getmethods__["value"] = AppearanceTextureProperty._get_value
AppearanceTextureProperty.__swig_setmethods__["value"] = AppearanceTextureProperty._set_value
AppearanceTextureProperty.value = property(AppearanceTextureProperty._get_value, AppearanceTextureProperty._set_value, doc="Gets and sets this property value.")

AppearanceTextureProperty.__swig_getmethods__["isUsed"] = AppearanceTextureProperty._get_isUsed
AppearanceTextureProperty.isUsed = property(AppearanceTextureProperty._get_isUsed, doc="Specifies if this AppearanceTexture is being used. This is the equivalent of the\ncheck box in the Appearance dialog to enable the use of a text for an appearance or not.\nif this is False, then the value property should not be used because there isn't an associated.\nAppearanceTexture.")

AppearanceTextureProperty.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, AppearanceTextureProperty) else None
AppearanceTextureProperty.cast = lambda arg: arg if isinstance(arg, AppearanceTextureProperty) else None

class ApplicationCommandEvent(Event):
    """An event endpoint that supports the connection to ApplicationCommandEventHandlers."""
    __swig_setmethods__ = {}
    for _s in [Event]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ApplicationCommandEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ApplicationCommandEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ApplicationCommandEvent *" : return _core.ApplicationCommandEvent___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ApplicationCommandEvent___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ApplicationCommandEvent___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ApplicationCommandEvent_classType
    if _newclass:classType = staticmethod(_core.ApplicationCommandEvent_classType)
    __swig_destroy__ = _core.delete_ApplicationCommandEvent
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Adds an event handler object to this event endpoint. 
        handler : The ApplicationCommandEventHandler to be called when this event is triggered. 
        Returns true if the handler was successfully added to the set of event handlers.
        """
        return _core.ApplicationCommandEvent_add(self, *args)

    def remove(self, *args) -> "bool" :
        """
        Removes a handler from this event endpoint. 
        handler : An ApplicationCommandEventHandler that was previously added to this event with the add method. 
        Returns true if the handler was found and removed from the set of event handlers.
        """
        return _core.ApplicationCommandEvent_remove(self, *args)

    def _get_name(self) -> "std::string" :
        """The name of the event - e.g. 'DocumentOpening'"""
        return _core.ApplicationCommandEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.ApplicationCommandEvent__get_sender(self)

    def _get_objectType(self) -> "char const *" : return _core.ApplicationCommandEvent__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ApplicationCommandEvent__get_isValid(self)
ApplicationCommandEvent_swigregister = _core.ApplicationCommandEvent_swigregister
ApplicationCommandEvent_swigregister(ApplicationCommandEvent)

def ApplicationCommandEvent_classType() -> "char const *" :
  return _core.ApplicationCommandEvent_classType()
ApplicationCommandEvent_classType = _core.ApplicationCommandEvent_classType

ApplicationCommandEvent.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ApplicationCommandEvent) else None
ApplicationCommandEvent.cast = lambda arg: arg if isinstance(arg, ApplicationCommandEvent) else None

class ApplicationCommandEventArgs(EventArgs):
    """
    Provides a set of arguments from a firing ApplicationCommandEvent to an ApplicationCommandEventHandler's 
    notify callback method.
    """
    __swig_setmethods__ = {}
    for _s in [EventArgs]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ApplicationCommandEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ApplicationCommandEventArgs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ApplicationCommandEventArgs *" : return _core.ApplicationCommandEventArgs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ApplicationCommandEventArgs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ApplicationCommandEventArgs___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ApplicationCommandEventArgs_classType
    if _newclass:classType = staticmethod(_core.ApplicationCommandEventArgs_classType)
    __swig_destroy__ = _core.delete_ApplicationCommandEventArgs
    __del__ = lambda self : None;
    def _get_commandDefinition(self) -> "adsk::core::Ptr< adsk::core::CommandDefinition >" :
        """Returns the CommandDefinition object for the command the event is being fired for."""
        return _core.ApplicationCommandEventArgs__get_commandDefinition(self)

    def _get_commandId(self) -> "std::string" :
        """Returns the unique id of the command the event if being fired for."""
        return _core.ApplicationCommandEventArgs__get_commandId(self)

    def _get_isCanceled(self) -> "bool" :
        """
        Used during the commandStarting event to get or set if the command should
        be allowed to continue executing or be canceled. This defaults to false,
        which will allow the command to execute. Setting this to true will cancel
        the command and not begin the execution.
        This property should be ignored for all events besides the commandStarting event.
        """
        return _core.ApplicationCommandEventArgs__get_isCanceled(self)

    def _set_isCanceled(self, *args) -> "bool" :
        """
        Used during the commandStarting event to get or set if the command should
        be allowed to continue executing or be canceled. This defaults to false,
        which will allow the command to execute. Setting this to true will cancel
        the command and not begin the execution.
        This property should be ignored for all events besides the commandStarting event.
        """
        return _core.ApplicationCommandEventArgs__set_isCanceled(self, *args)

    def _get_terminationReason(self) -> "adsk::core::CommandTerminationReason" :
        """
        Returns the reason the command is being terminated.
        This property should be ignored for all events besides the commandTerminated event.
        """
        return _core.ApplicationCommandEventArgs__get_terminationReason(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >" :
        """The event that the firing is in response to."""
        return _core.ApplicationCommandEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *" : return _core.ApplicationCommandEventArgs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ApplicationCommandEventArgs__get_isValid(self)
ApplicationCommandEventArgs_swigregister = _core.ApplicationCommandEventArgs_swigregister
ApplicationCommandEventArgs_swigregister(ApplicationCommandEventArgs)

def ApplicationCommandEventArgs_classType() -> "char const *" :
  return _core.ApplicationCommandEventArgs_classType()
ApplicationCommandEventArgs_classType = _core.ApplicationCommandEventArgs_classType

ApplicationCommandEventArgs.__swig_getmethods__["commandDefinition"] = ApplicationCommandEventArgs._get_commandDefinition
ApplicationCommandEventArgs.commandDefinition = property(ApplicationCommandEventArgs._get_commandDefinition, doc="Returns the CommandDefinition object for the command the event is being fired for.")

ApplicationCommandEventArgs.__swig_getmethods__["commandId"] = ApplicationCommandEventArgs._get_commandId
ApplicationCommandEventArgs.commandId = property(ApplicationCommandEventArgs._get_commandId, doc="Returns the unique id of the command the event if being fired for.")

ApplicationCommandEventArgs.__swig_getmethods__["isCanceled"] = ApplicationCommandEventArgs._get_isCanceled
ApplicationCommandEventArgs.__swig_setmethods__["isCanceled"] = ApplicationCommandEventArgs._set_isCanceled
ApplicationCommandEventArgs.isCanceled = property(ApplicationCommandEventArgs._get_isCanceled, ApplicationCommandEventArgs._set_isCanceled, doc="Used during the commandStarting event to get or set if the command should\nbe allowed to continue executing or be canceled. This defaults to false,\nwhich will allow the command to execute. Setting this to true will cancel\nthe command and not begin the execution.\nThis property should be ignored for all events besides the commandStarting event.")

ApplicationCommandEventArgs.__swig_getmethods__["terminationReason"] = ApplicationCommandEventArgs._get_terminationReason
ApplicationCommandEventArgs.terminationReason = property(ApplicationCommandEventArgs._get_terminationReason, doc="Returns the reason the command is being terminated.\nThis property should be ignored for all events besides the commandTerminated event.")

ApplicationCommandEventArgs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ApplicationCommandEventArgs) else None
ApplicationCommandEventArgs.cast = lambda arg: arg if isinstance(arg, ApplicationCommandEventArgs) else None

class ApplicationEvent(Event):
    """An ApplicationEvent represents a Fusion 360 application related event. For example, startupCompleted or OnlineStatusChanged"""
    __swig_setmethods__ = {}
    for _s in [Event]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ApplicationEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ApplicationEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ApplicationEvent *" : return _core.ApplicationEvent___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ApplicationEvent___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ApplicationEvent___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ApplicationEvent_classType
    if _newclass:classType = staticmethod(_core.ApplicationEvent_classType)
    __swig_destroy__ = _core.delete_ApplicationEvent
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Add a handler to be notified when the event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.ApplicationEvent_add(self, *args)

    def remove(self, *args) -> "bool" :
        """
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.ApplicationEvent_remove(self, *args)

    def _get_name(self) -> "std::string" :
        """The name of the event - e.g. 'DocumentOpening'"""
        return _core.ApplicationEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.ApplicationEvent__get_sender(self)

    def _get_objectType(self) -> "char const *" : return _core.ApplicationEvent__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ApplicationEvent__get_isValid(self)
ApplicationEvent_swigregister = _core.ApplicationEvent_swigregister
ApplicationEvent_swigregister(ApplicationEvent)

def ApplicationEvent_classType() -> "char const *" :
  return _core.ApplicationEvent_classType()
ApplicationEvent_classType = _core.ApplicationEvent_classType

ApplicationEvent.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ApplicationEvent) else None
ApplicationEvent.cast = lambda arg: arg if isinstance(arg, ApplicationEvent) else None

class ApplicationEventArgs(EventArgs):
    """
    The ApplicationEventArgs provides information associated with an application event. 
    Note that some properties are not available on every event
    """
    __swig_setmethods__ = {}
    for _s in [EventArgs]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ApplicationEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ApplicationEventArgs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ApplicationEventArgs *" : return _core.ApplicationEventArgs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ApplicationEventArgs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ApplicationEventArgs___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ApplicationEventArgs_classType
    if _newclass:classType = staticmethod(_core.ApplicationEventArgs_classType)
    __swig_destroy__ = _core.delete_ApplicationEventArgs
    __del__ = lambda self : None;
    def _get_isOffLine(self) -> "bool" :
        """Gets and sets if Fusion 360 is offline or not."""
        return _core.ApplicationEventArgs__get_isOffLine(self)

    def _set_isOffLine(self, *args) -> "bool" :
        """Gets and sets if Fusion 360 is offline or not."""
        return _core.ApplicationEventArgs__set_isOffLine(self, *args)

    def _get_hasInternetAccess(self) -> "bool" :
        """Gets if the client computer has access to the internet."""
        return _core.ApplicationEventArgs__get_hasInternetAccess(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >" :
        """The event that the firing is in response to."""
        return _core.ApplicationEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *" : return _core.ApplicationEventArgs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ApplicationEventArgs__get_isValid(self)
ApplicationEventArgs_swigregister = _core.ApplicationEventArgs_swigregister
ApplicationEventArgs_swigregister(ApplicationEventArgs)

def ApplicationEventArgs_classType() -> "char const *" :
  return _core.ApplicationEventArgs_classType()
ApplicationEventArgs_classType = _core.ApplicationEventArgs_classType

ApplicationEventArgs.__swig_getmethods__["isOffLine"] = ApplicationEventArgs._get_isOffLine
ApplicationEventArgs.__swig_setmethods__["isOffLine"] = ApplicationEventArgs._set_isOffLine
ApplicationEventArgs.isOffLine = property(ApplicationEventArgs._get_isOffLine, ApplicationEventArgs._set_isOffLine, doc="Gets and sets if Fusion 360 is offline or not.")

ApplicationEventArgs.__swig_getmethods__["hasInternetAccess"] = ApplicationEventArgs._get_hasInternetAccess
ApplicationEventArgs.hasInternetAccess = property(ApplicationEventArgs._get_hasInternetAccess, doc="Gets if the client computer has access to the internet.")

ApplicationEventArgs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ApplicationEventArgs) else None
ApplicationEventArgs.cast = lambda arg: arg if isinstance(arg, ApplicationEventArgs) else None

class Arc2D(Curve2D):
    """
    Transient 2D arc. A transient arc is not displayed or saved in a document. 
    Transient arcs are used as a wrapper to work with raw 2D arc information. They
    are created statically using one of the create methods supported by the Arc2D class.
    """
    __swig_setmethods__ = {}
    for _s in [Curve2D]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Arc2D, name, value)
    __swig_getmethods__ = {}
    for _s in [Curve2D]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Arc2D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Arc2D *" : return _core.Arc2D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Arc2D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Arc2D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Arc2D_classType
    if _newclass:classType = staticmethod(_core.Arc2D_classType)
    __swig_getmethods__["createByCenter"] = lambda x: _core.Arc2D_createByCenter
    if _newclass:createByCenter = staticmethod(_core.Arc2D_createByCenter)
    __swig_getmethods__["createByThreePoints"] = lambda x: _core.Arc2D_createByThreePoints
    if _newclass:createByThreePoints = staticmethod(_core.Arc2D_createByThreePoints)
    __swig_destroy__ = _core.delete_Arc2D
    __del__ = lambda self : None;
    def _get_center(self) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """Gets and sets the center position of the arc."""
        return _core.Arc2D__get_center(self)

    def _set_center(self, *args) -> "bool" :
        """Gets and sets the center position of the arc."""
        return _core.Arc2D__set_center(self, *args)

    def _get_radius(self) -> "double" :
        """Gets and sets the radius of the arc."""
        return _core.Arc2D__get_radius(self)

    def _set_radius(self, *args) -> "bool" :
        """Gets and sets the radius of the arc."""
        return _core.Arc2D__set_radius(self, *args)

    def _get_startAngle(self) -> "double" :
        """Gets and sets the start angle of the arc in radians, where 0 is along the x axis."""
        return _core.Arc2D__get_startAngle(self)

    def _set_startAngle(self, *args) -> "bool" :
        """Gets and sets the start angle of the arc in radians, where 0 is along the x axis."""
        return _core.Arc2D__set_startAngle(self, *args)

    def _get_endAngle(self) -> "double" :
        """Gets and sets the end angle of the arc in radians, where 0 is along the x axis."""
        return _core.Arc2D__get_endAngle(self)

    def _set_endAngle(self, *args) -> "bool" :
        """Gets and sets the end angle of the arc in radians, where 0 is along the x axis."""
        return _core.Arc2D__set_endAngle(self, *args)

    def _get_isClockwise(self) -> "bool" :
        """Specifies if the sweep direction of the arc is clockwise or counterclockwise."""
        return _core.Arc2D__get_isClockwise(self)

    def _get_startPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """Gets the position of the start point of the arc."""
        return _core.Arc2D__get_startPoint(self)

    def _get_endPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """Gets the position of the end point of the arc."""
        return _core.Arc2D__get_endPoint(self)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Arc2D >" :
        """
        Creates and returns an independent copy of this Arc2D object. 
        Returns a new Arc2D object that is a copy of this Arc2D object.
        """
        return _core.Arc2D_copy(self)

    def getData(self) -> "bool" :
        """
        Gets all of the data defining the arc. 
        center : The output center point of the arc. 
        radius : The output radius of the arc. 
        startAngle : The output start angle of the arc in radians, where 0 is along the x axis. 
        endAngle : The output end angle of the arc in radians, where 0 is along the x axis. 
        isClockwise : The output value that indicates if the sweep direction is clockwise or counterclockwise. 
        Returns true if successful
        """
        return _core.Arc2D_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets all of the data defining the arc. 
        center : A Point2D object defining the center position of the arc. 
        radius : The radius of the arc. 
        startAngle : The start angle of the arc in radians, where 0 is along the x axis. 
        endAngle : The end angle of the arc in radians, where 0 is along the x axis. 
        isClockwise : Indicates if the sweep direction is clockwise or counterclockwise. 
        Returns true if redefining the arc is successful
        """
        return _core.Arc2D_set(self, *args)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve2D >" :
        """Returns a NURBS curve that is geometrically identical to the arc."""
        return _core.Arc2D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve2DTypes" :
        """Returns the type of geometry this curve represents."""
        return _core.Arc2D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator2D >" :
        """Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Arc2D__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms this curve in 2D space. 
        matrix : A 2D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Arc2D_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Arc2D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Arc2D__get_isValid(self)
Arc2D_swigregister = _core.Arc2D_swigregister
Arc2D_swigregister(Arc2D)

def Arc2D_classType() -> "char const *" :
  return _core.Arc2D_classType()
Arc2D_classType = _core.Arc2D_classType

def Arc2D_createByCenter(*args) -> "adsk::core::Ptr< adsk::core::Point2D > const &" :
  return _core.Arc2D_createByCenter(*args)
Arc2D_createByCenter = _core.Arc2D_createByCenter

def Arc2D_createByThreePoints(*args) -> "adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Point2D > const &" :
  return _core.Arc2D_createByThreePoints(*args)
Arc2D_createByThreePoints = _core.Arc2D_createByThreePoints

Arc2D.__swig_getmethods__["center"] = Arc2D._get_center
Arc2D.__swig_setmethods__["center"] = Arc2D._set_center
Arc2D.center = property(Arc2D._get_center, Arc2D._set_center, doc="Gets and sets the center position of the arc.")

Arc2D.__swig_getmethods__["radius"] = Arc2D._get_radius
Arc2D.__swig_setmethods__["radius"] = Arc2D._set_radius
Arc2D.radius = property(Arc2D._get_radius, Arc2D._set_radius, doc="Gets and sets the radius of the arc.")

Arc2D.__swig_getmethods__["startAngle"] = Arc2D._get_startAngle
Arc2D.__swig_setmethods__["startAngle"] = Arc2D._set_startAngle
Arc2D.startAngle = property(Arc2D._get_startAngle, Arc2D._set_startAngle, doc="Gets and sets the start angle of the arc in radians, where 0 is along the x axis.")

Arc2D.__swig_getmethods__["endAngle"] = Arc2D._get_endAngle
Arc2D.__swig_setmethods__["endAngle"] = Arc2D._set_endAngle
Arc2D.endAngle = property(Arc2D._get_endAngle, Arc2D._set_endAngle, doc="Gets and sets the end angle of the arc in radians, where 0 is along the x axis.")

Arc2D.__swig_getmethods__["isClockwise"] = Arc2D._get_isClockwise
Arc2D.isClockwise = property(Arc2D._get_isClockwise, doc="Specifies if the sweep direction of the arc is clockwise or counterclockwise.")

Arc2D.__swig_getmethods__["startPoint"] = Arc2D._get_startPoint
Arc2D.startPoint = property(Arc2D._get_startPoint, doc="Gets the position of the start point of the arc.")

Arc2D.__swig_getmethods__["endPoint"] = Arc2D._get_endPoint
Arc2D.endPoint = property(Arc2D._get_endPoint, doc="Gets the position of the end point of the arc.")

Arc2D.__swig_getmethods__["asNurbsCurve"] = Arc2D._get_asNurbsCurve
Arc2D.asNurbsCurve = property(Arc2D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the arc.")

Arc2D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Arc2D) else None
Arc2D.cast = lambda arg: arg if isinstance(arg, Arc2D) else None

class Arc3D(Curve3D):
    """
    Transient 3D arc. A transient arc is not displayed or saved in a document.
    Transient 3D arcs are used as a wrapper to work with raw 3D arc information.
    They are created statically using one of the create methods of the Arc3D class.
    """
    __swig_setmethods__ = {}
    for _s in [Curve3D]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Arc3D, name, value)
    __swig_getmethods__ = {}
    for _s in [Curve3D]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Arc3D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Arc3D *" : return _core.Arc3D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Arc3D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Arc3D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Arc3D_classType
    if _newclass:classType = staticmethod(_core.Arc3D_classType)
    __swig_getmethods__["createByCenter"] = lambda x: _core.Arc3D_createByCenter
    if _newclass:createByCenter = staticmethod(_core.Arc3D_createByCenter)
    __swig_getmethods__["createByThreePoints"] = lambda x: _core.Arc3D_createByThreePoints
    if _newclass:createByThreePoints = staticmethod(_core.Arc3D_createByThreePoints)
    __swig_destroy__ = _core.delete_Arc3D
    __del__ = lambda self : None;
    def _get_center(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets the center position of the arc."""
        return _core.Arc3D__get_center(self)

    def _set_center(self, *args) -> "bool" :
        """Gets and sets the center position of the arc."""
        return _core.Arc3D__set_center(self, *args)

    def _get_normal(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Gets and sets the normal of the arc."""
        return _core.Arc3D__get_normal(self)

    def _get_referenceVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Gets and sets the reference vector of the arc."""
        return _core.Arc3D__get_referenceVector(self)

    def setAxes(self, *args) -> "bool" :
        """
        Sets the normal and reference vectors of the arc. 
        normal : The new normal vector. 
        referenceVector : The new reference vector from which the start and end angles are measured from.
        The reference vector must be perpendicular to the normal vector. 
        Returns true if successful
        """
        return _core.Arc3D_setAxes(self, *args)

    def _get_radius(self) -> "double" :
        """Gets and sets the radius of the arc."""
        return _core.Arc3D__get_radius(self)

    def _set_radius(self, *args) -> "bool" :
        """Gets and sets the radius of the arc."""
        return _core.Arc3D__set_radius(self, *args)

    def _get_startAngle(self) -> "double" :
        """
        Gets and sets the start angle of the arc in radians.
        This angle is measured from the reference vector using the right hand rule around the normal vector.
        """
        return _core.Arc3D__get_startAngle(self)

    def _set_startAngle(self, *args) -> "bool" :
        """
        Gets and sets the start angle of the arc in radians.
        This angle is measured from the reference vector using the right hand rule around the normal vector.
        """
        return _core.Arc3D__set_startAngle(self, *args)

    def _get_endAngle(self) -> "double" :
        """
        Gets and sets the end angle of the arc in radians.
        This angle is measured from the reference vector using the right hand rule around the normal vector.
        """
        return _core.Arc3D__get_endAngle(self)

    def _set_endAngle(self, *args) -> "bool" :
        """
        Gets and sets the end angle of the arc in radians.
        This angle is measured from the reference vector using the right hand rule around the normal vector.
        """
        return _core.Arc3D__set_endAngle(self, *args)

    def _get_startPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets the start point of the arc."""
        return _core.Arc3D__get_startPoint(self)

    def _get_endPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets the end point of the arc."""
        return _core.Arc3D__get_endPoint(self)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Arc3D >" :
        """
        Creates and returns an independent copy of this Arc3D object. 
        Returns a new Arc3D object that is a copy of this Arc3D object.
        """
        return _core.Arc3D_copy(self)

    def getData(self) -> "bool" :
        """
        Gets all of the data defining the arc. 
        center : The output center point of the arc. 
        normal : The output normal vector. 
        referenceVector : The output reference vector. 
        radius : The output radius of the arc. 
        startAngle : The output start angle in radians.
        This angle is measured from the reference vector using the right hand rule around the normal vector. 
        endAngle : The output end angle in radians.
        This angle is measured from the reference vector using the right hand rule around the normal vector. 
        Returns true if successful
        """
        return _core.Arc3D_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets all of the data defining the arc. 
        center : The center point of the arc. 
        normal : The normal vector of the arc.
        The plane perpendicular to this normal at the center point is the plane of the arc. 
        referenceVector : A reference vector from which the start and end angles are measured from.
        This vector must be perpendicular to the normal vector. 
        radius : The radius of the arc. 
        startAngle : The start angle in radians.
        This angle is measured from the reference vector using the right hand rule around the normal vector. 
        endAngle : The end angle in radians.
        This angle is measured from the reference vector using the right hand rule around the normal vector. 
        Returns true if successful
        """
        return _core.Arc3D_set(self, *args)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >" :
        """Returns a NURBS curve that is geometrically identical to the arc."""
        return _core.Arc3D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve3DTypes" :
        """Returns the type of geometry this curve represents."""
        return _core.Arc3D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >" :
        """Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Arc3D__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms this curve in 3D space. 
        matrix : A 3D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Arc3D_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Arc3D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Arc3D__get_isValid(self)
Arc3D_swigregister = _core.Arc3D_swigregister
Arc3D_swigregister(Arc3D)

def Arc3D_classType() -> "char const *" :
  return _core.Arc3D_classType()
Arc3D_classType = _core.Arc3D_classType

def Arc3D_createByCenter(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &" :
  return _core.Arc3D_createByCenter(*args)
Arc3D_createByCenter = _core.Arc3D_createByCenter

def Arc3D_createByThreePoints(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point3D > const &" :
  return _core.Arc3D_createByThreePoints(*args)
Arc3D_createByThreePoints = _core.Arc3D_createByThreePoints

Arc3D.__swig_getmethods__["center"] = Arc3D._get_center
Arc3D.__swig_setmethods__["center"] = Arc3D._set_center
Arc3D.center = property(Arc3D._get_center, Arc3D._set_center, doc="Gets and sets the center position of the arc.")

Arc3D.__swig_getmethods__["normal"] = Arc3D._get_normal
Arc3D.normal = property(Arc3D._get_normal, doc="Gets and sets the normal of the arc.")

Arc3D.__swig_getmethods__["referenceVector"] = Arc3D._get_referenceVector
Arc3D.referenceVector = property(Arc3D._get_referenceVector, doc="Gets and sets the reference vector of the arc.")

Arc3D.__swig_getmethods__["radius"] = Arc3D._get_radius
Arc3D.__swig_setmethods__["radius"] = Arc3D._set_radius
Arc3D.radius = property(Arc3D._get_radius, Arc3D._set_radius, doc="Gets and sets the radius of the arc.")

Arc3D.__swig_getmethods__["startAngle"] = Arc3D._get_startAngle
Arc3D.__swig_setmethods__["startAngle"] = Arc3D._set_startAngle
Arc3D.startAngle = property(Arc3D._get_startAngle, Arc3D._set_startAngle, doc="Gets and sets the start angle of the arc in radians.\nThis angle is measured from the reference vector using the right hand rule around the normal vector.")

Arc3D.__swig_getmethods__["endAngle"] = Arc3D._get_endAngle
Arc3D.__swig_setmethods__["endAngle"] = Arc3D._set_endAngle
Arc3D.endAngle = property(Arc3D._get_endAngle, Arc3D._set_endAngle, doc="Gets and sets the end angle of the arc in radians.\nThis angle is measured from the reference vector using the right hand rule around the normal vector.")

Arc3D.__swig_getmethods__["startPoint"] = Arc3D._get_startPoint
Arc3D.startPoint = property(Arc3D._get_startPoint, doc="Gets the start point of the arc.")

Arc3D.__swig_getmethods__["endPoint"] = Arc3D._get_endPoint
Arc3D.endPoint = property(Arc3D._get_endPoint, doc="Gets the end point of the arc.")

Arc3D.__swig_getmethods__["asNurbsCurve"] = Arc3D._get_asNurbsCurve
Arc3D.asNurbsCurve = property(Arc3D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the arc.")

Arc3D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Arc3D) else None
Arc3D.cast = lambda arg: arg if isinstance(arg, Arc3D) else None

class BooleanProperty(Property):
    """A material or appearance property that is a Boolean value."""
    __swig_setmethods__ = {}
    for _s in [Property]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BooleanProperty, name, value)
    __swig_getmethods__ = {}
    for _s in [Property]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BooleanProperty, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::BooleanProperty *" : return _core.BooleanProperty___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.BooleanProperty___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.BooleanProperty___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.BooleanProperty_classType
    if _newclass:classType = staticmethod(_core.BooleanProperty_classType)
    __swig_destroy__ = _core.delete_BooleanProperty
    __del__ = lambda self : None;
    def _get_value(self) -> "bool" :
        """Gets and sets the value of this property."""
        return _core.BooleanProperty__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """Gets and sets the value of this property."""
        return _core.BooleanProperty__set_value(self, *args)

    def _get_name(self) -> "std::string" :
        """
        Returns the name of this property as seen in the user interface. This name is localized
        and can change based on the current language
        """
        return _core.BooleanProperty__get_name(self)

    def _get_isReadOnly(self) -> "bool" :
        """Indicates if this property is read-only. If True any attempted edits will fail."""
        return _core.BooleanProperty__get_isReadOnly(self)

    def _get_id(self) -> "std::string" :
        """Returns the unique ID of this property."""
        return _core.BooleanProperty__get_id(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the parent of this property."""
        return _core.BooleanProperty__get_parent(self)

    def _get_objectType(self) -> "char const *" : return _core.BooleanProperty__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.BooleanProperty__get_isValid(self)
BooleanProperty_swigregister = _core.BooleanProperty_swigregister
BooleanProperty_swigregister(BooleanProperty)

def BooleanProperty_classType() -> "char const *" :
  return _core.BooleanProperty_classType()
BooleanProperty_classType = _core.BooleanProperty_classType

BooleanProperty.__swig_getmethods__["value"] = BooleanProperty._get_value
BooleanProperty.__swig_setmethods__["value"] = BooleanProperty._set_value
BooleanProperty.value = property(BooleanProperty._get_value, BooleanProperty._set_value, doc="Gets and sets the value of this property.")

BooleanProperty.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BooleanProperty) else None
BooleanProperty.cast = lambda arg: arg if isinstance(arg, BooleanProperty) else None

class BoolValueCommandInput(CommandInput):
    """
    Provides a command input to get a boolean value from the user. This is represented
    in the user inteface as either a button or a check box.
    """
    __swig_setmethods__ = {}
    for _s in [CommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoolValueCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [CommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BoolValueCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::BoolValueCommandInput *" : return _core.BoolValueCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.BoolValueCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.BoolValueCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.BoolValueCommandInput_classType
    if _newclass:classType = staticmethod(_core.BoolValueCommandInput_classType)
    __swig_destroy__ = _core.delete_BoolValueCommandInput
    __del__ = lambda self : None;
    def _get_value(self) -> "bool" :
        """
        Gets or sets the state of this input. If it's being displayed as a checkbox a value of true indicates the input is checked.
        If it's being displayed as a button, a value of true indicates the button is currently depressed.
        """
        return _core.BoolValueCommandInput__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """
        Gets or sets the state of this input. If it's being displayed as a checkbox a value of true indicates the input is checked.
        If it's being displayed as a button, a value of true indicates the button is currently depressed.
        """
        return _core.BoolValueCommandInput__set_value(self, *args)

    def _get_resourceFolder(self) -> "std::string" :
        """
        Gets the folder that contains the image to display on the button. Text
        can also be displayed, which is specified using the text property.
        """
        return _core.BoolValueCommandInput__get_resourceFolder(self)

    def _set_resourceFolder(self, *args) -> "bool" :
        """
        Gets the folder that contains the image to display on the button. Text
        can also be displayed, which is specified using the text property.
        """
        return _core.BoolValueCommandInput__set_resourceFolder(self, *args)

    def _get_isCheckBox(self) -> "bool" :
        """Indicates if this is being shown as a button or check box."""
        return _core.BoolValueCommandInput__get_isCheckBox(self)

    def _get_text(self) -> "std::string" :
        """
        Gets and sets text to be displayed on the button. If the resourceFolder
        is not specified then the button will be displayed with only text. If
        text and the resource folder are specified then both the icon and text
        will be displayed.
        """
        return _core.BoolValueCommandInput__get_text(self)

    def _set_text(self, *args) -> "bool" :
        """
        Gets and sets text to be displayed on the button. If the resourceFolder
        is not specified then the button will be displayed with only text. If
        text and the resource folder are specified then both the icon and text
        will be displayed.
        """
        return _core.BoolValueCommandInput__set_text(self, *args)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.BoolValueCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.BoolValueCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.BoolValueCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.BoolValueCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.BoolValueCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.BoolValueCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.BoolValueCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.BoolValueCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.BoolValueCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.BoolValueCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.BoolValueCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.BoolValueCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.BoolValueCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.BoolValueCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.BoolValueCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.BoolValueCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.BoolValueCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.BoolValueCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.BoolValueCommandInput__get_isValid(self)
BoolValueCommandInput_swigregister = _core.BoolValueCommandInput_swigregister
BoolValueCommandInput_swigregister(BoolValueCommandInput)

def BoolValueCommandInput_classType() -> "char const *" :
  return _core.BoolValueCommandInput_classType()
BoolValueCommandInput_classType = _core.BoolValueCommandInput_classType

BoolValueCommandInput.__swig_getmethods__["value"] = BoolValueCommandInput._get_value
BoolValueCommandInput.__swig_setmethods__["value"] = BoolValueCommandInput._set_value
BoolValueCommandInput.value = property(BoolValueCommandInput._get_value, BoolValueCommandInput._set_value, doc="Gets or sets the state of this input. If it's being displayed as a checkbox a value of true indicates the input is checked.\nIf it's being displayed as a button, a value of true indicates the button is currently depressed.")

BoolValueCommandInput.__swig_getmethods__["resourceFolder"] = BoolValueCommandInput._get_resourceFolder
BoolValueCommandInput.__swig_setmethods__["resourceFolder"] = BoolValueCommandInput._set_resourceFolder
BoolValueCommandInput.resourceFolder = property(BoolValueCommandInput._get_resourceFolder, BoolValueCommandInput._set_resourceFolder, doc="Gets the folder that contains the image to display on the button. Text\ncan also be displayed, which is specified using the text property.")

BoolValueCommandInput.__swig_getmethods__["isCheckBox"] = BoolValueCommandInput._get_isCheckBox
BoolValueCommandInput.isCheckBox = property(BoolValueCommandInput._get_isCheckBox, doc="Indicates if this is being shown as a button or check box.")

BoolValueCommandInput.__swig_getmethods__["text"] = BoolValueCommandInput._get_text
BoolValueCommandInput.__swig_setmethods__["text"] = BoolValueCommandInput._set_text
BoolValueCommandInput.text = property(BoolValueCommandInput._get_text, BoolValueCommandInput._set_text, doc="Gets and sets text to be displayed on the button. If the resourceFolder\nis not specified then the button will be displayed with only text. If\ntext and the resource folder are specified then both the icon and text\nwill be displayed.")

BoolValueCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BoolValueCommandInput) else None
BoolValueCommandInput.cast = lambda arg: arg if isinstance(arg, BoolValueCommandInput) else None

class ButtonControlDefinition(ControlDefinition):
    """
    Represents the information used to define a button. This isn't the visible button control but
    is the information needed to create a button control and fully defines a button except for 
    it's position within the user interface.
    """
    __swig_setmethods__ = {}
    for _s in [ControlDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ButtonControlDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ControlDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ButtonControlDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ButtonControlDefinition *" : return _core.ButtonControlDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ButtonControlDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ButtonControlDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ButtonControlDefinition_classType
    if _newclass:classType = staticmethod(_core.ButtonControlDefinition_classType)
    __swig_destroy__ = _core.delete_ButtonControlDefinition
    __del__ = lambda self : None;
    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls."""
        return _core.ButtonControlDefinition__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls."""
        return _core.ButtonControlDefinition__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface."""
        return _core.ButtonControlDefinition__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface."""
        return _core.ButtonControlDefinition__set_isVisible(self, *args)

    def _get_name(self) -> "std::string" :
        """Gets or sets the name for this control. This is the visible name displayed in the user interface."""
        return _core.ButtonControlDefinition__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Gets or sets the name for this control. This is the visible name displayed in the user interface."""
        return _core.ButtonControlDefinition__set_name(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.ButtonControlDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ButtonControlDefinition__get_isValid(self)
ButtonControlDefinition_swigregister = _core.ButtonControlDefinition_swigregister
ButtonControlDefinition_swigregister(ButtonControlDefinition)

def ButtonControlDefinition_classType() -> "char const *" :
  return _core.ButtonControlDefinition_classType()
ButtonControlDefinition_classType = _core.ButtonControlDefinition_classType

ButtonControlDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ButtonControlDefinition) else None
ButtonControlDefinition.cast = lambda arg: arg if isinstance(arg, ButtonControlDefinition) else None

class ButtonRowCommandInput(CommandInput):
    """Provides a command input to get a selection of a single button from a row of buttons."""
    __swig_setmethods__ = {}
    for _s in [CommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ButtonRowCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [CommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ButtonRowCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ButtonRowCommandInput *" : return _core.ButtonRowCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ButtonRowCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ButtonRowCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ButtonRowCommandInput_classType
    if _newclass:classType = staticmethod(_core.ButtonRowCommandInput_classType)
    __swig_destroy__ = _core.delete_ButtonRowCommandInput
    __del__ = lambda self : None;
    def _get_isMultiSelectEnabled(self) -> "bool" :
        """
        Returns if this button row can have multiple items selected at once or not.
        If True, multiple buttons can be selected at once. If False only one button
        can be selected and selecting another button unselects the one currently selected.
        """
        return _core.ButtonRowCommandInput__get_isMultiSelectEnabled(self)

    def _get_listItems(self) -> "adsk::core::Ptr< adsk::core::ListItems >" :
        """
        Returns the ListItems object associated with this button row. You use this
        object to populate and interact with the buttons in the row.
        """
        return _core.ButtonRowCommandInput__get_listItems(self)

    def _get_selectedItem(self) -> "adsk::core::Ptr< adsk::core::ListItem >" :
        """
        Gets the button in the row that is currently selected. This can return null in the 
        case where no button in the row has been selected.
        """
        return _core.ButtonRowCommandInput__get_selectedItem(self)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.ButtonRowCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.ButtonRowCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.ButtonRowCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.ButtonRowCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.ButtonRowCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.ButtonRowCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.ButtonRowCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.ButtonRowCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.ButtonRowCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.ButtonRowCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.ButtonRowCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.ButtonRowCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.ButtonRowCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.ButtonRowCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.ButtonRowCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.ButtonRowCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.ButtonRowCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.ButtonRowCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ButtonRowCommandInput__get_isValid(self)
ButtonRowCommandInput_swigregister = _core.ButtonRowCommandInput_swigregister
ButtonRowCommandInput_swigregister(ButtonRowCommandInput)

def ButtonRowCommandInput_classType() -> "char const *" :
  return _core.ButtonRowCommandInput_classType()
ButtonRowCommandInput_classType = _core.ButtonRowCommandInput_classType

ButtonRowCommandInput.__swig_getmethods__["isMultiSelectEnabled"] = ButtonRowCommandInput._get_isMultiSelectEnabled
ButtonRowCommandInput.isMultiSelectEnabled = property(ButtonRowCommandInput._get_isMultiSelectEnabled, doc="Returns if this button row can have multiple items selected at once or not.\nIf True, multiple buttons can be selected at once. If False only one button\ncan be selected and selecting another button unselects the one currently selected.")

ButtonRowCommandInput.__swig_getmethods__["listItems"] = ButtonRowCommandInput._get_listItems
ButtonRowCommandInput.listItems = property(ButtonRowCommandInput._get_listItems, doc="Returns the ListItems object associated with this button row. You use this\nobject to populate and interact with the buttons in the row.")

ButtonRowCommandInput.__swig_getmethods__["selectedItem"] = ButtonRowCommandInput._get_selectedItem
ButtonRowCommandInput.selectedItem = property(ButtonRowCommandInput._get_selectedItem, doc="Gets the button in the row that is currently selected. This can return null in the\ncase where no button in the row has been selected.")

ButtonRowCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ButtonRowCommandInput) else None
ButtonRowCommandInput.cast = lambda arg: arg if isinstance(arg, ButtonRowCommandInput) else None

class CameraEvent(Event):
    """
    A CameraEvent represents an event that occurs in reaction to the user manipulating the view.
    Camera changes happen when user changes the view by rotating, zooming in or out, panning, 
    changing from parallel to perspective, or when the extents of the viewport changes.
    """
    __swig_setmethods__ = {}
    for _s in [Event]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CameraEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CameraEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::CameraEvent *" : return _core.CameraEvent___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.CameraEvent___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.CameraEvent___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.CameraEvent_classType
    if _newclass:classType = staticmethod(_core.CameraEvent_classType)
    __swig_destroy__ = _core.delete_CameraEvent
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Add a handler to be notified when the event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.CameraEvent_add(self, *args)

    def remove(self, *args) -> "bool" :
        """
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.CameraEvent_remove(self, *args)

    def _get_name(self) -> "std::string" :
        """The name of the event - e.g. 'DocumentOpening'"""
        return _core.CameraEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.CameraEvent__get_sender(self)

    def _get_objectType(self) -> "char const *" : return _core.CameraEvent__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.CameraEvent__get_isValid(self)
CameraEvent_swigregister = _core.CameraEvent_swigregister
CameraEvent_swigregister(CameraEvent)

def CameraEvent_classType() -> "char const *" :
  return _core.CameraEvent_classType()
CameraEvent_classType = _core.CameraEvent_classType

CameraEvent.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CameraEvent) else None
CameraEvent.cast = lambda arg: arg if isinstance(arg, CameraEvent) else None

class CameraEventArgs(EventArgs):
    """
    The CameraEventArgs provides information associated with a camera change.
    Camera changes happen when user changes the view by rotating, zooming in or out, panning, 
    changing from parallel to perspective, or when the extents of the viewport changes.
    """
    __swig_setmethods__ = {}
    for _s in [EventArgs]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CameraEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CameraEventArgs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::CameraEventArgs *" : return _core.CameraEventArgs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.CameraEventArgs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.CameraEventArgs___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.CameraEventArgs_classType
    if _newclass:classType = staticmethod(_core.CameraEventArgs_classType)
    __swig_destroy__ = _core.delete_CameraEventArgs
    __del__ = lambda self : None;
    def _get_viewport(self) -> "adsk::core::Ptr< adsk::core::Viewport >" :
        """Returns the viewport that the modified camera is associated with."""
        return _core.CameraEventArgs__get_viewport(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >" :
        """The event that the firing is in response to."""
        return _core.CameraEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *" : return _core.CameraEventArgs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.CameraEventArgs__get_isValid(self)
CameraEventArgs_swigregister = _core.CameraEventArgs_swigregister
CameraEventArgs_swigregister(CameraEventArgs)

def CameraEventArgs_classType() -> "char const *" :
  return _core.CameraEventArgs_classType()
CameraEventArgs_classType = _core.CameraEventArgs_classType

CameraEventArgs.__swig_getmethods__["viewport"] = CameraEventArgs._get_viewport
CameraEventArgs.viewport = property(CameraEventArgs._get_viewport, doc="Returns the viewport that the modified camera is associated with.")

CameraEventArgs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CameraEventArgs) else None
CameraEventArgs.cast = lambda arg: arg if isinstance(arg, CameraEventArgs) else None

class CheckBoxControlDefinition(ControlDefinition):
    """
    Represents the information used to define a check box. This isn't the visible check box control but
    is the information needed to create a check box control and fully defines a check box except for 
    it's position within the user interface.
    """
    __swig_setmethods__ = {}
    for _s in [ControlDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CheckBoxControlDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ControlDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CheckBoxControlDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::CheckBoxControlDefinition *" : return _core.CheckBoxControlDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.CheckBoxControlDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.CheckBoxControlDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.CheckBoxControlDefinition_classType
    if _newclass:classType = staticmethod(_core.CheckBoxControlDefinition_classType)
    __swig_destroy__ = _core.delete_CheckBoxControlDefinition
    __del__ = lambda self : None;
    def _get_isChecked(self) -> "bool" :
        """
        Gets or sets whether the check box is checked. Changing this will result in changing any 
        associated controls and will execute the associated command.
        """
        return _core.CheckBoxControlDefinition__get_isChecked(self)

    def _set_isChecked(self, *args) -> "bool" :
        """
        Gets or sets whether the check box is checked. Changing this will result in changing any 
        associated controls and will execute the associated command.
        """
        return _core.CheckBoxControlDefinition__set_isChecked(self, *args)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls."""
        return _core.CheckBoxControlDefinition__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls."""
        return _core.CheckBoxControlDefinition__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface."""
        return _core.CheckBoxControlDefinition__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface."""
        return _core.CheckBoxControlDefinition__set_isVisible(self, *args)

    def _get_name(self) -> "std::string" :
        """Gets or sets the name for this control. This is the visible name displayed in the user interface."""
        return _core.CheckBoxControlDefinition__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Gets or sets the name for this control. This is the visible name displayed in the user interface."""
        return _core.CheckBoxControlDefinition__set_name(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.CheckBoxControlDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.CheckBoxControlDefinition__get_isValid(self)
CheckBoxControlDefinition_swigregister = _core.CheckBoxControlDefinition_swigregister
CheckBoxControlDefinition_swigregister(CheckBoxControlDefinition)

def CheckBoxControlDefinition_classType() -> "char const *" :
  return _core.CheckBoxControlDefinition_classType()
CheckBoxControlDefinition_classType = _core.CheckBoxControlDefinition_classType

CheckBoxControlDefinition.__swig_getmethods__["isChecked"] = CheckBoxControlDefinition._get_isChecked
CheckBoxControlDefinition.__swig_setmethods__["isChecked"] = CheckBoxControlDefinition._set_isChecked
CheckBoxControlDefinition.isChecked = property(CheckBoxControlDefinition._get_isChecked, CheckBoxControlDefinition._set_isChecked, doc="Gets or sets whether the check box is checked. Changing this will result in changing any\nassociated controls and will execute the associated command.")

CheckBoxControlDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CheckBoxControlDefinition) else None
CheckBoxControlDefinition.cast = lambda arg: arg if isinstance(arg, CheckBoxControlDefinition) else None

class ChoiceProperty(Property):
    """A material or appearance property that is a pre-defined list of choices."""
    __swig_setmethods__ = {}
    for _s in [Property]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChoiceProperty, name, value)
    __swig_getmethods__ = {}
    for _s in [Property]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ChoiceProperty, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ChoiceProperty *" : return _core.ChoiceProperty___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ChoiceProperty___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ChoiceProperty___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ChoiceProperty_classType
    if _newclass:classType = staticmethod(_core.ChoiceProperty_classType)
    __swig_destroy__ = _core.delete_ChoiceProperty
    __del__ = lambda self : None;
    def getChoices(self) -> "bool" :
        """
        Method that returns the list of available choices. 
        names : An array of the names of the choices. These coincide with the array of choices returned by the choices argument. 
        choices : An array of the choices. These coincide with the array of names returned by the names argument. 
        Returns true if the call was successful.
        """
        return _core.ChoiceProperty_getChoices(self)

    def _get_value(self) -> "std::string" :
        """
        Gets and sets the which choice is selected from the set of choices.
        The value is a string that matches one of the pre-defined choices.
        The names of the available choices can be obtained using GetChoices method.
        """
        return _core.ChoiceProperty__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """
        Gets and sets the which choice is selected from the set of choices.
        The value is a string that matches one of the pre-defined choices.
        The names of the available choices can be obtained using GetChoices method.
        """
        return _core.ChoiceProperty__set_value(self, *args)

    def _get_name(self) -> "std::string" :
        """
        Returns the name of this property as seen in the user interface. This name is localized
        and can change based on the current language
        """
        return _core.ChoiceProperty__get_name(self)

    def _get_isReadOnly(self) -> "bool" :
        """Indicates if this property is read-only. If True any attempted edits will fail."""
        return _core.ChoiceProperty__get_isReadOnly(self)

    def _get_id(self) -> "std::string" :
        """Returns the unique ID of this property."""
        return _core.ChoiceProperty__get_id(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the parent of this property."""
        return _core.ChoiceProperty__get_parent(self)

    def _get_objectType(self) -> "char const *" : return _core.ChoiceProperty__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ChoiceProperty__get_isValid(self)
ChoiceProperty_swigregister = _core.ChoiceProperty_swigregister
ChoiceProperty_swigregister(ChoiceProperty)

def ChoiceProperty_classType() -> "char const *" :
  return _core.ChoiceProperty_classType()
ChoiceProperty_classType = _core.ChoiceProperty_classType

ChoiceProperty.__swig_getmethods__["value"] = ChoiceProperty._get_value
ChoiceProperty.__swig_setmethods__["value"] = ChoiceProperty._set_value
ChoiceProperty.value = property(ChoiceProperty._get_value, ChoiceProperty._set_value, doc="Gets and sets the which choice is selected from the set of choices.\nThe value is a string that matches one of the pre-defined choices.\nThe names of the available choices can be obtained using GetChoices method.")

ChoiceProperty.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ChoiceProperty) else None
ChoiceProperty.cast = lambda arg: arg if isinstance(arg, ChoiceProperty) else None

class Circle2D(Curve2D):
    """
    Transient 2D circle. A transient circle is not displayed or saved in a document.
    Transient circles are used as a wrapper to work with raw 2D arc information. They
    are created statically using one of the create methods of the Circle2D class.
    """
    __swig_setmethods__ = {}
    for _s in [Curve2D]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Circle2D, name, value)
    __swig_getmethods__ = {}
    for _s in [Curve2D]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Circle2D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Circle2D *" : return _core.Circle2D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Circle2D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Circle2D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Circle2D_classType
    if _newclass:classType = staticmethod(_core.Circle2D_classType)
    __swig_getmethods__["createByCenter"] = lambda x: _core.Circle2D_createByCenter
    if _newclass:createByCenter = staticmethod(_core.Circle2D_createByCenter)
    __swig_getmethods__["createByThreePoints"] = lambda x: _core.Circle2D_createByThreePoints
    if _newclass:createByThreePoints = staticmethod(_core.Circle2D_createByThreePoints)
    __swig_destroy__ = _core.delete_Circle2D
    __del__ = lambda self : None;
    def _get_center(self) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """Gets and sets the center position of the circle."""
        return _core.Circle2D__get_center(self)

    def _set_center(self, *args) -> "bool" :
        """Gets and sets the center position of the circle."""
        return _core.Circle2D__set_center(self, *args)

    def _get_radius(self) -> "double" :
        """Gets and sets the radius of the circle."""
        return _core.Circle2D__get_radius(self)

    def _set_radius(self, *args) -> "bool" :
        """Gets and sets the radius of the circle."""
        return _core.Circle2D__set_radius(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Circle2D >" :
        """
        Creates and returns an independent copy of this Circle2D object. 
        Returns an independent copy of this Circle2D object.
        """
        return _core.Circle2D_copy(self)

    def getData(self) -> "bool" :
        """
        Gets all of the data defining the circle. 
        center : The output point defining the center position of the circle. 
        radius : The output radius of the circle. 
        Returns true if successful.
        """
        return _core.Circle2D_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets all of the data defining the circle. 
        center : A point that defines the center position of the circle. 
        radius : The radius of the circle. 
        Returns true if redefining the circle is successful
        """
        return _core.Circle2D_set(self, *args)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve2D >" :
        """Returns a NURBS curve that is geometrically identical to the circle."""
        return _core.Circle2D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve2DTypes" :
        """Returns the type of geometry this curve represents."""
        return _core.Circle2D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator2D >" :
        """Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Circle2D__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms this curve in 2D space. 
        matrix : A 2D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Circle2D_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Circle2D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Circle2D__get_isValid(self)
Circle2D_swigregister = _core.Circle2D_swigregister
Circle2D_swigregister(Circle2D)

def Circle2D_classType() -> "char const *" :
  return _core.Circle2D_classType()
Circle2D_classType = _core.Circle2D_classType

def Circle2D_createByCenter(*args) -> "adsk::core::Ptr< adsk::core::Point2D > const &" :
  return _core.Circle2D_createByCenter(*args)
Circle2D_createByCenter = _core.Circle2D_createByCenter

def Circle2D_createByThreePoints(*args) -> "adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Point2D > const &" :
  return _core.Circle2D_createByThreePoints(*args)
Circle2D_createByThreePoints = _core.Circle2D_createByThreePoints

Circle2D.__swig_getmethods__["center"] = Circle2D._get_center
Circle2D.__swig_setmethods__["center"] = Circle2D._set_center
Circle2D.center = property(Circle2D._get_center, Circle2D._set_center, doc="Gets and sets the center position of the circle.")

Circle2D.__swig_getmethods__["radius"] = Circle2D._get_radius
Circle2D.__swig_setmethods__["radius"] = Circle2D._set_radius
Circle2D.radius = property(Circle2D._get_radius, Circle2D._set_radius, doc="Gets and sets the radius of the circle.")

Circle2D.__swig_getmethods__["asNurbsCurve"] = Circle2D._get_asNurbsCurve
Circle2D.asNurbsCurve = property(Circle2D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the circle.")

Circle2D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Circle2D) else None
Circle2D.cast = lambda arg: arg if isinstance(arg, Circle2D) else None

class Circle3D(Curve3D):
    """
    Transient 3D circle. A transient circle is not displayed or saved in a document.
    Transient 3D circles are used as a wrapper to work with raw 3D circle information.
    They are created statically using one of the create methods of the Circle3D class.
    """
    __swig_setmethods__ = {}
    for _s in [Curve3D]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Circle3D, name, value)
    __swig_getmethods__ = {}
    for _s in [Curve3D]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Circle3D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Circle3D *" : return _core.Circle3D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Circle3D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Circle3D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Circle3D_classType
    if _newclass:classType = staticmethod(_core.Circle3D_classType)
    __swig_getmethods__["createByCenter"] = lambda x: _core.Circle3D_createByCenter
    if _newclass:createByCenter = staticmethod(_core.Circle3D_createByCenter)
    __swig_getmethods__["createByThreePoints"] = lambda x: _core.Circle3D_createByThreePoints
    if _newclass:createByThreePoints = staticmethod(_core.Circle3D_createByThreePoints)
    __swig_destroy__ = _core.delete_Circle3D
    __del__ = lambda self : None;
    def _get_center(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets the center position of the circle."""
        return _core.Circle3D__get_center(self)

    def _set_center(self, *args) -> "bool" :
        """Gets and sets the center position of the circle."""
        return _core.Circle3D__set_center(self, *args)

    def _get_normal(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Gets and sets the normal of the circle."""
        return _core.Circle3D__get_normal(self)

    def _set_normal(self, *args) -> "bool" :
        """Gets and sets the normal of the circle."""
        return _core.Circle3D__set_normal(self, *args)

    def _get_radius(self) -> "double" :
        """Gets and sets the radius of the circle."""
        return _core.Circle3D__get_radius(self)

    def _set_radius(self, *args) -> "bool" :
        """Gets and sets the radius of the circle."""
        return _core.Circle3D__set_radius(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Circle3D >" :
        """
        Creates and returns an independent copy of this Circle3D object. 
        Returns an independent copy of this Circle3D object.
        """
        return _core.Circle3D_copy(self)

    def getData(self) -> "bool" :
        """
        Gets all of the data defining the circle. 
        center : The output center point of the circle. 
        normal : The output normal vector. 
        radius : The output radius of the circle. 
        Returns true if successful
        """
        return _core.Circle3D_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets all of the data defining the circle. 
        center : The center point of the circle. 
        normal : The normal vector of the circle.
        The plane through the center point and perpendicular to the normal vector defines the plane of the circle. 
        radius : The radius of the circle. 
        Returns true if successful
        """
        return _core.Circle3D_set(self, *args)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >" :
        """Returns a NURBS curve that is geometrically identical to the circle."""
        return _core.Circle3D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve3DTypes" :
        """Returns the type of geometry this curve represents."""
        return _core.Circle3D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >" :
        """Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Circle3D__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms this curve in 3D space. 
        matrix : A 3D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Circle3D_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Circle3D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Circle3D__get_isValid(self)
Circle3D_swigregister = _core.Circle3D_swigregister
Circle3D_swigregister(Circle3D)

def Circle3D_classType() -> "char const *" :
  return _core.Circle3D_classType()
Circle3D_classType = _core.Circle3D_classType

def Circle3D_createByCenter(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &" :
  return _core.Circle3D_createByCenter(*args)
Circle3D_createByCenter = _core.Circle3D_createByCenter

def Circle3D_createByThreePoints(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point3D > const &" :
  return _core.Circle3D_createByThreePoints(*args)
Circle3D_createByThreePoints = _core.Circle3D_createByThreePoints

Circle3D.__swig_getmethods__["center"] = Circle3D._get_center
Circle3D.__swig_setmethods__["center"] = Circle3D._set_center
Circle3D.center = property(Circle3D._get_center, Circle3D._set_center, doc="Gets and sets the center position of the circle.")

Circle3D.__swig_getmethods__["normal"] = Circle3D._get_normal
Circle3D.__swig_setmethods__["normal"] = Circle3D._set_normal
Circle3D.normal = property(Circle3D._get_normal, Circle3D._set_normal, doc="Gets and sets the normal of the circle.")

Circle3D.__swig_getmethods__["radius"] = Circle3D._get_radius
Circle3D.__swig_setmethods__["radius"] = Circle3D._set_radius
Circle3D.radius = property(Circle3D._get_radius, Circle3D._set_radius, doc="Gets and sets the radius of the circle.")

Circle3D.__swig_getmethods__["asNurbsCurve"] = Circle3D._get_asNurbsCurve
Circle3D.asNurbsCurve = property(Circle3D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the circle.")

Circle3D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Circle3D) else None
Circle3D.cast = lambda arg: arg if isinstance(arg, Circle3D) else None

class ColorProperty(Property):
    """A color property associated with an appearance."""
    __swig_setmethods__ = {}
    for _s in [Property]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ColorProperty, name, value)
    __swig_getmethods__ = {}
    for _s in [Property]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ColorProperty, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ColorProperty *" : return _core.ColorProperty___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ColorProperty___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ColorProperty___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ColorProperty_classType
    if _newclass:classType = staticmethod(_core.ColorProperty_classType)
    __swig_destroy__ = _core.delete_ColorProperty
    __del__ = lambda self : None;
    def _get_connectedTexture(self) -> "adsk::core::Ptr< adsk::core::AppearanceTexture >" :
        """
        Gets the associated texture, if one exists. The HasConnectedTexture property controls 
        if there is an associated texture or not. If the parent is writable you can edit the 
        texture. If no texture exists, this property will return null.
        """
        return _core.ColorProperty__get_connectedTexture(self)

    def _get_hasConnectedTexture(self) -> "bool" :
        """
        Specifies if this color is specified using a simple color or a texture. If this returns true 
        the color is defined using a texture. If the parent is writable, this property can be set to 
        true to change the definition from a simple color to a texture. You can then use the ConnectedTexture
        property to get the associated texture and modify it.
        """
        return _core.ColorProperty__get_hasConnectedTexture(self)

    def _set_hasConnectedTexture(self, *args) -> "bool" :
        """
        Specifies if this color is specified using a simple color or a texture. If this returns true 
        the color is defined using a texture. If the parent is writable, this property can be set to 
        true to change the definition from a simple color to a texture. You can then use the ConnectedTexture
        property to get the associated texture and modify it.
        """
        return _core.ColorProperty__set_hasConnectedTexture(self, *args)

    def _get_hasMultipleValues(self) -> "bool" :
        """Indicates if this property has multiple values or not."""
        return _core.ColorProperty__get_hasMultipleValues(self)

    def _get_value(self) -> "adsk::core::Ptr< adsk::core::Color >" :
        """
        Gets and sets this property value if there is a color and not a texture defining
        this color . If a texture is used, this property returns null. Setting this property
        when a texture is used removes the texture and changes the color definition to a simple color.
        """
        return _core.ColorProperty__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """
        Gets and sets this property value if there is a color and not a texture defining
        this color . If a texture is used, this property returns null. Setting this property
        when a texture is used removes the texture and changes the color definition to a simple color.
        """
        return _core.ColorProperty__set_value(self, *args)

    def _get_values(self) -> "std::vector< adsk::core::Ptr< adsk::core::Color >,std::allocator< adsk::core::Ptr< adsk::core::Color > > >" :
        """
        Gets and sets the values associated with this property. The HasMultipleValues property 
        indicates if this property will be returning more than one value.
        """
        return _core.ColorProperty__get_values(self)

    def _set_values(self, *args) -> "bool" :
        """
        Gets and sets the values associated with this property. The HasMultipleValues property 
        indicates if this property will be returning more than one value.
        """
        return _core.ColorProperty__set_values(self, *args)

    def _get_name(self) -> "std::string" :
        """
        Returns the name of this property as seen in the user interface. This name is localized
        and can change based on the current language
        """
        return _core.ColorProperty__get_name(self)

    def _get_isReadOnly(self) -> "bool" :
        """Indicates if this property is read-only. If True any attempted edits will fail."""
        return _core.ColorProperty__get_isReadOnly(self)

    def _get_id(self) -> "std::string" :
        """Returns the unique ID of this property."""
        return _core.ColorProperty__get_id(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the parent of this property."""
        return _core.ColorProperty__get_parent(self)

    def _get_objectType(self) -> "char const *" : return _core.ColorProperty__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ColorProperty__get_isValid(self)
ColorProperty_swigregister = _core.ColorProperty_swigregister
ColorProperty_swigregister(ColorProperty)

def ColorProperty_classType() -> "char const *" :
  return _core.ColorProperty_classType()
ColorProperty_classType = _core.ColorProperty_classType

ColorProperty.__swig_getmethods__["connectedTexture"] = ColorProperty._get_connectedTexture
ColorProperty.connectedTexture = property(ColorProperty._get_connectedTexture, doc="Gets the associated texture, if one exists. The HasConnectedTexture property controls\nif there is an associated texture or not. If the parent is writable you can edit the\ntexture. If no texture exists, this property will return null.")

ColorProperty.__swig_getmethods__["hasConnectedTexture"] = ColorProperty._get_hasConnectedTexture
ColorProperty.__swig_setmethods__["hasConnectedTexture"] = ColorProperty._set_hasConnectedTexture
ColorProperty.hasConnectedTexture = property(ColorProperty._get_hasConnectedTexture, ColorProperty._set_hasConnectedTexture, doc="Specifies if this color is specified using a simple color or a texture. If this returns true\nthe color is defined using a texture. If the parent is writable, this property can be set to\ntrue to change the definition from a simple color to a texture. You can then use the ConnectedTexture\nproperty to get the associated texture and modify it.")

ColorProperty.__swig_getmethods__["hasMultipleValues"] = ColorProperty._get_hasMultipleValues
ColorProperty.hasMultipleValues = property(ColorProperty._get_hasMultipleValues, doc="Indicates if this property has multiple values or not.")

ColorProperty.__swig_getmethods__["value"] = ColorProperty._get_value
ColorProperty.__swig_setmethods__["value"] = ColorProperty._set_value
ColorProperty.value = property(ColorProperty._get_value, ColorProperty._set_value, doc="Gets and sets this property value if there is a color and not a texture defining\nthis color . If a texture is used, this property returns null. Setting this property\nwhen a texture is used removes the texture and changes the color definition to a simple color.")

ColorProperty.__swig_getmethods__["values"] = ColorProperty._get_values
ColorProperty.__swig_setmethods__["values"] = ColorProperty._set_values
ColorProperty.values = property(ColorProperty._get_values, ColorProperty._set_values, doc="Gets and sets the values associated with this property. The HasMultipleValues property\nindicates if this property will be returning more than one value.")

ColorProperty.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ColorProperty) else None
ColorProperty.cast = lambda arg: arg if isinstance(arg, ColorProperty) else None

class CommandControl(ToolbarControl):
    """Represents a button, check box, or radio control list in a panel, toolbar, or drop-down."""
    __swig_setmethods__ = {}
    for _s in [ToolbarControl]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CommandControl, name, value)
    __swig_getmethods__ = {}
    for _s in [ToolbarControl]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CommandControl, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::CommandControl *" : return _core.CommandControl___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.CommandControl___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.CommandControl___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.CommandControl_classType
    if _newclass:classType = staticmethod(_core.CommandControl_classType)
    __swig_destroy__ = _core.delete_CommandControl
    __del__ = lambda self : None;
    def _get_commandDefinition(self) -> "adsk::core::Ptr< adsk::core::CommandDefinition >" :
        """
        Gets the command definition associated with this button. The command definition defines
        all of the resource information used to display this button and receives the event when the button is clicked.
        """
        return _core.CommandControl__get_commandDefinition(self)

    def _get_isPromoted(self) -> "bool" :
        """
        Gets or sets if this command has been promoted to the parent panel.
        This property is ignored in the case where this control isn't in a panel.
        """
        return _core.CommandControl__get_isPromoted(self)

    def _set_isPromoted(self, *args) -> "bool" :
        """
        Gets or sets if this command has been promoted to the parent panel.
        This property is ignored in the case where this control isn't in a panel.
        """
        return _core.CommandControl__set_isPromoted(self, *args)

    def _get_isPromotedByDefault(self) -> "bool" :
        """
        Gets or sets if this command is a default command in the panel.
        This defines the default state of the panel if the UI is reset.
        This property is ignored in the case where this control isn't in a panel.
        """
        return _core.CommandControl__get_isPromotedByDefault(self)

    def _set_isPromotedByDefault(self, *args) -> "bool" :
        """
        Gets or sets if this command is a default command in the panel.
        This defines the default state of the panel if the UI is reset.
        This property is ignored in the case where this control isn't in a panel.
        """
        return _core.CommandControl__set_isPromotedByDefault(self, *args)

    def _get_id(self) -> "std::string" :
        """
        Gets the unique ID of this control. The ID is unique with respect to the other
        controls within the same panel, toolbar, or drop-down control.
        """
        return _core.CommandControl__get_id(self)

    def _get_index(self) -> "size_t" :
        """Gets the position of this control within the list of controls within the panel, toolbar, or drop-down control."""
        return _core.CommandControl__get_index(self)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this control is currently visible."""
        return _core.CommandControl__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this control is currently visible."""
        return _core.CommandControl__set_isVisible(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the Parent object. When associated with a toolbar (right or left QAT or the Nav Bar) this
        returns the parent Toolbar object. When associated with a panel it returns the parent ToolbarPanel object.
        When associated with a control (DropDownControl) it returns the parent control.
        """
        return _core.CommandControl__get_parent(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the ToolbarControl 
        Returns a boolean indicating if the deletion was successful.
        """
        return _core.CommandControl_deleteMe(self)

    def _get_objectType(self) -> "char const *" : return _core.CommandControl__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.CommandControl__get_isValid(self)
CommandControl_swigregister = _core.CommandControl_swigregister
CommandControl_swigregister(CommandControl)

def CommandControl_classType() -> "char const *" :
  return _core.CommandControl_classType()
CommandControl_classType = _core.CommandControl_classType

CommandControl.__swig_getmethods__["commandDefinition"] = CommandControl._get_commandDefinition
CommandControl.commandDefinition = property(CommandControl._get_commandDefinition, doc="Gets the command definition associated with this button. The command definition defines\nall of the resource information used to display this button and receives the event when the button is clicked.")

CommandControl.__swig_getmethods__["isPromoted"] = CommandControl._get_isPromoted
CommandControl.__swig_setmethods__["isPromoted"] = CommandControl._set_isPromoted
CommandControl.isPromoted = property(CommandControl._get_isPromoted, CommandControl._set_isPromoted, doc="Gets or sets if this command has been promoted to the parent panel.\nThis property is ignored in the case where this control isn't in a panel.")

CommandControl.__swig_getmethods__["isPromotedByDefault"] = CommandControl._get_isPromotedByDefault
CommandControl.__swig_setmethods__["isPromotedByDefault"] = CommandControl._set_isPromotedByDefault
CommandControl.isPromotedByDefault = property(CommandControl._get_isPromotedByDefault, CommandControl._set_isPromotedByDefault, doc="Gets or sets if this command is a default command in the panel.\nThis defines the default state of the panel if the UI is reset.\nThis property is ignored in the case where this control isn't in a panel.")

CommandControl.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CommandControl) else None
CommandControl.cast = lambda arg: arg if isinstance(arg, CommandControl) else None

class CommandCreatedEvent(Event):
    """Class that needs to be implemented in order to respond to the CommandCreatedEvent event."""
    __swig_setmethods__ = {}
    for _s in [Event]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CommandCreatedEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CommandCreatedEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::CommandCreatedEvent *" : return _core.CommandCreatedEvent___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.CommandCreatedEvent___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.CommandCreatedEvent___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.CommandCreatedEvent_classType
    if _newclass:classType = staticmethod(_core.CommandCreatedEvent_classType)
    __swig_destroy__ = _core.delete_CommandCreatedEvent
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Adds an event handler object to this event endpoint. 
        handler : The client implemented CommandCreatedEventHandler to be called when this event is triggered. 
        Returns true if the handler was successfully added to the set of event handlers.
        """
        return _core.CommandCreatedEvent_add(self, *args)

    def remove(self, *args) -> "bool" :
        """
        Removes a handler from this event endpoint. 
        handler : A CommandCreatedEventHandler that was previously added to this event with the add method. 
        Returns true if the handler was found and removed from the set of event handlers.
        """
        return _core.CommandCreatedEvent_remove(self, *args)

    def _get_name(self) -> "std::string" :
        """The name of the event - e.g. 'DocumentOpening'"""
        return _core.CommandCreatedEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.CommandCreatedEvent__get_sender(self)

    def _get_objectType(self) -> "char const *" : return _core.CommandCreatedEvent__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.CommandCreatedEvent__get_isValid(self)
CommandCreatedEvent_swigregister = _core.CommandCreatedEvent_swigregister
CommandCreatedEvent_swigregister(CommandCreatedEvent)

def CommandCreatedEvent_classType() -> "char const *" :
  return _core.CommandCreatedEvent_classType()
CommandCreatedEvent_classType = _core.CommandCreatedEvent_classType

CommandCreatedEvent.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CommandCreatedEvent) else None
CommandCreatedEvent.cast = lambda arg: arg if isinstance(arg, CommandCreatedEvent) else None

class CommandCreatedEventArgs(EventArgs):
    """Provides data for the CommandCreated event."""
    __swig_setmethods__ = {}
    for _s in [EventArgs]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CommandCreatedEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CommandCreatedEventArgs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::CommandCreatedEventArgs *" : return _core.CommandCreatedEventArgs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.CommandCreatedEventArgs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.CommandCreatedEventArgs___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.CommandCreatedEventArgs_classType
    if _newclass:classType = staticmethod(_core.CommandCreatedEventArgs_classType)
    __swig_destroy__ = _core.delete_CommandCreatedEventArgs
    __del__ = lambda self : None;
    def _get_command(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the newly created Command object that allows you to perform an action in response to the control being clicked."""
        return _core.CommandCreatedEventArgs__get_command(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >" :
        """The event that the firing is in response to."""
        return _core.CommandCreatedEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *" : return _core.CommandCreatedEventArgs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.CommandCreatedEventArgs__get_isValid(self)
CommandCreatedEventArgs_swigregister = _core.CommandCreatedEventArgs_swigregister
CommandCreatedEventArgs_swigregister(CommandCreatedEventArgs)

def CommandCreatedEventArgs_classType() -> "char const *" :
  return _core.CommandCreatedEventArgs_classType()
CommandCreatedEventArgs_classType = _core.CommandCreatedEventArgs_classType

CommandCreatedEventArgs.__swig_getmethods__["command"] = CommandCreatedEventArgs._get_command
CommandCreatedEventArgs.command = property(CommandCreatedEventArgs._get_command, doc="Gets the newly created Command object that allows you to perform an action in response to the control being clicked.")

CommandCreatedEventArgs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CommandCreatedEventArgs) else None
CommandCreatedEventArgs.cast = lambda arg: arg if isinstance(arg, CommandCreatedEventArgs) else None

class CommandEvent(Event):
    """An event endpoint that supports the connection to client implemented CommandEventHandlers."""
    __swig_setmethods__ = {}
    for _s in [Event]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CommandEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CommandEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::CommandEvent *" : return _core.CommandEvent___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.CommandEvent___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.CommandEvent___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.CommandEvent_classType
    if _newclass:classType = staticmethod(_core.CommandEvent_classType)
    __swig_destroy__ = _core.delete_CommandEvent
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Adds an event handler object to this event endpoint. 
        handler : The client implemented CommandEventHandler to be called when this event is triggered. 
        Returns true if the handler was successfully added to the set of event handlers.
        """
        return _core.CommandEvent_add(self, *args)

    def remove(self, *args) -> "bool" :
        """
        Removes a handler from this event endpoint. 
        handler : A CommandEventHandler that was previously added to this event with the add method. 
        Returns true if the handler was found and removed from the set of event handlers.
        """
        return _core.CommandEvent_remove(self, *args)

    def _get_name(self) -> "std::string" :
        """The name of the event - e.g. 'DocumentOpening'"""
        return _core.CommandEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.CommandEvent__get_sender(self)

    def _get_objectType(self) -> "char const *" : return _core.CommandEvent__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.CommandEvent__get_isValid(self)
CommandEvent_swigregister = _core.CommandEvent_swigregister
CommandEvent_swigregister(CommandEvent)

def CommandEvent_classType() -> "char const *" :
  return _core.CommandEvent_classType()
CommandEvent_classType = _core.CommandEvent_classType

CommandEvent.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CommandEvent) else None
CommandEvent.cast = lambda arg: arg if isinstance(arg, CommandEvent) else None

class CommandEventArgs(EventArgs):
    """Provides a set of arguments from a firing CommandEvent to a CommandEventHandler's notify callback method."""
    __swig_setmethods__ = {}
    for _s in [EventArgs]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CommandEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CommandEventArgs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::CommandEventArgs *" : return _core.CommandEventArgs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.CommandEventArgs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.CommandEventArgs___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.CommandEventArgs_classType
    if _newclass:classType = staticmethod(_core.CommandEventArgs_classType)
    __swig_destroy__ = _core.delete_CommandEventArgs
    __del__ = lambda self : None;
    def _get_command(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the Command object."""
        return _core.CommandEventArgs__get_command(self)

    def _get_executeFailed(self) -> "bool" :
        """
        Used during the execute event to get or set that the execute operations failed
        and the commands transaction should be aborted.
        This property should be ignored for all events besides the Execute event.
        """
        return _core.CommandEventArgs__get_executeFailed(self)

    def _set_executeFailed(self, *args) -> "bool" :
        """
        Used during the execute event to get or set that the execute operations failed
        and the commands transaction should be aborted.
        This property should be ignored for all events besides the Execute event.
        """
        return _core.CommandEventArgs__set_executeFailed(self, *args)

    def _get_executeFailedMessage(self) -> "std::string" :
        """
        Used during the execute event to get or set a description of an execute failure.
        This property should be ignored for all events besides the Execute event.
        """
        return _core.CommandEventArgs__get_executeFailedMessage(self)

    def _set_executeFailedMessage(self, *args) -> "bool" :
        """
        Used during the execute event to get or set a description of an execute failure.
        This property should be ignored for all events besides the Execute event.
        """
        return _core.CommandEventArgs__set_executeFailedMessage(self, *args)

    def _get_isValidResult(self) -> "bool" :
        """
        Used during the commandStarting event to get or set that the result of preview is valid
        and the command can reuse the result when Ok is hit.
        This property should be ignored for all events besides the executePreview event.
        """
        return _core.CommandEventArgs__get_isValidResult(self)

    def _set_isValidResult(self, *args) -> "bool" :
        """
        Used during the commandStarting event to get or set that the result of preview is valid
        and the command can reuse the result when Ok is hit.
        This property should be ignored for all events besides the executePreview event.
        """
        return _core.CommandEventArgs__set_isValidResult(self, *args)

    def _get_terminationReason(self) -> "adsk::core::CommandTerminationReason" :
        """Gets the termination reason of the command. It's only valid on the destroy event."""
        return _core.CommandEventArgs__get_terminationReason(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >" :
        """The event that the firing is in response to."""
        return _core.CommandEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *" : return _core.CommandEventArgs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.CommandEventArgs__get_isValid(self)
CommandEventArgs_swigregister = _core.CommandEventArgs_swigregister
CommandEventArgs_swigregister(CommandEventArgs)

def CommandEventArgs_classType() -> "char const *" :
  return _core.CommandEventArgs_classType()
CommandEventArgs_classType = _core.CommandEventArgs_classType

CommandEventArgs.__swig_getmethods__["command"] = CommandEventArgs._get_command
CommandEventArgs.command = property(CommandEventArgs._get_command, doc="Gets the Command object.")

CommandEventArgs.__swig_getmethods__["executeFailed"] = CommandEventArgs._get_executeFailed
CommandEventArgs.__swig_setmethods__["executeFailed"] = CommandEventArgs._set_executeFailed
CommandEventArgs.executeFailed = property(CommandEventArgs._get_executeFailed, CommandEventArgs._set_executeFailed, doc="Used during the execute event to get or set that the execute operations failed\nand the commands transaction should be aborted.\nThis property should be ignored for all events besides the Execute event.")

CommandEventArgs.__swig_getmethods__["executeFailedMessage"] = CommandEventArgs._get_executeFailedMessage
CommandEventArgs.__swig_setmethods__["executeFailedMessage"] = CommandEventArgs._set_executeFailedMessage
CommandEventArgs.executeFailedMessage = property(CommandEventArgs._get_executeFailedMessage, CommandEventArgs._set_executeFailedMessage, doc="Used during the execute event to get or set a description of an execute failure.\nThis property should be ignored for all events besides the Execute event.")

CommandEventArgs.__swig_getmethods__["isValidResult"] = CommandEventArgs._get_isValidResult
CommandEventArgs.__swig_setmethods__["isValidResult"] = CommandEventArgs._set_isValidResult
CommandEventArgs.isValidResult = property(CommandEventArgs._get_isValidResult, CommandEventArgs._set_isValidResult, doc="Used during the commandStarting event to get or set that the result of preview is valid\nand the command can reuse the result when Ok is hit.\nThis property should be ignored for all events besides the executePreview event.")

CommandEventArgs.__swig_getmethods__["terminationReason"] = CommandEventArgs._get_terminationReason
CommandEventArgs.terminationReason = property(CommandEventArgs._get_terminationReason, doc="Gets the termination reason of the command. It's only valid on the destroy event.")

CommandEventArgs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CommandEventArgs) else None
CommandEventArgs.cast = lambda arg: arg if isinstance(arg, CommandEventArgs) else None

class Cone(Surface):
    """
    Transient cone. A transient cone is not displayed or saved in a document.
    A transient cone is used as a wrapper to work with raw cone information. 
    A transient cone has no boundaries.
    The cone always goes to a point in its narrowing direction, and is infinite in its 
    widening direction.
    They are created statically using the create method of the Cone class.
    """
    __swig_setmethods__ = {}
    for _s in [Surface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Cone, name, value)
    __swig_getmethods__ = {}
    for _s in [Surface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Cone, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Cone *" : return _core.Cone___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Cone___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Cone___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Cone_classType
    if _newclass:classType = staticmethod(_core.Cone_classType)
    __swig_getmethods__["create"] = lambda x: _core.Cone_create
    if _newclass:create = staticmethod(_core.Cone_create)
    __swig_destroy__ = _core.delete_Cone
    __del__ = lambda self : None;
    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets the origin point (center) of the base of the cone."""
        return _core.Cone__get_origin(self)

    def _set_origin(self, *args) -> "bool" :
        """Gets and sets the origin point (center) of the base of the cone."""
        return _core.Cone__set_origin(self, *args)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Gets and sets the center axis (along the length) of the cone that defines its 
        normal direction.
        """
        return _core.Cone__get_axis(self)

    def _set_axis(self, *args) -> "bool" :
        """
        Gets and sets the center axis (along the length) of the cone that defines its 
        normal direction.
        """
        return _core.Cone__set_axis(self, *args)

    def _get_radius(self) -> "double" :
        """Gets and sets the radius of the cone."""
        return _core.Cone__get_radius(self)

    def _set_radius(self, *args) -> "bool" :
        """Gets and sets the radius of the cone."""
        return _core.Cone__set_radius(self, *args)

    def _get_halfAngle(self) -> "double" :
        """
        Gets and sets the taper half-angle of the cone in radians.
        A negative value indicates that the cone is narrowing in the direction of the 
        axis vector, whereas a positive value indicates that it is expanding in the direction of
        the axis vector.
        """
        return _core.Cone__get_halfAngle(self)

    def _set_halfAngle(self, *args) -> "bool" :
        """
        Gets and sets the taper half-angle of the cone in radians.
        A negative value indicates that the cone is narrowing in the direction of the 
        axis vector, whereas a positive value indicates that it is expanding in the direction of
        the axis vector.
        """
        return _core.Cone__set_halfAngle(self, *args)

    def getData(self) -> "bool" :
        """
        Gets the data that defines the cone. 
        origin : The output origin point (center) of the base of the cone. 
        axis : The output center axis (along the length) of the cone that defines its normal direction. 
        radius : The output radius of the cone. 
        halfAngle : The output taper half-angle of the cone. 
        Returns true if successful.
        """
        return _core.Cone_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets the data that defines the cone. 
        origin : The origin point (center) of the base of the cone. 
        axis : The center axis (along the length) of the cone that defines its normal direction. 
        radius : The radius of the cone. 
        halfAngle : The taper half-angle of the cone. 
        Returns true if successful.
        """
        return _core.Cone_set(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Cone >" :
        """
        Creates and returns an independent copy of this Cone object. 
        Returns a new Cone object that is a copy of this Cone object.
        """
        return _core.Cone_copy(self)

    def _get_surfaceType(self) -> "adsk::core::SurfaceTypes" :
        """Returns the surface type."""
        return _core.Cone__get_surfaceType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >" :
        """Returns the surface evaluator."""
        return _core.Cone__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Updates this surface by transforming it with a given input matrix. 
        matrix : A 3D matrix that defines the transform to apply to the surface. 
        Returns true if the transform was successful.
        """
        return _core.Cone_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Cone__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Cone__get_isValid(self)
Cone_swigregister = _core.Cone_swigregister
Cone_swigregister(Cone)

def Cone_classType() -> "char const *" :
  return _core.Cone_classType()
Cone_classType = _core.Cone_classType

def Cone_create(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &" :
  return _core.Cone_create(*args)
Cone_create = _core.Cone_create

Cone.__swig_getmethods__["origin"] = Cone._get_origin
Cone.__swig_setmethods__["origin"] = Cone._set_origin
Cone.origin = property(Cone._get_origin, Cone._set_origin, doc="Gets and sets the origin point (center) of the base of the cone.")

Cone.__swig_getmethods__["axis"] = Cone._get_axis
Cone.__swig_setmethods__["axis"] = Cone._set_axis
Cone.axis = property(Cone._get_axis, Cone._set_axis, doc="Gets and sets the center axis (along the length) of the cone that defines its\nnormal direction.")

Cone.__swig_getmethods__["radius"] = Cone._get_radius
Cone.__swig_setmethods__["radius"] = Cone._set_radius
Cone.radius = property(Cone._get_radius, Cone._set_radius, doc="Gets and sets the radius of the cone.")

Cone.__swig_getmethods__["halfAngle"] = Cone._get_halfAngle
Cone.__swig_setmethods__["halfAngle"] = Cone._set_halfAngle
Cone.halfAngle = property(Cone._get_halfAngle, Cone._set_halfAngle, doc="Gets and sets the taper half-angle of the cone in radians.\nA negative value indicates that the cone is narrowing in the direction of the\naxis vector, whereas a positive value indicates that it is expanding in the direction of\nthe axis vector.")

Cone.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Cone) else None
Cone.cast = lambda arg: arg if isinstance(arg, Cone) else None

class CustomEvent(Event):
    """
    A CustomEvent is primarily used to send an event from a worker thread you've created back
    to your add-in, which is running in the primary thread. It's also possible for add-ins to
    cooperate and another add-in can trigger this event in your add-in by knowing the custom
    event id.
    """
    __swig_setmethods__ = {}
    for _s in [Event]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::CustomEvent *" : return _core.CustomEvent___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.CustomEvent___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.CustomEvent___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.CustomEvent_classType
    if _newclass:classType = staticmethod(_core.CustomEvent_classType)
    __swig_destroy__ = _core.delete_CustomEvent
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Add a handler to be notified when the event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.CustomEvent_add(self, *args)

    def remove(self, *args) -> "bool" :
        """
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.CustomEvent_remove(self, *args)

    def _get_eventId(self) -> "std::string" :
        """
        Returns the id that was assigned to this event when it was registered. Each
        custom event has it's own unique id.
        """
        return _core.CustomEvent__get_eventId(self)

    def _get_name(self) -> "std::string" :
        """The name of the event - e.g. 'DocumentOpening'"""
        return _core.CustomEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.CustomEvent__get_sender(self)

    def _get_objectType(self) -> "char const *" : return _core.CustomEvent__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.CustomEvent__get_isValid(self)
CustomEvent_swigregister = _core.CustomEvent_swigregister
CustomEvent_swigregister(CustomEvent)

def CustomEvent_classType() -> "char const *" :
  return _core.CustomEvent_classType()
CustomEvent_classType = _core.CustomEvent_classType

CustomEvent.__swig_getmethods__["eventId"] = CustomEvent._get_eventId
CustomEvent.eventId = property(CustomEvent._get_eventId, doc="Returns the id that was assigned to this event when it was registered. Each\ncustom event has it's own unique id.")

CustomEvent.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomEvent) else None
CustomEvent.cast = lambda arg: arg if isinstance(arg, CustomEvent) else None

class CustomEventArgs(EventArgs):
    """
    The ApplicationEventArgs provides information associated with an application event. 
    Note that some properties are not available on every event
    """
    __swig_setmethods__ = {}
    for _s in [EventArgs]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomEventArgs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::CustomEventArgs *" : return _core.CustomEventArgs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.CustomEventArgs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.CustomEventArgs___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.CustomEventArgs_classType
    if _newclass:classType = staticmethod(_core.CustomEventArgs_classType)
    __swig_destroy__ = _core.delete_CustomEventArgs
    __del__ = lambda self : None;
    def _get_additionalInfo(self) -> "std::string" :
        """
        Information being passed to the add-in in the primary thread from the worker thread
        or other add-in.
        """
        return _core.CustomEventArgs__get_additionalInfo(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >" :
        """The event that the firing is in response to."""
        return _core.CustomEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *" : return _core.CustomEventArgs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.CustomEventArgs__get_isValid(self)
CustomEventArgs_swigregister = _core.CustomEventArgs_swigregister
CustomEventArgs_swigregister(CustomEventArgs)

def CustomEventArgs_classType() -> "char const *" :
  return _core.CustomEventArgs_classType()
CustomEventArgs_classType = _core.CustomEventArgs_classType

CustomEventArgs.__swig_getmethods__["additionalInfo"] = CustomEventArgs._get_additionalInfo
CustomEventArgs.additionalInfo = property(CustomEventArgs._get_additionalInfo, doc="Information being passed to the add-in in the primary thread from the worker thread\nor other add-in.")

CustomEventArgs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomEventArgs) else None
CustomEventArgs.cast = lambda arg: arg if isinstance(arg, CustomEventArgs) else None

class Cylinder(Surface):
    """
    Transient cylinder. A transient cylinder is not displayed or saved in a document.
    A transient cylinder is but is used as a wrapper to work with raw cylinder information. 
    A transient cylinder has no boundaries and is infinite in length. 
    They are created statically using the create method of the Cylinder class.
    """
    __swig_setmethods__ = {}
    for _s in [Surface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Cylinder, name, value)
    __swig_getmethods__ = {}
    for _s in [Surface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Cylinder, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Cylinder *" : return _core.Cylinder___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Cylinder___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Cylinder___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Cylinder_classType
    if _newclass:classType = staticmethod(_core.Cylinder_classType)
    __swig_getmethods__["create"] = lambda x: _core.Cylinder_create
    if _newclass:create = staticmethod(_core.Cylinder_create)
    __swig_destroy__ = _core.delete_Cylinder
    __del__ = lambda self : None;
    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """The origin point (center) of the base of the cylinder."""
        return _core.Cylinder__get_origin(self)

    def _set_origin(self, *args) -> "bool" :
        """The origin point (center) of the base of the cylinder."""
        return _core.Cylinder__set_origin(self, *args)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """The center axis (along the length) of the cylinder that defines its normal direction."""
        return _core.Cylinder__get_axis(self)

    def _set_axis(self, *args) -> "bool" :
        """The center axis (along the length) of the cylinder that defines its normal direction."""
        return _core.Cylinder__set_axis(self, *args)

    def _get_radius(self) -> "double" :
        """The radius of the cylinder."""
        return _core.Cylinder__get_radius(self)

    def _set_radius(self, *args) -> "bool" :
        """The radius of the cylinder."""
        return _core.Cylinder__set_radius(self, *args)

    def getData(self) -> "bool" :
        """
        Gets the data that defines the cylinder. 
        origin : The output origin point (center) of the base of the cylinder. 
        axis : The output center axis (along the length) of the cylinder that defines its normal direction. 
        radius : The output radius of the cylinder. 
        Returns true if successful.
        """
        return _core.Cylinder_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets the data that defines the cylinder. 
        origin : The origin point (center) of the base of the cylinder. 
        axis : The center axis (along the length) of the cylinder that defines its normal direction. 
        radius : The radius of the cylinder. 
        Returns true if successful.
        """
        return _core.Cylinder_set(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Cylinder >" :
        """
        Creates and returns an independent copy of this Cylinder object. 
        Returns a new Cylinder object that is a copy of this Cylinder object.
        """
        return _core.Cylinder_copy(self)

    def _get_surfaceType(self) -> "adsk::core::SurfaceTypes" :
        """Returns the surface type."""
        return _core.Cylinder__get_surfaceType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >" :
        """Returns the surface evaluator."""
        return _core.Cylinder__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Updates this surface by transforming it with a given input matrix. 
        matrix : A 3D matrix that defines the transform to apply to the surface. 
        Returns true if the transform was successful.
        """
        return _core.Cylinder_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Cylinder__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Cylinder__get_isValid(self)
Cylinder_swigregister = _core.Cylinder_swigregister
Cylinder_swigregister(Cylinder)

def Cylinder_classType() -> "char const *" :
  return _core.Cylinder_classType()
Cylinder_classType = _core.Cylinder_classType

def Cylinder_create(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &" :
  return _core.Cylinder_create(*args)
Cylinder_create = _core.Cylinder_create

Cylinder.__swig_getmethods__["origin"] = Cylinder._get_origin
Cylinder.__swig_setmethods__["origin"] = Cylinder._set_origin
Cylinder.origin = property(Cylinder._get_origin, Cylinder._set_origin, doc="The origin point (center) of the base of the cylinder.")

Cylinder.__swig_getmethods__["axis"] = Cylinder._get_axis
Cylinder.__swig_setmethods__["axis"] = Cylinder._set_axis
Cylinder.axis = property(Cylinder._get_axis, Cylinder._set_axis, doc="The center axis (along the length) of the cylinder that defines its normal direction.")

Cylinder.__swig_getmethods__["radius"] = Cylinder._get_radius
Cylinder.__swig_setmethods__["radius"] = Cylinder._set_radius
Cylinder.radius = property(Cylinder._get_radius, Cylinder._set_radius, doc="The radius of the cylinder.")

Cylinder.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Cylinder) else None
Cylinder.cast = lambda arg: arg if isinstance(arg, Cylinder) else None

class DirectionCommandInput(CommandInput):
    """
    Represents a command input that gets a direction from the user. This displays
    a button or a checkbox in the command dialog where the user can flip the direction if desired and also displays
    a manipulator in the graphics window to allow flipping the direction by clicking and dragging on the manipulator.
    """
    __swig_setmethods__ = {}
    for _s in [CommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DirectionCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [CommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DirectionCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DirectionCommandInput *" : return _core.DirectionCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DirectionCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DirectionCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DirectionCommandInput_classType
    if _newclass:classType = staticmethod(_core.DirectionCommandInput_classType)
    __swig_destroy__ = _core.delete_DirectionCommandInput
    __del__ = lambda self : None;
    def setManipulator(self, *args) -> "bool" :
        """
        Defines a direction manipulator arrow in the graphics viewport whose direction can be flipped by the 
        toggling the checkbox, clicking the button or by the user clicking and dragging on the manipulator arrow. 
        origin : The origin point of the direction manipulator (arrow) in the model space of the root component. 
        direction : The direction of the manipulator (arrow) in the model space of the root component. 
        Returns true if successful
        """
        return _core.DirectionCommandInput_setManipulator(self, *args)

    def _get_manipulatorOrigin(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        Gets the origin point of the direction manipulator (arrow) in the model space of the root component.
        To set the origin use the setManipulator method.
        """
        return _core.DirectionCommandInput__get_manipulatorOrigin(self)

    def _get_manipulatorDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Gets the direction of the manipulator (arrow) in the model space of the root component.
        To set the direction use the setManipulator method.
        """
        return _core.DirectionCommandInput__get_manipulatorDirection(self)

    def _get_isDirectionFlipped(self) -> "bool" :
        """
        Gets and sets if the direction manipulator displayed is flipped (reversed 180 degrees as compared to the 
        direction defined by the manipulatorDirection property). This is false for a newly created DirectionCommandInput.
        """
        return _core.DirectionCommandInput__get_isDirectionFlipped(self)

    def _set_isDirectionFlipped(self, *args) -> "bool" :
        """
        Gets and sets if the direction manipulator displayed is flipped (reversed 180 degrees as compared to the 
        direction defined by the manipulatorDirection property). This is false for a newly created DirectionCommandInput.
        """
        return _core.DirectionCommandInput__set_isDirectionFlipped(self, *args)

    def _get_resourceFolder(self) -> "std::string" :
        """
        Gets and sets the folder that contains the image to display on the button.
        The input is shown as a check box if set resource folder to empty.
        """
        return _core.DirectionCommandInput__get_resourceFolder(self)

    def _set_resourceFolder(self, *args) -> "bool" :
        """
        Gets and sets the folder that contains the image to display on the button.
        The input is shown as a check box if set resource folder to empty.
        """
        return _core.DirectionCommandInput__set_resourceFolder(self, *args)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.DirectionCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.DirectionCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.DirectionCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.DirectionCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.DirectionCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.DirectionCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.DirectionCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.DirectionCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.DirectionCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.DirectionCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.DirectionCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.DirectionCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.DirectionCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.DirectionCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.DirectionCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.DirectionCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.DirectionCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.DirectionCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DirectionCommandInput__get_isValid(self)
DirectionCommandInput_swigregister = _core.DirectionCommandInput_swigregister
DirectionCommandInput_swigregister(DirectionCommandInput)

def DirectionCommandInput_classType() -> "char const *" :
  return _core.DirectionCommandInput_classType()
DirectionCommandInput_classType = _core.DirectionCommandInput_classType

DirectionCommandInput.__swig_getmethods__["manipulatorOrigin"] = DirectionCommandInput._get_manipulatorOrigin
DirectionCommandInput.manipulatorOrigin = property(DirectionCommandInput._get_manipulatorOrigin, doc="Gets the origin point of the direction manipulator (arrow) in the model space of the root component.\nTo set the origin use the setManipulator method.")

DirectionCommandInput.__swig_getmethods__["manipulatorDirection"] = DirectionCommandInput._get_manipulatorDirection
DirectionCommandInput.manipulatorDirection = property(DirectionCommandInput._get_manipulatorDirection, doc="Gets the direction of the manipulator (arrow) in the model space of the root component.\nTo set the direction use the setManipulator method.")

DirectionCommandInput.__swig_getmethods__["isDirectionFlipped"] = DirectionCommandInput._get_isDirectionFlipped
DirectionCommandInput.__swig_setmethods__["isDirectionFlipped"] = DirectionCommandInput._set_isDirectionFlipped
DirectionCommandInput.isDirectionFlipped = property(DirectionCommandInput._get_isDirectionFlipped, DirectionCommandInput._set_isDirectionFlipped, doc="Gets and sets if the direction manipulator displayed is flipped (reversed 180 degrees as compared to the\ndirection defined by the manipulatorDirection property). This is false for a newly created DirectionCommandInput.")

DirectionCommandInput.__swig_getmethods__["resourceFolder"] = DirectionCommandInput._get_resourceFolder
DirectionCommandInput.__swig_setmethods__["resourceFolder"] = DirectionCommandInput._set_resourceFolder
DirectionCommandInput.resourceFolder = property(DirectionCommandInput._get_resourceFolder, DirectionCommandInput._set_resourceFolder, doc="Gets and sets the folder that contains the image to display on the button.\nThe input is shown as a check box if set resource folder to empty.")

DirectionCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DirectionCommandInput) else None
DirectionCommandInput.cast = lambda arg: arg if isinstance(arg, DirectionCommandInput) else None

class DistanceValueCommandInput(CommandInput):
    """
    Represents a command input that gets a distance from the user. This displays
    an entry in the command dialog where the user can enter a value and also displays
    a manipulator in the graphics window to allow them to graphically set the value.
    The input box is displayed in the dialog when the isVisible property of the command
    input is true. The manipulator is displayed in the graphics when both the isVisible
    and isEnabled properties are true.
    """
    __swig_setmethods__ = {}
    for _s in [CommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DistanceValueCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [CommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DistanceValueCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DistanceValueCommandInput *" : return _core.DistanceValueCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DistanceValueCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DistanceValueCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DistanceValueCommandInput_classType
    if _newclass:classType = staticmethod(_core.DistanceValueCommandInput_classType)
    __swig_destroy__ = _core.delete_DistanceValueCommandInput
    __del__ = lambda self : None;
    def _get_value(self) -> "double" :
        """
        Gets and sets the current value of the command input. The value is
        in centimeters but will be displayed to the user in the current default
        document units. Setting this value can fail if the input value is 
        not within the minimum and maximum value range.
        The isValidExpression property should be checked before using this
        value within the command because if the expression can't be evaluated
        there isn't a valid value. Fusion 360 won't allow the execution of a command
        that contains ValueCommandInput object with invalid expressions so you can
        dependably use the value in the execute event of the command.
        """
        return _core.DistanceValueCommandInput__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """
        Gets and sets the current value of the command input. The value is
        in centimeters but will be displayed to the user in the current default
        document units. Setting this value can fail if the input value is 
        not within the minimum and maximum value range.
        The isValidExpression property should be checked before using this
        value within the command because if the expression can't be evaluated
        there isn't a valid value. Fusion 360 won't allow the execution of a command
        that contains ValueCommandInput object with invalid expressions so you can
        dependably use the value in the execute event of the command.
        """
        return _core.DistanceValueCommandInput__set_value(self, *args)

    def _get_expression(self) -> "std::string" :
        """
        Gets or sets the expression displayed in the input field. This can contain equations and
        references to parameters but must result in a valid length expression. If units are not
        specified as part of the expression, the default units for the design are used.
        """
        return _core.DistanceValueCommandInput__get_expression(self)

    def _set_expression(self, *args) -> "bool" :
        """
        Gets or sets the expression displayed in the input field. This can contain equations and
        references to parameters but must result in a valid length expression. If units are not
        specified as part of the expression, the default units for the design are used.
        """
        return _core.DistanceValueCommandInput__set_expression(self, *args)

    def _get_minimumValue(self) -> "double" :
        """
        Gets and sets minimum value, if any, that the value can be. When getting this
        property you should first check the hasMinimumValue property to see if this property
        applies. Also, the isMinimumValueInclusive indicates if the minimum includes this
        value or will be up to this value.
        Setting this value will change the isMinimumValueInclusive to True and the hasMinimumValue property to True if hasMinimumValue is currently
        False, otherwise it will just update the value.
        """
        return _core.DistanceValueCommandInput__get_minimumValue(self)

    def _set_minimumValue(self, *args) -> "bool" :
        """
        Gets and sets minimum value, if any, that the value can be. When getting this
        property you should first check the hasMinimumValue property to see if this property
        applies. Also, the isMinimumValueInclusive indicates if the minimum includes this
        value or will be up to this value.
        Setting this value will change the isMinimumValueInclusive to True and the hasMinimumValue property to True if hasMinimumValue is currently
        False, otherwise it will just update the value.
        """
        return _core.DistanceValueCommandInput__set_minimumValue(self, *args)

    def _get_hasMinimumValue(self) -> "bool" :
        """
        Gets and sets if there is a minimum value for this command input. When setting this property, it is only valid
        to set it to False to remove the minimum value. Setting the minimumValue property will result in this property
        being set to True.
        """
        return _core.DistanceValueCommandInput__get_hasMinimumValue(self)

    def _set_hasMinimumValue(self, *args) -> "bool" :
        """
        Gets and sets if there is a minimum value for this command input. When setting this property, it is only valid
        to set it to False to remove the minimum value. Setting the minimumValue property will result in this property
        being set to True.
        """
        return _core.DistanceValueCommandInput__set_hasMinimumValue(self, *args)

    def _get_isMinimumValueInclusive(self) -> "bool" :
        """
        Gets and sets if the value of the input includes the minimum value or is up to the minimum value. For example,
        if the minimum value is zero and this property is True, the minimum value can be zero. If this is False, the 
        minimum value must be greater than zero. When the minimum value is first defined using the minimumValue property,
        this property is set to True. The value returned by this property is only meaningful when the hasMinimumValue property
        returns True.
        """
        return _core.DistanceValueCommandInput__get_isMinimumValueInclusive(self)

    def _set_isMinimumValueInclusive(self, *args) -> "bool" :
        """
        Gets and sets if the value of the input includes the minimum value or is up to the minimum value. For example,
        if the minimum value is zero and this property is True, the minimum value can be zero. If this is False, the 
        minimum value must be greater than zero. When the minimum value is first defined using the minimumValue property,
        this property is set to True. The value returned by this property is only meaningful when the hasMinimumValue property
        returns True.
        """
        return _core.DistanceValueCommandInput__set_isMinimumValueInclusive(self, *args)

    def _get_maximumValue(self) -> "double" :
        """
        Gets and sets maximum value, if any, that the value can be. When getting this
        property you should first check the hasMaximumValue property to see if this property
        applies. Also, the isMaximumValueInclusive indicates if the maximum includes this
        value or will be up to this value.
        """
        return _core.DistanceValueCommandInput__get_maximumValue(self)

    def _set_maximumValue(self, *args) -> "bool" :
        """
        Gets and sets maximum value, if any, that the value can be. When getting this
        property you should first check the hasMaximumValue property to see if this property
        applies. Also, the isMaximumValueInclusive indicates if the maximum includes this
        value or will be up to this value.
        """
        return _core.DistanceValueCommandInput__set_maximumValue(self, *args)

    def _get_hasMaximumValue(self) -> "bool" :
        """
        Gets and sets if there is a maximum value for this command input. When setting this property, it is only valid
        to set it to False to remove the maximum value. Setting the maximumValue property will result in this property
        being set to True.
        """
        return _core.DistanceValueCommandInput__get_hasMaximumValue(self)

    def _set_hasMaximumValue(self, *args) -> "bool" :
        """
        Gets and sets if there is a maximum value for this command input. When setting this property, it is only valid
        to set it to False to remove the maximum value. Setting the maximumValue property will result in this property
        being set to True.
        """
        return _core.DistanceValueCommandInput__set_hasMaximumValue(self, *args)

    def _get_isMaximumValueInclusive(self) -> "bool" :
        """
        Gets and sets if the value of the input includes the maximum value or is up to the maximum value. For example,
        if the maximum value is 100 and this property is True, the maximum value can be 100. If this is False, the 
        minimum value must be less than 100. When the maximum value is first defined using the maximumValue property,
        this property is set to True. The value returned by this property is only meaninful when the hasMaximumValue property
        returns True.
        """
        return _core.DistanceValueCommandInput__get_isMaximumValueInclusive(self)

    def _set_isMaximumValueInclusive(self, *args) -> "bool" :
        """
        Gets and sets if the value of the input includes the maximum value or is up to the maximum value. For example,
        if the maximum value is 100 and this property is True, the maximum value can be 100. If this is False, the 
        minimum value must be less than 100. When the maximum value is first defined using the maximumValue property,
        this property is set to True. The value returned by this property is only meaninful when the hasMaximumValue property
        returns True.
        """
        return _core.DistanceValueCommandInput__set_isMaximumValueInclusive(self, *args)

    def setManipulator(self, *args) -> "bool" :
        """
        Defines the position and orientation of the manipulator. The manipulator is only visible
        when both the isVisible and isEnabled properties are true. If those properties are
        true and the setManipulator has not been called, the manipulator will be displayed in
        a default location (0,0,0) and direction (1,0,0). Because of that the input is typically
        set to be invisible and/or disabled and then enabled once enough input has been specified
        that you can display the manipulator in the desired location. 
        origin : Defines the position of the manipulator in root component space. 
        direction : Defines the direction of the manipulator in root component space. 
        Returns true if successful.
        """
        return _core.DistanceValueCommandInput_setManipulator(self, *args)

    def _get_manipulatorOrigin(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        Gets the origin point of the manipulator in the model space of the root component.
        To set the origin use the setManipulator method.
        """
        return _core.DistanceValueCommandInput__get_manipulatorOrigin(self)

    def _get_manipulatorDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Gets the positive direction of the manipulator in the model space or the root component.
        To set the direction use the setManipulator method.
        """
        return _core.DistanceValueCommandInput__get_manipulatorDirection(self)

    def _get_isValidExpression(self) -> "bool" :
        """
        Returns true if the current expression is valid and can be evaluated. If this
        is false, the value returned should be ignored because there currently is
        not a valid value.
        """
        return _core.DistanceValueCommandInput__get_isValidExpression(self)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.DistanceValueCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.DistanceValueCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.DistanceValueCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.DistanceValueCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.DistanceValueCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.DistanceValueCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.DistanceValueCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.DistanceValueCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.DistanceValueCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.DistanceValueCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.DistanceValueCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.DistanceValueCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.DistanceValueCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.DistanceValueCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.DistanceValueCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.DistanceValueCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.DistanceValueCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.DistanceValueCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DistanceValueCommandInput__get_isValid(self)
DistanceValueCommandInput_swigregister = _core.DistanceValueCommandInput_swigregister
DistanceValueCommandInput_swigregister(DistanceValueCommandInput)

def DistanceValueCommandInput_classType() -> "char const *" :
  return _core.DistanceValueCommandInput_classType()
DistanceValueCommandInput_classType = _core.DistanceValueCommandInput_classType

DistanceValueCommandInput.__swig_getmethods__["value"] = DistanceValueCommandInput._get_value
DistanceValueCommandInput.__swig_setmethods__["value"] = DistanceValueCommandInput._set_value
DistanceValueCommandInput.value = property(DistanceValueCommandInput._get_value, DistanceValueCommandInput._set_value, doc="Gets and sets the current value of the command input. The value is\nin centimeters but will be displayed to the user in the current default\ndocument units. Setting this value can fail if the input value is\nnot within the minimum and maximum value range.\nThe isValidExpression property should be checked before using this\nvalue within the command because if the expression can't be evaluated\nthere isn't a valid value. Fusion 360 won't allow the execution of a command\nthat contains ValueCommandInput object with invalid expressions so you can\ndependably use the value in the execute event of the command.")

DistanceValueCommandInput.__swig_getmethods__["expression"] = DistanceValueCommandInput._get_expression
DistanceValueCommandInput.__swig_setmethods__["expression"] = DistanceValueCommandInput._set_expression
DistanceValueCommandInput.expression = property(DistanceValueCommandInput._get_expression, DistanceValueCommandInput._set_expression, doc="Gets or sets the expression displayed in the input field. This can contain equations and\nreferences to parameters but must result in a valid length expression. If units are not\nspecified as part of the expression, the default units for the design are used.")

DistanceValueCommandInput.__swig_getmethods__["minimumValue"] = DistanceValueCommandInput._get_minimumValue
DistanceValueCommandInput.__swig_setmethods__["minimumValue"] = DistanceValueCommandInput._set_minimumValue
DistanceValueCommandInput.minimumValue = property(DistanceValueCommandInput._get_minimumValue, DistanceValueCommandInput._set_minimumValue, doc="Gets and sets minimum value, if any, that the value can be. When getting this\nproperty you should first check the hasMinimumValue property to see if this property\napplies. Also, the isMinimumValueInclusive indicates if the minimum includes this\nvalue or will be up to this value.\nSetting this value will change the isMinimumValueInclusive to True and the hasMinimumValue property to True if hasMinimumValue is currently\nFalse, otherwise it will just update the value.")

DistanceValueCommandInput.__swig_getmethods__["hasMinimumValue"] = DistanceValueCommandInput._get_hasMinimumValue
DistanceValueCommandInput.__swig_setmethods__["hasMinimumValue"] = DistanceValueCommandInput._set_hasMinimumValue
DistanceValueCommandInput.hasMinimumValue = property(DistanceValueCommandInput._get_hasMinimumValue, DistanceValueCommandInput._set_hasMinimumValue, doc="Gets and sets if there is a minimum value for this command input. When setting this property, it is only valid\nto set it to False to remove the minimum value. Setting the minimumValue property will result in this property\nbeing set to True.")

DistanceValueCommandInput.__swig_getmethods__["isMinimumValueInclusive"] = DistanceValueCommandInput._get_isMinimumValueInclusive
DistanceValueCommandInput.__swig_setmethods__["isMinimumValueInclusive"] = DistanceValueCommandInput._set_isMinimumValueInclusive
DistanceValueCommandInput.isMinimumValueInclusive = property(DistanceValueCommandInput._get_isMinimumValueInclusive, DistanceValueCommandInput._set_isMinimumValueInclusive, doc="Gets and sets if the value of the input includes the minimum value or is up to the minimum value. For example,\nif the minimum value is zero and this property is True, the minimum value can be zero. If this is False, the\nminimum value must be greater than zero. When the minimum value is first defined using the minimumValue property,\nthis property is set to True. The value returned by this property is only meaningful when the hasMinimumValue property\nreturns True.")

DistanceValueCommandInput.__swig_getmethods__["maximumValue"] = DistanceValueCommandInput._get_maximumValue
DistanceValueCommandInput.__swig_setmethods__["maximumValue"] = DistanceValueCommandInput._set_maximumValue
DistanceValueCommandInput.maximumValue = property(DistanceValueCommandInput._get_maximumValue, DistanceValueCommandInput._set_maximumValue, doc="Gets and sets maximum value, if any, that the value can be. When getting this\nproperty you should first check the hasMaximumValue property to see if this property\napplies. Also, the isMaximumValueInclusive indicates if the maximum includes this\nvalue or will be up to this value.")

DistanceValueCommandInput.__swig_getmethods__["hasMaximumValue"] = DistanceValueCommandInput._get_hasMaximumValue
DistanceValueCommandInput.__swig_setmethods__["hasMaximumValue"] = DistanceValueCommandInput._set_hasMaximumValue
DistanceValueCommandInput.hasMaximumValue = property(DistanceValueCommandInput._get_hasMaximumValue, DistanceValueCommandInput._set_hasMaximumValue, doc="Gets and sets if there is a maximum value for this command input. When setting this property, it is only valid\nto set it to False to remove the maximum value. Setting the maximumValue property will result in this property\nbeing set to True.")

DistanceValueCommandInput.__swig_getmethods__["isMaximumValueInclusive"] = DistanceValueCommandInput._get_isMaximumValueInclusive
DistanceValueCommandInput.__swig_setmethods__["isMaximumValueInclusive"] = DistanceValueCommandInput._set_isMaximumValueInclusive
DistanceValueCommandInput.isMaximumValueInclusive = property(DistanceValueCommandInput._get_isMaximumValueInclusive, DistanceValueCommandInput._set_isMaximumValueInclusive, doc="Gets and sets if the value of the input includes the maximum value or is up to the maximum value. For example,\nif the maximum value is 100 and this property is True, the maximum value can be 100. If this is False, the\nminimum value must be less than 100. When the maximum value is first defined using the maximumValue property,\nthis property is set to True. The value returned by this property is only meaninful when the hasMaximumValue property\nreturns True.")

DistanceValueCommandInput.__swig_getmethods__["manipulatorOrigin"] = DistanceValueCommandInput._get_manipulatorOrigin
DistanceValueCommandInput.manipulatorOrigin = property(DistanceValueCommandInput._get_manipulatorOrigin, doc="Gets the origin point of the manipulator in the model space of the root component.\nTo set the origin use the setManipulator method.")

DistanceValueCommandInput.__swig_getmethods__["manipulatorDirection"] = DistanceValueCommandInput._get_manipulatorDirection
DistanceValueCommandInput.manipulatorDirection = property(DistanceValueCommandInput._get_manipulatorDirection, doc="Gets the positive direction of the manipulator in the model space or the root component.\nTo set the direction use the setManipulator method.")

DistanceValueCommandInput.__swig_getmethods__["isValidExpression"] = DistanceValueCommandInput._get_isValidExpression
DistanceValueCommandInput.isValidExpression = property(DistanceValueCommandInput._get_isValidExpression, doc="Returns true if the current expression is valid and can be evaluated. If this\nis false, the value returned should be ignored because there currently is\nnot a valid value.")

DistanceValueCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DistanceValueCommandInput) else None
DistanceValueCommandInput.cast = lambda arg: arg if isinstance(arg, DistanceValueCommandInput) else None

class DocumentEvent(Event):
    """A DocumentEvent represents a document related event. For example, DocumentOpening or DocumentOpened."""
    __swig_setmethods__ = {}
    for _s in [Event]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DocumentEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DocumentEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DocumentEvent *" : return _core.DocumentEvent___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DocumentEvent___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DocumentEvent___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DocumentEvent_classType
    if _newclass:classType = staticmethod(_core.DocumentEvent_classType)
    __swig_destroy__ = _core.delete_DocumentEvent
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Add a handler to be notified when the file event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.DocumentEvent_add(self, *args)

    def remove(self, *args) -> "bool" :
        """
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.DocumentEvent_remove(self, *args)

    def _get_name(self) -> "std::string" :
        """The name of the event - e.g. 'DocumentOpening'"""
        return _core.DocumentEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.DocumentEvent__get_sender(self)

    def _get_objectType(self) -> "char const *" : return _core.DocumentEvent__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DocumentEvent__get_isValid(self)
DocumentEvent_swigregister = _core.DocumentEvent_swigregister
DocumentEvent_swigregister(DocumentEvent)

def DocumentEvent_classType() -> "char const *" :
  return _core.DocumentEvent_classType()
DocumentEvent_classType = _core.DocumentEvent_classType

DocumentEvent.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DocumentEvent) else None
DocumentEvent.cast = lambda arg: arg if isinstance(arg, DocumentEvent) else None

class DocumentEventArgs(EventArgs):
    """
    The DocumentEventArgs provides information associated with a document event. 
    Note that some properties are not available on every event 
    - for example, the Document is not available on the DocumentOpening event because 
    the Document is not yet available.
    """
    __swig_setmethods__ = {}
    for _s in [EventArgs]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DocumentEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DocumentEventArgs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DocumentEventArgs *" : return _core.DocumentEventArgs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DocumentEventArgs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DocumentEventArgs___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DocumentEventArgs_classType
    if _newclass:classType = staticmethod(_core.DocumentEventArgs_classType)
    __swig_destroy__ = _core.delete_DocumentEventArgs
    __del__ = lambda self : None;
    def _get_document(self) -> "adsk::core::Ptr< adsk::core::Document >" :
        """
        Provides access to the document that is open. Can be null in the case
        where the event is fired before the document has been opened or after it has been closed.
        """
        return _core.DocumentEventArgs__get_document(self)

    def _get_fullPath(self) -> "std::string" :
        """The full path to the file."""
        return _core.DocumentEventArgs__get_fullPath(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >" :
        """The event that the firing is in response to."""
        return _core.DocumentEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *" : return _core.DocumentEventArgs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DocumentEventArgs__get_isValid(self)
DocumentEventArgs_swigregister = _core.DocumentEventArgs_swigregister
DocumentEventArgs_swigregister(DocumentEventArgs)

def DocumentEventArgs_classType() -> "char const *" :
  return _core.DocumentEventArgs_classType()
DocumentEventArgs_classType = _core.DocumentEventArgs_classType

DocumentEventArgs.__swig_getmethods__["document"] = DocumentEventArgs._get_document
DocumentEventArgs.document = property(DocumentEventArgs._get_document, doc="Provides access to the document that is open. Can be null in the case\nwhere the event is fired before the document has been opened or after it has been closed.")

DocumentEventArgs.__swig_getmethods__["fullPath"] = DocumentEventArgs._get_fullPath
DocumentEventArgs.fullPath = property(DocumentEventArgs._get_fullPath, doc="The full path to the file.")

DocumentEventArgs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DocumentEventArgs) else None
DocumentEventArgs.cast = lambda arg: arg if isinstance(arg, DocumentEventArgs) else None

class DropDownCommandInput(CommandInput):
    """Provides a command input to get the choice in a dropdown list from the user."""
    __swig_setmethods__ = {}
    for _s in [CommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DropDownCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [CommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DropDownCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DropDownCommandInput *" : return _core.DropDownCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DropDownCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DropDownCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DropDownCommandInput_classType
    if _newclass:classType = staticmethod(_core.DropDownCommandInput_classType)
    __swig_destroy__ = _core.delete_DropDownCommandInput
    __del__ = lambda self : None;
    def _get_dropDownStyle(self) -> "adsk::core::DropDownStyles" :
        """Returns the style of drop down this was created as."""
        return _core.DropDownCommandInput__get_dropDownStyle(self)

    def _get_listItems(self) -> "adsk::core::Ptr< adsk::core::ListItems >" :
        """
        Returns the ListItems object associated with this drop-down. You use this
        object to populate and interact with the items in the drop-down.
        """
        return _core.DropDownCommandInput__get_listItems(self)

    def _get_selectedItem(self) -> "adsk::core::Ptr< adsk::core::ListItem >" :
        """
        Gets the item in the list that is currently selected. This can return null in the 
        case where no item in the list has been selected. This should be ignored
        for CheckBoxDropDownStyle style drop-downs because multiple items can be selected
        and each LiteItem should be checked individually.
        """
        return _core.DropDownCommandInput__get_selectedItem(self)

    def _get_maxVisibleItems(self) -> "int" :
        """Gets or sets the maximum allowed size on screen of the drop down list, measured in items."""
        return _core.DropDownCommandInput__get_maxVisibleItems(self)

    def _set_maxVisibleItems(self, *args) -> "bool" :
        """Gets or sets the maximum allowed size on screen of the drop down list, measured in items."""
        return _core.DropDownCommandInput__set_maxVisibleItems(self, *args)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.DropDownCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.DropDownCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.DropDownCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.DropDownCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.DropDownCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.DropDownCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.DropDownCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.DropDownCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.DropDownCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.DropDownCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.DropDownCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.DropDownCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.DropDownCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.DropDownCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.DropDownCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.DropDownCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.DropDownCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.DropDownCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DropDownCommandInput__get_isValid(self)
DropDownCommandInput_swigregister = _core.DropDownCommandInput_swigregister
DropDownCommandInput_swigregister(DropDownCommandInput)

def DropDownCommandInput_classType() -> "char const *" :
  return _core.DropDownCommandInput_classType()
DropDownCommandInput_classType = _core.DropDownCommandInput_classType

DropDownCommandInput.__swig_getmethods__["dropDownStyle"] = DropDownCommandInput._get_dropDownStyle
DropDownCommandInput.dropDownStyle = property(DropDownCommandInput._get_dropDownStyle, doc="Returns the style of drop down this was created as.")

DropDownCommandInput.__swig_getmethods__["listItems"] = DropDownCommandInput._get_listItems
DropDownCommandInput.listItems = property(DropDownCommandInput._get_listItems, doc="Returns the ListItems object associated with this drop-down. You use this\nobject to populate and interact with the items in the drop-down.")

DropDownCommandInput.__swig_getmethods__["selectedItem"] = DropDownCommandInput._get_selectedItem
DropDownCommandInput.selectedItem = property(DropDownCommandInput._get_selectedItem, doc="Gets the item in the list that is currently selected. This can return null in the\ncase where no item in the list has been selected. This should be ignored\nfor CheckBoxDropDownStyle style drop-downs because multiple items can be selected\nand each LiteItem should be checked individually.")

DropDownCommandInput.__swig_getmethods__["maxVisibleItems"] = DropDownCommandInput._get_maxVisibleItems
DropDownCommandInput.__swig_setmethods__["maxVisibleItems"] = DropDownCommandInput._set_maxVisibleItems
DropDownCommandInput.maxVisibleItems = property(DropDownCommandInput._get_maxVisibleItems, DropDownCommandInput._set_maxVisibleItems, doc="Gets or sets the maximum allowed size on screen of the drop down list, measured in items.")

DropDownCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DropDownCommandInput) else None
DropDownCommandInput.cast = lambda arg: arg if isinstance(arg, DropDownCommandInput) else None

class DropDownControl(ToolbarControl):
    """Represents a drop-down control."""
    __swig_setmethods__ = {}
    for _s in [ToolbarControl]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DropDownControl, name, value)
    __swig_getmethods__ = {}
    for _s in [ToolbarControl]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DropDownControl, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DropDownControl *" : return _core.DropDownControl___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DropDownControl___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DropDownControl___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DropDownControl_classType
    if _newclass:classType = staticmethod(_core.DropDownControl_classType)
    __swig_destroy__ = _core.delete_DropDownControl
    __del__ = lambda self : None;
    def _get_controls(self) -> "adsk::core::Ptr< adsk::core::ToolbarControls >" :
        """Gets the associated ToolbarControls collection. Through this you can add additional controls to the drop-down."""
        return _core.DropDownControl__get_controls(self)

    def _get_resourceFolder(self) -> "std::string" :
        """Gets or sets the resource folder containing the image used for the icon when the drop-down is in a toolbar."""
        return _core.DropDownControl__get_resourceFolder(self)

    def _set_resourceFolder(self, *args) -> "bool" :
        """Gets or sets the resource folder containing the image used for the icon when the drop-down is in a toolbar."""
        return _core.DropDownControl__set_resourceFolder(self, *args)

    def _get_name(self) -> "std::string" :
        """Gets or sets the Name displayed for this drop down. This isn't used when the drop-down is in a toolbar because an icon is used in that case."""
        return _core.DropDownControl__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Gets or sets the Name displayed for this drop down. This isn't used when the drop-down is in a toolbar because an icon is used in that case."""
        return _core.DropDownControl__set_name(self, *args)

    def _get_id(self) -> "std::string" :
        """
        Gets the unique ID of this control. The ID is unique with respect to the other
        controls within the same panel, toolbar, or drop-down control.
        """
        return _core.DropDownControl__get_id(self)

    def _get_index(self) -> "size_t" :
        """Gets the position of this control within the list of controls within the panel, toolbar, or drop-down control."""
        return _core.DropDownControl__get_index(self)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this control is currently visible."""
        return _core.DropDownControl__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this control is currently visible."""
        return _core.DropDownControl__set_isVisible(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the Parent object. When associated with a toolbar (right or left QAT or the Nav Bar) this
        returns the parent Toolbar object. When associated with a panel it returns the parent ToolbarPanel object.
        When associated with a control (DropDownControl) it returns the parent control.
        """
        return _core.DropDownControl__get_parent(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the ToolbarControl 
        Returns a boolean indicating if the deletion was successful.
        """
        return _core.DropDownControl_deleteMe(self)

    def _get_objectType(self) -> "char const *" : return _core.DropDownControl__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DropDownControl__get_isValid(self)
DropDownControl_swigregister = _core.DropDownControl_swigregister
DropDownControl_swigregister(DropDownControl)

def DropDownControl_classType() -> "char const *" :
  return _core.DropDownControl_classType()
DropDownControl_classType = _core.DropDownControl_classType

DropDownControl.__swig_getmethods__["controls"] = DropDownControl._get_controls
DropDownControl.controls = property(DropDownControl._get_controls, doc="Gets the associated ToolbarControls collection. Through this you can add additional controls to the drop-down.")

DropDownControl.__swig_getmethods__["resourceFolder"] = DropDownControl._get_resourceFolder
DropDownControl.__swig_setmethods__["resourceFolder"] = DropDownControl._set_resourceFolder
DropDownControl.resourceFolder = property(DropDownControl._get_resourceFolder, DropDownControl._set_resourceFolder, doc="Gets or sets the resource folder containing the image used for the icon when the drop-down is in a toolbar.")

DropDownControl.__swig_getmethods__["name"] = DropDownControl._get_name
DropDownControl.__swig_setmethods__["name"] = DropDownControl._set_name
DropDownControl.name = property(DropDownControl._get_name, DropDownControl._set_name, doc="Gets or sets the Name displayed for this drop down. This isn't used when the drop-down is in a toolbar because an icon is used in that case.")

DropDownControl.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DropDownControl) else None
DropDownControl.cast = lambda arg: arg if isinstance(arg, DropDownControl) else None

class DXF2DImportOptions(ImportOptions):
    """
    Defines that a 2D DXF Import to create sketches (based on layers in the DXF file) is to be performed and 
    specifies the various options.
    """
    __swig_setmethods__ = {}
    for _s in [ImportOptions]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DXF2DImportOptions, name, value)
    __swig_getmethods__ = {}
    for _s in [ImportOptions]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DXF2DImportOptions, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::DXF2DImportOptions *" : return _core.DXF2DImportOptions___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.DXF2DImportOptions___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.DXF2DImportOptions___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.DXF2DImportOptions_classType
    if _newclass:classType = staticmethod(_core.DXF2DImportOptions_classType)
    __swig_destroy__ = _core.delete_DXF2DImportOptions
    __del__ = lambda self : None;
    def _get_planarEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the construction plane or planar face that defines the plane that the resulting sketches will
        be created on.
        """
        return _core.DXF2DImportOptions__get_planarEntity(self)

    def _set_planarEntity(self, *args) -> "bool" :
        """
        Gets and sets the construction plane or planar face that defines the plane that the resulting sketches will
        be created on.
        """
        return _core.DXF2DImportOptions__set_planarEntity(self, *args)

    def _get_position(self) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """
        Gets and sets the X,Y offset position for the origin of the imported DXF data relative to the sketch origin.
        This defaults to (0,0) in a newly created DXF2DImportOptions object.
        """
        return _core.DXF2DImportOptions__get_position(self)

    def _set_position(self, *args) -> "bool" :
        """
        Gets and sets the X,Y offset position for the origin of the imported DXF data relative to the sketch origin.
        This defaults to (0,0) in a newly created DXF2DImportOptions object.
        """
        return _core.DXF2DImportOptions__set_position(self, *args)

    def _get_results(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Returns a collection of Sketch objects. A sketch is created for each layer in the dxf file 
        that contains 2D geometry. Any 3D geometry contained in the DXF file is ignored.
        The names of the resulting sketches correspond to the layer names in the DXF file.
        Currently, the only way to get a single sketch as a result is to supply a DXF file that only has 2D geometry
        on a single layer.
        """
        return _core.DXF2DImportOptions__get_results(self)

    def _get_filename(self) -> "std::string" :
        """Gets and sets the filename or url of the file to be imported."""
        return _core.DXF2DImportOptions__get_filename(self)

    def _set_filename(self, *args) -> "bool" :
        """Gets and sets the filename or url of the file to be imported."""
        return _core.DXF2DImportOptions__set_filename(self, *args)

    def _get_isViewFit(self) -> "bool" :
        """
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.DXF2DImportOptions__get_isViewFit(self)

    def _set_isViewFit(self, *args) -> "bool" :
        """
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.DXF2DImportOptions__set_isViewFit(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.DXF2DImportOptions__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.DXF2DImportOptions__get_isValid(self)
DXF2DImportOptions_swigregister = _core.DXF2DImportOptions_swigregister
DXF2DImportOptions_swigregister(DXF2DImportOptions)

def DXF2DImportOptions_classType() -> "char const *" :
  return _core.DXF2DImportOptions_classType()
DXF2DImportOptions_classType = _core.DXF2DImportOptions_classType

DXF2DImportOptions.__swig_getmethods__["planarEntity"] = DXF2DImportOptions._get_planarEntity
DXF2DImportOptions.__swig_setmethods__["planarEntity"] = DXF2DImportOptions._set_planarEntity
DXF2DImportOptions.planarEntity = property(DXF2DImportOptions._get_planarEntity, DXF2DImportOptions._set_planarEntity, doc="Gets and sets the construction plane or planar face that defines the plane that the resulting sketches will\nbe created on.")

DXF2DImportOptions.__swig_getmethods__["position"] = DXF2DImportOptions._get_position
DXF2DImportOptions.__swig_setmethods__["position"] = DXF2DImportOptions._set_position
DXF2DImportOptions.position = property(DXF2DImportOptions._get_position, DXF2DImportOptions._set_position, doc="Gets and sets the X,Y offset position for the origin of the imported DXF data relative to the sketch origin.\nThis defaults to (0,0) in a newly created DXF2DImportOptions object.")

DXF2DImportOptions.__swig_getmethods__["results"] = DXF2DImportOptions._get_results
DXF2DImportOptions.results = property(DXF2DImportOptions._get_results, doc="Returns a collection of Sketch objects. A sketch is created for each layer in the dxf file\nthat contains 2D geometry. Any 3D geometry contained in the DXF file is ignored.\nThe names of the resulting sketches correspond to the layer names in the DXF file.\nCurrently, the only way to get a single sketch as a result is to supply a DXF file that only has 2D geometry\non a single layer.")

DXF2DImportOptions.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DXF2DImportOptions) else None
DXF2DImportOptions.cast = lambda arg: arg if isinstance(arg, DXF2DImportOptions) else None

class Ellipse2D(Curve2D):
    """
    Transient 2D ellipse. A transient ellipse is not displayed or saved in a document.
    Transient 2D ellipses are used as a wrapper to work with raw 2D ellipse information.
    They are created statically using the create method of the Ellipse2D class.
    """
    __swig_setmethods__ = {}
    for _s in [Curve2D]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Ellipse2D, name, value)
    __swig_getmethods__ = {}
    for _s in [Curve2D]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Ellipse2D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Ellipse2D *" : return _core.Ellipse2D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Ellipse2D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Ellipse2D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Ellipse2D_classType
    if _newclass:classType = staticmethod(_core.Ellipse2D_classType)
    __swig_getmethods__["create"] = lambda x: _core.Ellipse2D_create
    if _newclass:create = staticmethod(_core.Ellipse2D_create)
    __swig_destroy__ = _core.delete_Ellipse2D
    __del__ = lambda self : None;
    def _get_center(self) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """Gets and sets the center position of the ellipse."""
        return _core.Ellipse2D__get_center(self)

    def _set_center(self, *args) -> "bool" :
        """Gets and sets the center position of the ellipse."""
        return _core.Ellipse2D__set_center(self, *args)

    def _get_majorAxis(self) -> "adsk::core::Ptr< adsk::core::Vector2D >" :
        """Gets and sets the major axis of the ellipse."""
        return _core.Ellipse2D__get_majorAxis(self)

    def _set_majorAxis(self, *args) -> "bool" :
        """Gets and sets the major axis of the ellipse."""
        return _core.Ellipse2D__set_majorAxis(self, *args)

    def _get_majorRadius(self) -> "double" :
        """Gets and sets the major radius of the ellipse."""
        return _core.Ellipse2D__get_majorRadius(self)

    def _set_majorRadius(self, *args) -> "bool" :
        """Gets and sets the major radius of the ellipse."""
        return _core.Ellipse2D__set_majorRadius(self, *args)

    def _get_minorRadius(self) -> "double" :
        """Gets and sets the minor radius of the ellipse."""
        return _core.Ellipse2D__get_minorRadius(self)

    def _set_minorRadius(self, *args) -> "bool" :
        """Gets and sets the minor radius of the ellipse."""
        return _core.Ellipse2D__set_minorRadius(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Ellipse2D >" :
        """
        Creates and returns a copy of this Ellipse2D object. 
        Returns a new Ellipse2D object that is a copy of this Ellipse2D object.
        """
        return _core.Ellipse2D_copy(self)

    def getData(self) -> "bool" :
        """
        Gets all of the data defining the ellipse. 
        center : The output center point of the ellipse. 
        majorAxis : The output major axis of the ellipse. 
        majorRadius : The output major radius of the of the ellipse. 
        minorRadius : The output minor radius of the of the ellipse. 
        Returns true if successful.
        """
        return _core.Ellipse2D_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets all of the data defining the ellipse. 
        center : A Point2D object that defines the center of the ellipse. 
        majorAxis : The major axis of the ellipse. 
        majorRadius : The major radius of the of the ellipse. 
        minorRadius : The minor radius of the of the ellipse. 
        Returns true if redefining the ellipse is successful.
        """
        return _core.Ellipse2D_set(self, *args)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve2D >" :
        """Returns a NURBS curve that is geometrically identical to the ellipse."""
        return _core.Ellipse2D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve2DTypes" :
        """Returns the type of geometry this curve represents."""
        return _core.Ellipse2D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator2D >" :
        """Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Ellipse2D__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms this curve in 2D space. 
        matrix : A 2D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Ellipse2D_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Ellipse2D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Ellipse2D__get_isValid(self)
Ellipse2D_swigregister = _core.Ellipse2D_swigregister
Ellipse2D_swigregister(Ellipse2D)

def Ellipse2D_classType() -> "char const *" :
  return _core.Ellipse2D_classType()
Ellipse2D_classType = _core.Ellipse2D_classType

def Ellipse2D_create(*args) -> "adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Vector2D > const &" :
  return _core.Ellipse2D_create(*args)
Ellipse2D_create = _core.Ellipse2D_create

Ellipse2D.__swig_getmethods__["center"] = Ellipse2D._get_center
Ellipse2D.__swig_setmethods__["center"] = Ellipse2D._set_center
Ellipse2D.center = property(Ellipse2D._get_center, Ellipse2D._set_center, doc="Gets and sets the center position of the ellipse.")

Ellipse2D.__swig_getmethods__["majorAxis"] = Ellipse2D._get_majorAxis
Ellipse2D.__swig_setmethods__["majorAxis"] = Ellipse2D._set_majorAxis
Ellipse2D.majorAxis = property(Ellipse2D._get_majorAxis, Ellipse2D._set_majorAxis, doc="Gets and sets the major axis of the ellipse.")

Ellipse2D.__swig_getmethods__["majorRadius"] = Ellipse2D._get_majorRadius
Ellipse2D.__swig_setmethods__["majorRadius"] = Ellipse2D._set_majorRadius
Ellipse2D.majorRadius = property(Ellipse2D._get_majorRadius, Ellipse2D._set_majorRadius, doc="Gets and sets the major radius of the ellipse.")

Ellipse2D.__swig_getmethods__["minorRadius"] = Ellipse2D._get_minorRadius
Ellipse2D.__swig_setmethods__["minorRadius"] = Ellipse2D._set_minorRadius
Ellipse2D.minorRadius = property(Ellipse2D._get_minorRadius, Ellipse2D._set_minorRadius, doc="Gets and sets the minor radius of the ellipse.")

Ellipse2D.__swig_getmethods__["asNurbsCurve"] = Ellipse2D._get_asNurbsCurve
Ellipse2D.asNurbsCurve = property(Ellipse2D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the ellipse.")

Ellipse2D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Ellipse2D) else None
Ellipse2D.cast = lambda arg: arg if isinstance(arg, Ellipse2D) else None

class Ellipse3D(Curve3D):
    """
    Transient 3D ellipse. A transient ellipse is n0t displayed or saved in a document.
    Transient 3D ellipses are used as a wrapper to work with raw 3D ellipse information.
    They are created statically using the create method of the Ellipse3D class.
    """
    __swig_setmethods__ = {}
    for _s in [Curve3D]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Ellipse3D, name, value)
    __swig_getmethods__ = {}
    for _s in [Curve3D]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Ellipse3D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Ellipse3D *" : return _core.Ellipse3D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Ellipse3D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Ellipse3D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Ellipse3D_classType
    if _newclass:classType = staticmethod(_core.Ellipse3D_classType)
    __swig_getmethods__["create"] = lambda x: _core.Ellipse3D_create
    if _newclass:create = staticmethod(_core.Ellipse3D_create)
    __swig_destroy__ = _core.delete_Ellipse3D
    __del__ = lambda self : None;
    def _get_center(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets the center position of the ellipse."""
        return _core.Ellipse3D__get_center(self)

    def _set_center(self, *args) -> "bool" :
        """Gets and sets the center position of the ellipse."""
        return _core.Ellipse3D__set_center(self, *args)

    def _get_normal(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Gets and sets the normal of the ellipse."""
        return _core.Ellipse3D__get_normal(self)

    def _get_majorAxis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Gets and sets the major axis of the ellipse."""
        return _core.Ellipse3D__get_majorAxis(self)

    def _set_majorAxis(self, *args) -> "bool" :
        """Gets and sets the major axis of the ellipse."""
        return _core.Ellipse3D__set_majorAxis(self, *args)

    def _get_majorRadius(self) -> "double" :
        """Gets and sets the major radius of the ellipse."""
        return _core.Ellipse3D__get_majorRadius(self)

    def _set_majorRadius(self, *args) -> "bool" :
        """Gets and sets the major radius of the ellipse."""
        return _core.Ellipse3D__set_majorRadius(self, *args)

    def _get_minorRadius(self) -> "double" :
        """Gets and sets the minor radius of the ellipse."""
        return _core.Ellipse3D__get_minorRadius(self)

    def _set_minorRadius(self, *args) -> "bool" :
        """Gets and sets the minor radius of the ellipse."""
        return _core.Ellipse3D__set_minorRadius(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Ellipse3D >" :
        """
        Creates a copy of this Ellipse3D object. 
        Returns the independent copy of the ellipse.
        """
        return _core.Ellipse3D_copy(self)

    def getData(self) -> "bool" :
        """
        Gets all of the data defining the ellipse. 
        center : The output center point of the ellipse. 
        normal : The output normal vector of the ellipse. 
        majorAxis : The output major axis of the ellipse 
        majorRadius : The output major radius of the of the ellipse. 
        minorRadius : The output minor radius of the of the ellipse. 
        Returns true if successful.
        """
        return _core.Ellipse3D_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets all of the data defining the ellipse. 
        center : The center point of the ellipse. 
        normal : The normal vector of the ellipse.
        The plane through the center point and perpendicular to the normal vector defines the plane of the ellipse. 
        majorAxis : The major axis of the ellipse. 
        majorRadius : The major radius of the of the ellipse. 
        minorRadius : The minor radius of the of the ellipse. 
        Returns true if successful.
        """
        return _core.Ellipse3D_set(self, *args)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >" :
        """Returns a NURBS curve that is geometrically identical to the ellipse."""
        return _core.Ellipse3D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve3DTypes" :
        """Returns the type of geometry this curve represents."""
        return _core.Ellipse3D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >" :
        """Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Ellipse3D__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms this curve in 3D space. 
        matrix : A 3D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Ellipse3D_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Ellipse3D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Ellipse3D__get_isValid(self)
Ellipse3D_swigregister = _core.Ellipse3D_swigregister
Ellipse3D_swigregister(Ellipse3D)

def Ellipse3D_classType() -> "char const *" :
  return _core.Ellipse3D_classType()
Ellipse3D_classType = _core.Ellipse3D_classType

def Ellipse3D_create(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &" :
  return _core.Ellipse3D_create(*args)
Ellipse3D_create = _core.Ellipse3D_create

Ellipse3D.__swig_getmethods__["center"] = Ellipse3D._get_center
Ellipse3D.__swig_setmethods__["center"] = Ellipse3D._set_center
Ellipse3D.center = property(Ellipse3D._get_center, Ellipse3D._set_center, doc="Gets and sets the center position of the ellipse.")

Ellipse3D.__swig_getmethods__["normal"] = Ellipse3D._get_normal
Ellipse3D.normal = property(Ellipse3D._get_normal, doc="Gets and sets the normal of the ellipse.")

Ellipse3D.__swig_getmethods__["majorAxis"] = Ellipse3D._get_majorAxis
Ellipse3D.__swig_setmethods__["majorAxis"] = Ellipse3D._set_majorAxis
Ellipse3D.majorAxis = property(Ellipse3D._get_majorAxis, Ellipse3D._set_majorAxis, doc="Gets and sets the major axis of the ellipse.")

Ellipse3D.__swig_getmethods__["majorRadius"] = Ellipse3D._get_majorRadius
Ellipse3D.__swig_setmethods__["majorRadius"] = Ellipse3D._set_majorRadius
Ellipse3D.majorRadius = property(Ellipse3D._get_majorRadius, Ellipse3D._set_majorRadius, doc="Gets and sets the major radius of the ellipse.")

Ellipse3D.__swig_getmethods__["minorRadius"] = Ellipse3D._get_minorRadius
Ellipse3D.__swig_setmethods__["minorRadius"] = Ellipse3D._set_minorRadius
Ellipse3D.minorRadius = property(Ellipse3D._get_minorRadius, Ellipse3D._set_minorRadius, doc="Gets and sets the minor radius of the ellipse.")

Ellipse3D.__swig_getmethods__["asNurbsCurve"] = Ellipse3D._get_asNurbsCurve
Ellipse3D.asNurbsCurve = property(Ellipse3D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the ellipse.")

Ellipse3D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Ellipse3D) else None
Ellipse3D.cast = lambda arg: arg if isinstance(arg, Ellipse3D) else None

class EllipticalArc2D(Curve2D):
    """
    Transient 2D elliptical arc. A transient elliptical arc is not displayed or saved in a document.
    Transient 2D elliptical arcs are used as a wrapper to work with raw 2D elliptical arc information.
    They are created statically using the create method of the EllipticalArc2D class.
    """
    __swig_setmethods__ = {}
    for _s in [Curve2D]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EllipticalArc2D, name, value)
    __swig_getmethods__ = {}
    for _s in [Curve2D]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EllipticalArc2D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::EllipticalArc2D *" : return _core.EllipticalArc2D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.EllipticalArc2D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.EllipticalArc2D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.EllipticalArc2D_classType
    if _newclass:classType = staticmethod(_core.EllipticalArc2D_classType)
    __swig_getmethods__["create"] = lambda x: _core.EllipticalArc2D_create
    if _newclass:create = staticmethod(_core.EllipticalArc2D_create)
    __swig_destroy__ = _core.delete_EllipticalArc2D
    __del__ = lambda self : None;
    def _get_center(self) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """Gets and sets the center position of the elliptical arc."""
        return _core.EllipticalArc2D__get_center(self)

    def _set_center(self, *args) -> "bool" :
        """Gets and sets the center position of the elliptical arc."""
        return _core.EllipticalArc2D__set_center(self, *args)

    def _get_majorAxis(self) -> "adsk::core::Ptr< adsk::core::Vector2D >" :
        """Gets and sets the major axis of the elliptical arc."""
        return _core.EllipticalArc2D__get_majorAxis(self)

    def _set_majorAxis(self, *args) -> "bool" :
        """Gets and sets the major axis of the elliptical arc."""
        return _core.EllipticalArc2D__set_majorAxis(self, *args)

    def _get_majorRadius(self) -> "double" :
        """Gets and sets the major radius of the elliptical arc."""
        return _core.EllipticalArc2D__get_majorRadius(self)

    def _set_majorRadius(self, *args) -> "bool" :
        """Gets and sets the major radius of the elliptical arc."""
        return _core.EllipticalArc2D__set_majorRadius(self, *args)

    def _get_minorRadius(self) -> "double" :
        """Gets and sets the minor radius of the elliptical arc."""
        return _core.EllipticalArc2D__get_minorRadius(self)

    def _set_minorRadius(self, *args) -> "bool" :
        """Gets and sets the minor radius of the elliptical arc."""
        return _core.EllipticalArc2D__set_minorRadius(self, *args)

    def _get_startAngle(self) -> "double" :
        """Gets and sets the start angle of the elliptical arc in radians, where 0 is along the major axis."""
        return _core.EllipticalArc2D__get_startAngle(self)

    def _set_startAngle(self, *args) -> "bool" :
        """Gets and sets the start angle of the elliptical arc in radians, where 0 is along the major axis."""
        return _core.EllipticalArc2D__set_startAngle(self, *args)

    def _get_endAngle(self) -> "double" :
        """Gets and sets the end angle of the elliptical arc in radians, where 0 is along the major axis."""
        return _core.EllipticalArc2D__get_endAngle(self)

    def _set_endAngle(self, *args) -> "bool" :
        """Gets and sets the end angle of the elliptical arc in radians, where 0 is along the major axis."""
        return _core.EllipticalArc2D__set_endAngle(self, *args)

    def _get_isClockwise(self) -> "bool" :
        """Indicates if the sweep direction of the elliptical arc is clockwise or counterclockwise."""
        return _core.EllipticalArc2D__get_isClockwise(self)

    def _get_isCircular(self) -> "bool" :
        """Indicates if the elliptical arc is the geometric equivalent of a circular arc"""
        return _core.EllipticalArc2D__get_isCircular(self)

    def _get_startPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """Gets the position of the start point of the elliptical arc."""
        return _core.EllipticalArc2D__get_startPoint(self)

    def _get_endPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """Gets the position of the end point of the elliptical arc."""
        return _core.EllipticalArc2D__get_endPoint(self)

    def copy(self) -> "adsk::core::Ptr< adsk::core::EllipticalArc2D >" :
        """
        Creates and returns a copy of this EllipticalArc2D object. 
        Returns a new EllipticalArc2D object that is a copy of this Arc2D object.
        """
        return _core.EllipticalArc2D_copy(self)

    def getData(self) -> "bool" :
        """
        Gets all of the data defining the elliptical arc. 
        center : The output center point of the elliptical arc. 
        majorAxis : The output major axis of the elliptical arc. 
        majorRadius : The output major radius of the of the elliptical arc. 
        minorRadius : The output minor radius of the of the elliptical arc. 
        startAngle : The output start angle of the elliptical arc in radians, where 0 is along the major axis. 
        endAngle : The output end angle of the elliptical arc in radians, where 0 is along the major axis. 
        Returns true if successful
        """
        return _core.EllipticalArc2D_getData(self)

    def set(self, *args) -> "bool" :
        """
        center : A Point2D object that defines the center of the elliptical arc. 
        majorAxis : The major axis of the elliptical arc. 
        majorRadius : The major radius of the of the elliptical arc. 
        minorRadius : The minor radius of the of the elliptical arc. 
        startAngle : The start angle of the elliptical arc in radians, where 0 is along the major axis. 
        endAngle : The end angle of the elliptical arc in radians, where 0 is along the major axis. 
        Returns true if redefining the elliptical arc is successful
        """
        return _core.EllipticalArc2D_set(self, *args)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve2D >" :
        """Returns a NURBS curve that is geometrically identical to the elliptical arc."""
        return _core.EllipticalArc2D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve2DTypes" :
        """Returns the type of geometry this curve represents."""
        return _core.EllipticalArc2D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator2D >" :
        """Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.EllipticalArc2D__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms this curve in 2D space. 
        matrix : A 2D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.EllipticalArc2D_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.EllipticalArc2D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.EllipticalArc2D__get_isValid(self)
EllipticalArc2D_swigregister = _core.EllipticalArc2D_swigregister
EllipticalArc2D_swigregister(EllipticalArc2D)

def EllipticalArc2D_classType() -> "char const *" :
  return _core.EllipticalArc2D_classType()
EllipticalArc2D_classType = _core.EllipticalArc2D_classType

def EllipticalArc2D_create(*args) -> "adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Vector2D > const &" :
  return _core.EllipticalArc2D_create(*args)
EllipticalArc2D_create = _core.EllipticalArc2D_create

EllipticalArc2D.__swig_getmethods__["center"] = EllipticalArc2D._get_center
EllipticalArc2D.__swig_setmethods__["center"] = EllipticalArc2D._set_center
EllipticalArc2D.center = property(EllipticalArc2D._get_center, EllipticalArc2D._set_center, doc="Gets and sets the center position of the elliptical arc.")

EllipticalArc2D.__swig_getmethods__["majorAxis"] = EllipticalArc2D._get_majorAxis
EllipticalArc2D.__swig_setmethods__["majorAxis"] = EllipticalArc2D._set_majorAxis
EllipticalArc2D.majorAxis = property(EllipticalArc2D._get_majorAxis, EllipticalArc2D._set_majorAxis, doc="Gets and sets the major axis of the elliptical arc.")

EllipticalArc2D.__swig_getmethods__["majorRadius"] = EllipticalArc2D._get_majorRadius
EllipticalArc2D.__swig_setmethods__["majorRadius"] = EllipticalArc2D._set_majorRadius
EllipticalArc2D.majorRadius = property(EllipticalArc2D._get_majorRadius, EllipticalArc2D._set_majorRadius, doc="Gets and sets the major radius of the elliptical arc.")

EllipticalArc2D.__swig_getmethods__["minorRadius"] = EllipticalArc2D._get_minorRadius
EllipticalArc2D.__swig_setmethods__["minorRadius"] = EllipticalArc2D._set_minorRadius
EllipticalArc2D.minorRadius = property(EllipticalArc2D._get_minorRadius, EllipticalArc2D._set_minorRadius, doc="Gets and sets the minor radius of the elliptical arc.")

EllipticalArc2D.__swig_getmethods__["startAngle"] = EllipticalArc2D._get_startAngle
EllipticalArc2D.__swig_setmethods__["startAngle"] = EllipticalArc2D._set_startAngle
EllipticalArc2D.startAngle = property(EllipticalArc2D._get_startAngle, EllipticalArc2D._set_startAngle, doc="Gets and sets the start angle of the elliptical arc in radians, where 0 is along the major axis.")

EllipticalArc2D.__swig_getmethods__["endAngle"] = EllipticalArc2D._get_endAngle
EllipticalArc2D.__swig_setmethods__["endAngle"] = EllipticalArc2D._set_endAngle
EllipticalArc2D.endAngle = property(EllipticalArc2D._get_endAngle, EllipticalArc2D._set_endAngle, doc="Gets and sets the end angle of the elliptical arc in radians, where 0 is along the major axis.")

EllipticalArc2D.__swig_getmethods__["isClockwise"] = EllipticalArc2D._get_isClockwise
EllipticalArc2D.isClockwise = property(EllipticalArc2D._get_isClockwise, doc="Indicates if the sweep direction of the elliptical arc is clockwise or counterclockwise.")

EllipticalArc2D.__swig_getmethods__["isCircular"] = EllipticalArc2D._get_isCircular
EllipticalArc2D.isCircular = property(EllipticalArc2D._get_isCircular, doc="Indicates if the elliptical arc is the geometric equivalent of a circular arc")

EllipticalArc2D.__swig_getmethods__["startPoint"] = EllipticalArc2D._get_startPoint
EllipticalArc2D.startPoint = property(EllipticalArc2D._get_startPoint, doc="Gets the position of the start point of the elliptical arc.")

EllipticalArc2D.__swig_getmethods__["endPoint"] = EllipticalArc2D._get_endPoint
EllipticalArc2D.endPoint = property(EllipticalArc2D._get_endPoint, doc="Gets the position of the end point of the elliptical arc.")

EllipticalArc2D.__swig_getmethods__["asNurbsCurve"] = EllipticalArc2D._get_asNurbsCurve
EllipticalArc2D.asNurbsCurve = property(EllipticalArc2D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the elliptical arc.")

EllipticalArc2D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, EllipticalArc2D) else None
EllipticalArc2D.cast = lambda arg: arg if isinstance(arg, EllipticalArc2D) else None

class EllipticalArc3D(Curve3D):
    """
    Transient 3D elliptical arc. A transient elliptical arc is not displayed or saved in a document.
    Transient 3D elliptical arcs are used as a wrapper to work with raw 3D elliptical arc information.
    They are created statically using the create method of the EllipticalArc3D class.
    """
    __swig_setmethods__ = {}
    for _s in [Curve3D]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EllipticalArc3D, name, value)
    __swig_getmethods__ = {}
    for _s in [Curve3D]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EllipticalArc3D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::EllipticalArc3D *" : return _core.EllipticalArc3D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.EllipticalArc3D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.EllipticalArc3D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.EllipticalArc3D_classType
    if _newclass:classType = staticmethod(_core.EllipticalArc3D_classType)
    __swig_getmethods__["create"] = lambda x: _core.EllipticalArc3D_create
    if _newclass:create = staticmethod(_core.EllipticalArc3D_create)
    __swig_destroy__ = _core.delete_EllipticalArc3D
    __del__ = lambda self : None;
    def _get_center(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets the center point of the elliptical arc."""
        return _core.EllipticalArc3D__get_center(self)

    def _set_center(self, *args) -> "bool" :
        """Gets and sets the center point of the elliptical arc."""
        return _core.EllipticalArc3D__set_center(self, *args)

    def _get_normal(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Gets and sets the normal of the elliptical arc."""
        return _core.EllipticalArc3D__get_normal(self)

    def _get_majorAxis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Gets and sets the major axis of the elliptical arc."""
        return _core.EllipticalArc3D__get_majorAxis(self)

    def _set_majorAxis(self, *args) -> "bool" :
        """Gets and sets the major axis of the elliptical arc."""
        return _core.EllipticalArc3D__set_majorAxis(self, *args)

    def _get_majorRadius(self) -> "double" :
        """Gets and sets the major radius of the elliptical arc."""
        return _core.EllipticalArc3D__get_majorRadius(self)

    def _set_majorRadius(self, *args) -> "bool" :
        """Gets and sets the major radius of the elliptical arc."""
        return _core.EllipticalArc3D__set_majorRadius(self, *args)

    def _get_minorRadius(self) -> "double" :
        """Gets and sets the minor radius of the elliptical arc."""
        return _core.EllipticalArc3D__get_minorRadius(self)

    def _set_minorRadius(self, *args) -> "bool" :
        """Gets and sets the minor radius of the elliptical arc."""
        return _core.EllipticalArc3D__set_minorRadius(self, *args)

    def _get_startAngle(self) -> "double" :
        """Gets and sets the start angle of the elliptical arc."""
        return _core.EllipticalArc3D__get_startAngle(self)

    def _set_startAngle(self, *args) -> "bool" :
        """Gets and sets the start angle of the elliptical arc."""
        return _core.EllipticalArc3D__set_startAngle(self, *args)

    def _get_endAngle(self) -> "double" :
        """Gets and sets the end angle of the elliptical arc."""
        return _core.EllipticalArc3D__get_endAngle(self)

    def _set_endAngle(self, *args) -> "bool" :
        """Gets and sets the end angle of the elliptical arc."""
        return _core.EllipticalArc3D__set_endAngle(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::EllipticalArc3D >" :
        """
        Creates and returns a copy of this EllipticalArc3D object. 
        Returns a new EllipticalArc3D object that is a copy of this Arc3D object.
        """
        return _core.EllipticalArc3D_copy(self)

    def getData(self) -> "bool" :
        """
        Gets all of the data defining the elliptical arc. 
        center : The output center point of the elliptical arc. 
        normal : The output normal vector of the elliptical arc. 
        majorAxis : The output major axis of the elliptical arc. 
        majorRadius : The output major radius of the of the elliptical arc. 
        minorRadius : The output minor radius of the of the elliptical arc. 
        startAngle : The output start angle of the elliptical arc in radians, where 0 is along the major axis. 
        endAngle : The output end angle of the elliptical arc in radians, where 0 is along the major axis. 
        Returns true if successful.
        """
        return _core.EllipticalArc3D_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets all of the data defining the elliptical arc. 
        center : The center point of the elliptical arc. 
        normal : The normal vector of the elliptical arc. 
        majorAxis : The major axis of the elliptical arc. 
        majorRadius : The major radius of the of the elliptical arc. 
        minorRadius : The minor radius of the of the elliptical arc. 
        startAngle : The start angle of the elliptical arc in radians, where 0 is along the major axis. 
        endAngle : The end angle of the elliptical arc in radians, where 0 is along the major axis. 
        Returns true if successful.
        """
        return _core.EllipticalArc3D_set(self, *args)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >" :
        """Returns a NURBS curve that is geometrically identical to the elliptical arc."""
        return _core.EllipticalArc3D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve3DTypes" :
        """Returns the type of geometry this curve represents."""
        return _core.EllipticalArc3D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >" :
        """Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.EllipticalArc3D__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms this curve in 3D space. 
        matrix : A 3D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.EllipticalArc3D_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.EllipticalArc3D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.EllipticalArc3D__get_isValid(self)
EllipticalArc3D_swigregister = _core.EllipticalArc3D_swigregister
EllipticalArc3D_swigregister(EllipticalArc3D)

def EllipticalArc3D_classType() -> "char const *" :
  return _core.EllipticalArc3D_classType()
EllipticalArc3D_classType = _core.EllipticalArc3D_classType

def EllipticalArc3D_create(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &" :
  return _core.EllipticalArc3D_create(*args)
EllipticalArc3D_create = _core.EllipticalArc3D_create

EllipticalArc3D.__swig_getmethods__["center"] = EllipticalArc3D._get_center
EllipticalArc3D.__swig_setmethods__["center"] = EllipticalArc3D._set_center
EllipticalArc3D.center = property(EllipticalArc3D._get_center, EllipticalArc3D._set_center, doc="Gets and sets the center point of the elliptical arc.")

EllipticalArc3D.__swig_getmethods__["normal"] = EllipticalArc3D._get_normal
EllipticalArc3D.normal = property(EllipticalArc3D._get_normal, doc="Gets and sets the normal of the elliptical arc.")

EllipticalArc3D.__swig_getmethods__["majorAxis"] = EllipticalArc3D._get_majorAxis
EllipticalArc3D.__swig_setmethods__["majorAxis"] = EllipticalArc3D._set_majorAxis
EllipticalArc3D.majorAxis = property(EllipticalArc3D._get_majorAxis, EllipticalArc3D._set_majorAxis, doc="Gets and sets the major axis of the elliptical arc.")

EllipticalArc3D.__swig_getmethods__["majorRadius"] = EllipticalArc3D._get_majorRadius
EllipticalArc3D.__swig_setmethods__["majorRadius"] = EllipticalArc3D._set_majorRadius
EllipticalArc3D.majorRadius = property(EllipticalArc3D._get_majorRadius, EllipticalArc3D._set_majorRadius, doc="Gets and sets the major radius of the elliptical arc.")

EllipticalArc3D.__swig_getmethods__["minorRadius"] = EllipticalArc3D._get_minorRadius
EllipticalArc3D.__swig_setmethods__["minorRadius"] = EllipticalArc3D._set_minorRadius
EllipticalArc3D.minorRadius = property(EllipticalArc3D._get_minorRadius, EllipticalArc3D._set_minorRadius, doc="Gets and sets the minor radius of the elliptical arc.")

EllipticalArc3D.__swig_getmethods__["startAngle"] = EllipticalArc3D._get_startAngle
EllipticalArc3D.__swig_setmethods__["startAngle"] = EllipticalArc3D._set_startAngle
EllipticalArc3D.startAngle = property(EllipticalArc3D._get_startAngle, EllipticalArc3D._set_startAngle, doc="Gets and sets the start angle of the elliptical arc.")

EllipticalArc3D.__swig_getmethods__["endAngle"] = EllipticalArc3D._get_endAngle
EllipticalArc3D.__swig_setmethods__["endAngle"] = EllipticalArc3D._set_endAngle
EllipticalArc3D.endAngle = property(EllipticalArc3D._get_endAngle, EllipticalArc3D._set_endAngle, doc="Gets and sets the end angle of the elliptical arc.")

EllipticalArc3D.__swig_getmethods__["asNurbsCurve"] = EllipticalArc3D._get_asNurbsCurve
EllipticalArc3D.asNurbsCurve = property(EllipticalArc3D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the elliptical arc.")

EllipticalArc3D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, EllipticalArc3D) else None
EllipticalArc3D.cast = lambda arg: arg if isinstance(arg, EllipticalArc3D) else None

class EllipticalCone(Surface):
    """
    Transient elliptical cone. A transient elliptical cone is not displayed or saved in a document.
    A transient elliptical cone is used as a wrapper to work with raw elliptical cone information. 
    A transient elliptical cone has no boundaries.
    The cone always goes to a point in its narrowing direction, and is infinite in its
    widening direction.
    They are created statically using the create method of the EllipticalCone class.
    """
    __swig_setmethods__ = {}
    for _s in [Surface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EllipticalCone, name, value)
    __swig_getmethods__ = {}
    for _s in [Surface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EllipticalCone, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::EllipticalCone *" : return _core.EllipticalCone___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.EllipticalCone___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.EllipticalCone___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.EllipticalCone_classType
    if _newclass:classType = staticmethod(_core.EllipticalCone_classType)
    __swig_getmethods__["create"] = lambda x: _core.EllipticalCone_create
    if _newclass:create = staticmethod(_core.EllipticalCone_create)
    __swig_destroy__ = _core.delete_EllipticalCone
    __del__ = lambda self : None;
    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets the origin point (center) of the base of the cone."""
        return _core.EllipticalCone__get_origin(self)

    def _set_origin(self, *args) -> "bool" :
        """Gets and sets the origin point (center) of the base of the cone."""
        return _core.EllipticalCone__set_origin(self, *args)

    def getAxes(self) -> "void" :
        """
        Gets the center axis of the cone that defines its normal direction and the major axis 
        direction of the ellipse that defines it. 
        axis : The output center axis (along the length) of the cone that defines its normal direction. 
        majorAxisDirection : The output direction of the major axis of the ellipse that defines the cone.
        """
        return _core.EllipticalCone_getAxes(self)

    def setAxes(self, *args) -> "bool" :
        """
        Sets the center axis of the cone and the major axis direction of the ellipse that defines it. 
        axis : The center axis (along the length) of the cone that defines its normal direction. 
        majorAxisDirection : The direction of the major axis of the ellipse that defines the cone. 
        Returns true if successful.
        """
        return _core.EllipticalCone_setAxes(self, *args)

    def _get_majorRadius(self) -> "double" :
        """Gets and sets the major radius of the ellipse that defines the cone."""
        return _core.EllipticalCone__get_majorRadius(self)

    def _set_majorRadius(self, *args) -> "bool" :
        """Gets and sets the major radius of the ellipse that defines the cone."""
        return _core.EllipticalCone__set_majorRadius(self, *args)

    def _get_minorRadius(self) -> "double" :
        """Gets and sets the minor radius of the ellipse that defines the cone."""
        return _core.EllipticalCone__get_minorRadius(self)

    def _set_minorRadius(self, *args) -> "bool" :
        """Gets and sets the minor radius of the ellipse that defines the cone."""
        return _core.EllipticalCone__set_minorRadius(self, *args)

    def _get_halfAngle(self) -> "double" :
        """
        Gets and sets the taper half-angle of the elliptical cone. 
        A negative value indicates that the cone is narrowing in the direction of the axis vector, 
        whereas a positive values indicates that it is expanding in the direction of the axis vector.
        """
        return _core.EllipticalCone__get_halfAngle(self)

    def _set_halfAngle(self, *args) -> "bool" :
        """
        Gets and sets the taper half-angle of the elliptical cone. 
        A negative value indicates that the cone is narrowing in the direction of the axis vector, 
        whereas a positive values indicates that it is expanding in the direction of the axis vector.
        """
        return _core.EllipticalCone__set_halfAngle(self, *args)

    def getData(self) -> "bool" :
        """
        Gets the data that defines the Elliptical Cone. 
        origin : The output origin point (center) of the base of the cone. 
        axis : The output center axis (along the length) of the cone that defines its normal direction. 
        majorAxisDirection : The output direction of the major axis of the ellipse that defines the cone. 
        majorRadius : The output major radius of the ellipse that defines the cone. 
        minorRadius : The output minor radius of the ellipse that defines the cone. 
        halfAngle : The output taper half-angle of the cone. 
        Returns true if successful.
        """
        return _core.EllipticalCone_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets the data that defines the Elliptical Cone. 
        origin : The origin point (center) of the base of the cone. 
        axis : The center axis (along the length) of the cone that defines its normal direction. 
        majorAxisDirection : The direction of the major axis of the ellipse that defines the cone. 
        majorRadius : The major radius of the ellipse that defines the cone. 
        minorRadius : The minor radius of the ellipse that defines the cone. 
        halfAngle : The taper half-angle of the cone. 
        Returns true if successful.
        """
        return _core.EllipticalCone_set(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::EllipticalCone >" :
        """
        Creates and returns an independent copy of this EllipticalCone object. 
        Returns a new EllipticalCone object that is a copy of this EllipticalCone object.
        """
        return _core.EllipticalCone_copy(self)

    def _get_surfaceType(self) -> "adsk::core::SurfaceTypes" :
        """Returns the surface type."""
        return _core.EllipticalCone__get_surfaceType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >" :
        """Returns the surface evaluator."""
        return _core.EllipticalCone__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Updates this surface by transforming it with a given input matrix. 
        matrix : A 3D matrix that defines the transform to apply to the surface. 
        Returns true if the transform was successful.
        """
        return _core.EllipticalCone_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.EllipticalCone__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.EllipticalCone__get_isValid(self)
EllipticalCone_swigregister = _core.EllipticalCone_swigregister
EllipticalCone_swigregister(EllipticalCone)

def EllipticalCone_classType() -> "char const *" :
  return _core.EllipticalCone_classType()
EllipticalCone_classType = _core.EllipticalCone_classType

def EllipticalCone_create(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &" :
  return _core.EllipticalCone_create(*args)
EllipticalCone_create = _core.EllipticalCone_create

EllipticalCone.__swig_getmethods__["origin"] = EllipticalCone._get_origin
EllipticalCone.__swig_setmethods__["origin"] = EllipticalCone._set_origin
EllipticalCone.origin = property(EllipticalCone._get_origin, EllipticalCone._set_origin, doc="Gets and sets the origin point (center) of the base of the cone.")

EllipticalCone.__swig_getmethods__["majorRadius"] = EllipticalCone._get_majorRadius
EllipticalCone.__swig_setmethods__["majorRadius"] = EllipticalCone._set_majorRadius
EllipticalCone.majorRadius = property(EllipticalCone._get_majorRadius, EllipticalCone._set_majorRadius, doc="Gets and sets the major radius of the ellipse that defines the cone.")

EllipticalCone.__swig_getmethods__["minorRadius"] = EllipticalCone._get_minorRadius
EllipticalCone.__swig_setmethods__["minorRadius"] = EllipticalCone._set_minorRadius
EllipticalCone.minorRadius = property(EllipticalCone._get_minorRadius, EllipticalCone._set_minorRadius, doc="Gets and sets the minor radius of the ellipse that defines the cone.")

EllipticalCone.__swig_getmethods__["halfAngle"] = EllipticalCone._get_halfAngle
EllipticalCone.__swig_setmethods__["halfAngle"] = EllipticalCone._set_halfAngle
EllipticalCone.halfAngle = property(EllipticalCone._get_halfAngle, EllipticalCone._set_halfAngle, doc="Gets and sets the taper half-angle of the elliptical cone.\nA negative value indicates that the cone is narrowing in the direction of the axis vector,\nwhereas a positive values indicates that it is expanding in the direction of the axis vector.")

EllipticalCone.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, EllipticalCone) else None
EllipticalCone.cast = lambda arg: arg if isinstance(arg, EllipticalCone) else None

class EllipticalCylinder(Surface):
    """
    Transient elliptical cylinder. A transient elliptical cylinder is not displayed or saved 
    in a document.
    A transient elliptical cylinder is used as a wrapper to work with raw elliptical cylinder 
    information. 
    A transient elliptical cylinder has no boundaries and is infinite in length. 
    They are created statically using the create method of the EllipticalCylinder class.
    """
    __swig_setmethods__ = {}
    for _s in [Surface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EllipticalCylinder, name, value)
    __swig_getmethods__ = {}
    for _s in [Surface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EllipticalCylinder, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::EllipticalCylinder *" : return _core.EllipticalCylinder___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.EllipticalCylinder___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.EllipticalCylinder___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.EllipticalCylinder_classType
    if _newclass:classType = staticmethod(_core.EllipticalCylinder_classType)
    __swig_getmethods__["create"] = lambda x: _core.EllipticalCylinder_create
    if _newclass:create = staticmethod(_core.EllipticalCylinder_create)
    __swig_destroy__ = _core.delete_EllipticalCylinder
    __del__ = lambda self : None;
    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets the origin point (center) of the base of the cylinder."""
        return _core.EllipticalCylinder__get_origin(self)

    def _set_origin(self, *args) -> "bool" :
        """Gets and sets the origin point (center) of the base of the cylinder."""
        return _core.EllipticalCylinder__set_origin(self, *args)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Gets and set the center axis (along the length) of the cylinder that defines 
        its normal direction.
        """
        return _core.EllipticalCylinder__get_axis(self)

    def _set_axis(self, *args) -> "bool" :
        """
        Gets and set the center axis (along the length) of the cylinder that defines 
        its normal direction.
        """
        return _core.EllipticalCylinder__set_axis(self, *args)

    def _get_majorAxis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Gets and sets the direction of the major axis of the ellipse that defines the cylinder."""
        return _core.EllipticalCylinder__get_majorAxis(self)

    def _set_majorAxis(self, *args) -> "bool" :
        """Gets and sets the direction of the major axis of the ellipse that defines the cylinder."""
        return _core.EllipticalCylinder__set_majorAxis(self, *args)

    def _get_majorRadius(self) -> "double" :
        """Gets and sets the major radius of the ellipse that defines the cylinder."""
        return _core.EllipticalCylinder__get_majorRadius(self)

    def _set_majorRadius(self, *args) -> "bool" :
        """Gets and sets the major radius of the ellipse that defines the cylinder."""
        return _core.EllipticalCylinder__set_majorRadius(self, *args)

    def _get_minorRadius(self) -> "double" :
        """Gets and sets the minor radius of the ellipse that defines the cylinder."""
        return _core.EllipticalCylinder__get_minorRadius(self)

    def _set_minorRadius(self, *args) -> "bool" :
        """Gets and sets the minor radius of the ellipse that defines the cylinder."""
        return _core.EllipticalCylinder__set_minorRadius(self, *args)

    def getData(self) -> "bool" :
        """
        Gets the data defining the elliptical cylinder. 
        origin : The output origin point (center) of the base of the cylinder. 
        axis : The output center axis (along the length) of the cylinder that defines its normal direction. 
        majorAxis : The output direction of the major axis of the ellipse that defines the cylinder. 
        majorRadius : The output major radius of the ellipse that defines the cylinder. 
        minorRadius : The output minor radius of the ellipse that defines the cylinder. 
        Returns true if successful.
        """
        return _core.EllipticalCylinder_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets the data defining the elliptical cylinder. 
        origin : The origin point (center) of the base of the cylinder. 
        axis : The center axis (along the length) of the cylinder that defines its normal direction. 
        majorAxis : The direction of the major axis of the ellipse that defines the cylinder. 
        majorRadius : The major radius of the ellipse that defines the cylinder. 
        minorRadius : The minor radius of the ellipse that defines the cylinder. 
        Returns true if successful.
        """
        return _core.EllipticalCylinder_set(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::EllipticalCylinder >" :
        """
        Creates and returns an independent copy of this EllipticalCylinder object. 
        Returns a new EllipticalCylinder object that is a copy of this EllipticalCylinder object.
        """
        return _core.EllipticalCylinder_copy(self)

    def _get_surfaceType(self) -> "adsk::core::SurfaceTypes" :
        """Returns the surface type."""
        return _core.EllipticalCylinder__get_surfaceType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >" :
        """Returns the surface evaluator."""
        return _core.EllipticalCylinder__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Updates this surface by transforming it with a given input matrix. 
        matrix : A 3D matrix that defines the transform to apply to the surface. 
        Returns true if the transform was successful.
        """
        return _core.EllipticalCylinder_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.EllipticalCylinder__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.EllipticalCylinder__get_isValid(self)
EllipticalCylinder_swigregister = _core.EllipticalCylinder_swigregister
EllipticalCylinder_swigregister(EllipticalCylinder)

def EllipticalCylinder_classType() -> "char const *" :
  return _core.EllipticalCylinder_classType()
EllipticalCylinder_classType = _core.EllipticalCylinder_classType

def EllipticalCylinder_create(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &" :
  return _core.EllipticalCylinder_create(*args)
EllipticalCylinder_create = _core.EllipticalCylinder_create

EllipticalCylinder.__swig_getmethods__["origin"] = EllipticalCylinder._get_origin
EllipticalCylinder.__swig_setmethods__["origin"] = EllipticalCylinder._set_origin
EllipticalCylinder.origin = property(EllipticalCylinder._get_origin, EllipticalCylinder._set_origin, doc="Gets and sets the origin point (center) of the base of the cylinder.")

EllipticalCylinder.__swig_getmethods__["axis"] = EllipticalCylinder._get_axis
EllipticalCylinder.__swig_setmethods__["axis"] = EllipticalCylinder._set_axis
EllipticalCylinder.axis = property(EllipticalCylinder._get_axis, EllipticalCylinder._set_axis, doc="Gets and set the center axis (along the length) of the cylinder that defines\nits normal direction.")

EllipticalCylinder.__swig_getmethods__["majorAxis"] = EllipticalCylinder._get_majorAxis
EllipticalCylinder.__swig_setmethods__["majorAxis"] = EllipticalCylinder._set_majorAxis
EllipticalCylinder.majorAxis = property(EllipticalCylinder._get_majorAxis, EllipticalCylinder._set_majorAxis, doc="Gets and sets the direction of the major axis of the ellipse that defines the cylinder.")

EllipticalCylinder.__swig_getmethods__["majorRadius"] = EllipticalCylinder._get_majorRadius
EllipticalCylinder.__swig_setmethods__["majorRadius"] = EllipticalCylinder._set_majorRadius
EllipticalCylinder.majorRadius = property(EllipticalCylinder._get_majorRadius, EllipticalCylinder._set_majorRadius, doc="Gets and sets the major radius of the ellipse that defines the cylinder.")

EllipticalCylinder.__swig_getmethods__["minorRadius"] = EllipticalCylinder._get_minorRadius
EllipticalCylinder.__swig_setmethods__["minorRadius"] = EllipticalCylinder._set_minorRadius
EllipticalCylinder.minorRadius = property(EllipticalCylinder._get_minorRadius, EllipticalCylinder._set_minorRadius, doc="Gets and sets the minor radius of the ellipse that defines the cylinder.")

EllipticalCylinder.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, EllipticalCylinder) else None
EllipticalCylinder.cast = lambda arg: arg if isinstance(arg, EllipticalCylinder) else None

class FilenameProperty(Property):
    """A file name property associated with an appearance."""
    __swig_setmethods__ = {}
    for _s in [Property]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FilenameProperty, name, value)
    __swig_getmethods__ = {}
    for _s in [Property]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FilenameProperty, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::FilenameProperty *" : return _core.FilenameProperty___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.FilenameProperty___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.FilenameProperty___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.FilenameProperty_classType
    if _newclass:classType = staticmethod(_core.FilenameProperty_classType)
    __swig_destroy__ = _core.delete_FilenameProperty
    __del__ = lambda self : None;
    def _get_hasMultipleValues(self) -> "bool" :
        """Gets the boolean flag that indicates if this property has multiple values or not."""
        return _core.FilenameProperty__get_hasMultipleValues(self)

    def _get_value(self) -> "std::string" :
        """Gets and sets the value of this property."""
        return _core.FilenameProperty__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """Gets and sets the value of this property."""
        return _core.FilenameProperty__set_value(self, *args)

    def _get_values(self) -> "std::vector< std::string,std::allocator< std::string > >" :
        """
        Gets and sets the values associated with this property. HasMultipleValues 
        property indicates if this property will be returning more than one value.
        """
        return _core.FilenameProperty__get_values(self)

    def _set_values(self, *args) -> "bool" :
        """
        Gets and sets the values associated with this property. HasMultipleValues 
        property indicates if this property will be returning more than one value.
        """
        return _core.FilenameProperty__set_values(self, *args)

    def _get_name(self) -> "std::string" :
        """
        Returns the name of this property as seen in the user interface. This name is localized
        and can change based on the current language
        """
        return _core.FilenameProperty__get_name(self)

    def _get_isReadOnly(self) -> "bool" :
        """Indicates if this property is read-only. If True any attempted edits will fail."""
        return _core.FilenameProperty__get_isReadOnly(self)

    def _get_id(self) -> "std::string" :
        """Returns the unique ID of this property."""
        return _core.FilenameProperty__get_id(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the parent of this property."""
        return _core.FilenameProperty__get_parent(self)

    def _get_objectType(self) -> "char const *" : return _core.FilenameProperty__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.FilenameProperty__get_isValid(self)
FilenameProperty_swigregister = _core.FilenameProperty_swigregister
FilenameProperty_swigregister(FilenameProperty)

def FilenameProperty_classType() -> "char const *" :
  return _core.FilenameProperty_classType()
FilenameProperty_classType = _core.FilenameProperty_classType

FilenameProperty.__swig_getmethods__["hasMultipleValues"] = FilenameProperty._get_hasMultipleValues
FilenameProperty.hasMultipleValues = property(FilenameProperty._get_hasMultipleValues, doc="Gets the boolean flag that indicates if this property has multiple values or not.")

FilenameProperty.__swig_getmethods__["value"] = FilenameProperty._get_value
FilenameProperty.__swig_setmethods__["value"] = FilenameProperty._set_value
FilenameProperty.value = property(FilenameProperty._get_value, FilenameProperty._set_value, doc="Gets and sets the value of this property.")

FilenameProperty.__swig_getmethods__["values"] = FilenameProperty._get_values
FilenameProperty.__swig_setmethods__["values"] = FilenameProperty._set_values
FilenameProperty.values = property(FilenameProperty._get_values, FilenameProperty._set_values, doc="Gets and sets the values associated with this property. HasMultipleValues\nproperty indicates if this property will be returning more than one value.")

FilenameProperty.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FilenameProperty) else None
FilenameProperty.cast = lambda arg: arg if isinstance(arg, FilenameProperty) else None

class FloatProperty(Property):
    """A float or real value property associated with a material or appearance."""
    __swig_setmethods__ = {}
    for _s in [Property]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatProperty, name, value)
    __swig_getmethods__ = {}
    for _s in [Property]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FloatProperty, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::FloatProperty *" : return _core.FloatProperty___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.FloatProperty___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.FloatProperty___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.FloatProperty_classType
    if _newclass:classType = staticmethod(_core.FloatProperty_classType)
    __swig_destroy__ = _core.delete_FloatProperty
    __del__ = lambda self : None;
    def _get_hasConnectedTexture(self) -> "bool" :
        """
        Gets and sets the boolean flag that indicates if the float value has been overridden 
        using a texture. Setting this property to False will remove the texture so that a float 
        value is used. Setting this property to True will connect a texture to this float value.
        """
        return _core.FloatProperty__get_hasConnectedTexture(self)

    def _set_hasConnectedTexture(self, *args) -> "bool" :
        """
        Gets and sets the boolean flag that indicates if the float value has been overridden 
        using a texture. Setting this property to False will remove the texture so that a float 
        value is used. Setting this property to True will connect a texture to this float value.
        """
        return _core.FloatProperty__set_hasConnectedTexture(self, *args)

    def _get_connectedTexture(self) -> "adsk::core::Ptr< adsk::core::AppearanceTexture >" :
        """
        Gets the associated texture, if one exists. The HasConnectedTexture property controls 
        if there is an associated texture or not. If it's parent writable you can edit the 
        texture. If no texture exists, this property will return Nothing.
        """
        return _core.FloatProperty__get_connectedTexture(self)

    def getLimits(self) -> "bool" :
        """
        Method that returns any limits for the value of this property. The HasLimits property can
        be used to see if there are any limits or not. 
        hasLowLimit : Output Boolean that indicates if there is a low limit or not. 
        lowLimit : If the hasLowLimit argument is true, this argument returns the low limit. 
        hasHighLimit : Output Boolean that indicates if there is a high limit or not. 
        highLimit : If the hasHighLimit argument is true, this argument returns the high limit. 
        Returns true if the method call was successful.
        """
        return _core.FloatProperty_getLimits(self)

    def _get_hasLimits(self) -> "bool" :
        """
        Gets the boolean flag that indicates if the value of this property has any limits it must be within to 
        be valid. If True, use the GetLimits method to get the limit values.
        """
        return _core.FloatProperty__get_hasLimits(self)

    def _get_hasMultipleValues(self) -> "bool" :
        """Gets the boolean flag that indicates if this property has multiple values or not."""
        return _core.FloatProperty__get_hasMultipleValues(self)

    def _get_isPercentage(self) -> "bool" :
        """
        Gets the boolean flag that indicates that this property represents a percentage value so 
        the valid values must be in the range of 0.0 to 1.0 unless theyre further limited by 
        additional limits which can be determined with the HasLimits property.
        """
        return _core.FloatProperty__get_isPercentage(self)

    def _get_units(self) -> "std::string" :
        """
        Gets the units that the value of this property is returned in. The String returned is a 
        valid Fusion 360 unit string.
        """
        return _core.FloatProperty__get_units(self)

    def _get_value(self) -> "double" :
        """
        Gets and sets this property value. The value of this property should be ignored 
        if the HasConnectedTexture property is true. Setting this will remove any 
        associated texture, if there is one.
        """
        return _core.FloatProperty__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """
        Gets and sets this property value. The value of this property should be ignored 
        if the HasConnectedTexture property is true. Setting this will remove any 
        associated texture, if there is one.
        """
        return _core.FloatProperty__set_value(self, *args)

    def _get_values(self) -> "std::vector< double,std::allocator< double > >" :
        """
        Gets and sets the values associated with this property. HasMultipleValues property 
        indicates if this property will be returning more than one value.
        """
        return _core.FloatProperty__get_values(self)

    def _set_values(self, *args) -> "bool" :
        """
        Gets and sets the values associated with this property. HasMultipleValues property 
        indicates if this property will be returning more than one value.
        """
        return _core.FloatProperty__set_values(self, *args)

    def _get_name(self) -> "std::string" :
        """
        Returns the name of this property as seen in the user interface. This name is localized
        and can change based on the current language
        """
        return _core.FloatProperty__get_name(self)

    def _get_isReadOnly(self) -> "bool" :
        """Indicates if this property is read-only. If True any attempted edits will fail."""
        return _core.FloatProperty__get_isReadOnly(self)

    def _get_id(self) -> "std::string" :
        """Returns the unique ID of this property."""
        return _core.FloatProperty__get_id(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the parent of this property."""
        return _core.FloatProperty__get_parent(self)

    def _get_objectType(self) -> "char const *" : return _core.FloatProperty__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.FloatProperty__get_isValid(self)
FloatProperty_swigregister = _core.FloatProperty_swigregister
FloatProperty_swigregister(FloatProperty)

def FloatProperty_classType() -> "char const *" :
  return _core.FloatProperty_classType()
FloatProperty_classType = _core.FloatProperty_classType

FloatProperty.__swig_getmethods__["hasConnectedTexture"] = FloatProperty._get_hasConnectedTexture
FloatProperty.__swig_setmethods__["hasConnectedTexture"] = FloatProperty._set_hasConnectedTexture
FloatProperty.hasConnectedTexture = property(FloatProperty._get_hasConnectedTexture, FloatProperty._set_hasConnectedTexture, doc="Gets and sets the boolean flag that indicates if the float value has been overridden\nusing a texture. Setting this property to False will remove the texture so that a float\nvalue is used. Setting this property to True will connect a texture to this float value.")

FloatProperty.__swig_getmethods__["connectedTexture"] = FloatProperty._get_connectedTexture
FloatProperty.connectedTexture = property(FloatProperty._get_connectedTexture, doc="Gets the associated texture, if one exists. The HasConnectedTexture property controls\nif there is an associated texture or not. If it's parent writable you can edit the\ntexture. If no texture exists, this property will return Nothing.")

FloatProperty.__swig_getmethods__["hasLimits"] = FloatProperty._get_hasLimits
FloatProperty.hasLimits = property(FloatProperty._get_hasLimits, doc="Gets the boolean flag that indicates if the value of this property has any limits it must be within to\nbe valid. If True, use the GetLimits method to get the limit values.")

FloatProperty.__swig_getmethods__["hasMultipleValues"] = FloatProperty._get_hasMultipleValues
FloatProperty.hasMultipleValues = property(FloatProperty._get_hasMultipleValues, doc="Gets the boolean flag that indicates if this property has multiple values or not.")

FloatProperty.__swig_getmethods__["isPercentage"] = FloatProperty._get_isPercentage
FloatProperty.isPercentage = property(FloatProperty._get_isPercentage, doc="Gets the boolean flag that indicates that this property represents a percentage value so\nthe valid values must be in the range of 0.0 to 1.0 unless theyre further limited by\nadditional limits which can be determined with the HasLimits property.")

FloatProperty.__swig_getmethods__["units"] = FloatProperty._get_units
FloatProperty.units = property(FloatProperty._get_units, doc="Gets the units that the value of this property is returned in. The String returned is a\nvalid Fusion 360 unit string.")

FloatProperty.__swig_getmethods__["value"] = FloatProperty._get_value
FloatProperty.__swig_setmethods__["value"] = FloatProperty._set_value
FloatProperty.value = property(FloatProperty._get_value, FloatProperty._set_value, doc="Gets and sets this property value. The value of this property should be ignored\nif the HasConnectedTexture property is true. Setting this will remove any\nassociated texture, if there is one.")

FloatProperty.__swig_getmethods__["values"] = FloatProperty._get_values
FloatProperty.__swig_setmethods__["values"] = FloatProperty._set_values
FloatProperty.values = property(FloatProperty._get_values, FloatProperty._set_values, doc="Gets and sets the values associated with this property. HasMultipleValues property\nindicates if this property will be returning more than one value.")

FloatProperty.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FloatProperty) else None
FloatProperty.cast = lambda arg: arg if isinstance(arg, FloatProperty) else None

class FloatSpinnerCommandInput(CommandInput):
    """Provides a command input to get the value of a spinner from the user, the value type is float."""
    __swig_setmethods__ = {}
    for _s in [CommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatSpinnerCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [CommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FloatSpinnerCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::FloatSpinnerCommandInput *" : return _core.FloatSpinnerCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.FloatSpinnerCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.FloatSpinnerCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.FloatSpinnerCommandInput_classType
    if _newclass:classType = staticmethod(_core.FloatSpinnerCommandInput_classType)
    __swig_destroy__ = _core.delete_FloatSpinnerCommandInput
    __del__ = lambda self : None;
    def _get_value(self) -> "double" :
        """
        Gets and sets the value associated with this input. The value is always in
        the database units of the unit type specified. For example, if the unit type is 'inch'
        this value is in centimeters since centimeters are the database length unit. When setting the
        value it is converted into a string using the unit type and displayed in the input box.
        The isValidExpression property should be checked before using this
        value within the command because if the expression can't be evaluated
        there isn't a valid value. Fusion 360 won't allow the execution of a command
        that contains ValueCommandInput object with invalid expressions so you can
        dependably use the value in the execute event of the command.
        """
        return _core.FloatSpinnerCommandInput__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """
        Gets and sets the value associated with this input. The value is always in
        the database units of the unit type specified. For example, if the unit type is 'inch'
        this value is in centimeters since centimeters are the database length unit. When setting the
        value it is converted into a string using the unit type and displayed in the input box.
        The isValidExpression property should be checked before using this
        value within the command because if the expression can't be evaluated
        there isn't a valid value. Fusion 360 won't allow the execution of a command
        that contains ValueCommandInput object with invalid expressions so you can
        dependably use the value in the execute event of the command.
        """
        return _core.FloatSpinnerCommandInput__set_value(self, *args)

    def _get_unitType(self) -> "std::string" :
        """Gets the unit type that is used when evaluating the user's input."""
        return _core.FloatSpinnerCommandInput__get_unitType(self)

    def _get_minimumValue(self) -> "double" :
        """Gets the minimum allowed value of the spinner in database units."""
        return _core.FloatSpinnerCommandInput__get_minimumValue(self)

    def _get_maximumValue(self) -> "double" :
        """Gets the maximum allowed value of the spinner in database units."""
        return _core.FloatSpinnerCommandInput__get_maximumValue(self)

    def _get_spinStep(self) -> "double" :
        """
        Gets the spin step value in the unit type set by the unitType argument. 
        The value should be more than zero. This is the amount the spinner will advance
        when the user clicks the spin button beside the value.
        """
        return _core.FloatSpinnerCommandInput__get_spinStep(self)

    def _get_expression(self) -> "std::string" :
        """
        Gets or sets the expression displayed in the input field. This can contain equations and
        references to parameters. It is evaluated using the specified unit type.
        """
        return _core.FloatSpinnerCommandInput__get_expression(self)

    def _set_expression(self, *args) -> "bool" :
        """
        Gets or sets the expression displayed in the input field. This can contain equations and
        references to parameters. It is evaluated using the specified unit type.
        """
        return _core.FloatSpinnerCommandInput__set_expression(self, *args)

    def _get_isValidExpression(self) -> "bool" :
        """
        Returns true if the current expression is valid and can be evaluated. If this
        is false, the value returned should be ignored because there currently is
        not a valid value.
        """
        return _core.FloatSpinnerCommandInput__get_isValidExpression(self)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.FloatSpinnerCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.FloatSpinnerCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.FloatSpinnerCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.FloatSpinnerCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.FloatSpinnerCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.FloatSpinnerCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.FloatSpinnerCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.FloatSpinnerCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.FloatSpinnerCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.FloatSpinnerCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.FloatSpinnerCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.FloatSpinnerCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.FloatSpinnerCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.FloatSpinnerCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.FloatSpinnerCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.FloatSpinnerCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.FloatSpinnerCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.FloatSpinnerCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.FloatSpinnerCommandInput__get_isValid(self)
FloatSpinnerCommandInput_swigregister = _core.FloatSpinnerCommandInput_swigregister
FloatSpinnerCommandInput_swigregister(FloatSpinnerCommandInput)

def FloatSpinnerCommandInput_classType() -> "char const *" :
  return _core.FloatSpinnerCommandInput_classType()
FloatSpinnerCommandInput_classType = _core.FloatSpinnerCommandInput_classType

FloatSpinnerCommandInput.__swig_getmethods__["value"] = FloatSpinnerCommandInput._get_value
FloatSpinnerCommandInput.__swig_setmethods__["value"] = FloatSpinnerCommandInput._set_value
FloatSpinnerCommandInput.value = property(FloatSpinnerCommandInput._get_value, FloatSpinnerCommandInput._set_value, doc="Gets and sets the value associated with this input. The value is always in\nthe database units of the unit type specified. For example, if the unit type is 'inch'\nthis value is in centimeters since centimeters are the database length unit. When setting the\nvalue it is converted into a string using the unit type and displayed in the input box.\nThe isValidExpression property should be checked before using this\nvalue within the command because if the expression can't be evaluated\nthere isn't a valid value. Fusion 360 won't allow the execution of a command\nthat contains ValueCommandInput object with invalid expressions so you can\ndependably use the value in the execute event of the command.")

FloatSpinnerCommandInput.__swig_getmethods__["unitType"] = FloatSpinnerCommandInput._get_unitType
FloatSpinnerCommandInput.unitType = property(FloatSpinnerCommandInput._get_unitType, doc="Gets the unit type that is used when evaluating the user's input.")

FloatSpinnerCommandInput.__swig_getmethods__["minimumValue"] = FloatSpinnerCommandInput._get_minimumValue
FloatSpinnerCommandInput.minimumValue = property(FloatSpinnerCommandInput._get_minimumValue, doc="Gets the minimum allowed value of the spinner in database units.")

FloatSpinnerCommandInput.__swig_getmethods__["maximumValue"] = FloatSpinnerCommandInput._get_maximumValue
FloatSpinnerCommandInput.maximumValue = property(FloatSpinnerCommandInput._get_maximumValue, doc="Gets the maximum allowed value of the spinner in database units.")

FloatSpinnerCommandInput.__swig_getmethods__["spinStep"] = FloatSpinnerCommandInput._get_spinStep
FloatSpinnerCommandInput.spinStep = property(FloatSpinnerCommandInput._get_spinStep, doc="Gets the spin step value in the unit type set by the unitType argument.\nThe value should be more than zero. This is the amount the spinner will advance\nwhen the user clicks the spin button beside the value.")

FloatSpinnerCommandInput.__swig_getmethods__["expression"] = FloatSpinnerCommandInput._get_expression
FloatSpinnerCommandInput.__swig_setmethods__["expression"] = FloatSpinnerCommandInput._set_expression
FloatSpinnerCommandInput.expression = property(FloatSpinnerCommandInput._get_expression, FloatSpinnerCommandInput._set_expression, doc="Gets or sets the expression displayed in the input field. This can contain equations and\nreferences to parameters. It is evaluated using the specified unit type.")

FloatSpinnerCommandInput.__swig_getmethods__["isValidExpression"] = FloatSpinnerCommandInput._get_isValidExpression
FloatSpinnerCommandInput.isValidExpression = property(FloatSpinnerCommandInput._get_isValidExpression, doc="Returns true if the current expression is valid and can be evaluated. If this\nis false, the value returned should be ignored because there currently is\nnot a valid value.")

FloatSpinnerCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FloatSpinnerCommandInput) else None
FloatSpinnerCommandInput.cast = lambda arg: arg if isinstance(arg, FloatSpinnerCommandInput) else None

class FusionArchiveImportOptions(ImportOptions):
    """Defines that a Fusion 360 Archive import is to be done and specifies the various options."""
    __swig_setmethods__ = {}
    for _s in [ImportOptions]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FusionArchiveImportOptions, name, value)
    __swig_getmethods__ = {}
    for _s in [ImportOptions]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FusionArchiveImportOptions, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::FusionArchiveImportOptions *" : return _core.FusionArchiveImportOptions___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.FusionArchiveImportOptions___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.FusionArchiveImportOptions___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.FusionArchiveImportOptions_classType
    if _newclass:classType = staticmethod(_core.FusionArchiveImportOptions_classType)
    __swig_destroy__ = _core.delete_FusionArchiveImportOptions
    __del__ = lambda self : None;
    def _get_filename(self) -> "std::string" :
        """Gets and sets the filename or url of the file to be imported."""
        return _core.FusionArchiveImportOptions__get_filename(self)

    def _set_filename(self, *args) -> "bool" :
        """Gets and sets the filename or url of the file to be imported."""
        return _core.FusionArchiveImportOptions__set_filename(self, *args)

    def _get_isViewFit(self) -> "bool" :
        """
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.FusionArchiveImportOptions__get_isViewFit(self)

    def _set_isViewFit(self, *args) -> "bool" :
        """
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.FusionArchiveImportOptions__set_isViewFit(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.FusionArchiveImportOptions__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.FusionArchiveImportOptions__get_isValid(self)
FusionArchiveImportOptions_swigregister = _core.FusionArchiveImportOptions_swigregister
FusionArchiveImportOptions_swigregister(FusionArchiveImportOptions)

def FusionArchiveImportOptions_classType() -> "char const *" :
  return _core.FusionArchiveImportOptions_classType()
FusionArchiveImportOptions_classType = _core.FusionArchiveImportOptions_classType

FusionArchiveImportOptions.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FusionArchiveImportOptions) else None
FusionArchiveImportOptions.cast = lambda arg: arg if isinstance(arg, FusionArchiveImportOptions) else None

class GroupCommandInput(CommandInput):
    """
    Group Command inputs organize a set of command inputs into a collapsible 
    list within a command dialog
    """
    __swig_setmethods__ = {}
    for _s in [CommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GroupCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [CommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GroupCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::GroupCommandInput *" : return _core.GroupCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.GroupCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.GroupCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.GroupCommandInput_classType
    if _newclass:classType = staticmethod(_core.GroupCommandInput_classType)
    __swig_destroy__ = _core.delete_GroupCommandInput
    __del__ = lambda self : None;
    def _get_children(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """
        Gets the CommandInputs collection for this GroupCommandInput. 
        Use the add methods on this collection to add child CommandInputs to this Group in the desired order.
        """
        return _core.GroupCommandInput__get_children(self)

    def _get_isExpanded(self) -> "bool" :
        """
        Gets or sets if this group is expanded.
        If this is a sub-group of another group and the isEnabledCheckBoxDisplayed property is set to false 
        then the isExpanded property must be set to true.
        """
        return _core.GroupCommandInput__get_isExpanded(self)

    def _set_isExpanded(self, *args) -> "bool" :
        """
        Gets or sets if this group is expanded.
        If this is a sub-group of another group and the isEnabledCheckBoxDisplayed property is set to false 
        then the isExpanded property must be set to true.
        """
        return _core.GroupCommandInput__set_isExpanded(self, *args)

    def _get_isEnabledCheckBoxDisplayed(self) -> "bool" :
        """
        Gets or sets if this group has a checkbox for enabling/disabling the group.
        If this is a sub-group of another group and the isEnabledCheckBoxDisplayed property is set to false 
        then the isExpanded property must be set to true.
        """
        return _core.GroupCommandInput__get_isEnabledCheckBoxDisplayed(self)

    def _set_isEnabledCheckBoxDisplayed(self, *args) -> "bool" :
        """
        Gets or sets if this group has a checkbox for enabling/disabling the group.
        If this is a sub-group of another group and the isEnabledCheckBoxDisplayed property is set to false 
        then the isExpanded property must be set to true.
        """
        return _core.GroupCommandInput__set_isEnabledCheckBoxDisplayed(self, *args)

    def _get_isEnabledCheckBoxChecked(self) -> "bool" :
        """
        Gets or sets if the enabled check box is checked or not. This is only
        valid when the isEnabledCheckBoxDisplayed property is true.
        """
        return _core.GroupCommandInput__get_isEnabledCheckBoxChecked(self)

    def _set_isEnabledCheckBoxChecked(self, *args) -> "bool" :
        """
        Gets or sets if the enabled check box is checked or not. This is only
        valid when the isEnabledCheckBoxDisplayed property is true.
        """
        return _core.GroupCommandInput__set_isEnabledCheckBoxChecked(self, *args)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.GroupCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.GroupCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.GroupCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.GroupCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.GroupCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.GroupCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.GroupCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.GroupCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.GroupCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.GroupCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.GroupCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.GroupCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.GroupCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.GroupCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.GroupCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.GroupCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.GroupCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.GroupCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.GroupCommandInput__get_isValid(self)
GroupCommandInput_swigregister = _core.GroupCommandInput_swigregister
GroupCommandInput_swigregister(GroupCommandInput)

def GroupCommandInput_classType() -> "char const *" :
  return _core.GroupCommandInput_classType()
GroupCommandInput_classType = _core.GroupCommandInput_classType

GroupCommandInput.__swig_getmethods__["children"] = GroupCommandInput._get_children
GroupCommandInput.children = property(GroupCommandInput._get_children, doc="Gets the CommandInputs collection for this GroupCommandInput.\nUse the add methods on this collection to add child CommandInputs to this Group in the desired order.")

GroupCommandInput.__swig_getmethods__["isExpanded"] = GroupCommandInput._get_isExpanded
GroupCommandInput.__swig_setmethods__["isExpanded"] = GroupCommandInput._set_isExpanded
GroupCommandInput.isExpanded = property(GroupCommandInput._get_isExpanded, GroupCommandInput._set_isExpanded, doc="Gets or sets if this group is expanded.\nIf this is a sub-group of another group and the isEnabledCheckBoxDisplayed property is set to false\nthen the isExpanded property must be set to true.")

GroupCommandInput.__swig_getmethods__["isEnabledCheckBoxDisplayed"] = GroupCommandInput._get_isEnabledCheckBoxDisplayed
GroupCommandInput.__swig_setmethods__["isEnabledCheckBoxDisplayed"] = GroupCommandInput._set_isEnabledCheckBoxDisplayed
GroupCommandInput.isEnabledCheckBoxDisplayed = property(GroupCommandInput._get_isEnabledCheckBoxDisplayed, GroupCommandInput._set_isEnabledCheckBoxDisplayed, doc="Gets or sets if this group has a checkbox for enabling/disabling the group.\nIf this is a sub-group of another group and the isEnabledCheckBoxDisplayed property is set to false\nthen the isExpanded property must be set to true.")

GroupCommandInput.__swig_getmethods__["isEnabledCheckBoxChecked"] = GroupCommandInput._get_isEnabledCheckBoxChecked
GroupCommandInput.__swig_setmethods__["isEnabledCheckBoxChecked"] = GroupCommandInput._set_isEnabledCheckBoxChecked
GroupCommandInput.isEnabledCheckBoxChecked = property(GroupCommandInput._get_isEnabledCheckBoxChecked, GroupCommandInput._set_isEnabledCheckBoxChecked, doc="Gets or sets if the enabled check box is checked or not. This is only\nvalid when the isEnabledCheckBoxDisplayed property is true.")

GroupCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, GroupCommandInput) else None
GroupCommandInput.cast = lambda arg: arg if isinstance(arg, GroupCommandInput) else None

class HTMLEvent(Event):
    """
    A HTMLEvent is fired when triggered from JavaScript code associated with HTML used
    in a palette.
    """
    __swig_setmethods__ = {}
    for _s in [Event]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTMLEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HTMLEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::HTMLEvent *" : return _core.HTMLEvent___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.HTMLEvent___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.HTMLEvent___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.HTMLEvent_classType
    if _newclass:classType = staticmethod(_core.HTMLEvent_classType)
    __swig_destroy__ = _core.delete_HTMLEvent
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Add a handler to be notified when the event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.HTMLEvent_add(self, *args)

    def remove(self, *args) -> "bool" :
        """
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.HTMLEvent_remove(self, *args)

    def _get_name(self) -> "std::string" :
        """The name of the event - e.g. 'DocumentOpening'"""
        return _core.HTMLEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.HTMLEvent__get_sender(self)

    def _get_objectType(self) -> "char const *" : return _core.HTMLEvent__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.HTMLEvent__get_isValid(self)
HTMLEvent_swigregister = _core.HTMLEvent_swigregister
HTMLEvent_swigregister(HTMLEvent)

def HTMLEvent_classType() -> "char const *" :
  return _core.HTMLEvent_classType()
HTMLEvent_classType = _core.HTMLEvent_classType

HTMLEvent.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, HTMLEvent) else None
HTMLEvent.cast = lambda arg: arg if isinstance(arg, HTMLEvent) else None

class HTMLEventArgs(EventArgs):
    """
    The HTMLEventArgs provides access to the information sent from the JavaScript
    that's associated with HTML being displayed within a palette.
    """
    __swig_setmethods__ = {}
    for _s in [EventArgs]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTMLEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HTMLEventArgs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::HTMLEventArgs *" : return _core.HTMLEventArgs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.HTMLEventArgs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.HTMLEventArgs___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.HTMLEventArgs_classType
    if _newclass:classType = staticmethod(_core.HTMLEventArgs_classType)
    __swig_destroy__ = _core.delete_HTMLEventArgs
    __del__ = lambda self : None;
    def _get_action(self) -> "std::string" :
        """
        The action string sent from the JavaScript associated with HTML displayed 
        in the palette. The string can represent any type of data in any format but 
        JSON is commonly used to pass more complex data.
        """
        return _core.HTMLEventArgs__get_action(self)

    def _get_data(self) -> "std::string" :
        """
        The data string sent from the JavaScript associated with HTML displayed 
        in the palette. The string can represent any type of data in any format but 
        JSON is commonly used to pass more complex data.
        """
        return _core.HTMLEventArgs__get_data(self)

    def _get_returnData(self) -> "std::string" :
        """Set this property to return data back to the JavaScript that's associated with the HTML."""
        return _core.HTMLEventArgs__get_returnData(self)

    def _set_returnData(self, *args) -> "bool" :
        """Set this property to return data back to the JavaScript that's associated with the HTML."""
        return _core.HTMLEventArgs__set_returnData(self, *args)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >" :
        """The event that the firing is in response to."""
        return _core.HTMLEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *" : return _core.HTMLEventArgs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.HTMLEventArgs__get_isValid(self)
HTMLEventArgs_swigregister = _core.HTMLEventArgs_swigregister
HTMLEventArgs_swigregister(HTMLEventArgs)

def HTMLEventArgs_classType() -> "char const *" :
  return _core.HTMLEventArgs_classType()
HTMLEventArgs_classType = _core.HTMLEventArgs_classType

HTMLEventArgs.__swig_getmethods__["action"] = HTMLEventArgs._get_action
HTMLEventArgs.action = property(HTMLEventArgs._get_action, doc="The action string sent from the JavaScript associated with HTML displayed\nin the palette. The string can represent any type of data in any format but\nJSON is commonly used to pass more complex data.")

HTMLEventArgs.__swig_getmethods__["data"] = HTMLEventArgs._get_data
HTMLEventArgs.data = property(HTMLEventArgs._get_data, doc="The data string sent from the JavaScript associated with HTML displayed\nin the palette. The string can represent any type of data in any format but\nJSON is commonly used to pass more complex data.")

HTMLEventArgs.__swig_getmethods__["returnData"] = HTMLEventArgs._get_returnData
HTMLEventArgs.__swig_setmethods__["returnData"] = HTMLEventArgs._set_returnData
HTMLEventArgs.returnData = property(HTMLEventArgs._get_returnData, HTMLEventArgs._set_returnData, doc="Set this property to return data back to the JavaScript that's associated with the HTML.")

HTMLEventArgs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, HTMLEventArgs) else None
HTMLEventArgs.cast = lambda arg: arg if isinstance(arg, HTMLEventArgs) else None

class IGESImportOptions(ImportOptions):
    """Defines that an IGES import is to be done and specifies the various options."""
    __swig_setmethods__ = {}
    for _s in [ImportOptions]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IGESImportOptions, name, value)
    __swig_getmethods__ = {}
    for _s in [ImportOptions]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IGESImportOptions, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::IGESImportOptions *" : return _core.IGESImportOptions___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.IGESImportOptions___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.IGESImportOptions___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.IGESImportOptions_classType
    if _newclass:classType = staticmethod(_core.IGESImportOptions_classType)
    __swig_destroy__ = _core.delete_IGESImportOptions
    __del__ = lambda self : None;
    def _get_filename(self) -> "std::string" :
        """Gets and sets the filename or url of the file to be imported."""
        return _core.IGESImportOptions__get_filename(self)

    def _set_filename(self, *args) -> "bool" :
        """Gets and sets the filename or url of the file to be imported."""
        return _core.IGESImportOptions__set_filename(self, *args)

    def _get_isViewFit(self) -> "bool" :
        """
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.IGESImportOptions__get_isViewFit(self)

    def _set_isViewFit(self, *args) -> "bool" :
        """
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.IGESImportOptions__set_isViewFit(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.IGESImportOptions__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.IGESImportOptions__get_isValid(self)
IGESImportOptions_swigregister = _core.IGESImportOptions_swigregister
IGESImportOptions_swigregister(IGESImportOptions)

def IGESImportOptions_classType() -> "char const *" :
  return _core.IGESImportOptions_classType()
IGESImportOptions_classType = _core.IGESImportOptions_classType

IGESImportOptions.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, IGESImportOptions) else None
IGESImportOptions.cast = lambda arg: arg if isinstance(arg, IGESImportOptions) else None

class ImageCommandInput(CommandInput):
    """Provides an image command input for including an image in a command dialog."""
    __swig_setmethods__ = {}
    for _s in [CommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [CommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ImageCommandInput *" : return _core.ImageCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ImageCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ImageCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ImageCommandInput_classType
    if _newclass:classType = staticmethod(_core.ImageCommandInput_classType)
    __swig_destroy__ = _core.delete_ImageCommandInput
    __del__ = lambda self : None;
    def _get_imageFile(self) -> "std::string" :
        """
        Gets and sets the full path and file name of the image file.
        Supported image format is .png
        Images are displayed in the command dialog using their actual size.
        """
        return _core.ImageCommandInput__get_imageFile(self)

    def _set_imageFile(self, *args) -> "bool" :
        """
        Gets and sets the full path and file name of the image file.
        Supported image format is .png
        Images are displayed in the command dialog using their actual size.
        """
        return _core.ImageCommandInput__set_imageFile(self, *args)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.ImageCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.ImageCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.ImageCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.ImageCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.ImageCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.ImageCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.ImageCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.ImageCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.ImageCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.ImageCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.ImageCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.ImageCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.ImageCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.ImageCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.ImageCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.ImageCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.ImageCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.ImageCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ImageCommandInput__get_isValid(self)
ImageCommandInput_swigregister = _core.ImageCommandInput_swigregister
ImageCommandInput_swigregister(ImageCommandInput)

def ImageCommandInput_classType() -> "char const *" :
  return _core.ImageCommandInput_classType()
ImageCommandInput_classType = _core.ImageCommandInput_classType

ImageCommandInput.__swig_getmethods__["imageFile"] = ImageCommandInput._get_imageFile
ImageCommandInput.__swig_setmethods__["imageFile"] = ImageCommandInput._set_imageFile
ImageCommandInput.imageFile = property(ImageCommandInput._get_imageFile, ImageCommandInput._set_imageFile, doc="Gets and sets the full path and file name of the image file.\nSupported image format is .png\nImages are displayed in the command dialog using their actual size.")

ImageCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ImageCommandInput) else None
ImageCommandInput.cast = lambda arg: arg if isinstance(arg, ImageCommandInput) else None

class InfiniteLine3D(Curve3D):
    """
    Transient 3D infinite line. An infinite line is defined by a position and direction in space 
    and has no start or end points.
    They are created statically using the create method of the InfiniteLine3D class.
    """
    __swig_setmethods__ = {}
    for _s in [Curve3D]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InfiniteLine3D, name, value)
    __swig_getmethods__ = {}
    for _s in [Curve3D]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InfiniteLine3D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::InfiniteLine3D *" : return _core.InfiniteLine3D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.InfiniteLine3D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.InfiniteLine3D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.InfiniteLine3D_classType
    if _newclass:classType = staticmethod(_core.InfiniteLine3D_classType)
    __swig_getmethods__["create"] = lambda x: _core.InfiniteLine3D_create
    if _newclass:create = staticmethod(_core.InfiniteLine3D_create)
    __swig_destroy__ = _core.delete_InfiniteLine3D
    __del__ = lambda self : None;
    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets the origin point of the line."""
        return _core.InfiniteLine3D__get_origin(self)

    def _set_origin(self, *args) -> "bool" :
        """Gets and sets the origin point of the line."""
        return _core.InfiniteLine3D__set_origin(self, *args)

    def _get_direction(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Gets and sets the direction of the line."""
        return _core.InfiniteLine3D__get_direction(self)

    def _set_direction(self, *args) -> "bool" :
        """Gets and sets the direction of the line."""
        return _core.InfiniteLine3D__set_direction(self, *args)

    def isColinearTo(self, *args) -> "bool" :
        """
        Compare this line with another to check for collinearity. 
        line : The line to compare with for collinearity. 
        Returns true if the two lines are collinear.
        """
        return _core.InfiniteLine3D_isColinearTo(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::InfiniteLine3D >" :
        """
        Creates and returns a copy of this line object. 
        Returns an independent copy of this line object.
        """
        return _core.InfiniteLine3D_copy(self)

    def intersectWithCurve(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Intersect this line with a curve to get the intersection point(s). 
        curve : The intersecting curve.
        The curve can be a Line3D, InfininteLine3D, Circle3D, Arc3D, EllipticalArc3D, Ellipse3D, 
        or NurbsCurve3D. 
        Returns a collection of the intersection points.
        """
        return _core.InfiniteLine3D_intersectWithCurve(self, *args)

    def intersectWithSurface(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Intersect this line with a surface to get the intersection point(s). 
        surface : The intersecting surface.
        The surface can be a Plane, Cone, Cylinder, EllipticalCone, EllipticalCylinder, Sphere, 
        Torus, or a NurbsSurface. 
        Returns a collection of the intersection points.
        """
        return _core.InfiniteLine3D_intersectWithSurface(self, *args)

    def getData(self) -> "bool" :
        """
        Gets all of the data defining the infinite line. 
        origin : The output origin point of the line. 
        direction : The output direction of the line. 
        Returns true if successful.
        """
        return _core.InfiniteLine3D_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets all of the data defining the infinite line. 
        origin : The origin point of the line. 
        direction : The direction of the line. 
        Returns true if successful.
        """
        return _core.InfiniteLine3D_set(self, *args)

    def _get_curveType(self) -> "adsk::core::Curve3DTypes" :
        """Returns the type of geometry this curve represents."""
        return _core.InfiniteLine3D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >" :
        """Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.InfiniteLine3D__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms this curve in 3D space. 
        matrix : A 3D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.InfiniteLine3D_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.InfiniteLine3D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.InfiniteLine3D__get_isValid(self)
InfiniteLine3D_swigregister = _core.InfiniteLine3D_swigregister
InfiniteLine3D_swigregister(InfiniteLine3D)

def InfiniteLine3D_classType() -> "char const *" :
  return _core.InfiniteLine3D_classType()
InfiniteLine3D_classType = _core.InfiniteLine3D_classType

def InfiniteLine3D_create(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &" :
  return _core.InfiniteLine3D_create(*args)
InfiniteLine3D_create = _core.InfiniteLine3D_create

InfiniteLine3D.__swig_getmethods__["origin"] = InfiniteLine3D._get_origin
InfiniteLine3D.__swig_setmethods__["origin"] = InfiniteLine3D._set_origin
InfiniteLine3D.origin = property(InfiniteLine3D._get_origin, InfiniteLine3D._set_origin, doc="Gets and sets the origin point of the line.")

InfiniteLine3D.__swig_getmethods__["direction"] = InfiniteLine3D._get_direction
InfiniteLine3D.__swig_setmethods__["direction"] = InfiniteLine3D._set_direction
InfiniteLine3D.direction = property(InfiniteLine3D._get_direction, InfiniteLine3D._set_direction, doc="Gets and sets the direction of the line.")

InfiniteLine3D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, InfiniteLine3D) else None
InfiniteLine3D.cast = lambda arg: arg if isinstance(arg, InfiniteLine3D) else None

class InputChangedEvent(Event):
    """An event endpoint that supports the connection to client implemented InputChangedEventHandlers."""
    __swig_setmethods__ = {}
    for _s in [Event]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InputChangedEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InputChangedEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::InputChangedEvent *" : return _core.InputChangedEvent___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.InputChangedEvent___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.InputChangedEvent___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.InputChangedEvent_classType
    if _newclass:classType = staticmethod(_core.InputChangedEvent_classType)
    __swig_destroy__ = _core.delete_InputChangedEvent
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Adds an event handler to this event endpoint. 
        handler : The client implemented InputChangedEventHandler to be called when this event is triggered. 
        Returns true if the handler was successfully added to the set of event handlers.
        """
        return _core.InputChangedEvent_add(self, *args)

    def remove(self, *args) -> "bool" :
        """
        Removes a handler from this event endpoint. 
        handler : A InputChangedEventHandler that was previously added to this event with the add method. 
        Returns true if the handler was found and removed from the set of event handlers.
        """
        return _core.InputChangedEvent_remove(self, *args)

    def _get_name(self) -> "std::string" :
        """The name of the event - e.g. 'DocumentOpening'"""
        return _core.InputChangedEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.InputChangedEvent__get_sender(self)

    def _get_objectType(self) -> "char const *" : return _core.InputChangedEvent__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.InputChangedEvent__get_isValid(self)
InputChangedEvent_swigregister = _core.InputChangedEvent_swigregister
InputChangedEvent_swigregister(InputChangedEvent)

def InputChangedEvent_classType() -> "char const *" :
  return _core.InputChangedEvent_classType()
InputChangedEvent_classType = _core.InputChangedEvent_classType

InputChangedEvent.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, InputChangedEvent) else None
InputChangedEvent.cast = lambda arg: arg if isinstance(arg, InputChangedEvent) else None

class InputChangedEventArgs(EventArgs):
    """Provides a set of arguments from a firing InputChangedEvent to a InputEventChangedEventHandler's notify callback method."""
    __swig_setmethods__ = {}
    for _s in [EventArgs]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InputChangedEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InputChangedEventArgs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::InputChangedEventArgs *" : return _core.InputChangedEventArgs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.InputChangedEventArgs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.InputChangedEventArgs___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.InputChangedEventArgs_classType
    if _newclass:classType = staticmethod(_core.InputChangedEventArgs_classType)
    __swig_destroy__ = _core.delete_InputChangedEventArgs
    __del__ = lambda self : None;
    def _get_input(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """Returns the command input that has just changed."""
        return _core.InputChangedEventArgs__get_input(self)

    def _get_inputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Returns the collection of command inputs that are associated with the command this event is being fired for."""
        return _core.InputChangedEventArgs__get_inputs(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >" :
        """The event that the firing is in response to."""
        return _core.InputChangedEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *" : return _core.InputChangedEventArgs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.InputChangedEventArgs__get_isValid(self)
InputChangedEventArgs_swigregister = _core.InputChangedEventArgs_swigregister
InputChangedEventArgs_swigregister(InputChangedEventArgs)

def InputChangedEventArgs_classType() -> "char const *" :
  return _core.InputChangedEventArgs_classType()
InputChangedEventArgs_classType = _core.InputChangedEventArgs_classType

InputChangedEventArgs.__swig_getmethods__["input"] = InputChangedEventArgs._get_input
InputChangedEventArgs.input = property(InputChangedEventArgs._get_input, doc="Returns the command input that has just changed.")

InputChangedEventArgs.__swig_getmethods__["inputs"] = InputChangedEventArgs._get_inputs
InputChangedEventArgs.inputs = property(InputChangedEventArgs._get_inputs, doc="Returns the collection of command inputs that are associated with the command this event is being fired for.")

InputChangedEventArgs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, InputChangedEventArgs) else None
InputChangedEventArgs.cast = lambda arg: arg if isinstance(arg, InputChangedEventArgs) else None

class IntegerProperty(Property):
    """An integer value property associated with a material or appearance."""
    __swig_setmethods__ = {}
    for _s in [Property]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntegerProperty, name, value)
    __swig_getmethods__ = {}
    for _s in [Property]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntegerProperty, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::IntegerProperty *" : return _core.IntegerProperty___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.IntegerProperty___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.IntegerProperty___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.IntegerProperty_classType
    if _newclass:classType = staticmethod(_core.IntegerProperty_classType)
    __swig_destroy__ = _core.delete_IntegerProperty
    __del__ = lambda self : None;
    def getLimits(self) -> "bool" :
        """
        Method that returns any limits for the value of this property. The HasLimits property can
        be used to see if there are any limits or not. 
        hasLowLimit : Output Boolean that indicates if there is a low limit or not. 
        lowLimit : If the hasLowLimit argument is true, this argument returns the low limit. 
        hasHighLimit : Output Boolean that indicates if there is a high limit or not. 
        highLimit : If the hasHighLimit argument is true, this argument returns the high limit. 
        Returns true if the method call was successful.
        """
        return _core.IntegerProperty_getLimits(self)

    def _get_hasLimits(self) -> "bool" :
        """
        Gets the boolean flag that indicates if the value of this property has any limits it must 
        be within to be valid. If True, use the GetLimits method to get the limit values.
        """
        return _core.IntegerProperty__get_hasLimits(self)

    def _get_hasMultipleValues(self) -> "bool" :
        """Gets the boolean flag that indicates if this property has multiple values or not."""
        return _core.IntegerProperty__get_hasMultipleValues(self)

    def _get_value(self) -> "int" :
        """
        Gets and sets this property value. The value of this property should be ignored 
        if the HasConnectedTexture property is true. Setting this will remove any 
        associated texture, if there is one.
        """
        return _core.IntegerProperty__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """
        Gets and sets this property value. The value of this property should be ignored 
        if the HasConnectedTexture property is true. Setting this will remove any 
        associated texture, if there is one.
        """
        return _core.IntegerProperty__set_value(self, *args)

    def _get_values(self) -> "std::vector< int,std::allocator< int > >" :
        """
        Gets and sets the values associated with this property. HasMultipleValues property 
        indicates if this property will be returning more than one value.
        """
        return _core.IntegerProperty__get_values(self)

    def _set_values(self, *args) -> "bool" :
        """
        Gets and sets the values associated with this property. HasMultipleValues property 
        indicates if this property will be returning more than one value.
        """
        return _core.IntegerProperty__set_values(self, *args)

    def _get_name(self) -> "std::string" :
        """
        Returns the name of this property as seen in the user interface. This name is localized
        and can change based on the current language
        """
        return _core.IntegerProperty__get_name(self)

    def _get_isReadOnly(self) -> "bool" :
        """Indicates if this property is read-only. If True any attempted edits will fail."""
        return _core.IntegerProperty__get_isReadOnly(self)

    def _get_id(self) -> "std::string" :
        """Returns the unique ID of this property."""
        return _core.IntegerProperty__get_id(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the parent of this property."""
        return _core.IntegerProperty__get_parent(self)

    def _get_objectType(self) -> "char const *" : return _core.IntegerProperty__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.IntegerProperty__get_isValid(self)
IntegerProperty_swigregister = _core.IntegerProperty_swigregister
IntegerProperty_swigregister(IntegerProperty)

def IntegerProperty_classType() -> "char const *" :
  return _core.IntegerProperty_classType()
IntegerProperty_classType = _core.IntegerProperty_classType

IntegerProperty.__swig_getmethods__["hasLimits"] = IntegerProperty._get_hasLimits
IntegerProperty.hasLimits = property(IntegerProperty._get_hasLimits, doc="Gets the boolean flag that indicates if the value of this property has any limits it must\nbe within to be valid. If True, use the GetLimits method to get the limit values.")

IntegerProperty.__swig_getmethods__["hasMultipleValues"] = IntegerProperty._get_hasMultipleValues
IntegerProperty.hasMultipleValues = property(IntegerProperty._get_hasMultipleValues, doc="Gets the boolean flag that indicates if this property has multiple values or not.")

IntegerProperty.__swig_getmethods__["value"] = IntegerProperty._get_value
IntegerProperty.__swig_setmethods__["value"] = IntegerProperty._set_value
IntegerProperty.value = property(IntegerProperty._get_value, IntegerProperty._set_value, doc="Gets and sets this property value. The value of this property should be ignored\nif the HasConnectedTexture property is true. Setting this will remove any\nassociated texture, if there is one.")

IntegerProperty.__swig_getmethods__["values"] = IntegerProperty._get_values
IntegerProperty.__swig_setmethods__["values"] = IntegerProperty._set_values
IntegerProperty.values = property(IntegerProperty._get_values, IntegerProperty._set_values, doc="Gets and sets the values associated with this property. HasMultipleValues property\nindicates if this property will be returning more than one value.")

IntegerProperty.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, IntegerProperty) else None
IntegerProperty.cast = lambda arg: arg if isinstance(arg, IntegerProperty) else None

class IntegerSpinnerCommandInput(CommandInput):
    """Provides a command input to get the value of a spinner from the user, the value type is integer."""
    __swig_setmethods__ = {}
    for _s in [CommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntegerSpinnerCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [CommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntegerSpinnerCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::IntegerSpinnerCommandInput *" : return _core.IntegerSpinnerCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.IntegerSpinnerCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.IntegerSpinnerCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.IntegerSpinnerCommandInput_classType
    if _newclass:classType = staticmethod(_core.IntegerSpinnerCommandInput_classType)
    __swig_destroy__ = _core.delete_IntegerSpinnerCommandInput
    __del__ = lambda self : None;
    def _get_value(self) -> "int" :
        """Gets and sets the value associated with this input."""
        return _core.IntegerSpinnerCommandInput__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """Gets and sets the value associated with this input."""
        return _core.IntegerSpinnerCommandInput__set_value(self, *args)

    def _get_minimumValue(self) -> "int" :
        """Gets the minimum allowed value of the spinner."""
        return _core.IntegerSpinnerCommandInput__get_minimumValue(self)

    def _get_maximumValue(self) -> "int" :
        """Gets the maximum allowed value of the spinner."""
        return _core.IntegerSpinnerCommandInput__get_maximumValue(self)

    def _get_spinStep(self) -> "size_t" :
        """
        Gets the spin step. The value should be more than zero. This is the amount the spinner will advance
        when the user clicks the spin button beside the value.
        """
        return _core.IntegerSpinnerCommandInput__get_spinStep(self)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.IntegerSpinnerCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.IntegerSpinnerCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.IntegerSpinnerCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.IntegerSpinnerCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.IntegerSpinnerCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.IntegerSpinnerCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.IntegerSpinnerCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.IntegerSpinnerCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.IntegerSpinnerCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.IntegerSpinnerCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.IntegerSpinnerCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.IntegerSpinnerCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.IntegerSpinnerCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.IntegerSpinnerCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.IntegerSpinnerCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.IntegerSpinnerCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.IntegerSpinnerCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.IntegerSpinnerCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.IntegerSpinnerCommandInput__get_isValid(self)
IntegerSpinnerCommandInput_swigregister = _core.IntegerSpinnerCommandInput_swigregister
IntegerSpinnerCommandInput_swigregister(IntegerSpinnerCommandInput)

def IntegerSpinnerCommandInput_classType() -> "char const *" :
  return _core.IntegerSpinnerCommandInput_classType()
IntegerSpinnerCommandInput_classType = _core.IntegerSpinnerCommandInput_classType

IntegerSpinnerCommandInput.__swig_getmethods__["value"] = IntegerSpinnerCommandInput._get_value
IntegerSpinnerCommandInput.__swig_setmethods__["value"] = IntegerSpinnerCommandInput._set_value
IntegerSpinnerCommandInput.value = property(IntegerSpinnerCommandInput._get_value, IntegerSpinnerCommandInput._set_value, doc="Gets and sets the value associated with this input.")

IntegerSpinnerCommandInput.__swig_getmethods__["minimumValue"] = IntegerSpinnerCommandInput._get_minimumValue
IntegerSpinnerCommandInput.minimumValue = property(IntegerSpinnerCommandInput._get_minimumValue, doc="Gets the minimum allowed value of the spinner.")

IntegerSpinnerCommandInput.__swig_getmethods__["maximumValue"] = IntegerSpinnerCommandInput._get_maximumValue
IntegerSpinnerCommandInput.maximumValue = property(IntegerSpinnerCommandInput._get_maximumValue, doc="Gets the maximum allowed value of the spinner.")

IntegerSpinnerCommandInput.__swig_getmethods__["spinStep"] = IntegerSpinnerCommandInput._get_spinStep
IntegerSpinnerCommandInput.spinStep = property(IntegerSpinnerCommandInput._get_spinStep, doc="Gets the spin step. The value should be more than zero. This is the amount the spinner will advance\nwhen the user clicks the spin button beside the value.")

IntegerSpinnerCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, IntegerSpinnerCommandInput) else None
IntegerSpinnerCommandInput.cast = lambda arg: arg if isinstance(arg, IntegerSpinnerCommandInput) else None

class KeyboardEvent(Event):
    """An event endpoint that supports the connection to client implemented KeyboardEventHandlers."""
    __swig_setmethods__ = {}
    for _s in [Event]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KeyboardEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, KeyboardEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::KeyboardEvent *" : return _core.KeyboardEvent___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.KeyboardEvent___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.KeyboardEvent___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.KeyboardEvent_classType
    if _newclass:classType = staticmethod(_core.KeyboardEvent_classType)
    __swig_destroy__ = _core.delete_KeyboardEvent
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Adds an event handler to this event endpoint. 
        handler : The client implemented KeyboardEventHandler to be called when this event is triggered. 
        Returns true if the handler was successfully added to the set of event handlers.
        """
        return _core.KeyboardEvent_add(self, *args)

    def remove(self, *args) -> "bool" :
        """
        Removes a handler from this event endpoint. 
        handler : A KeyboardEventHandler that was previously added to this event with the add method. 
        Returns true if the handler was found and removed from the set of event handlers.
        """
        return _core.KeyboardEvent_remove(self, *args)

    def _get_name(self) -> "std::string" :
        """The name of the event - e.g. 'DocumentOpening'"""
        return _core.KeyboardEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.KeyboardEvent__get_sender(self)

    def _get_objectType(self) -> "char const *" : return _core.KeyboardEvent__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.KeyboardEvent__get_isValid(self)
KeyboardEvent_swigregister = _core.KeyboardEvent_swigregister
KeyboardEvent_swigregister(KeyboardEvent)

def KeyboardEvent_classType() -> "char const *" :
  return _core.KeyboardEvent_classType()
KeyboardEvent_classType = _core.KeyboardEvent_classType

KeyboardEvent.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, KeyboardEvent) else None
KeyboardEvent.cast = lambda arg: arg if isinstance(arg, KeyboardEvent) else None

class KeyboardEventArgs(EventArgs):
    """Provides a set of arguments from a firing KeyboardEvent to a KeyboardEventHandler's notify callback method."""
    __swig_setmethods__ = {}
    for _s in [EventArgs]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KeyboardEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, KeyboardEventArgs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::KeyboardEventArgs *" : return _core.KeyboardEventArgs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.KeyboardEventArgs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.KeyboardEventArgs___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.KeyboardEventArgs_classType
    if _newclass:classType = staticmethod(_core.KeyboardEventArgs_classType)
    __swig_destroy__ = _core.delete_KeyboardEventArgs
    __del__ = lambda self : None;
    def _get_modifierMask(self) -> "int" :
        """
        Gets the set of keyboard modifiers that were active. The value is the Boolean
        combination of KeyboardModifiers values.
        """
        return _core.KeyboardEventArgs__get_modifierMask(self)

    def _get_keyCode(self) -> "adsk::core::KeyCodes" :
        """Gets the keyboard key."""
        return _core.KeyboardEventArgs__get_keyCode(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >" :
        """The event that the firing is in response to."""
        return _core.KeyboardEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *" : return _core.KeyboardEventArgs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.KeyboardEventArgs__get_isValid(self)
KeyboardEventArgs_swigregister = _core.KeyboardEventArgs_swigregister
KeyboardEventArgs_swigregister(KeyboardEventArgs)

def KeyboardEventArgs_classType() -> "char const *" :
  return _core.KeyboardEventArgs_classType()
KeyboardEventArgs_classType = _core.KeyboardEventArgs_classType

KeyboardEventArgs.__swig_getmethods__["modifierMask"] = KeyboardEventArgs._get_modifierMask
KeyboardEventArgs.modifierMask = property(KeyboardEventArgs._get_modifierMask, doc="Gets the set of keyboard modifiers that were active. The value is the Boolean\ncombination of KeyboardModifiers values.")

KeyboardEventArgs.__swig_getmethods__["keyCode"] = KeyboardEventArgs._get_keyCode
KeyboardEventArgs.keyCode = property(KeyboardEventArgs._get_keyCode, doc="Gets the keyboard key.")

KeyboardEventArgs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, KeyboardEventArgs) else None
KeyboardEventArgs.cast = lambda arg: arg if isinstance(arg, KeyboardEventArgs) else None

class Line2D(Curve2D):
    """
    Transient 2D line. A transient line is not displayed or saved in a document.
    Transient 2D lines are used as a wrapper to work with raw 2D line information.
    They are created statically using the create method of the Line2D class.
    """
    __swig_setmethods__ = {}
    for _s in [Curve2D]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Line2D, name, value)
    __swig_getmethods__ = {}
    for _s in [Curve2D]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Line2D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Line2D *" : return _core.Line2D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Line2D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Line2D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Line2D_classType
    if _newclass:classType = staticmethod(_core.Line2D_classType)
    __swig_getmethods__["create"] = lambda x: _core.Line2D_create
    if _newclass:create = staticmethod(_core.Line2D_create)
    __swig_destroy__ = _core.delete_Line2D
    __del__ = lambda self : None;
    def _get_startPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """Gets and sets the start point of the line."""
        return _core.Line2D__get_startPoint(self)

    def _set_startPoint(self, *args) -> "bool" :
        """Gets and sets the start point of the line."""
        return _core.Line2D__set_startPoint(self, *args)

    def _get_endPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """Gets and sets the end point of the line."""
        return _core.Line2D__get_endPoint(self)

    def _set_endPoint(self, *args) -> "bool" :
        """Gets and sets the end point of the line."""
        return _core.Line2D__set_endPoint(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Line2D >" :
        """
        Creates and returns a copy of this line object. 
        Returns an independent copy of this line object.
        """
        return _core.Line2D_copy(self)

    def getData(self) -> "bool" :
        """
        Gets all of the data defining the line segment. 
        startPoint : The output start point of the line. 
        endPoint : The output end point of the line. 
        Returns true if successful.
        """
        return _core.Line2D_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets all of the data defining the line segment. 
        startPoint : The start point of the line 
        endPoint : The end point of the line 
        Returns true if redefining the line is successful
        """
        return _core.Line2D_set(self, *args)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve2D >" :
        """Returns a NURBS curve that is geometrically identical to the line."""
        return _core.Line2D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve2DTypes" :
        """Returns the type of geometry this curve represents."""
        return _core.Line2D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator2D >" :
        """Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Line2D__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms this curve in 2D space. 
        matrix : A 2D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Line2D_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Line2D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Line2D__get_isValid(self)
Line2D_swigregister = _core.Line2D_swigregister
Line2D_swigregister(Line2D)

def Line2D_classType() -> "char const *" :
  return _core.Line2D_classType()
Line2D_classType = _core.Line2D_classType

def Line2D_create(*args) -> "adsk::core::Ptr< adsk::core::Point2D > const &, adsk::core::Ptr< adsk::core::Point2D > const &" :
  return _core.Line2D_create(*args)
Line2D_create = _core.Line2D_create

Line2D.__swig_getmethods__["startPoint"] = Line2D._get_startPoint
Line2D.__swig_setmethods__["startPoint"] = Line2D._set_startPoint
Line2D.startPoint = property(Line2D._get_startPoint, Line2D._set_startPoint, doc="Gets and sets the start point of the line.")

Line2D.__swig_getmethods__["endPoint"] = Line2D._get_endPoint
Line2D.__swig_setmethods__["endPoint"] = Line2D._set_endPoint
Line2D.endPoint = property(Line2D._get_endPoint, Line2D._set_endPoint, doc="Gets and sets the end point of the line.")

Line2D.__swig_getmethods__["asNurbsCurve"] = Line2D._get_asNurbsCurve
Line2D.asNurbsCurve = property(Line2D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the line.")

Line2D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Line2D) else None
Line2D.cast = lambda arg: arg if isinstance(arg, Line2D) else None

class Line3D(Curve3D):
    """
    Transient 3D line. A transient line is not displayed or saved in a document.
    Transient 3D lines are used as a wrapper to work with raw 3D line information.
    They are created statically using the create method of the Line3D class.
    """
    __swig_setmethods__ = {}
    for _s in [Curve3D]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Line3D, name, value)
    __swig_getmethods__ = {}
    for _s in [Curve3D]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Line3D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Line3D *" : return _core.Line3D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Line3D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Line3D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Line3D_classType
    if _newclass:classType = staticmethod(_core.Line3D_classType)
    __swig_getmethods__["create"] = lambda x: _core.Line3D_create
    if _newclass:create = staticmethod(_core.Line3D_create)
    __swig_destroy__ = _core.delete_Line3D
    __del__ = lambda self : None;
    def _get_startPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets the start point of the line."""
        return _core.Line3D__get_startPoint(self)

    def _set_startPoint(self, *args) -> "bool" :
        """Gets and sets the start point of the line."""
        return _core.Line3D__set_startPoint(self, *args)

    def _get_endPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets the end point of the line."""
        return _core.Line3D__get_endPoint(self)

    def _set_endPoint(self, *args) -> "bool" :
        """Gets and sets the end point of the line."""
        return _core.Line3D__set_endPoint(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Line3D >" :
        """
        Creates and returns a copy of this line object. 
        Returns an independent copy of this line object.
        """
        return _core.Line3D_copy(self)

    def asInfiniteLine(self) -> "adsk::core::Ptr< adsk::core::InfiniteLine3D >" :
        """
        Creates an equivalent InfiniteLine3D. 
        Returns an equivalent InfiniteLine3D
        """
        return _core.Line3D_asInfiniteLine(self)

    def isColinearTo(self, *args) -> "bool" :
        """
        Compare this line with another to check for collinearity 
        line : The line to compare with for collinearity 
        Returns true if the two lines are collinear
        """
        return _core.Line3D_isColinearTo(self, *args)

    def intersectWithCurve(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Intersect this line with a curve to get the intersection point(s). 
        curve : The intersecting curve.
        The curve can be a Line3D, InfininteLine3D, Circle3D, Arc3D, EllipticalArc3D, Ellipse3D, 
        or NurbsCurve3D. 
        Returns a collection of the intersection points
        """
        return _core.Line3D_intersectWithCurve(self, *args)

    def intersectWithSurface(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Intersect this line with a surface to get the intersection point(s). 
        surface : The intersecting surface.
        The surface can be a Plane, Cone, Cylinder, EllipticalCone, EllipticalCylinder, Sphere, 
        Torus or a NurbsSurface. 
        Returns a collection of the intersection points.
        """
        return _core.Line3D_intersectWithSurface(self, *args)

    def getData(self) -> "bool" :
        """
        Gets all of the data defining the line segment. 
        startPoint : The output start point of the line. 
        endPoint : The output end point of the line. 
        Returns true if successful.
        """
        return _core.Line3D_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets all of the data defining the line segment. 
        startPoint : The start point of the line. 
        endPoint : The end point of the line. 
        Returns true if successful.
        """
        return _core.Line3D_set(self, *args)

    def _get_asNurbsCurve(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >" :
        """Returns a NURBS curve that is geometrically identical to the line."""
        return _core.Line3D__get_asNurbsCurve(self)

    def _get_curveType(self) -> "adsk::core::Curve3DTypes" :
        """Returns the type of geometry this curve represents."""
        return _core.Line3D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >" :
        """Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.Line3D__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms this curve in 3D space. 
        matrix : A 3D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.Line3D_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Line3D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Line3D__get_isValid(self)
Line3D_swigregister = _core.Line3D_swigregister
Line3D_swigregister(Line3D)

def Line3D_classType() -> "char const *" :
  return _core.Line3D_classType()
Line3D_classType = _core.Line3D_classType

def Line3D_create(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point3D > const &" :
  return _core.Line3D_create(*args)
Line3D_create = _core.Line3D_create

Line3D.__swig_getmethods__["startPoint"] = Line3D._get_startPoint
Line3D.__swig_setmethods__["startPoint"] = Line3D._set_startPoint
Line3D.startPoint = property(Line3D._get_startPoint, Line3D._set_startPoint, doc="Gets and sets the start point of the line.")

Line3D.__swig_getmethods__["endPoint"] = Line3D._get_endPoint
Line3D.__swig_setmethods__["endPoint"] = Line3D._set_endPoint
Line3D.endPoint = property(Line3D._get_endPoint, Line3D._set_endPoint, doc="Gets and sets the end point of the line.")

Line3D.__swig_getmethods__["asNurbsCurve"] = Line3D._get_asNurbsCurve
Line3D.asNurbsCurve = property(Line3D._get_asNurbsCurve, doc="Returns a NURBS curve that is geometrically identical to the line.")

Line3D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Line3D) else None
Line3D.cast = lambda arg: arg if isinstance(arg, Line3D) else None

class ListControlDefinition(ControlDefinition):
    """
    Represents the information used to define a list of check boxes, radio buttons, or text with icons. This class
    isn't the visible list control but is the information needed to create a list control and fully defines a list except for 
    it's position within the user interface.
    """
    __swig_setmethods__ = {}
    for _s in [ControlDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListControlDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ControlDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListControlDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ListControlDefinition *" : return _core.ListControlDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ListControlDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ListControlDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ListControlDefinition_classType
    if _newclass:classType = staticmethod(_core.ListControlDefinition_classType)
    __swig_destroy__ = _core.delete_ListControlDefinition
    __del__ = lambda self : None;
    def _get_listItems(self) -> "adsk::core::Ptr< adsk::core::ListItems >" :
        """Gets the associated ListControlItems collection through which you can add and modify items in the list."""
        return _core.ListControlDefinition__get_listItems(self)

    def _get_listControlDisplayType(self) -> "adsk::core::ListControlDisplayTypes" :
        """Gets how this list control will be displayed; as a standard list, a list of check boxes, or a list of radio buttons."""
        return _core.ListControlDefinition__get_listControlDisplayType(self)

    def _get_lastSelected(self) -> "adsk::core::Ptr< adsk::core::ListItem >" :
        """
        Gets the item in the list that was last selected. This can return null
        in the case where this control is displayed as a list of check boxes and there hasn't 
        been any interaction by the end-user. In the case of a list of check boxes, this returns
        the item that was last clicked by the user, whether it was to check or uncheck the item.
        In the case of a list of radio buttons, this always returns the item that is currently selected.
        """
        return _core.ListControlDefinition__get_lastSelected(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls."""
        return _core.ListControlDefinition__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this definition is enabled or not. This has the effect of enabling and disabling any associated controls."""
        return _core.ListControlDefinition__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface."""
        return _core.ListControlDefinition__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this definition is visible or not. This has the effect of making any associated controls visible or invisible in the user interface."""
        return _core.ListControlDefinition__set_isVisible(self, *args)

    def _get_name(self) -> "std::string" :
        """Gets or sets the name for this control. This is the visible name displayed in the user interface."""
        return _core.ListControlDefinition__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Gets or sets the name for this control. This is the visible name displayed in the user interface."""
        return _core.ListControlDefinition__set_name(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.ListControlDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ListControlDefinition__get_isValid(self)
ListControlDefinition_swigregister = _core.ListControlDefinition_swigregister
ListControlDefinition_swigregister(ListControlDefinition)

def ListControlDefinition_classType() -> "char const *" :
  return _core.ListControlDefinition_classType()
ListControlDefinition_classType = _core.ListControlDefinition_classType

ListControlDefinition.__swig_getmethods__["listItems"] = ListControlDefinition._get_listItems
ListControlDefinition.listItems = property(ListControlDefinition._get_listItems, doc="Gets the associated ListControlItems collection through which you can add and modify items in the list.")

ListControlDefinition.__swig_getmethods__["listControlDisplayType"] = ListControlDefinition._get_listControlDisplayType
ListControlDefinition.listControlDisplayType = property(ListControlDefinition._get_listControlDisplayType, doc="Gets how this list control will be displayed; as a standard list, a list of check boxes, or a list of radio buttons.")

ListControlDefinition.__swig_getmethods__["lastSelected"] = ListControlDefinition._get_lastSelected
ListControlDefinition.lastSelected = property(ListControlDefinition._get_lastSelected, doc="Gets the item in the list that was last selected. This can return null\nin the case where this control is displayed as a list of check boxes and there hasn't\nbeen any interaction by the end-user. In the case of a list of check boxes, this returns\nthe item that was last clicked by the user, whether it was to check or uncheck the item.\nIn the case of a list of radio buttons, this always returns the item that is currently selected.")

ListControlDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ListControlDefinition) else None
ListControlDefinition.cast = lambda arg: arg if isinstance(arg, ListControlDefinition) else None

class MarkingMenuEvent(Event):
    """
    A MarkingMenuEvent is fired when the marking menu and context menu are displayed. For example, in response to the
    markingMenuDisplaying event.
    """
    __swig_setmethods__ = {}
    for _s in [Event]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MarkingMenuEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MarkingMenuEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::MarkingMenuEvent *" : return _core.MarkingMenuEvent___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.MarkingMenuEvent___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.MarkingMenuEvent___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.MarkingMenuEvent_classType
    if _newclass:classType = staticmethod(_core.MarkingMenuEvent_classType)
    __swig_destroy__ = _core.delete_MarkingMenuEvent
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Add a handler to be notified when the event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.MarkingMenuEvent_add(self, *args)

    def remove(self, *args) -> "bool" :
        """
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.MarkingMenuEvent_remove(self, *args)

    def _get_name(self) -> "std::string" :
        """The name of the event - e.g. 'DocumentOpening'"""
        return _core.MarkingMenuEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.MarkingMenuEvent__get_sender(self)

    def _get_objectType(self) -> "char const *" : return _core.MarkingMenuEvent__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.MarkingMenuEvent__get_isValid(self)
MarkingMenuEvent_swigregister = _core.MarkingMenuEvent_swigregister
MarkingMenuEvent_swigregister(MarkingMenuEvent)

def MarkingMenuEvent_classType() -> "char const *" :
  return _core.MarkingMenuEvent_classType()
MarkingMenuEvent_classType = _core.MarkingMenuEvent_classType

MarkingMenuEvent.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MarkingMenuEvent) else None
MarkingMenuEvent.cast = lambda arg: arg if isinstance(arg, MarkingMenuEvent) else None

class MarkingMenuEventArgs(EventArgs):
    """
    The MarkingMenuEventArgs provides information associated with the marking and context
    menu being displayed.
    """
    __swig_setmethods__ = {}
    for _s in [EventArgs]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MarkingMenuEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MarkingMenuEventArgs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::MarkingMenuEventArgs *" : return _core.MarkingMenuEventArgs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.MarkingMenuEventArgs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.MarkingMenuEventArgs___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.MarkingMenuEventArgs_classType
    if _newclass:classType = staticmethod(_core.MarkingMenuEventArgs_classType)
    __swig_destroy__ = _core.delete_MarkingMenuEventArgs
    __del__ = lambda self : None;
    def _get_radialMarkingMenu(self) -> "adsk::core::Ptr< adsk::core::RadialMarkingMenu >" :
        """Provides access to the radial marking menu."""
        return _core.MarkingMenuEventArgs__get_radialMarkingMenu(self)

    def _get_linearMarkingMenu(self) -> "adsk::core::Ptr< adsk::core::LinearMarkingMenu >" :
        """Provides access to the linear marking menu."""
        return _core.MarkingMenuEventArgs__get_linearMarkingMenu(self)

    def _get_selectedEntities(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base >,std::allocator< adsk::core::Ptr< adsk::core::Base > > >" :
        """
        Returns the currently selected entities that the user left-clicked over.
        These provide the 'context' of what should be displayed in the menu. This
        can be an empty array in the case where they clicked in a open area within 
        the graphics window.
        """
        return _core.MarkingMenuEventArgs__get_selectedEntities(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >" :
        """The event that the firing is in response to."""
        return _core.MarkingMenuEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *" : return _core.MarkingMenuEventArgs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.MarkingMenuEventArgs__get_isValid(self)
MarkingMenuEventArgs_swigregister = _core.MarkingMenuEventArgs_swigregister
MarkingMenuEventArgs_swigregister(MarkingMenuEventArgs)

def MarkingMenuEventArgs_classType() -> "char const *" :
  return _core.MarkingMenuEventArgs_classType()
MarkingMenuEventArgs_classType = _core.MarkingMenuEventArgs_classType

MarkingMenuEventArgs.__swig_getmethods__["radialMarkingMenu"] = MarkingMenuEventArgs._get_radialMarkingMenu
MarkingMenuEventArgs.radialMarkingMenu = property(MarkingMenuEventArgs._get_radialMarkingMenu, doc="Provides access to the radial marking menu.")

MarkingMenuEventArgs.__swig_getmethods__["linearMarkingMenu"] = MarkingMenuEventArgs._get_linearMarkingMenu
MarkingMenuEventArgs.linearMarkingMenu = property(MarkingMenuEventArgs._get_linearMarkingMenu, doc="Provides access to the linear marking menu.")

MarkingMenuEventArgs.__swig_getmethods__["selectedEntities"] = MarkingMenuEventArgs._get_selectedEntities
MarkingMenuEventArgs.selectedEntities = property(MarkingMenuEventArgs._get_selectedEntities, doc="Returns the currently selected entities that the user left-clicked over.\nThese provide the 'context' of what should be displayed in the menu. This\ncan be an empty array in the case where they clicked in a open area within\nthe graphics window.")

MarkingMenuEventArgs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MarkingMenuEventArgs) else None
MarkingMenuEventArgs.cast = lambda arg: arg if isinstance(arg, MarkingMenuEventArgs) else None

class MouseEvent(Event):
    """An event endpoint that supports the connection to client implemented MouseEventHandlers."""
    __swig_setmethods__ = {}
    for _s in [Event]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MouseEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MouseEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::MouseEvent *" : return _core.MouseEvent___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.MouseEvent___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.MouseEvent___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.MouseEvent_classType
    if _newclass:classType = staticmethod(_core.MouseEvent_classType)
    __swig_destroy__ = _core.delete_MouseEvent
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Adds an event handler to this event endpoint. 
        handler : The client implemented MouseEventHandler to be called when this event is triggered. 
        Returns true if the handler was successfully added to the set of event handlers.
        """
        return _core.MouseEvent_add(self, *args)

    def remove(self, *args) -> "bool" :
        """
        Removes a handler from this event endpoint. 
        handler : A MouseEventhandler that was previously added to this event with the add method. 
        Returns true if the handler was found and removed from the set of event handlers.
        """
        return _core.MouseEvent_remove(self, *args)

    def _get_name(self) -> "std::string" :
        """The name of the event - e.g. 'DocumentOpening'"""
        return _core.MouseEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.MouseEvent__get_sender(self)

    def _get_objectType(self) -> "char const *" : return _core.MouseEvent__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.MouseEvent__get_isValid(self)
MouseEvent_swigregister = _core.MouseEvent_swigregister
MouseEvent_swigregister(MouseEvent)

def MouseEvent_classType() -> "char const *" :
  return _core.MouseEvent_classType()
MouseEvent_classType = _core.MouseEvent_classType

MouseEvent.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MouseEvent) else None
MouseEvent.cast = lambda arg: arg if isinstance(arg, MouseEvent) else None

class MouseEventArgs(EventArgs):
    """Provides a set of arguments from a firing MouseEvent to a MouseEventHandler's notify callback method."""
    __swig_setmethods__ = {}
    for _s in [EventArgs]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MouseEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MouseEventArgs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::MouseEventArgs *" : return _core.MouseEventArgs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.MouseEventArgs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.MouseEventArgs___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.MouseEventArgs_classType
    if _newclass:classType = staticmethod(_core.MouseEventArgs_classType)
    __swig_destroy__ = _core.delete_MouseEventArgs
    __del__ = lambda self : None;
    def _get_button(self) -> "adsk::core::MouseButtons" :
        """
        Gets which mouse button(s) are pressed. The returned value
        is bitwise and can indicate that more than one button is pressed.
        """
        return _core.MouseEventArgs__get_button(self)

    def _get_clicks(self) -> "size_t" :
        """Gets the number of times the button was pressed and released."""
        return _core.MouseEventArgs__get_clicks(self)

    def _get_wheelDelta(self) -> "int" :
        """Gets a signed count of the number of detents the mouse wheel has rotated."""
        return _core.MouseEventArgs__get_wheelDelta(self)

    def _get_keyboardModifiers(self) -> "adsk::core::KeyboardModifiers" :
        """
        Gets which modifier keys are currently pressed. The returned value
        is bitwise and can indicate that more than one button is pressed.
        """
        return _core.MouseEventArgs__get_keyboardModifiers(self)

    def _get_position(self) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """Gets the coordinate of the mouse in screen space."""
        return _core.MouseEventArgs__get_position(self)

    def _get_viewportPosition(self) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """
        Gets the coordinate of the mouse in viewport space, if the mouse is
        within a viewport. If the mouse is not over a viewport this property will return null.
        """
        return _core.MouseEventArgs__get_viewportPosition(self)

    def _get_viewport(self) -> "adsk::core::Ptr< adsk::core::Viewport >" :
        """
        Returns the viewport where the mouse event occurred, if it was within a viewport.
        If the mouse is not over a viewport this property will return null.
        """
        return _core.MouseEventArgs__get_viewport(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >" :
        """The event that the firing is in response to."""
        return _core.MouseEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *" : return _core.MouseEventArgs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.MouseEventArgs__get_isValid(self)
MouseEventArgs_swigregister = _core.MouseEventArgs_swigregister
MouseEventArgs_swigregister(MouseEventArgs)

def MouseEventArgs_classType() -> "char const *" :
  return _core.MouseEventArgs_classType()
MouseEventArgs_classType = _core.MouseEventArgs_classType

MouseEventArgs.__swig_getmethods__["button"] = MouseEventArgs._get_button
MouseEventArgs.button = property(MouseEventArgs._get_button, doc="Gets which mouse button(s) are pressed. The returned value\nis bitwise and can indicate that more than one button is pressed.")

MouseEventArgs.__swig_getmethods__["clicks"] = MouseEventArgs._get_clicks
MouseEventArgs.clicks = property(MouseEventArgs._get_clicks, doc="Gets the number of times the button was pressed and released.")

MouseEventArgs.__swig_getmethods__["wheelDelta"] = MouseEventArgs._get_wheelDelta
MouseEventArgs.wheelDelta = property(MouseEventArgs._get_wheelDelta, doc="Gets a signed count of the number of detents the mouse wheel has rotated.")

MouseEventArgs.__swig_getmethods__["keyboardModifiers"] = MouseEventArgs._get_keyboardModifiers
MouseEventArgs.keyboardModifiers = property(MouseEventArgs._get_keyboardModifiers, doc="Gets which modifier keys are currently pressed. The returned value\nis bitwise and can indicate that more than one button is pressed.")

MouseEventArgs.__swig_getmethods__["position"] = MouseEventArgs._get_position
MouseEventArgs.position = property(MouseEventArgs._get_position, doc="Gets the coordinate of the mouse in screen space.")

MouseEventArgs.__swig_getmethods__["viewportPosition"] = MouseEventArgs._get_viewportPosition
MouseEventArgs.viewportPosition = property(MouseEventArgs._get_viewportPosition, doc="Gets the coordinate of the mouse in viewport space, if the mouse is\nwithin a viewport. If the mouse is not over a viewport this property will return null.")

MouseEventArgs.__swig_getmethods__["viewport"] = MouseEventArgs._get_viewport
MouseEventArgs.viewport = property(MouseEventArgs._get_viewport, doc="Returns the viewport where the mouse event occurred, if it was within a viewport.\nIf the mouse is not over a viewport this property will return null.")

MouseEventArgs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MouseEventArgs) else None
MouseEventArgs.cast = lambda arg: arg if isinstance(arg, MouseEventArgs) else None

class NurbsCurve2D(Curve2D):
    """
    Transient 2D NURBS curve. A transient NURBS curve is not displayed or saved in a document.
    Transient 2D NURBS curves are used as a wrapper to work with raw 2D NURBS curve information.
    They are created statically using one of the create methods of the NurbsCurve2D class.
    """
    __swig_setmethods__ = {}
    for _s in [Curve2D]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NurbsCurve2D, name, value)
    __swig_getmethods__ = {}
    for _s in [Curve2D]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NurbsCurve2D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::NurbsCurve2D *" : return _core.NurbsCurve2D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.NurbsCurve2D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.NurbsCurve2D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.NurbsCurve2D_classType
    if _newclass:classType = staticmethod(_core.NurbsCurve2D_classType)
    __swig_getmethods__["createNonRational"] = lambda x: _core.NurbsCurve2D_createNonRational
    if _newclass:createNonRational = staticmethod(_core.NurbsCurve2D_createNonRational)
    __swig_getmethods__["createRational"] = lambda x: _core.NurbsCurve2D_createRational
    if _newclass:createRational = staticmethod(_core.NurbsCurve2D_createRational)
    __swig_destroy__ = _core.delete_NurbsCurve2D
    __del__ = lambda self : None;
    def _get_controlPointCount(self) -> "int" :
        """Gets the number of control points that define the curve"""
        return _core.NurbsCurve2D__get_controlPointCount(self)

    def copy(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve2D >" :
        """
        Creates and returns an independent copy of this NurbsCurve2D object. 
        Returns an independent copy of this NurbsCurve2D.
        """
        return _core.NurbsCurve2D_copy(self)

    def _get_degree(self) -> "int" :
        """Returns the degree of the curve"""
        return _core.NurbsCurve2D__get_degree(self)

    def _get_knotCount(self) -> "int" :
        """Returns the knot count of the curve"""
        return _core.NurbsCurve2D__get_knotCount(self)

    def _get_isRational(self) -> "bool" :
        """Indicates if the curve is rational or non-rational type"""
        return _core.NurbsCurve2D__get_isRational(self)

    def _get_isClosed(self) -> "bool" :
        """Indicates if the curve is closed"""
        return _core.NurbsCurve2D__get_isClosed(self)

    def _get_isPeriodic(self) -> "bool" :
        """Indicates if the curve is periodic."""
        return _core.NurbsCurve2D__get_isPeriodic(self)

    def _get_controlPoints(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D >,std::allocator< adsk::core::Ptr< adsk::core::Point2D > > >" :
        """Returns an array of Point2D objects that define the control points of the curve."""
        return _core.NurbsCurve2D__get_controlPoints(self)

    def _get_knots(self) -> "std::vector< double,std::allocator< double > >" :
        """Returns an array of numbers that define the Knots of the curve."""
        return _core.NurbsCurve2D__get_knots(self)

    def getData(self) -> "bool" :
        """
        Gets the data that defines a transient 2D NURBS rational b-spline object. 
        controlPoints : The output array of control point that define the path of the spline. 
        degree : The output degree of curvature of the spline. 
        knots : The output array of numbers that define the knots of the spline. 
        isRational : The output value indicating if the spline is rational. A rational spline will have a weight value
        for each control point. 
        weights : The output array of numbers that define the weights for the spline. 
        isPeriodic : The output value indicating if the spline is Periodic. A periodic curve has a start point and
        end point that meet (with curvature continuity) forming a closed loop. 
        Returns true if successful.
        """
        return _core.NurbsCurve2D_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets the data that defines a transient 2D NURBS rational b-spline object. 
        controlPoints : The array of control point that define the path of the spline 
        degree : The degree of curvature of the spline 
        knots : An array of numbers that define the knots of the spline. 
        isRational : A bool indicating if the spline is rational. A rational spline must have a weight value
        for each control point. 
        weights : An array of numbers that define the weights for the spline. 
        isPeriodic : A bool specifying if the spline is to be Periodic. A periodic curve has a start point and
        end point that meet (with curvature continuity) forming a closed loop. 
        Returns true if successful
        """
        return _core.NurbsCurve2D_set(self, *args)

    def extract(self, *args) -> "adsk::core::Ptr< adsk::core::NurbsCurve2D >" :
        """
        Defines a new nurbs curve that is the subset of this nurbs curve in the parameter 
        range of [startParam, endParam] 
        startParam : The parameter position of the start of the subset. 
        endParam : The parameter position of the end of the subset. 
        Returns a new NurbsCurve2D object.
        """
        return _core.NurbsCurve2D_extract(self, *args)

    def merge(self, *args) -> "adsk::core::Ptr< adsk::core::NurbsCurve2D >" :
        """
        Define a new nurbs curve that is the result of combining this nurbs curve with 
        another nurbs curve. 
        nurbsCurve : The nurbs curve to combine with 
        Returns a new NurbsCurve2D object.
        """
        return _core.NurbsCurve2D_merge(self, *args)

    def _get_curveType(self) -> "adsk::core::Curve2DTypes" :
        """Returns the type of geometry this curve represents."""
        return _core.NurbsCurve2D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator2D >" :
        """Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.NurbsCurve2D__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms this curve in 2D space. 
        matrix : A 2D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.NurbsCurve2D_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.NurbsCurve2D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.NurbsCurve2D__get_isValid(self)
NurbsCurve2D_swigregister = _core.NurbsCurve2D_swigregister
NurbsCurve2D_swigregister(NurbsCurve2D)

def NurbsCurve2D_classType() -> "char const *" :
  return _core.NurbsCurve2D_classType()
NurbsCurve2D_classType = _core.NurbsCurve2D_classType

def NurbsCurve2D_createNonRational(*args) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > > const &, std::vector< double > const &" :
  return _core.NurbsCurve2D_createNonRational(*args)
NurbsCurve2D_createNonRational = _core.NurbsCurve2D_createNonRational

def NurbsCurve2D_createRational(*args) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D > > const &, std::vector< double > const &, std::vector< double > const &" :
  return _core.NurbsCurve2D_createRational(*args)
NurbsCurve2D_createRational = _core.NurbsCurve2D_createRational

NurbsCurve2D.__swig_getmethods__["controlPointCount"] = NurbsCurve2D._get_controlPointCount
NurbsCurve2D.controlPointCount = property(NurbsCurve2D._get_controlPointCount, doc="Gets the number of control points that define the curve")

NurbsCurve2D.__swig_getmethods__["degree"] = NurbsCurve2D._get_degree
NurbsCurve2D.degree = property(NurbsCurve2D._get_degree, doc="Returns the degree of the curve")

NurbsCurve2D.__swig_getmethods__["knotCount"] = NurbsCurve2D._get_knotCount
NurbsCurve2D.knotCount = property(NurbsCurve2D._get_knotCount, doc="Returns the knot count of the curve")

NurbsCurve2D.__swig_getmethods__["isRational"] = NurbsCurve2D._get_isRational
NurbsCurve2D.isRational = property(NurbsCurve2D._get_isRational, doc="Indicates if the curve is rational or non-rational type")

NurbsCurve2D.__swig_getmethods__["isClosed"] = NurbsCurve2D._get_isClosed
NurbsCurve2D.isClosed = property(NurbsCurve2D._get_isClosed, doc="Indicates if the curve is closed")

NurbsCurve2D.__swig_getmethods__["isPeriodic"] = NurbsCurve2D._get_isPeriodic
NurbsCurve2D.isPeriodic = property(NurbsCurve2D._get_isPeriodic, doc="Indicates if the curve is periodic.")

NurbsCurve2D.__swig_getmethods__["controlPoints"] = NurbsCurve2D._get_controlPoints
NurbsCurve2D.controlPoints = property(NurbsCurve2D._get_controlPoints, doc="Returns an array of Point2D objects that define the control points of the curve.")

NurbsCurve2D.__swig_getmethods__["knots"] = NurbsCurve2D._get_knots
NurbsCurve2D.knots = property(NurbsCurve2D._get_knots, doc="Returns an array of numbers that define the Knots of the curve.")

NurbsCurve2D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, NurbsCurve2D) else None
NurbsCurve2D.cast = lambda arg: arg if isinstance(arg, NurbsCurve2D) else None

class NurbsCurve3D(Curve3D):
    """
    Transient 3D NURBS curve. A transient NURBS curve is not displayed or saved in a document.
    Transient 3D NURBS curves are used as a wrapper to work with raw 3D NURBS curve information.
    They are created statically using one of the create methods of the NurbsCurve3D class.
    """
    __swig_setmethods__ = {}
    for _s in [Curve3D]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NurbsCurve3D, name, value)
    __swig_getmethods__ = {}
    for _s in [Curve3D]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NurbsCurve3D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::NurbsCurve3D *" : return _core.NurbsCurve3D___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.NurbsCurve3D___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.NurbsCurve3D___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.NurbsCurve3D_classType
    if _newclass:classType = staticmethod(_core.NurbsCurve3D_classType)
    __swig_getmethods__["createNonRational"] = lambda x: _core.NurbsCurve3D_createNonRational
    if _newclass:createNonRational = staticmethod(_core.NurbsCurve3D_createNonRational)
    __swig_getmethods__["createRational"] = lambda x: _core.NurbsCurve3D_createRational
    if _newclass:createRational = staticmethod(_core.NurbsCurve3D_createRational)
    __swig_destroy__ = _core.delete_NurbsCurve3D
    __del__ = lambda self : None;
    def _get_controlPointCount(self) -> "int" :
        """Gets the number of control points that define the curve."""
        return _core.NurbsCurve3D__get_controlPointCount(self)

    def _get_degree(self) -> "int" :
        """Returns the degree of the curve."""
        return _core.NurbsCurve3D__get_degree(self)

    def _get_knotCount(self) -> "int" :
        """Returns the knot count of the curve."""
        return _core.NurbsCurve3D__get_knotCount(self)

    def _get_isRational(self) -> "bool" :
        """Indicates if the curve is rational or non-rational type."""
        return _core.NurbsCurve3D__get_isRational(self)

    def _get_isClosed(self) -> "bool" :
        """Indicates if the curve is closed."""
        return _core.NurbsCurve3D__get_isClosed(self)

    def _get_isPeriodic(self) -> "bool" :
        """Indicates if the curve is periodic."""
        return _core.NurbsCurve3D__get_isPeriodic(self)

    def _get_controlPoints(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D >,std::allocator< adsk::core::Ptr< adsk::core::Point3D > > >" :
        """Returns an array of Point3D objects that define the control points of the curve."""
        return _core.NurbsCurve3D__get_controlPoints(self)

    def _get_knots(self) -> "std::vector< double,std::allocator< double > >" :
        """Returns an array of numbers that define the knot vector of the curve."""
        return _core.NurbsCurve3D__get_knots(self)

    def getData(self) -> "bool" :
        """
        Gets the data that defines a transient 3D NURBS rational b-spline object. 
        controlPoints : The output array of control point that define the path of the spline. 
        degree : The output degree of curvature of the spline. 
        knots : The output array of numbers that define the knot vector of the spline. 
        isRational : The output value indicating if the spline is rational. A rational spline will have a weight value
        for each control point. 
        weights : The output array of numbers that define the weights for the spline. 
        isPeriodic : The output value indicating if the spline is Periodic. A periodic curve has a start point and
        end point that meet (with curvature continuity) forming a closed loop. 
        Returns true if successful.
        """
        return _core.NurbsCurve3D_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets the data that defines a transient 3D NURBS rational b-spline object. 
        controlPoints : The array of control point that define the path of the spline. 
        degree : The degree of curvature of the spline. 
        knots : An array of numbers that define the knot vector of the spline. 
        isRational : A bool value indicating if the spline is rational. A rational spline must have a weight value
        for each control point. 
        weights : An array of numbers that define the weights for the spline. 
        isPeriodic : A bool indicating if the spline is Periodic. A periodic curve has a start point and
        end point that meet (with curvature continuity) forming a closed loop. 
        Returns true if successful.
        """
        return _core.NurbsCurve3D_set(self, *args)

    def extract(self, *args) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >" :
        """
        Defines a new nurbs curve that is the subset of this nurbs curve in the parameter 
        range of [startParam, endParam] 
        startParam : The parameter position that defines the start of the subset. 
        endParam : The parameter position that defines the end of the subset. 
        Returns a new NurbsCurve3D object.
        """
        return _core.NurbsCurve3D_extract(self, *args)

    def merge(self, *args) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >" :
        """
        Define a new nurbs curve that is the result of combining this nurbs curve with 
        another nurbs curve. 
        nurbsCurve : The nurbs curve to combine with. 
        Returns a new NurbsCurve3D object.
        """
        return _core.NurbsCurve3D_merge(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >" :
        """
        Creates and returns an independent copy of this NurbsCurve3D object. 
        Returns an independent copy of this NurbsCurve3D.
        """
        return _core.NurbsCurve3D_copy(self)

    def _get_curveType(self) -> "adsk::core::Curve3DTypes" :
        """Returns the type of geometry this curve represents."""
        return _core.NurbsCurve3D__get_curveType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >" :
        """Returns an evaluator object that lets you perform additional evaluations on the curve."""
        return _core.NurbsCurve3D__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Transforms this curve in 3D space. 
        matrix : A 3D matrix that defines the transform to apply to the curve. 
        Return true if the transform was successful.
        """
        return _core.NurbsCurve3D_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.NurbsCurve3D__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.NurbsCurve3D__get_isValid(self)
NurbsCurve3D_swigregister = _core.NurbsCurve3D_swigregister
NurbsCurve3D_swigregister(NurbsCurve3D)

def NurbsCurve3D_classType() -> "char const *" :
  return _core.NurbsCurve3D_classType()
NurbsCurve3D_classType = _core.NurbsCurve3D_classType

def NurbsCurve3D_createNonRational(*args) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > > const &, std::vector< double > const &" :
  return _core.NurbsCurve3D_createNonRational(*args)
NurbsCurve3D_createNonRational = _core.NurbsCurve3D_createNonRational

def NurbsCurve3D_createRational(*args) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > > const &, std::vector< double > const &, std::vector< double > const &" :
  return _core.NurbsCurve3D_createRational(*args)
NurbsCurve3D_createRational = _core.NurbsCurve3D_createRational

NurbsCurve3D.__swig_getmethods__["controlPointCount"] = NurbsCurve3D._get_controlPointCount
NurbsCurve3D.controlPointCount = property(NurbsCurve3D._get_controlPointCount, doc="Gets the number of control points that define the curve.")

NurbsCurve3D.__swig_getmethods__["degree"] = NurbsCurve3D._get_degree
NurbsCurve3D.degree = property(NurbsCurve3D._get_degree, doc="Returns the degree of the curve.")

NurbsCurve3D.__swig_getmethods__["knotCount"] = NurbsCurve3D._get_knotCount
NurbsCurve3D.knotCount = property(NurbsCurve3D._get_knotCount, doc="Returns the knot count of the curve.")

NurbsCurve3D.__swig_getmethods__["isRational"] = NurbsCurve3D._get_isRational
NurbsCurve3D.isRational = property(NurbsCurve3D._get_isRational, doc="Indicates if the curve is rational or non-rational type.")

NurbsCurve3D.__swig_getmethods__["isClosed"] = NurbsCurve3D._get_isClosed
NurbsCurve3D.isClosed = property(NurbsCurve3D._get_isClosed, doc="Indicates if the curve is closed.")

NurbsCurve3D.__swig_getmethods__["isPeriodic"] = NurbsCurve3D._get_isPeriodic
NurbsCurve3D.isPeriodic = property(NurbsCurve3D._get_isPeriodic, doc="Indicates if the curve is periodic.")

NurbsCurve3D.__swig_getmethods__["controlPoints"] = NurbsCurve3D._get_controlPoints
NurbsCurve3D.controlPoints = property(NurbsCurve3D._get_controlPoints, doc="Returns an array of Point3D objects that define the control points of the curve.")

NurbsCurve3D.__swig_getmethods__["knots"] = NurbsCurve3D._get_knots
NurbsCurve3D.knots = property(NurbsCurve3D._get_knots, doc="Returns an array of numbers that define the knot vector of the curve.")

NurbsCurve3D.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, NurbsCurve3D) else None
NurbsCurve3D.cast = lambda arg: arg if isinstance(arg, NurbsCurve3D) else None

class NurbsSurface(Surface):
    """
    Transient NURBS surface. A transient NURBS surface is not displayed or saved in a document.
    A transient NURBS surface is used as a wrapper to work with raw NURBS surface information. 
    A transient NURBS surface is bounded by it's natural boundaries and does not support the 
    definition of arbitrary boundaries. 
    A NURBS surface is typically obtained from a BREPFace object, which does have boundary information.
    They are created statically using the create method of the NurbsSurface class.
    """
    __swig_setmethods__ = {}
    for _s in [Surface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NurbsSurface, name, value)
    __swig_getmethods__ = {}
    for _s in [Surface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NurbsSurface, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::NurbsSurface *" : return _core.NurbsSurface___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.NurbsSurface___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.NurbsSurface___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.NurbsSurface_classType
    if _newclass:classType = staticmethod(_core.NurbsSurface_classType)
    __swig_getmethods__["create"] = lambda x: _core.NurbsSurface_create
    if _newclass:create = staticmethod(_core.NurbsSurface_create)
    __swig_destroy__ = _core.delete_NurbsSurface
    __del__ = lambda self : None;
    def _get_controlPointCountU(self) -> "int" :
        """Gets the number of control points in the U direction."""
        return _core.NurbsSurface__get_controlPointCountU(self)

    def _get_controlPointCountV(self) -> "int" :
        """Gets the number of control points in the V direction."""
        return _core.NurbsSurface__get_controlPointCountV(self)

    def _get_degreeU(self) -> "int" :
        """Gets the degree in the U direction."""
        return _core.NurbsSurface__get_degreeU(self)

    def _get_degreeV(self) -> "int" :
        """Gets the degree in the V direction."""
        return _core.NurbsSurface__get_degreeV(self)

    def _get_knotCountU(self) -> "int" :
        """Gets the knot count in the U direction."""
        return _core.NurbsSurface__get_knotCountU(self)

    def _get_knotCountV(self) -> "int" :
        """Gets thekKnot count in the V direction."""
        return _core.NurbsSurface__get_knotCountV(self)

    def _get_propertiesU(self) -> "adsk::core::NurbsSurfaceProperties" :
        """Gets the properties (NurbsSurfaceProperties) of the surface in the U direction."""
        return _core.NurbsSurface__get_propertiesU(self)

    def _get_propertiesV(self) -> "adsk::core::NurbsSurfaceProperties" :
        """Gets the properties (NurbsSurfaceProperties) of the surface in the V direction."""
        return _core.NurbsSurface__get_propertiesV(self)

    def _get_controlPoints(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D >,std::allocator< adsk::core::Ptr< adsk::core::Point3D > > >" :
        """Gets an array of control points from the surface."""
        return _core.NurbsSurface__get_controlPoints(self)

    def _get_knotsU(self) -> "std::vector< double,std::allocator< double > >" :
        """Get the knot vector from the U direction."""
        return _core.NurbsSurface__get_knotsU(self)

    def _get_knotsV(self) -> "std::vector< double,std::allocator< double > >" :
        """Get the knot vector from the V direction"""
        return _core.NurbsSurface__get_knotsV(self)

    def getData(self) -> "bool" :
        """
        Gets the data that defines the NURBS surface. 
        degreeU : The output degree in the U direction. 
        degreeV : The output degree in the V direction. 
        controlPointCountU : The output number of control points in the U direction. 
        controlPointCountV : The output number of control points in the V direction. 
        controlPoints : An output array of surface control points. 
        knotsU : The output knot vector for the U direction. 
        knotsV : The output knot vector for the V direction. 
        weights : An output array of weights that corresponds to the control points of the surface. 
        propertiesU : The output properties (NurbsSurfaceProperties) of the surface in the U direction. 
        propertiesV : The output properties (NurbsSurfaceProperties) of the surface in the V direction. 
        Returns true if successful.
        """
        return _core.NurbsSurface_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets the data that defines the NURBS surface. 
        degreeU : The degree in the U direction. 
        degreeV : The degree in the V direction. 
        controlPointCountU : The number of control points in the U direction. 
        controlPointCountV : The number of control points in the V direction. 
        controlPoints : An array of surface control points. 
        knotsU : The knot vector for the U direction. 
        knotsV : The knot vector for the V direction. 
        weights : An array of weights that corresponds to the control points of the surface. 
        propertiesU : The properties (NurbsSurfaceProperties) of the surface in the U direction. 
        propertiesV : The properties (NurbsSurfaceProperties) of the surface in the V direction. 
        Returns true if successful
        """
        return _core.NurbsSurface_set(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::NurbsSurface >" :
        """
        Creates and returns an independent copy of this NurbsSurface object. 
        Returns a new NurbsSurface object that is a copy of this NurbsSurface object.
        """
        return _core.NurbsSurface_copy(self)

    def _get_surfaceType(self) -> "adsk::core::SurfaceTypes" :
        """Returns the surface type."""
        return _core.NurbsSurface__get_surfaceType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >" :
        """Returns the surface evaluator."""
        return _core.NurbsSurface__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Updates this surface by transforming it with a given input matrix. 
        matrix : A 3D matrix that defines the transform to apply to the surface. 
        Returns true if the transform was successful.
        """
        return _core.NurbsSurface_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.NurbsSurface__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.NurbsSurface__get_isValid(self)
NurbsSurface_swigregister = _core.NurbsSurface_swigregister
NurbsSurface_swigregister(NurbsSurface)

def NurbsSurface_classType() -> "char const *" :
  return _core.NurbsSurface_classType()
NurbsSurface_classType = _core.NurbsSurface_classType

def NurbsSurface_create(*args) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D > > const &, std::vector< double > const &, std::vector< double > const &, std::vector< double > const &" :
  return _core.NurbsSurface_create(*args)
NurbsSurface_create = _core.NurbsSurface_create

NurbsSurface.__swig_getmethods__["controlPointCountU"] = NurbsSurface._get_controlPointCountU
NurbsSurface.controlPointCountU = property(NurbsSurface._get_controlPointCountU, doc="Gets the number of control points in the U direction.")

NurbsSurface.__swig_getmethods__["controlPointCountV"] = NurbsSurface._get_controlPointCountV
NurbsSurface.controlPointCountV = property(NurbsSurface._get_controlPointCountV, doc="Gets the number of control points in the V direction.")

NurbsSurface.__swig_getmethods__["degreeU"] = NurbsSurface._get_degreeU
NurbsSurface.degreeU = property(NurbsSurface._get_degreeU, doc="Gets the degree in the U direction.")

NurbsSurface.__swig_getmethods__["degreeV"] = NurbsSurface._get_degreeV
NurbsSurface.degreeV = property(NurbsSurface._get_degreeV, doc="Gets the degree in the V direction.")

NurbsSurface.__swig_getmethods__["knotCountU"] = NurbsSurface._get_knotCountU
NurbsSurface.knotCountU = property(NurbsSurface._get_knotCountU, doc="Gets the knot count in the U direction.")

NurbsSurface.__swig_getmethods__["knotCountV"] = NurbsSurface._get_knotCountV
NurbsSurface.knotCountV = property(NurbsSurface._get_knotCountV, doc="Gets thekKnot count in the V direction.")

NurbsSurface.__swig_getmethods__["propertiesU"] = NurbsSurface._get_propertiesU
NurbsSurface.propertiesU = property(NurbsSurface._get_propertiesU, doc="Gets the properties (NurbsSurfaceProperties) of the surface in the U direction.")

NurbsSurface.__swig_getmethods__["propertiesV"] = NurbsSurface._get_propertiesV
NurbsSurface.propertiesV = property(NurbsSurface._get_propertiesV, doc="Gets the properties (NurbsSurfaceProperties) of the surface in the V direction.")

NurbsSurface.__swig_getmethods__["controlPoints"] = NurbsSurface._get_controlPoints
NurbsSurface.controlPoints = property(NurbsSurface._get_controlPoints, doc="Gets an array of control points from the surface.")

NurbsSurface.__swig_getmethods__["knotsU"] = NurbsSurface._get_knotsU
NurbsSurface.knotsU = property(NurbsSurface._get_knotsU, doc="Get the knot vector from the U direction.")

NurbsSurface.__swig_getmethods__["knotsV"] = NurbsSurface._get_knotsV
NurbsSurface.knotsV = property(NurbsSurface._get_knotsV, doc="Get the knot vector from the V direction")

NurbsSurface.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, NurbsSurface) else None
NurbsSurface.cast = lambda arg: arg if isinstance(arg, NurbsSurface) else None

class Plane(Surface):
    """
    Transient plane. A transient plane is not displayed or saved in a document.
    Transient planes are used as a wrapper to work with raw plane information. 
    A transient plane has no boundaries or size, but is infinite and is represented 
    by a position, a normal, and an orientation in space.
    They are created statically using the create method of the Plane class.
    """
    __swig_setmethods__ = {}
    for _s in [Surface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Plane, name, value)
    __swig_getmethods__ = {}
    for _s in [Surface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Plane, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Plane *" : return _core.Plane___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Plane___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Plane___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Plane_classType
    if _newclass:classType = staticmethod(_core.Plane_classType)
    __swig_getmethods__["create"] = lambda x: _core.Plane_create
    if _newclass:create = staticmethod(_core.Plane_create)
    __swig_getmethods__["createUsingDirections"] = lambda x: _core.Plane_createUsingDirections
    if _newclass:createUsingDirections = staticmethod(_core.Plane_createUsingDirections)
    __swig_destroy__ = _core.delete_Plane
    __del__ = lambda self : None;
    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets the origin point of the plane."""
        return _core.Plane__get_origin(self)

    def _set_origin(self, *args) -> "bool" :
        """Gets and sets the origin point of the plane."""
        return _core.Plane__set_origin(self, *args)

    def _get_normal(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Gets and sets the normal of the plane."""
        return _core.Plane__get_normal(self)

    def _set_normal(self, *args) -> "bool" :
        """Gets and sets the normal of the plane."""
        return _core.Plane__set_normal(self, *args)

    def _get_uDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Gets the U Direction of the plane."""
        return _core.Plane__get_uDirection(self)

    def _get_vDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Gets the V Direction of the plane."""
        return _core.Plane__get_vDirection(self)

    def setUVDirections(self, *args) -> "bool" :
        """
        Sets the U and V directions of the plane. 
        uDirection : The U direction for the plane. 
        vDirection : The V direction for the plane. 
        Returns true if successful.
        """
        return _core.Plane_setUVDirections(self, *args)

    def isParallelToPlane(self, *args) -> "bool" :
        """
        Checks if this plane is parallel to another plane. 
        plane : The plane to compare with for parallelism. 
        Returns true if the planes are parallel.
        """
        return _core.Plane_isParallelToPlane(self, *args)

    def isParallelToLine(self, *args) -> "bool" :
        """
        Checks if this plane is parallel to a line. 
        line : The line to compare with for parallelism. 
        Returns true if the plane and line are parallel.
        """
        return _core.Plane_isParallelToLine(self, *args)

    def isPerpendicularToPlane(self, *args) -> "bool" :
        """
        Checks if this plane is perpendicular to another plane. 
        plane : The plane to compare with for perpendicularity. 
        Returns true if the planes are perpendicular.
        """
        return _core.Plane_isPerpendicularToPlane(self, *args)

    def isPerpendicularToLine(self, *args) -> "bool" :
        """
        Checks if this plane is perpendicular to a line. 
        line : The line to compare with for perpendicularity. 
        Returns true if the plane and line are perpendicular.
        """
        return _core.Plane_isPerpendicularToLine(self, *args)

    def isCoPlanarTo(self, *args) -> "bool" :
        """
        Checks if this plane is coplanar with another plane. 
        plane : The plane to compare with for coplanarity. 
        Returns true if the planes are coplanar.
        """
        return _core.Plane_isCoPlanarTo(self, *args)

    def intersectWithPlane(self, *args) -> "adsk::core::Ptr< adsk::core::InfiniteLine3D >" :
        """
        Creates an infinite line at the intersection of this plane with another plane. 
        plane : The plane to intersect with. 
        Returns an InfiniteLine3D object or null if the planes do not intersect (are parallel).
        """
        return _core.Plane_intersectWithPlane(self, *args)

    def intersectWithLine(self, *args) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        Creates a 3D point at the intersection of this plane and a line. 
        line : The line to intersect with. 
        Returns a Point3D object or null if the plane and line do not intersect (are parallel).
        """
        return _core.Plane_intersectWithLine(self, *args)

    def intersectWithCurve(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Intersect this plane with a curve to get the intersection point(s). 
        curve : The intersecting curve.
        The curve can be a Line3D, InfininteLine3D, Circle3D, Arc3D, EllipticalArc3D, Ellipse3D, 
        or NurbsCurve3D. 
        Returns a collection of the intersection points.
        """
        return _core.Plane_intersectWithCurve(self, *args)

    def intersectWithSurface(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Intersect this plane with a surface to get the intersection point(s). 
        surface : The intersecting surface.
        The surface can be a Plane, Cone, Cylinder, EllipticalCone, EllipticalCylinder, Sphere, 
        Torus, or a NurbsSurface. 
        Returns a collection of the intersection points.
        """
        return _core.Plane_intersectWithSurface(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Plane >" :
        """
        Creates and returns an independent copy of this Plane object. 
        Returns a new Plane object that is a copy of this Plane object.
        """
        return _core.Plane_copy(self)

    def _get_surfaceType(self) -> "adsk::core::SurfaceTypes" :
        """Returns the surface type."""
        return _core.Plane__get_surfaceType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >" :
        """Returns the surface evaluator."""
        return _core.Plane__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Updates this surface by transforming it with a given input matrix. 
        matrix : A 3D matrix that defines the transform to apply to the surface. 
        Returns true if the transform was successful.
        """
        return _core.Plane_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Plane__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Plane__get_isValid(self)
Plane_swigregister = _core.Plane_swigregister
Plane_swigregister(Plane)

def Plane_classType() -> "char const *" :
  return _core.Plane_classType()
Plane_classType = _core.Plane_classType

def Plane_create(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &" :
  return _core.Plane_create(*args)
Plane_create = _core.Plane_create

def Plane_createUsingDirections(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &" :
  return _core.Plane_createUsingDirections(*args)
Plane_createUsingDirections = _core.Plane_createUsingDirections

Plane.__swig_getmethods__["origin"] = Plane._get_origin
Plane.__swig_setmethods__["origin"] = Plane._set_origin
Plane.origin = property(Plane._get_origin, Plane._set_origin, doc="Gets and sets the origin point of the plane.")

Plane.__swig_getmethods__["normal"] = Plane._get_normal
Plane.__swig_setmethods__["normal"] = Plane._set_normal
Plane.normal = property(Plane._get_normal, Plane._set_normal, doc="Gets and sets the normal of the plane.")

Plane.__swig_getmethods__["uDirection"] = Plane._get_uDirection
Plane.uDirection = property(Plane._get_uDirection, doc="Gets the U Direction of the plane.")

Plane.__swig_getmethods__["vDirection"] = Plane._get_vDirection
Plane.vDirection = property(Plane._get_vDirection, doc="Gets the V Direction of the plane.")

Plane.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Plane) else None
Plane.cast = lambda arg: arg if isinstance(arg, Plane) else None

class RadioButtonGroupCommandInput(CommandInput):
    """Provides a command input to get the choice from a radio button group from the user."""
    __swig_setmethods__ = {}
    for _s in [CommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadioButtonGroupCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [CommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RadioButtonGroupCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::RadioButtonGroupCommandInput *" : return _core.RadioButtonGroupCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.RadioButtonGroupCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.RadioButtonGroupCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.RadioButtonGroupCommandInput_classType
    if _newclass:classType = staticmethod(_core.RadioButtonGroupCommandInput_classType)
    __swig_destroy__ = _core.delete_RadioButtonGroupCommandInput
    __del__ = lambda self : None;
    def _get_listItems(self) -> "adsk::core::Ptr< adsk::core::ListItems >" :
        """
        Returns the ListItems object associated with this radio button group. You use this
        object to populate and interact with the items in the radio button group.
        """
        return _core.RadioButtonGroupCommandInput__get_listItems(self)

    def _get_selectedItem(self) -> "adsk::core::Ptr< adsk::core::ListItem >" :
        """Gets and sets the item in the radio button list that is currently selected."""
        return _core.RadioButtonGroupCommandInput__get_selectedItem(self)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.RadioButtonGroupCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.RadioButtonGroupCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.RadioButtonGroupCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.RadioButtonGroupCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.RadioButtonGroupCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.RadioButtonGroupCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.RadioButtonGroupCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.RadioButtonGroupCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.RadioButtonGroupCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.RadioButtonGroupCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.RadioButtonGroupCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.RadioButtonGroupCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.RadioButtonGroupCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.RadioButtonGroupCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.RadioButtonGroupCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.RadioButtonGroupCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.RadioButtonGroupCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.RadioButtonGroupCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.RadioButtonGroupCommandInput__get_isValid(self)
RadioButtonGroupCommandInput_swigregister = _core.RadioButtonGroupCommandInput_swigregister
RadioButtonGroupCommandInput_swigregister(RadioButtonGroupCommandInput)

def RadioButtonGroupCommandInput_classType() -> "char const *" :
  return _core.RadioButtonGroupCommandInput_classType()
RadioButtonGroupCommandInput_classType = _core.RadioButtonGroupCommandInput_classType

RadioButtonGroupCommandInput.__swig_getmethods__["listItems"] = RadioButtonGroupCommandInput._get_listItems
RadioButtonGroupCommandInput.listItems = property(RadioButtonGroupCommandInput._get_listItems, doc="Returns the ListItems object associated with this radio button group. You use this\nobject to populate and interact with the items in the radio button group.")

RadioButtonGroupCommandInput.__swig_getmethods__["selectedItem"] = RadioButtonGroupCommandInput._get_selectedItem
RadioButtonGroupCommandInput.selectedItem = property(RadioButtonGroupCommandInput._get_selectedItem, doc="Gets and sets the item in the radio button list that is currently selected.")

RadioButtonGroupCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RadioButtonGroupCommandInput) else None
RadioButtonGroupCommandInput.cast = lambda arg: arg if isinstance(arg, RadioButtonGroupCommandInput) else None

class SATImportOptions(ImportOptions):
    """Defines that a SAT import is to be done and specifies the various options."""
    __swig_setmethods__ = {}
    for _s in [ImportOptions]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SATImportOptions, name, value)
    __swig_getmethods__ = {}
    for _s in [ImportOptions]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SATImportOptions, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::SATImportOptions *" : return _core.SATImportOptions___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.SATImportOptions___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.SATImportOptions___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.SATImportOptions_classType
    if _newclass:classType = staticmethod(_core.SATImportOptions_classType)
    __swig_destroy__ = _core.delete_SATImportOptions
    __del__ = lambda self : None;
    def _get_filename(self) -> "std::string" :
        """Gets and sets the filename or url of the file to be imported."""
        return _core.SATImportOptions__get_filename(self)

    def _set_filename(self, *args) -> "bool" :
        """Gets and sets the filename or url of the file to be imported."""
        return _core.SATImportOptions__set_filename(self, *args)

    def _get_isViewFit(self) -> "bool" :
        """
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.SATImportOptions__get_isViewFit(self)

    def _set_isViewFit(self, *args) -> "bool" :
        """
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.SATImportOptions__set_isViewFit(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.SATImportOptions__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.SATImportOptions__get_isValid(self)
SATImportOptions_swigregister = _core.SATImportOptions_swigregister
SATImportOptions_swigregister(SATImportOptions)

def SATImportOptions_classType() -> "char const *" :
  return _core.SATImportOptions_classType()
SATImportOptions_classType = _core.SATImportOptions_classType

SATImportOptions.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SATImportOptions) else None
SATImportOptions.cast = lambda arg: arg if isinstance(arg, SATImportOptions) else None


def _get_adsk_core_SelectionCommandInput_Bodies() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_Bodies()
_get_adsk_core_SelectionCommandInput_Bodies = _core._get_adsk_core_SelectionCommandInput_Bodies

def _get_adsk_core_SelectionCommandInput_SolidBodies() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_SolidBodies()
_get_adsk_core_SelectionCommandInput_SolidBodies = _core._get_adsk_core_SelectionCommandInput_SolidBodies

def _get_adsk_core_SelectionCommandInput_SurfaceBodies() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_SurfaceBodies()
_get_adsk_core_SelectionCommandInput_SurfaceBodies = _core._get_adsk_core_SelectionCommandInput_SurfaceBodies

def _get_adsk_core_SelectionCommandInput_MeshBodies() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_MeshBodies()
_get_adsk_core_SelectionCommandInput_MeshBodies = _core._get_adsk_core_SelectionCommandInput_MeshBodies

def _get_adsk_core_SelectionCommandInput_Faces() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_Faces()
_get_adsk_core_SelectionCommandInput_Faces = _core._get_adsk_core_SelectionCommandInput_Faces

def _get_adsk_core_SelectionCommandInput_SolidFaces() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_SolidFaces()
_get_adsk_core_SelectionCommandInput_SolidFaces = _core._get_adsk_core_SelectionCommandInput_SolidFaces

def _get_adsk_core_SelectionCommandInput_SurfaceFaces() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_SurfaceFaces()
_get_adsk_core_SelectionCommandInput_SurfaceFaces = _core._get_adsk_core_SelectionCommandInput_SurfaceFaces

def _get_adsk_core_SelectionCommandInput_PlanarFaces() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_PlanarFaces()
_get_adsk_core_SelectionCommandInput_PlanarFaces = _core._get_adsk_core_SelectionCommandInput_PlanarFaces

def _get_adsk_core_SelectionCommandInput_CylindricalFaces() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_CylindricalFaces()
_get_adsk_core_SelectionCommandInput_CylindricalFaces = _core._get_adsk_core_SelectionCommandInput_CylindricalFaces

def _get_adsk_core_SelectionCommandInput_ConicalFaces() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_ConicalFaces()
_get_adsk_core_SelectionCommandInput_ConicalFaces = _core._get_adsk_core_SelectionCommandInput_ConicalFaces

def _get_adsk_core_SelectionCommandInput_SphericalFaces() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_SphericalFaces()
_get_adsk_core_SelectionCommandInput_SphericalFaces = _core._get_adsk_core_SelectionCommandInput_SphericalFaces

def _get_adsk_core_SelectionCommandInput_ToroidalFaces() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_ToroidalFaces()
_get_adsk_core_SelectionCommandInput_ToroidalFaces = _core._get_adsk_core_SelectionCommandInput_ToroidalFaces

def _get_adsk_core_SelectionCommandInput_SplineFaces() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_SplineFaces()
_get_adsk_core_SelectionCommandInput_SplineFaces = _core._get_adsk_core_SelectionCommandInput_SplineFaces

def _get_adsk_core_SelectionCommandInput_Edges() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_Edges()
_get_adsk_core_SelectionCommandInput_Edges = _core._get_adsk_core_SelectionCommandInput_Edges

def _get_adsk_core_SelectionCommandInput_LinearEdges() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_LinearEdges()
_get_adsk_core_SelectionCommandInput_LinearEdges = _core._get_adsk_core_SelectionCommandInput_LinearEdges

def _get_adsk_core_SelectionCommandInput_CircularEdges() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_CircularEdges()
_get_adsk_core_SelectionCommandInput_CircularEdges = _core._get_adsk_core_SelectionCommandInput_CircularEdges

def _get_adsk_core_SelectionCommandInput_EllipticalEdges() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_EllipticalEdges()
_get_adsk_core_SelectionCommandInput_EllipticalEdges = _core._get_adsk_core_SelectionCommandInput_EllipticalEdges

def _get_adsk_core_SelectionCommandInput_TangentEdges() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_TangentEdges()
_get_adsk_core_SelectionCommandInput_TangentEdges = _core._get_adsk_core_SelectionCommandInput_TangentEdges

def _get_adsk_core_SelectionCommandInput_NonTangentEdges() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_NonTangentEdges()
_get_adsk_core_SelectionCommandInput_NonTangentEdges = _core._get_adsk_core_SelectionCommandInput_NonTangentEdges

def _get_adsk_core_SelectionCommandInput_Vertices() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_Vertices()
_get_adsk_core_SelectionCommandInput_Vertices = _core._get_adsk_core_SelectionCommandInput_Vertices

def _get_adsk_core_SelectionCommandInput_RootComponents() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_RootComponents()
_get_adsk_core_SelectionCommandInput_RootComponents = _core._get_adsk_core_SelectionCommandInput_RootComponents

def _get_adsk_core_SelectionCommandInput_Occurrences() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_Occurrences()
_get_adsk_core_SelectionCommandInput_Occurrences = _core._get_adsk_core_SelectionCommandInput_Occurrences

def _get_adsk_core_SelectionCommandInput_Sketches() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_Sketches()
_get_adsk_core_SelectionCommandInput_Sketches = _core._get_adsk_core_SelectionCommandInput_Sketches

def _get_adsk_core_SelectionCommandInput_SketchCurves() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_SketchCurves()
_get_adsk_core_SelectionCommandInput_SketchCurves = _core._get_adsk_core_SelectionCommandInput_SketchCurves

def _get_adsk_core_SelectionCommandInput_SketchLines() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_SketchLines()
_get_adsk_core_SelectionCommandInput_SketchLines = _core._get_adsk_core_SelectionCommandInput_SketchLines

def _get_adsk_core_SelectionCommandInput_SketchCircles() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_SketchCircles()
_get_adsk_core_SelectionCommandInput_SketchCircles = _core._get_adsk_core_SelectionCommandInput_SketchCircles

def _get_adsk_core_SelectionCommandInput_SketchPoints() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_SketchPoints()
_get_adsk_core_SelectionCommandInput_SketchPoints = _core._get_adsk_core_SelectionCommandInput_SketchPoints

def _get_adsk_core_SelectionCommandInput_ConstructionPoints() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_ConstructionPoints()
_get_adsk_core_SelectionCommandInput_ConstructionPoints = _core._get_adsk_core_SelectionCommandInput_ConstructionPoints

def _get_adsk_core_SelectionCommandInput_ConstructionLines() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_ConstructionLines()
_get_adsk_core_SelectionCommandInput_ConstructionLines = _core._get_adsk_core_SelectionCommandInput_ConstructionLines

def _get_adsk_core_SelectionCommandInput_ConstructionPlanes() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_ConstructionPlanes()
_get_adsk_core_SelectionCommandInput_ConstructionPlanes = _core._get_adsk_core_SelectionCommandInput_ConstructionPlanes

def _get_adsk_core_SelectionCommandInput_Features() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_Features()
_get_adsk_core_SelectionCommandInput_Features = _core._get_adsk_core_SelectionCommandInput_Features

def _get_adsk_core_SelectionCommandInput_Canvases() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_Canvases()
_get_adsk_core_SelectionCommandInput_Canvases = _core._get_adsk_core_SelectionCommandInput_Canvases

def _get_adsk_core_SelectionCommandInput_Decals() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_Decals()
_get_adsk_core_SelectionCommandInput_Decals = _core._get_adsk_core_SelectionCommandInput_Decals

def _get_adsk_core_SelectionCommandInput_JointOrigins() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_JointOrigins()
_get_adsk_core_SelectionCommandInput_JointOrigins = _core._get_adsk_core_SelectionCommandInput_JointOrigins

def _get_adsk_core_SelectionCommandInput_Joints() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_Joints()
_get_adsk_core_SelectionCommandInput_Joints = _core._get_adsk_core_SelectionCommandInput_Joints

def _get_adsk_core_SelectionCommandInput_SketchConstraints() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_SketchConstraints()
_get_adsk_core_SelectionCommandInput_SketchConstraints = _core._get_adsk_core_SelectionCommandInput_SketchConstraints

def _get_adsk_core_SelectionCommandInput_Profiles() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_Profiles()
_get_adsk_core_SelectionCommandInput_Profiles = _core._get_adsk_core_SelectionCommandInput_Profiles

def _get_adsk_core_SelectionCommandInput_Texts() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_Texts()
_get_adsk_core_SelectionCommandInput_Texts = _core._get_adsk_core_SelectionCommandInput_Texts

def _get_adsk_core_SelectionCommandInput_CustomGraphics() -> "std::string const" :
  return _core._get_adsk_core_SelectionCommandInput_CustomGraphics()
_get_adsk_core_SelectionCommandInput_CustomGraphics = _core._get_adsk_core_SelectionCommandInput_CustomGraphics
class _SelectionCommandInput_Meta_Class(type):
    def __init__(cls, name, bases, nmspc):
        super().__init__(name, bases, nmspc)
    def _get_Bodies(cls): return _get_adsk_core_SelectionCommandInput_Bodies()
    Bodies = property(_get_Bodies)
    def _get_SolidBodies(cls): return _get_adsk_core_SelectionCommandInput_SolidBodies()
    SolidBodies = property(_get_SolidBodies)
    def _get_SurfaceBodies(cls): return _get_adsk_core_SelectionCommandInput_SurfaceBodies()
    SurfaceBodies = property(_get_SurfaceBodies)
    def _get_MeshBodies(cls): return _get_adsk_core_SelectionCommandInput_MeshBodies()
    MeshBodies = property(_get_MeshBodies)
    def _get_Faces(cls): return _get_adsk_core_SelectionCommandInput_Faces()
    Faces = property(_get_Faces)
    def _get_SolidFaces(cls): return _get_adsk_core_SelectionCommandInput_SolidFaces()
    SolidFaces = property(_get_SolidFaces)
    def _get_SurfaceFaces(cls): return _get_adsk_core_SelectionCommandInput_SurfaceFaces()
    SurfaceFaces = property(_get_SurfaceFaces)
    def _get_PlanarFaces(cls): return _get_adsk_core_SelectionCommandInput_PlanarFaces()
    PlanarFaces = property(_get_PlanarFaces)
    def _get_CylindricalFaces(cls): return _get_adsk_core_SelectionCommandInput_CylindricalFaces()
    CylindricalFaces = property(_get_CylindricalFaces)
    def _get_ConicalFaces(cls): return _get_adsk_core_SelectionCommandInput_ConicalFaces()
    ConicalFaces = property(_get_ConicalFaces)
    def _get_SphericalFaces(cls): return _get_adsk_core_SelectionCommandInput_SphericalFaces()
    SphericalFaces = property(_get_SphericalFaces)
    def _get_ToroidalFaces(cls): return _get_adsk_core_SelectionCommandInput_ToroidalFaces()
    ToroidalFaces = property(_get_ToroidalFaces)
    def _get_SplineFaces(cls): return _get_adsk_core_SelectionCommandInput_SplineFaces()
    SplineFaces = property(_get_SplineFaces)
    def _get_Edges(cls): return _get_adsk_core_SelectionCommandInput_Edges()
    Edges = property(_get_Edges)
    def _get_LinearEdges(cls): return _get_adsk_core_SelectionCommandInput_LinearEdges()
    LinearEdges = property(_get_LinearEdges)
    def _get_CircularEdges(cls): return _get_adsk_core_SelectionCommandInput_CircularEdges()
    CircularEdges = property(_get_CircularEdges)
    def _get_EllipticalEdges(cls): return _get_adsk_core_SelectionCommandInput_EllipticalEdges()
    EllipticalEdges = property(_get_EllipticalEdges)
    def _get_TangentEdges(cls): return _get_adsk_core_SelectionCommandInput_TangentEdges()
    TangentEdges = property(_get_TangentEdges)
    def _get_NonTangentEdges(cls): return _get_adsk_core_SelectionCommandInput_NonTangentEdges()
    NonTangentEdges = property(_get_NonTangentEdges)
    def _get_Vertices(cls): return _get_adsk_core_SelectionCommandInput_Vertices()
    Vertices = property(_get_Vertices)
    def _get_RootComponents(cls): return _get_adsk_core_SelectionCommandInput_RootComponents()
    RootComponents = property(_get_RootComponents)
    def _get_Occurrences(cls): return _get_adsk_core_SelectionCommandInput_Occurrences()
    Occurrences = property(_get_Occurrences)
    def _get_Sketches(cls): return _get_adsk_core_SelectionCommandInput_Sketches()
    Sketches = property(_get_Sketches)
    def _get_SketchCurves(cls): return _get_adsk_core_SelectionCommandInput_SketchCurves()
    SketchCurves = property(_get_SketchCurves)
    def _get_SketchLines(cls): return _get_adsk_core_SelectionCommandInput_SketchLines()
    SketchLines = property(_get_SketchLines)
    def _get_SketchCircles(cls): return _get_adsk_core_SelectionCommandInput_SketchCircles()
    SketchCircles = property(_get_SketchCircles)
    def _get_SketchPoints(cls): return _get_adsk_core_SelectionCommandInput_SketchPoints()
    SketchPoints = property(_get_SketchPoints)
    def _get_ConstructionPoints(cls): return _get_adsk_core_SelectionCommandInput_ConstructionPoints()
    ConstructionPoints = property(_get_ConstructionPoints)
    def _get_ConstructionLines(cls): return _get_adsk_core_SelectionCommandInput_ConstructionLines()
    ConstructionLines = property(_get_ConstructionLines)
    def _get_ConstructionPlanes(cls): return _get_adsk_core_SelectionCommandInput_ConstructionPlanes()
    ConstructionPlanes = property(_get_ConstructionPlanes)
    def _get_Features(cls): return _get_adsk_core_SelectionCommandInput_Features()
    Features = property(_get_Features)
    def _get_Canvases(cls): return _get_adsk_core_SelectionCommandInput_Canvases()
    Canvases = property(_get_Canvases)
    def _get_Decals(cls): return _get_adsk_core_SelectionCommandInput_Decals()
    Decals = property(_get_Decals)
    def _get_JointOrigins(cls): return _get_adsk_core_SelectionCommandInput_JointOrigins()
    JointOrigins = property(_get_JointOrigins)
    def _get_Joints(cls): return _get_adsk_core_SelectionCommandInput_Joints()
    Joints = property(_get_Joints)
    def _get_SketchConstraints(cls): return _get_adsk_core_SelectionCommandInput_SketchConstraints()
    SketchConstraints = property(_get_SketchConstraints)
    def _get_Profiles(cls): return _get_adsk_core_SelectionCommandInput_Profiles()
    Profiles = property(_get_Profiles)
    def _get_Texts(cls): return _get_adsk_core_SelectionCommandInput_Texts()
    Texts = property(_get_Texts)
    def _get_CustomGraphics(cls): return _get_adsk_core_SelectionCommandInput_CustomGraphics()
    CustomGraphics = property(_get_CustomGraphics)

class SelectionCommandInput(CommandInput, metaclass=_SelectionCommandInput_Meta_Class):
    """Provides a command input to get a selection from the user."""
    __swig_setmethods__ = {}
    for _s in [CommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SelectionCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [CommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SelectionCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::SelectionCommandInput *" : return _core.SelectionCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.SelectionCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.SelectionCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.SelectionCommandInput_classType
    if _newclass:classType = staticmethod(_core.SelectionCommandInput_classType)
    __swig_destroy__ = _core.delete_SelectionCommandInput
    __del__ = lambda self : None;
    def _get_commandPrompt(self) -> "std::string" :
        """Gets or sets the tooltip shown next to the cursor."""
        return _core.SelectionCommandInput__get_commandPrompt(self)

    def _set_commandPrompt(self, *args) -> "bool" :
        """Gets or sets the tooltip shown next to the cursor."""
        return _core.SelectionCommandInput__set_commandPrompt(self, *args)

    def addSelectionFilter(self, *args) -> "bool" :
        """
        Adds an additional filter to the existing filter list. 
        filter : The name of a selection filter to add. The valid list of selection filters can be found here: <a href='SelectionFilters_UM.htm'>Selection Filters</a>. 
        Returns true if the filter was added successfully.
        """
        return _core.SelectionCommandInput_addSelectionFilter(self, *args)

    def clearSelectionFilter(self) -> "bool" :
        """
        Clears the list of selection filters. 
        Returns true if successful.
        """
        return _core.SelectionCommandInput_clearSelectionFilter(self)

    def _get_selectionFilters(self) -> "std::vector< std::string,std::allocator< std::string > >" :
        """Gets or sets the list of selection filters. The valid list of selection filters can be found here: <a href='SelectionFilters_UM.htm'>Selection Filters</a>."""
        return _core.SelectionCommandInput__get_selectionFilters(self)

    def _set_selectionFilters(self, *args) -> "bool" :
        """Gets or sets the list of selection filters. The valid list of selection filters can be found here: <a href='SelectionFilters_UM.htm'>Selection Filters</a>."""
        return _core.SelectionCommandInput__set_selectionFilters(self, *args)

    def _get_selectionCount(self) -> "size_t" :
        """Gets the current number of selections the user has made for this input."""
        return _core.SelectionCommandInput__get_selectionCount(self)

    def selection(self, *args) -> "adsk::core::Ptr< adsk::core::Selection >" :
        """
        Returns the selection at the specified index. 
        index : The index of the selection to return. 
        Returns the Selection at the specified index, or null on error.
        """
        return _core.SelectionCommandInput_selection(self, *args)

    def addSelection(self, *args) -> "bool" :
        """
        Adds the selection to the list of selections associated with this input. This method is not valid within
        the commandCreated event but must be used later in the command lifetime. If you want to pre-populate the
        selection when the command is starting, you can use this method in the activate method of the Command.
        It's also valid to use in other events once the command is running, such as the validateInputs event. 
        selection : The entity to add a selection of to this input. The addition may fail if the entity
        does not match the selection filter, or adding it would exceed the limits. 
        Returns true if a selection to the entity was added to this input.
        """
        return _core.SelectionCommandInput_addSelection(self, *args)

    def getSelectionLimits(self) -> "bool" :
        """
        Get the limits currently defined for this input. 
        minimum : The minimum number of selections required. A value of zero means that there is no minimum limit. 
        maximum : The maximum number of selections required. A value of zero means that there is no maximum limit. 
        Returns true if the selection limits were successfully returned.
        """
        return _core.SelectionCommandInput_getSelectionLimits(self)

    def setSelectionLimits(self, *args) -> "bool" :
        """
        Defines the limits for the number of selections associated with this input.
        A maximum value of 0 indicates that there is no maximum. 
        minimum : The minimum number of selections required. A value of zero means that there is no minimum limit. 
        maximum : The maximum number of selections required. A value of zero means that there is no maximum limit.
        If maximum is equal to minimim, then exactly that number of selections is required. 
        Returns true if the limits were successfully set.
        """
        return _core.SelectionCommandInput_setSelectionLimits(self, *args)

    def clearSelection(self) -> "bool" :
        """
        Clears the current selection so no entities are in the selection. 
        Returns true if successful.
        """
        return _core.SelectionCommandInput_clearSelection(self)

    def _get_hasFocus(self) -> "bool" :
        """
        Gets and sets if this selection input has focus with respect to other selection inputs on the
        command dialog. Only one selection input on a dialog can have focus at a time so setting hasFocus to true
        will remove the focus from the selection input that previously had focus. When a selection input
        has focus, any user selections will be added to that selection input and the selection rules associated
        with that selection input will apply.
        """
        return _core.SelectionCommandInput__get_hasFocus(self)

    def _set_hasFocus(self, *args) -> "bool" :
        """
        Gets and sets if this selection input has focus with respect to other selection inputs on the
        command dialog. Only one selection input on a dialog can have focus at a time so setting hasFocus to true
        will remove the focus from the selection input that previously had focus. When a selection input
        has focus, any user selections will be added to that selection input and the selection rules associated
        with that selection input will apply.
        """
        return _core.SelectionCommandInput__set_hasFocus(self, *args)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.SelectionCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.SelectionCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.SelectionCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.SelectionCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.SelectionCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.SelectionCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.SelectionCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.SelectionCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.SelectionCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.SelectionCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.SelectionCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.SelectionCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.SelectionCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.SelectionCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.SelectionCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.SelectionCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.SelectionCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.SelectionCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.SelectionCommandInput__get_isValid(self)
SelectionCommandInput_swigregister = _core.SelectionCommandInput_swigregister
SelectionCommandInput_swigregister(SelectionCommandInput)

def SelectionCommandInput_classType() -> "char const *" :
  return _core.SelectionCommandInput_classType()
SelectionCommandInput_classType = _core.SelectionCommandInput_classType

SelectionCommandInput.__swig_getmethods__["commandPrompt"] = SelectionCommandInput._get_commandPrompt
SelectionCommandInput.__swig_setmethods__["commandPrompt"] = SelectionCommandInput._set_commandPrompt
SelectionCommandInput.commandPrompt = property(SelectionCommandInput._get_commandPrompt, SelectionCommandInput._set_commandPrompt, doc="Gets or sets the tooltip shown next to the cursor.")

SelectionCommandInput.__swig_getmethods__["selectionFilters"] = SelectionCommandInput._get_selectionFilters
SelectionCommandInput.__swig_setmethods__["selectionFilters"] = SelectionCommandInput._set_selectionFilters
SelectionCommandInput.selectionFilters = property(SelectionCommandInput._get_selectionFilters, SelectionCommandInput._set_selectionFilters, doc="Gets or sets the list of selection filters. The valid list of selection filters can be found here: <a href='SelectionFilters_UM.htm'>Selection Filters</a>.")

SelectionCommandInput.__swig_getmethods__["selectionCount"] = SelectionCommandInput._get_selectionCount
SelectionCommandInput.selectionCount = property(SelectionCommandInput._get_selectionCount, doc="Gets the current number of selections the user has made for this input.")

SelectionCommandInput.__swig_getmethods__["hasFocus"] = SelectionCommandInput._get_hasFocus
SelectionCommandInput.__swig_setmethods__["hasFocus"] = SelectionCommandInput._set_hasFocus
SelectionCommandInput.hasFocus = property(SelectionCommandInput._get_hasFocus, SelectionCommandInput._set_hasFocus, doc="Gets and sets if this selection input has focus with respect to other selection inputs on the\ncommand dialog. Only one selection input on a dialog can have focus at a time so setting hasFocus to true\nwill remove the focus from the selection input that previously had focus. When a selection input\nhas focus, any user selections will be added to that selection input and the selection rules associated\nwith that selection input will apply.")

SelectionCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SelectionCommandInput) else None
SelectionCommandInput.cast = lambda arg: arg if isinstance(arg, SelectionCommandInput) else None

class SelectionEvent(Event):
    """An event endpoint that supports the connection to client implemented SelectionEventHandlers."""
    __swig_setmethods__ = {}
    for _s in [Event]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SelectionEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SelectionEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::SelectionEvent *" : return _core.SelectionEvent___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.SelectionEvent___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.SelectionEvent___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.SelectionEvent_classType
    if _newclass:classType = staticmethod(_core.SelectionEvent_classType)
    __swig_destroy__ = _core.delete_SelectionEvent
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Adds an event handler to this event endpoint. 
        handler : The client implemented SelectionEventHandler to be called when this event is triggered. 
        Returns true if the handler was successfully added to the set of event handlers.
        """
        return _core.SelectionEvent_add(self, *args)

    def remove(self, *args) -> "bool" :
        """
        Removes a handler from this event endpoint. 
        handler : A SelectionEventHandler that was previously added to this event with the add method. 
        Returns true if the handler was found and removed from the set of event handlers.
        """
        return _core.SelectionEvent_remove(self, *args)

    def _get_activeInput(self) -> "adsk::core::Ptr< adsk::core::SelectionCommandInput >" :
        """
        Returns the SelectionCommandInput that is currently active in the command dialog and
        that the user is selecting entities for. This can be used to determine which set of
        rules you want to apply to determine if the current entity is selectable or not.
        """
        return _core.SelectionEvent__get_activeInput(self)

    def _get_name(self) -> "std::string" :
        """The name of the event - e.g. 'DocumentOpening'"""
        return _core.SelectionEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.SelectionEvent__get_sender(self)

    def _get_objectType(self) -> "char const *" : return _core.SelectionEvent__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.SelectionEvent__get_isValid(self)
SelectionEvent_swigregister = _core.SelectionEvent_swigregister
SelectionEvent_swigregister(SelectionEvent)

def SelectionEvent_classType() -> "char const *" :
  return _core.SelectionEvent_classType()
SelectionEvent_classType = _core.SelectionEvent_classType

SelectionEvent.__swig_getmethods__["activeInput"] = SelectionEvent._get_activeInput
SelectionEvent.activeInput = property(SelectionEvent._get_activeInput, doc="Returns the SelectionCommandInput that is currently active in the command dialog and\nthat the user is selecting entities for. This can be used to determine which set of\nrules you want to apply to determine if the current entity is selectable or not.")

SelectionEvent.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SelectionEvent) else None
SelectionEvent.cast = lambda arg: arg if isinstance(arg, SelectionEvent) else None

class SelectionEventArgs(EventArgs):
    """Provides a set of arguments from a firing SelectionEvent to a SelectionEventHandler's notify callback method."""
    __swig_setmethods__ = {}
    for _s in [EventArgs]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SelectionEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SelectionEventArgs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::SelectionEventArgs *" : return _core.SelectionEventArgs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.SelectionEventArgs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.SelectionEventArgs___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.SelectionEventArgs_classType
    if _newclass:classType = staticmethod(_core.SelectionEventArgs_classType)
    __swig_destroy__ = _core.delete_SelectionEventArgs
    __del__ = lambda self : None;
    def _get_selection(self) -> "adsk::core::Ptr< adsk::core::Selection >" :
        """Gets the entity that is valid for selection."""
        return _core.SelectionEventArgs__get_selection(self)

    def _get_isSelectable(self) -> "bool" :
        """
        Gets or sets whether this entity should be made available to be selected.
        The value is initialized to true, so doing nothing will result
        in the entity being selectable.
        """
        return _core.SelectionEventArgs__get_isSelectable(self)

    def _set_isSelectable(self, *args) -> "bool" :
        """
        Gets or sets whether this entity should be made available to be selected.
        The value is initialized to true, so doing nothing will result
        in the entity being selectable.
        """
        return _core.SelectionEventArgs__set_isSelectable(self, *args)

    def _get_additionalEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets or sets any additional entities that should be pre-highlighted and selected
        if the entity the mouse is over is selected. If you add an entity that is already 
        selected, it will be unselected. The result of adding additional entitities is the
        same as if they were selected one at a time by the user and the user can unselect each
        entity one at a time by picking it while it's selected.
        An example of how this might be used is that that the user can select a group of
        tangentially connected edges by picking a single edge. You can use the 
        BrepEdge.tangentiallyConnectedEdges to easily find the tangent edges and add them
        to the set of additional entities to be selected. These edges are pre-highlighted 
        and then selected.
        If you are using this property you need to make sure that the selection 
        limits for the SelectionCommandInput have been set appropriately. For example, a 
        newly created SeletionCommandInput is set to only allow the selection of a single
        entity. By adding additional entities you'll need more than one entity because the
        entire set of entities will be added to the selection. Use the setSelectionLimits
        method of the SelectionCommandInput to change the number of allowed selections.
        The additional entities should all be valid based on the current selection filter.
        """
        return _core.SelectionEventArgs__get_additionalEntities(self)

    def _set_additionalEntities(self, *args) -> "bool" :
        """
        Gets or sets any additional entities that should be pre-highlighted and selected
        if the entity the mouse is over is selected. If you add an entity that is already 
        selected, it will be unselected. The result of adding additional entitities is the
        same as if they were selected one at a time by the user and the user can unselect each
        entity one at a time by picking it while it's selected.
        An example of how this might be used is that that the user can select a group of
        tangentially connected edges by picking a single edge. You can use the 
        BrepEdge.tangentiallyConnectedEdges to easily find the tangent edges and add them
        to the set of additional entities to be selected. These edges are pre-highlighted 
        and then selected.
        If you are using this property you need to make sure that the selection 
        limits for the SelectionCommandInput have been set appropriately. For example, a 
        newly created SeletionCommandInput is set to only allow the selection of a single
        entity. By adding additional entities you'll need more than one entity because the
        entire set of entities will be added to the selection. Use the setSelectionLimits
        method of the SelectionCommandInput to change the number of allowed selections.
        The additional entities should all be valid based on the current selection filter.
        """
        return _core.SelectionEventArgs__set_additionalEntities(self, *args)

    def _get_activeInput(self) -> "adsk::core::Ptr< adsk::core::SelectionCommandInput >" :
        """
        Returns the SelectionCommandInput that is currently active in the command dialog and
        that the user is selecting entities for. This can be used to determine which set of
        rules you want to apply to determine if the current entity is selectable or not.
        """
        return _core.SelectionEventArgs__get_activeInput(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >" :
        """The event that the firing is in response to."""
        return _core.SelectionEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *" : return _core.SelectionEventArgs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.SelectionEventArgs__get_isValid(self)
SelectionEventArgs_swigregister = _core.SelectionEventArgs_swigregister
SelectionEventArgs_swigregister(SelectionEventArgs)

def SelectionEventArgs_classType() -> "char const *" :
  return _core.SelectionEventArgs_classType()
SelectionEventArgs_classType = _core.SelectionEventArgs_classType

SelectionEventArgs.__swig_getmethods__["selection"] = SelectionEventArgs._get_selection
SelectionEventArgs.selection = property(SelectionEventArgs._get_selection, doc="Gets the entity that is valid for selection.")

SelectionEventArgs.__swig_getmethods__["isSelectable"] = SelectionEventArgs._get_isSelectable
SelectionEventArgs.__swig_setmethods__["isSelectable"] = SelectionEventArgs._set_isSelectable
SelectionEventArgs.isSelectable = property(SelectionEventArgs._get_isSelectable, SelectionEventArgs._set_isSelectable, doc="Gets or sets whether this entity should be made available to be selected.\nThe value is initialized to true, so doing nothing will result\nin the entity being selectable.")

SelectionEventArgs.__swig_getmethods__["additionalEntities"] = SelectionEventArgs._get_additionalEntities
SelectionEventArgs.__swig_setmethods__["additionalEntities"] = SelectionEventArgs._set_additionalEntities
SelectionEventArgs.additionalEntities = property(SelectionEventArgs._get_additionalEntities, SelectionEventArgs._set_additionalEntities, doc="Gets or sets any additional entities that should be pre-highlighted and selected\nif the entity the mouse is over is selected. If you add an entity that is already\nselected, it will be unselected. The result of adding additional entitities is the\nsame as if they were selected one at a time by the user and the user can unselect each\nentity one at a time by picking it while it's selected.\nAn example of how this might be used is that that the user can select a group of\ntangentially connected edges by picking a single edge. You can use the\nBrepEdge.tangentiallyConnectedEdges to easily find the tangent edges and add them\nto the set of additional entities to be selected. These edges are pre-highlighted\nand then selected.\nIf you are using this property you need to make sure that the selection\nlimits for the SelectionCommandInput have been set appropriately. For example, a\nnewly created SeletionCommandInput is set to only allow the selection of a single\nentity. By adding additional entities you'll need more than one entity because the\nentire set of entities will be added to the selection. Use the setSelectionLimits\nmethod of the SelectionCommandInput to change the number of allowed selections.\nThe additional entities should all be valid based on the current selection filter.")

SelectionEventArgs.__swig_getmethods__["activeInput"] = SelectionEventArgs._get_activeInput
SelectionEventArgs.activeInput = property(SelectionEventArgs._get_activeInput, doc="Returns the SelectionCommandInput that is currently active in the command dialog and\nthat the user is selecting entities for. This can be used to determine which set of\nrules you want to apply to determine if the current entity is selectable or not.")

SelectionEventArgs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SelectionEventArgs) else None
SelectionEventArgs.cast = lambda arg: arg if isinstance(arg, SelectionEventArgs) else None

class SeparatorControl(ToolbarControl):
    """Represents a separator within a panel, toolbar, or drop-down control."""
    __swig_setmethods__ = {}
    for _s in [ToolbarControl]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SeparatorControl, name, value)
    __swig_getmethods__ = {}
    for _s in [ToolbarControl]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SeparatorControl, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::SeparatorControl *" : return _core.SeparatorControl___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.SeparatorControl___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.SeparatorControl___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.SeparatorControl_classType
    if _newclass:classType = staticmethod(_core.SeparatorControl_classType)
    __swig_destroy__ = _core.delete_SeparatorControl
    __del__ = lambda self : None;
    def _get_id(self) -> "std::string" :
        """
        Gets the unique ID of this control. The ID is unique with respect to the other
        controls within the same panel, toolbar, or drop-down control.
        """
        return _core.SeparatorControl__get_id(self)

    def _get_index(self) -> "size_t" :
        """Gets the position of this control within the list of controls within the panel, toolbar, or drop-down control."""
        return _core.SeparatorControl__get_index(self)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this control is currently visible."""
        return _core.SeparatorControl__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this control is currently visible."""
        return _core.SeparatorControl__set_isVisible(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the Parent object. When associated with a toolbar (right or left QAT or the Nav Bar) this
        returns the parent Toolbar object. When associated with a panel it returns the parent ToolbarPanel object.
        When associated with a control (DropDownControl) it returns the parent control.
        """
        return _core.SeparatorControl__get_parent(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the ToolbarControl 
        Returns a boolean indicating if the deletion was successful.
        """
        return _core.SeparatorControl_deleteMe(self)

    def _get_objectType(self) -> "char const *" : return _core.SeparatorControl__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.SeparatorControl__get_isValid(self)
SeparatorControl_swigregister = _core.SeparatorControl_swigregister
SeparatorControl_swigregister(SeparatorControl)

def SeparatorControl_classType() -> "char const *" :
  return _core.SeparatorControl_classType()
SeparatorControl_classType = _core.SeparatorControl_classType

SeparatorControl.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SeparatorControl) else None
SeparatorControl.cast = lambda arg: arg if isinstance(arg, SeparatorControl) else None

class SliderCommandInput(CommandInput):
    """Provides a command input to get the value of a slider from the user."""
    __swig_setmethods__ = {}
    for _s in [CommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SliderCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [CommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SliderCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::SliderCommandInput *" : return _core.SliderCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.SliderCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.SliderCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.SliderCommandInput_classType
    if _newclass:classType = staticmethod(_core.SliderCommandInput_classType)
    __swig_destroy__ = _core.delete_SliderCommandInput
    __del__ = lambda self : None;
    def _get_expressionOne(self) -> "std::string" :
        """
        Uses an expression to set the value in the first input field. This can contain equations and
        is evaluated using the specified unit type.
        """
        return _core.SliderCommandInput__get_expressionOne(self)

    def _set_expressionOne(self, *args) -> "bool" :
        """
        Uses an expression to set the value in the first input field. This can contain equations and
        is evaluated using the specified unit type.
        """
        return _core.SliderCommandInput__set_expressionOne(self, *args)

    def _get_expressionTwo(self) -> "std::string" :
        """
        Uses an expression to set the value in the second input field. This can contain equations and
        is evaluated using the specified unit type.
        This property is only available when the hasTwoSliders property returns true.
        """
        return _core.SliderCommandInput__get_expressionTwo(self)

    def _set_expressionTwo(self, *args) -> "bool" :
        """
        Uses an expression to set the value in the second input field. This can contain equations and
        is evaluated using the specified unit type.
        This property is only available when the hasTwoSliders property returns true.
        """
        return _core.SliderCommandInput__set_expressionTwo(self, *args)

    def _get_unitType(self) -> "std::string" :
        """Gets and sets the unit type that is used when evaluating the user's input."""
        return _core.SliderCommandInput__get_unitType(self)

    def _set_unitType(self, *args) -> "bool" :
        """Gets and sets the unit type that is used when evaluating the user's input."""
        return _core.SliderCommandInput__set_unitType(self, *args)

    def _get_hasTwoSliders(self) -> "bool" :
        """Gets if the command input has two sliders."""
        return _core.SliderCommandInput__get_hasTwoSliders(self)

    def setText(self, *args) -> "bool" :
        """
        Sets the text of the slider. Both the left and the right text should be set. 
        left : Indicates the text on the left side of the slider. 
        right : Indicates the text on the right side of the slider. 
        Returns true if successful.
        """
        return _core.SliderCommandInput_setText(self, *args)

    def getText(self, *args) -> "std::string" :
        """
        Gets the texts of the slider if text has been defined. 
        isLeft : Indicates to get the left or right text. 
        Returns the left or right text of the slider.
        """
        return _core.SliderCommandInput_getText(self, *args)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.SliderCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.SliderCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.SliderCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.SliderCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.SliderCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.SliderCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.SliderCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.SliderCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.SliderCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.SliderCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.SliderCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.SliderCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.SliderCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.SliderCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.SliderCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.SliderCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.SliderCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.SliderCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.SliderCommandInput__get_isValid(self)
SliderCommandInput_swigregister = _core.SliderCommandInput_swigregister
SliderCommandInput_swigregister(SliderCommandInput)

def SliderCommandInput_classType() -> "char const *" :
  return _core.SliderCommandInput_classType()
SliderCommandInput_classType = _core.SliderCommandInput_classType

SliderCommandInput.__swig_getmethods__["expressionOne"] = SliderCommandInput._get_expressionOne
SliderCommandInput.__swig_setmethods__["expressionOne"] = SliderCommandInput._set_expressionOne
SliderCommandInput.expressionOne = property(SliderCommandInput._get_expressionOne, SliderCommandInput._set_expressionOne, doc="Uses an expression to set the value in the first input field. This can contain equations and\nis evaluated using the specified unit type.")

SliderCommandInput.__swig_getmethods__["expressionTwo"] = SliderCommandInput._get_expressionTwo
SliderCommandInput.__swig_setmethods__["expressionTwo"] = SliderCommandInput._set_expressionTwo
SliderCommandInput.expressionTwo = property(SliderCommandInput._get_expressionTwo, SliderCommandInput._set_expressionTwo, doc="Uses an expression to set the value in the second input field. This can contain equations and\nis evaluated using the specified unit type.\nThis property is only available when the hasTwoSliders property returns true.")

SliderCommandInput.__swig_getmethods__["unitType"] = SliderCommandInput._get_unitType
SliderCommandInput.__swig_setmethods__["unitType"] = SliderCommandInput._set_unitType
SliderCommandInput.unitType = property(SliderCommandInput._get_unitType, SliderCommandInput._set_unitType, doc="Gets and sets the unit type that is used when evaluating the user's input.")

SliderCommandInput.__swig_getmethods__["hasTwoSliders"] = SliderCommandInput._get_hasTwoSliders
SliderCommandInput.hasTwoSliders = property(SliderCommandInput._get_hasTwoSliders, doc="Gets if the command input has two sliders.")

SliderCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SliderCommandInput) else None
SliderCommandInput.cast = lambda arg: arg if isinstance(arg, SliderCommandInput) else None

class SMTImportOptions(ImportOptions):
    """Defines that an SMT import is to be done and specifies the various options."""
    __swig_setmethods__ = {}
    for _s in [ImportOptions]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SMTImportOptions, name, value)
    __swig_getmethods__ = {}
    for _s in [ImportOptions]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SMTImportOptions, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::SMTImportOptions *" : return _core.SMTImportOptions___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.SMTImportOptions___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.SMTImportOptions___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.SMTImportOptions_classType
    if _newclass:classType = staticmethod(_core.SMTImportOptions_classType)
    __swig_destroy__ = _core.delete_SMTImportOptions
    __del__ = lambda self : None;
    def _get_filename(self) -> "std::string" :
        """Gets and sets the filename or url of the file to be imported."""
        return _core.SMTImportOptions__get_filename(self)

    def _set_filename(self, *args) -> "bool" :
        """Gets and sets the filename or url of the file to be imported."""
        return _core.SMTImportOptions__set_filename(self, *args)

    def _get_isViewFit(self) -> "bool" :
        """
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.SMTImportOptions__get_isViewFit(self)

    def _set_isViewFit(self, *args) -> "bool" :
        """
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.SMTImportOptions__set_isViewFit(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.SMTImportOptions__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.SMTImportOptions__get_isValid(self)
SMTImportOptions_swigregister = _core.SMTImportOptions_swigregister
SMTImportOptions_swigregister(SMTImportOptions)

def SMTImportOptions_classType() -> "char const *" :
  return _core.SMTImportOptions_classType()
SMTImportOptions_classType = _core.SMTImportOptions_classType

SMTImportOptions.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SMTImportOptions) else None
SMTImportOptions.cast = lambda arg: arg if isinstance(arg, SMTImportOptions) else None

class Sphere(Surface):
    """
    Transient sphere. A transient sphere is not displayed or saved in a document.
    Transient spheres are used as a wrapper to work with raw sphere information. 
    A transient sphere is a full sphere defined by a point and a radius.
    They are created statically using the create method of the Sphere class.
    """
    __swig_setmethods__ = {}
    for _s in [Surface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Sphere, name, value)
    __swig_getmethods__ = {}
    for _s in [Surface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Sphere, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Sphere *" : return _core.Sphere___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Sphere___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Sphere___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Sphere_classType
    if _newclass:classType = staticmethod(_core.Sphere_classType)
    __swig_getmethods__["create"] = lambda x: _core.Sphere_create
    if _newclass:create = staticmethod(_core.Sphere_create)
    __swig_destroy__ = _core.delete_Sphere
    __del__ = lambda self : None;
    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets the origin point (center) of the sphere."""
        return _core.Sphere__get_origin(self)

    def _set_origin(self, *args) -> "bool" :
        """Gets and sets the origin point (center) of the sphere."""
        return _core.Sphere__set_origin(self, *args)

    def _get_radius(self) -> "double" :
        """Gets and sets the radius of the sphere."""
        return _core.Sphere__get_radius(self)

    def _set_radius(self, *args) -> "bool" :
        """Gets and sets the radius of the sphere."""
        return _core.Sphere__set_radius(self, *args)

    def getData(self) -> "bool" :
        """
        Gets all of the data defining the sphere. 
        origin : The output origin point (center) of the sphere. 
        radius : The output radius of the sphere. 
        Returns true if successful.
        """
        return _core.Sphere_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets all of the data defining the sphere. 
        origin : The origin point (center) of the sphere. 
        radius : The radius of the sphere. 
        Returns true if successful.
        """
        return _core.Sphere_set(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Sphere >" :
        """
        Creates and returns an independent copy of this Sphere object. 
        Returns a new Sphere object that is a copy of this Sphere object.
        """
        return _core.Sphere_copy(self)

    def _get_surfaceType(self) -> "adsk::core::SurfaceTypes" :
        """Returns the surface type."""
        return _core.Sphere__get_surfaceType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >" :
        """Returns the surface evaluator."""
        return _core.Sphere__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Updates this surface by transforming it with a given input matrix. 
        matrix : A 3D matrix that defines the transform to apply to the surface. 
        Returns true if the transform was successful.
        """
        return _core.Sphere_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Sphere__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Sphere__get_isValid(self)
Sphere_swigregister = _core.Sphere_swigregister
Sphere_swigregister(Sphere)

def Sphere_classType() -> "char const *" :
  return _core.Sphere_classType()
Sphere_classType = _core.Sphere_classType

def Sphere_create(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &" :
  return _core.Sphere_create(*args)
Sphere_create = _core.Sphere_create

Sphere.__swig_getmethods__["origin"] = Sphere._get_origin
Sphere.__swig_setmethods__["origin"] = Sphere._set_origin
Sphere.origin = property(Sphere._get_origin, Sphere._set_origin, doc="Gets and sets the origin point (center) of the sphere.")

Sphere.__swig_getmethods__["radius"] = Sphere._get_radius
Sphere.__swig_setmethods__["radius"] = Sphere._set_radius
Sphere.radius = property(Sphere._get_radius, Sphere._set_radius, doc="Gets and sets the radius of the sphere.")

Sphere.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Sphere) else None
Sphere.cast = lambda arg: arg if isinstance(arg, Sphere) else None

class SplitButtonControl(ToolbarControl):
    """
    A split button has two active areas that the user can click;
    the main button portion and the drop-down arrow. Clicking the main button, executes the displayed command.
    Clicking the drop-down displays the drop-down with additional commands.
    """
    __swig_setmethods__ = {}
    for _s in [ToolbarControl]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SplitButtonControl, name, value)
    __swig_getmethods__ = {}
    for _s in [ToolbarControl]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SplitButtonControl, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::SplitButtonControl *" : return _core.SplitButtonControl___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.SplitButtonControl___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.SplitButtonControl___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.SplitButtonControl_classType
    if _newclass:classType = staticmethod(_core.SplitButtonControl_classType)
    __swig_destroy__ = _core.delete_SplitButtonControl
    __del__ = lambda self : None;
    def _get_defaultCommandDefinition(self) -> "adsk::core::Ptr< adsk::core::CommandDefinition >" :
        """Gets the command definition that is used as the default command on the main portion of the split button."""
        return _core.SplitButtonControl__get_defaultCommandDefinition(self)

    def _get_isLastUsedShown(self) -> "bool" :
        """Gets if this button behaves where the last executed command becomes the command on the main portion of the split button."""
        return _core.SplitButtonControl__get_isLastUsedShown(self)

    def _get_additionalDefinitions(self) -> "std::vector< adsk::core::Ptr< adsk::core::CommandDefinition >,std::allocator< adsk::core::Ptr< adsk::core::CommandDefinition > > >" :
        """Gets or sets the command definitions used to define the buttons associated with the split button."""
        return _core.SplitButtonControl__get_additionalDefinitions(self)

    def _set_additionalDefinitions(self, *args) -> "bool" :
        """Gets or sets the command definitions used to define the buttons associated with the split button."""
        return _core.SplitButtonControl__set_additionalDefinitions(self, *args)

    def _get_id(self) -> "std::string" :
        """
        Gets the unique ID of this control. The ID is unique with respect to the other
        controls within the same panel, toolbar, or drop-down control.
        """
        return _core.SplitButtonControl__get_id(self)

    def _get_index(self) -> "size_t" :
        """Gets the position of this control within the list of controls within the panel, toolbar, or drop-down control."""
        return _core.SplitButtonControl__get_index(self)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this control is currently visible."""
        return _core.SplitButtonControl__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this control is currently visible."""
        return _core.SplitButtonControl__set_isVisible(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the Parent object. When associated with a toolbar (right or left QAT or the Nav Bar) this
        returns the parent Toolbar object. When associated with a panel it returns the parent ToolbarPanel object.
        When associated with a control (DropDownControl) it returns the parent control.
        """
        return _core.SplitButtonControl__get_parent(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the ToolbarControl 
        Returns a boolean indicating if the deletion was successful.
        """
        return _core.SplitButtonControl_deleteMe(self)

    def _get_objectType(self) -> "char const *" : return _core.SplitButtonControl__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.SplitButtonControl__get_isValid(self)
SplitButtonControl_swigregister = _core.SplitButtonControl_swigregister
SplitButtonControl_swigregister(SplitButtonControl)

def SplitButtonControl_classType() -> "char const *" :
  return _core.SplitButtonControl_classType()
SplitButtonControl_classType = _core.SplitButtonControl_classType

SplitButtonControl.__swig_getmethods__["defaultCommandDefinition"] = SplitButtonControl._get_defaultCommandDefinition
SplitButtonControl.defaultCommandDefinition = property(SplitButtonControl._get_defaultCommandDefinition, doc="Gets the command definition that is used as the default command on the main portion of the split button.")

SplitButtonControl.__swig_getmethods__["isLastUsedShown"] = SplitButtonControl._get_isLastUsedShown
SplitButtonControl.isLastUsedShown = property(SplitButtonControl._get_isLastUsedShown, doc="Gets if this button behaves where the last executed command becomes the command on the main portion of the split button.")

SplitButtonControl.__swig_getmethods__["additionalDefinitions"] = SplitButtonControl._get_additionalDefinitions
SplitButtonControl.__swig_setmethods__["additionalDefinitions"] = SplitButtonControl._set_additionalDefinitions
SplitButtonControl.additionalDefinitions = property(SplitButtonControl._get_additionalDefinitions, SplitButtonControl._set_additionalDefinitions, doc="Gets or sets the command definitions used to define the buttons associated with the split button.")

SplitButtonControl.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SplitButtonControl) else None
SplitButtonControl.cast = lambda arg: arg if isinstance(arg, SplitButtonControl) else None

class STEPImportOptions(ImportOptions):
    """Defines that a STEP import is to be done and specifies the various options."""
    __swig_setmethods__ = {}
    for _s in [ImportOptions]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, STEPImportOptions, name, value)
    __swig_getmethods__ = {}
    for _s in [ImportOptions]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, STEPImportOptions, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::STEPImportOptions *" : return _core.STEPImportOptions___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.STEPImportOptions___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.STEPImportOptions___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.STEPImportOptions_classType
    if _newclass:classType = staticmethod(_core.STEPImportOptions_classType)
    __swig_destroy__ = _core.delete_STEPImportOptions
    __del__ = lambda self : None;
    def _get_filename(self) -> "std::string" :
        """Gets and sets the filename or url of the file to be imported."""
        return _core.STEPImportOptions__get_filename(self)

    def _set_filename(self, *args) -> "bool" :
        """Gets and sets the filename or url of the file to be imported."""
        return _core.STEPImportOptions__set_filename(self, *args)

    def _get_isViewFit(self) -> "bool" :
        """
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.STEPImportOptions__get_isViewFit(self)

    def _set_isViewFit(self, *args) -> "bool" :
        """
        Specifies if the camera should be adjusted to fit the geometry of the import.
        This defaults to true, which will cause a change in the current view. Setting this
        to false will leave the view as-is and just import the geometry.
        """
        return _core.STEPImportOptions__set_isViewFit(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.STEPImportOptions__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.STEPImportOptions__get_isValid(self)
STEPImportOptions_swigregister = _core.STEPImportOptions_swigregister
STEPImportOptions_swigregister(STEPImportOptions)

def STEPImportOptions_classType() -> "char const *" :
  return _core.STEPImportOptions_classType()
STEPImportOptions_classType = _core.STEPImportOptions_classType

STEPImportOptions.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, STEPImportOptions) else None
STEPImportOptions.cast = lambda arg: arg if isinstance(arg, STEPImportOptions) else None

class StringProperty(Property):
    """A string value property associated with a material or appearance."""
    __swig_setmethods__ = {}
    for _s in [Property]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringProperty, name, value)
    __swig_getmethods__ = {}
    for _s in [Property]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StringProperty, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::StringProperty *" : return _core.StringProperty___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.StringProperty___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.StringProperty___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.StringProperty_classType
    if _newclass:classType = staticmethod(_core.StringProperty_classType)
    __swig_destroy__ = _core.delete_StringProperty
    __del__ = lambda self : None;
    def _get_value(self) -> "std::string" :
        """Gets and sets the property value."""
        return _core.StringProperty__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """Gets and sets the property value."""
        return _core.StringProperty__set_value(self, *args)

    def _get_name(self) -> "std::string" :
        """
        Returns the name of this property as seen in the user interface. This name is localized
        and can change based on the current language
        """
        return _core.StringProperty__get_name(self)

    def _get_isReadOnly(self) -> "bool" :
        """Indicates if this property is read-only. If True any attempted edits will fail."""
        return _core.StringProperty__get_isReadOnly(self)

    def _get_id(self) -> "std::string" :
        """Returns the unique ID of this property."""
        return _core.StringProperty__get_id(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the parent of this property."""
        return _core.StringProperty__get_parent(self)

    def _get_objectType(self) -> "char const *" : return _core.StringProperty__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.StringProperty__get_isValid(self)
StringProperty_swigregister = _core.StringProperty_swigregister
StringProperty_swigregister(StringProperty)

def StringProperty_classType() -> "char const *" :
  return _core.StringProperty_classType()
StringProperty_classType = _core.StringProperty_classType

StringProperty.__swig_getmethods__["value"] = StringProperty._get_value
StringProperty.__swig_setmethods__["value"] = StringProperty._set_value
StringProperty.value = property(StringProperty._get_value, StringProperty._set_value, doc="Gets and sets the property value.")

StringProperty.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, StringProperty) else None
StringProperty.cast = lambda arg: arg if isinstance(arg, StringProperty) else None

class StringValueCommandInput(CommandInput):
    """Provides a command input to get a string value from the user."""
    __swig_setmethods__ = {}
    for _s in [CommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringValueCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [CommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StringValueCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::StringValueCommandInput *" : return _core.StringValueCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.StringValueCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.StringValueCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.StringValueCommandInput_classType
    if _newclass:classType = staticmethod(_core.StringValueCommandInput_classType)
    __swig_destroy__ = _core.delete_StringValueCommandInput
    __del__ = lambda self : None;
    def _get_value(self) -> "std::string" :
        """Gets or sets the value of this input."""
        return _core.StringValueCommandInput__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """Gets or sets the value of this input."""
        return _core.StringValueCommandInput__set_value(self, *args)

    def _get_isPassword(self) -> "bool" :
        """
        Gets or sets if this string input behaves as a password field.
        This defaults to false for a newly created StringValueCommandInput.
        If true, dots are displayed instead of the actual characters but
        the value property will get and set the actual string.
        """
        return _core.StringValueCommandInput__get_isPassword(self)

    def _set_isPassword(self, *args) -> "bool" :
        """
        Gets or sets if this string input behaves as a password field.
        This defaults to false for a newly created StringValueCommandInput.
        If true, dots are displayed instead of the actual characters but
        the value property will get and set the actual string.
        """
        return _core.StringValueCommandInput__set_isPassword(self, *args)

    def _get_isReadOnly(self) -> "bool" :
        """
        Gets and sets if the string value is read-only or not. If it is read-only the user
        cannot edit the text. This property is initialized to False for a newly created
        StringValueCommandInput object.
        """
        return _core.StringValueCommandInput__get_isReadOnly(self)

    def _set_isReadOnly(self, *args) -> "bool" :
        """
        Gets and sets if the string value is read-only or not. If it is read-only the user
        cannot edit the text. This property is initialized to False for a newly created
        StringValueCommandInput object.
        """
        return _core.StringValueCommandInput__set_isReadOnly(self, *args)

    def _get_isValueError(self) -> "bool" :
        """
        Specifies if the current value shown is valid or not. Any string is valid for a 
        StringValueCommandInput, but you many have some criteria that the string needs
        to meet for it to be valid in your application. You you use the command's validateInputs
        event to verify that inputs are valid and control whether the 'OK' button is enabled
        or not, and you can also set this property on specific StringValueCommandInputs objects
        to indicate to the user that a specific value is not correct. When this property is
        true, Fusion 360 will change the color of the text to red to indicate to the user there is
        a problem.
        """
        return _core.StringValueCommandInput__get_isValueError(self)

    def _set_isValueError(self, *args) -> "bool" :
        """
        Specifies if the current value shown is valid or not. Any string is valid for a 
        StringValueCommandInput, but you many have some criteria that the string needs
        to meet for it to be valid in your application. You you use the command's validateInputs
        event to verify that inputs are valid and control whether the 'OK' button is enabled
        or not, and you can also set this property on specific StringValueCommandInputs objects
        to indicate to the user that a specific value is not correct. When this property is
        true, Fusion 360 will change the color of the text to red to indicate to the user there is
        a problem.
        """
        return _core.StringValueCommandInput__set_isValueError(self, *args)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.StringValueCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.StringValueCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.StringValueCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.StringValueCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.StringValueCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.StringValueCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.StringValueCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.StringValueCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.StringValueCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.StringValueCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.StringValueCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.StringValueCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.StringValueCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.StringValueCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.StringValueCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.StringValueCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.StringValueCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.StringValueCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.StringValueCommandInput__get_isValid(self)
StringValueCommandInput_swigregister = _core.StringValueCommandInput_swigregister
StringValueCommandInput_swigregister(StringValueCommandInput)

def StringValueCommandInput_classType() -> "char const *" :
  return _core.StringValueCommandInput_classType()
StringValueCommandInput_classType = _core.StringValueCommandInput_classType

StringValueCommandInput.__swig_getmethods__["value"] = StringValueCommandInput._get_value
StringValueCommandInput.__swig_setmethods__["value"] = StringValueCommandInput._set_value
StringValueCommandInput.value = property(StringValueCommandInput._get_value, StringValueCommandInput._set_value, doc="Gets or sets the value of this input.")

StringValueCommandInput.__swig_getmethods__["isPassword"] = StringValueCommandInput._get_isPassword
StringValueCommandInput.__swig_setmethods__["isPassword"] = StringValueCommandInput._set_isPassword
StringValueCommandInput.isPassword = property(StringValueCommandInput._get_isPassword, StringValueCommandInput._set_isPassword, doc="Gets or sets if this string input behaves as a password field.\nThis defaults to false for a newly created StringValueCommandInput.\nIf true, dots are displayed instead of the actual characters but\nthe value property will get and set the actual string.")

StringValueCommandInput.__swig_getmethods__["isReadOnly"] = StringValueCommandInput._get_isReadOnly
StringValueCommandInput.__swig_setmethods__["isReadOnly"] = StringValueCommandInput._set_isReadOnly
StringValueCommandInput.isReadOnly = property(StringValueCommandInput._get_isReadOnly, StringValueCommandInput._set_isReadOnly, doc="Gets and sets if the string value is read-only or not. If it is read-only the user\ncannot edit the text. This property is initialized to False for a newly created\nStringValueCommandInput object.")

StringValueCommandInput.__swig_getmethods__["isValueError"] = StringValueCommandInput._get_isValueError
StringValueCommandInput.__swig_setmethods__["isValueError"] = StringValueCommandInput._set_isValueError
StringValueCommandInput.isValueError = property(StringValueCommandInput._get_isValueError, StringValueCommandInput._set_isValueError, doc="Specifies if the current value shown is valid or not. Any string is valid for a\nStringValueCommandInput, but you many have some criteria that the string needs\nto meet for it to be valid in your application. You you use the command's validateInputs\nevent to verify that inputs are valid and control whether the 'OK' button is enabled\nor not, and you can also set this property on specific StringValueCommandInputs objects\nto indicate to the user that a specific value is not correct. When this property is\ntrue, Fusion 360 will change the color of the text to red to indicate to the user there is\na problem.")

StringValueCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, StringValueCommandInput) else None
StringValueCommandInput.cast = lambda arg: arg if isinstance(arg, StringValueCommandInput) else None

class TabCommandInput(CommandInput):
    """Tab command inputs contain a set of command inputs and/or group command inputs/"""
    __swig_setmethods__ = {}
    for _s in [CommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TabCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [CommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TabCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::TabCommandInput *" : return _core.TabCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.TabCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.TabCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.TabCommandInput_classType
    if _newclass:classType = staticmethod(_core.TabCommandInput_classType)
    __swig_destroy__ = _core.delete_TabCommandInput
    __del__ = lambda self : None;
    def _get_children(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """
        Gets the CommandInputs collection for this TabCommandInput.
        Use the add methods on this collection to add child CommandInputs to this Tab in the desired order.
        """
        return _core.TabCommandInput__get_children(self)

    def _get_resourceFolder(self) -> "std::string" :
        """
        Gets the folder that contains the image for the tab. If no name is specified (no text on tab), 
        a resourceFolder containing the image to appear on the tab needs to be provided.
        """
        return _core.TabCommandInput__get_resourceFolder(self)

    def _get_isActive(self) -> "bool" :
        """Gets if this is the currently activated (selected) tab."""
        return _core.TabCommandInput__get_isActive(self)

    def activate(self) -> "bool" :
        """Sets this to be the currently activated (selected) tab."""
        return _core.TabCommandInput_activate(self)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.TabCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.TabCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.TabCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.TabCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.TabCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.TabCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.TabCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.TabCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.TabCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.TabCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.TabCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.TabCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.TabCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.TabCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.TabCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.TabCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.TabCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.TabCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.TabCommandInput__get_isValid(self)
TabCommandInput_swigregister = _core.TabCommandInput_swigregister
TabCommandInput_swigregister(TabCommandInput)

def TabCommandInput_classType() -> "char const *" :
  return _core.TabCommandInput_classType()
TabCommandInput_classType = _core.TabCommandInput_classType

TabCommandInput.__swig_getmethods__["children"] = TabCommandInput._get_children
TabCommandInput.children = property(TabCommandInput._get_children, doc="Gets the CommandInputs collection for this TabCommandInput.\nUse the add methods on this collection to add child CommandInputs to this Tab in the desired order.")

TabCommandInput.__swig_getmethods__["resourceFolder"] = TabCommandInput._get_resourceFolder
TabCommandInput.resourceFolder = property(TabCommandInput._get_resourceFolder, doc="Gets the folder that contains the image for the tab. If no name is specified (no text on tab),\na resourceFolder containing the image to appear on the tab needs to be provided.")

TabCommandInput.__swig_getmethods__["isActive"] = TabCommandInput._get_isActive
TabCommandInput.isActive = property(TabCommandInput._get_isActive, doc="Gets if this is the currently activated (selected) tab.")

TabCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TabCommandInput) else None
TabCommandInput.cast = lambda arg: arg if isinstance(arg, TabCommandInput) else None

class TableCommandInput(CommandInput):
    """
    Represents a table within a command dialog. The table consists of
    rows and columns where each cell can contain another command input. The 
    selection and button row command inputs cannot be used within a table.
    In addition to the rows and columns, each table can optionally have a
    toolbar of seperate command inputs that is shown at the bottom of the table.
    A table command input can conceptually be compared to an Excel table where you
    have an infinite number of rows and columns available but use a small portion.
    As you add inputs to the table, the table will adjust so all used columns are
    visible. The visible number of rows is controlled by you and if you create
    more rows than can be displayed a scroll bar becomes available.
    For an example of this command input, see the loft command which uses it to show
    the selected profiles and rails.
    """
    __swig_setmethods__ = {}
    for _s in [CommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TableCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [CommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TableCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::TableCommandInput *" : return _core.TableCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.TableCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.TableCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.TableCommandInput_classType
    if _newclass:classType = staticmethod(_core.TableCommandInput_classType)
    __swig_destroy__ = _core.delete_TableCommandInput
    __del__ = lambda self : None;
    def _get_numberOfColumns(self) -> "int" :
        """
        Returns the current number of visible columns displayed. Setting this property
        has no effect because the number of columns is automatically inferred by
        the command inputs that have been added to the table. The table automatically
        adjusts the number of rows displayed so all inputs can be seen.
        """
        return _core.TableCommandInput__get_numberOfColumns(self)

    def _set_numberOfColumns(self, *args) -> "bool" :
        """
        Returns the current number of visible columns displayed. Setting this property
        has no effect because the number of columns is automatically inferred by
        the command inputs that have been added to the table. The table automatically
        adjusts the number of rows displayed so all inputs can be seen.
        """
        return _core.TableCommandInput__set_numberOfColumns(self, *args)

    def _get_columnRatio(self) -> "std::string" :
        """
        Gets and sets the width ratio of the columns. This is defined using a string
        such as '1:1:1' where this defines that the first three columns are all the same width.
        A value of '2:1' defines that the first column is twice the width of the second.
        If the table has more columns than are defined by this property, they will automatically
        default to a value of 1. If this property defines the width of more columns than are
        displayed, the extra definitions are ignored.
        You can also specify 0 as a column width and this will have the effect of hiding
        that column. Setting a column width to 0 does not delete the column or the command inputs
        but only hides them so they can be turned back on at a later time by resetting the
        column ratio.
        """
        return _core.TableCommandInput__get_columnRatio(self)

    def _set_columnRatio(self, *args) -> "bool" :
        """
        Gets and sets the width ratio of the columns. This is defined using a string
        such as '1:1:1' where this defines that the first three columns are all the same width.
        A value of '2:1' defines that the first column is twice the width of the second.
        If the table has more columns than are defined by this property, they will automatically
        default to a value of 1. If this property defines the width of more columns than are
        displayed, the extra definitions are ignored.
        You can also specify 0 as a column width and this will have the effect of hiding
        that column. Setting a column width to 0 does not delete the column or the command inputs
        but only hides them so they can be turned back on at a later time by resetting the
        column ratio.
        """
        return _core.TableCommandInput__set_columnRatio(self, *args)

    def _get_hasGrid(self) -> "bool" :
        """
        Gets and sets whether a grid is displayed for the table. For a newly created
        table, this property defaults to false.
        """
        return _core.TableCommandInput__get_hasGrid(self)

    def _set_hasGrid(self, *args) -> "bool" :
        """
        Gets and sets whether a grid is displayed for the table. For a newly created
        table, this property defaults to false.
        """
        return _core.TableCommandInput__set_hasGrid(self, *args)

    def _get_rowSpacing(self) -> "int" :
        """
        Gets and sets the spacing between rows. This is defined in pixels. For a newly
        created table, this property defaults to 1.
        """
        return _core.TableCommandInput__get_rowSpacing(self)

    def _set_rowSpacing(self, *args) -> "bool" :
        """
        Gets and sets the spacing between rows. This is defined in pixels. For a newly
        created table, this property defaults to 1.
        """
        return _core.TableCommandInput__set_rowSpacing(self, *args)

    def _get_columnSpacing(self) -> "int" :
        """
        Gets and sets the spacing between columns. This is defined in pixels. For a newly
        created table, this property defaults to 1.
        """
        return _core.TableCommandInput__get_columnSpacing(self)

    def _set_columnSpacing(self, *args) -> "bool" :
        """
        Gets and sets the spacing between columns. This is defined in pixels. For a newly
        created table, this property defaults to 1.
        """
        return _core.TableCommandInput__set_columnSpacing(self, *args)

    def _get_minimumVisibleRows(self) -> "int" :
        """
        Gets and sets the minimum number of rows displayed. This is the minimum amount of
        space taken up on the command dialog, even if the table doesn't yet contain any
        rows. For a newly created table, this property defaults to 2.
        """
        return _core.TableCommandInput__get_minimumVisibleRows(self)

    def _set_minimumVisibleRows(self, *args) -> "bool" :
        """
        Gets and sets the minimum number of rows displayed. This is the minimum amount of
        space taken up on the command dialog, even if the table doesn't yet contain any
        rows. For a newly created table, this property defaults to 2.
        """
        return _core.TableCommandInput__set_minimumVisibleRows(self, *args)

    def _get_maximumVisibleRows(self) -> "int" :
        """
        Gets and sets the maximum number of rows that can be displayed. As rows are added
        the visible size of the table will grow to show all rows until this maximum number
        of rows is reached and then a scroll bar will be displayed to allow the user to
        access all rows. For a new created table, this property defaults to 4.
        """
        return _core.TableCommandInput__get_maximumVisibleRows(self)

    def _set_maximumVisibleRows(self, *args) -> "bool" :
        """
        Gets and sets the maximum number of rows that can be displayed. As rows are added
        the visible size of the table will grow to show all rows until this maximum number
        of rows is reached and then a scroll bar will be displayed to allow the user to
        access all rows. For a new created table, this property defaults to 4.
        """
        return _core.TableCommandInput__set_maximumVisibleRows(self, *args)

    def deleteRow(self, *args) -> "bool" :
        """
        Deletes the specified row. The following rows will be shifted up. The row and the 
        command inputs it contains are deleted. To temporarily hide a row you can set the 
        visibility of all of the command inputs it contains to be invisible. If all inputs
        are invisible the row will automatically be hidden. 
        row : The row to delete where valid values are 0 to the number of rows minus 1. A value of
        0 will delete the first row. A value greater than the number of rows will delete the
        last row. 
        Returns true if the delete was successful.
        """
        return _core.TableCommandInput_deleteRow(self, *args)

    def _get_tablePresentationStyle(self) -> "adsk::core::TablePresentationStyles" :
        """Gets and sets the presentation style the table is currently using for its display."""
        return _core.TableCommandInput__get_tablePresentationStyle(self)

    def _set_tablePresentationStyle(self, *args) -> "bool" :
        """Gets and sets the presentation style the table is currently using for its display."""
        return _core.TableCommandInput__set_tablePresentationStyle(self, *args)

    def addCommandInput(self, *args) -> "bool" :
        """
        Adds a command input to a particular cell in the table. Rows are automatically added to the table to
        able to contain the command input. The command input can span multiple columns within a row and spanning
        across multiple rows is not currently supported.
        The command input is created in the standard way but when it's added to the table using this method it 
        will be displayed in the table instead of the main area of the dialog. 
        input : The command input to associate to a cell. The command input is created in the standard way but when it's added to 
        the table using this method it will be displayed in the table instead of the main area of the dialog. 
        row : The row index of the cell where 0 is the first row. 
        column : The column index of the cell where 0 is the first column. 
        rowSpan : The number of additional rows that this input uses. The default value of 0 indicates that no additional
        rows are used. Row spanning is not currently supported so this value must always be 0. 
        columnSpan : The number of additional columns that this input uses. The default value of 0 indicates that no additional
        columns are used. 
        Returns true if the association of the command input to the cell was successful.
        """
        return _core.TableCommandInput_addCommandInput(self, *args)

    def removeInput(self, *args) -> "bool" :
        """
        Removes the command input that is at the specified row and column. This doesn't delete the command input from
        the collection of inputs associated with the command but just removes it from being displayed in the table. 
        row : The row where the command input to be removed is located. 
        column : The row where the command input to be removed is located. 
        Returns true if the removal was successful.
        """
        return _core.TableCommandInput_removeInput(self, *args)

    def getPosition(self, *args) -> "bool" :
        """
        Gets the position of the specified command input within the table. 
        input : The existing command input you want to find the associated cell for. 
        row : The returned row index of the cell. 
        column : The returned column index of the cell. 
        rowSpan : The returned number of additional rows used by the input. A value of 0
        indicates that no additional rows are used. 
        columnSpan : The returned number of additional columns used by the input. A value of 0
        indicates that no additional columns are used. 
        Returns true if the position was successfully returned.
        """
        return _core.TableCommandInput_getPosition(self, *args)

    def _get_rowCount(self) -> "int" :
        """
        Returns the number of rows in the table. The actual number of rows in the table is defined
        by the number of rows that contain command inputs.
        """
        return _core.TableCommandInput__get_rowCount(self)

    def clear(self) -> "bool" :
        """
        Removes all rows in the table and the toolbar. 
        Returns true if successful.
        """
        return _core.TableCommandInput_clear(self)

    def _get_selectedRow(self) -> "int" :
        """
        Gets and sets which row is selected in the user-interface. A value of 0 indicates
        that the first row is selected. A value of -1 indicates that no row is selected.
        """
        return _core.TableCommandInput__get_selectedRow(self)

    def _set_selectedRow(self, *args) -> "bool" :
        """
        Gets and sets which row is selected in the user-interface. A value of 0 indicates
        that the first row is selected. A value of -1 indicates that no row is selected.
        """
        return _core.TableCommandInput__set_selectedRow(self, *args)

    def addToolbarCommandInput(self, *args) -> "bool" :
        """
        Adds a new command input to the toolbar at the bottom of the table. 
        input : Adds a command input to the toolbar at the bottom of the table. The inputs are displayed
        in the same order that they're added.
        The command input is created in the standard way but when it's added to the table using this method it 
        will be displayed in the table instead of the main area of the dialog. 
        Returns true if the command input was successfully added.
        """
        return _core.TableCommandInput_addToolbarCommandInput(self, *args)

    def getInputAtPosition(self, *args) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Returns the command input that is in the specified row and column. In the case
        where a command input spans multiple columns, the same input can be returned
        from mulitple positions. 
        row : The row index to return the command input from where the first row is 0. 
        column : The row index to return the command input from where the first row is 0. 
        Returns the command input that is in the specified row and column. If there
        isn't a command input in the specified location, null is returned.
        """
        return _core.TableCommandInput_getInputAtPosition(self, *args)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.TableCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.TableCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.TableCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.TableCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.TableCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.TableCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.TableCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.TableCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.TableCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.TableCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.TableCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.TableCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.TableCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.TableCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.TableCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.TableCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.TableCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.TableCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.TableCommandInput__get_isValid(self)
TableCommandInput_swigregister = _core.TableCommandInput_swigregister
TableCommandInput_swigregister(TableCommandInput)

def TableCommandInput_classType() -> "char const *" :
  return _core.TableCommandInput_classType()
TableCommandInput_classType = _core.TableCommandInput_classType

TableCommandInput.__swig_getmethods__["numberOfColumns"] = TableCommandInput._get_numberOfColumns
TableCommandInput.__swig_setmethods__["numberOfColumns"] = TableCommandInput._set_numberOfColumns
TableCommandInput.numberOfColumns = property(TableCommandInput._get_numberOfColumns, TableCommandInput._set_numberOfColumns, doc="Returns the current number of visible columns displayed. Setting this property\nhas no effect because the number of columns is automatically inferred by\nthe command inputs that have been added to the table. The table automatically\nadjusts the number of rows displayed so all inputs can be seen.")

TableCommandInput.__swig_getmethods__["columnRatio"] = TableCommandInput._get_columnRatio
TableCommandInput.__swig_setmethods__["columnRatio"] = TableCommandInput._set_columnRatio
TableCommandInput.columnRatio = property(TableCommandInput._get_columnRatio, TableCommandInput._set_columnRatio, doc="Gets and sets the width ratio of the columns. This is defined using a string\nsuch as '1:1:1' where this defines that the first three columns are all the same width.\nA value of '2:1' defines that the first column is twice the width of the second.\nIf the table has more columns than are defined by this property, they will automatically\ndefault to a value of 1. If this property defines the width of more columns than are\ndisplayed, the extra definitions are ignored.\nYou can also specify 0 as a column width and this will have the effect of hiding\nthat column. Setting a column width to 0 does not delete the column or the command inputs\nbut only hides them so they can be turned back on at a later time by resetting the\ncolumn ratio.")

TableCommandInput.__swig_getmethods__["hasGrid"] = TableCommandInput._get_hasGrid
TableCommandInput.__swig_setmethods__["hasGrid"] = TableCommandInput._set_hasGrid
TableCommandInput.hasGrid = property(TableCommandInput._get_hasGrid, TableCommandInput._set_hasGrid, doc="Gets and sets whether a grid is displayed for the table. For a newly created\ntable, this property defaults to false.")

TableCommandInput.__swig_getmethods__["rowSpacing"] = TableCommandInput._get_rowSpacing
TableCommandInput.__swig_setmethods__["rowSpacing"] = TableCommandInput._set_rowSpacing
TableCommandInput.rowSpacing = property(TableCommandInput._get_rowSpacing, TableCommandInput._set_rowSpacing, doc="Gets and sets the spacing between rows. This is defined in pixels. For a newly\ncreated table, this property defaults to 1.")

TableCommandInput.__swig_getmethods__["columnSpacing"] = TableCommandInput._get_columnSpacing
TableCommandInput.__swig_setmethods__["columnSpacing"] = TableCommandInput._set_columnSpacing
TableCommandInput.columnSpacing = property(TableCommandInput._get_columnSpacing, TableCommandInput._set_columnSpacing, doc="Gets and sets the spacing between columns. This is defined in pixels. For a newly\ncreated table, this property defaults to 1.")

TableCommandInput.__swig_getmethods__["minimumVisibleRows"] = TableCommandInput._get_minimumVisibleRows
TableCommandInput.__swig_setmethods__["minimumVisibleRows"] = TableCommandInput._set_minimumVisibleRows
TableCommandInput.minimumVisibleRows = property(TableCommandInput._get_minimumVisibleRows, TableCommandInput._set_minimumVisibleRows, doc="Gets and sets the minimum number of rows displayed. This is the minimum amount of\nspace taken up on the command dialog, even if the table doesn't yet contain any\nrows. For a newly created table, this property defaults to 2.")

TableCommandInput.__swig_getmethods__["maximumVisibleRows"] = TableCommandInput._get_maximumVisibleRows
TableCommandInput.__swig_setmethods__["maximumVisibleRows"] = TableCommandInput._set_maximumVisibleRows
TableCommandInput.maximumVisibleRows = property(TableCommandInput._get_maximumVisibleRows, TableCommandInput._set_maximumVisibleRows, doc="Gets and sets the maximum number of rows that can be displayed. As rows are added\nthe visible size of the table will grow to show all rows until this maximum number\nof rows is reached and then a scroll bar will be displayed to allow the user to\naccess all rows. For a new created table, this property defaults to 4.")

TableCommandInput.__swig_getmethods__["tablePresentationStyle"] = TableCommandInput._get_tablePresentationStyle
TableCommandInput.__swig_setmethods__["tablePresentationStyle"] = TableCommandInput._set_tablePresentationStyle
TableCommandInput.tablePresentationStyle = property(TableCommandInput._get_tablePresentationStyle, TableCommandInput._set_tablePresentationStyle, doc="Gets and sets the presentation style the table is currently using for its display.")

TableCommandInput.__swig_getmethods__["rowCount"] = TableCommandInput._get_rowCount
TableCommandInput.rowCount = property(TableCommandInput._get_rowCount, doc="Returns the number of rows in the table. The actual number of rows in the table is defined\nby the number of rows that contain command inputs.")

TableCommandInput.__swig_getmethods__["selectedRow"] = TableCommandInput._get_selectedRow
TableCommandInput.__swig_setmethods__["selectedRow"] = TableCommandInput._set_selectedRow
TableCommandInput.selectedRow = property(TableCommandInput._get_selectedRow, TableCommandInput._set_selectedRow, doc="Gets and sets which row is selected in the user-interface. A value of 0 indicates\nthat the first row is selected. A value of -1 indicates that no row is selected.")

TableCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TableCommandInput) else None
TableCommandInput.cast = lambda arg: arg if isinstance(arg, TableCommandInput) else None

class TextBoxCommandInput(CommandInput):
    """Provides a command input to interact with a text box."""
    __swig_setmethods__ = {}
    for _s in [CommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TextBoxCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [CommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TextBoxCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::TextBoxCommandInput *" : return _core.TextBoxCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.TextBoxCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.TextBoxCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.TextBoxCommandInput_classType
    if _newclass:classType = staticmethod(_core.TextBoxCommandInput_classType)
    __swig_destroy__ = _core.delete_TextBoxCommandInput
    __del__ = lambda self : None;
    def _get_formattedText(self) -> "std::string" :
        """
        Gets and sets the formatted text displayed in the dialog. Formatted text includes
        any html formatting that has been defined. For example, you can use basic html formatting such as
        <b>Bold</b>, <i>Italic</i>, and <br /> for a line break.
        """
        return _core.TextBoxCommandInput__get_formattedText(self)

    def _set_formattedText(self, *args) -> "bool" :
        """
        Gets and sets the formatted text displayed in the dialog. Formatted text includes
        any html formatting that has been defined. For example, you can use basic html formatting such as
        <b>Bold</b>, <i>Italic</i>, and <br /> for a line break.
        """
        return _core.TextBoxCommandInput__set_formattedText(self, *args)

    def _get_text(self) -> "std::string" :
        """
        Gets and sets the text in the text box. This returns the string
        as seen in the text box with any formatting stripped out.
        """
        return _core.TextBoxCommandInput__get_text(self)

    def _set_text(self, *args) -> "bool" :
        """
        Gets and sets the text in the text box. This returns the string
        as seen in the text box with any formatting stripped out.
        """
        return _core.TextBoxCommandInput__set_text(self, *args)

    def _get_numRows(self) -> "int" :
        """
        Gets and sets the height of the text box as defined by the number of rows of
        text that can be displayed. If the text is larger than will fit in the box
        a scroll bar will automatically be displayed.
        """
        return _core.TextBoxCommandInput__get_numRows(self)

    def _set_numRows(self, *args) -> "bool" :
        """
        Gets and sets the height of the text box as defined by the number of rows of
        text that can be displayed. If the text is larger than will fit in the box
        a scroll bar will automatically be displayed.
        """
        return _core.TextBoxCommandInput__set_numRows(self, *args)

    def _get_isReadOnly(self) -> "bool" :
        """
        Gets and sets if the text box is read-only or not. If it is read-only the user
        cannot edit the text.
        """
        return _core.TextBoxCommandInput__get_isReadOnly(self)

    def _set_isReadOnly(self, *args) -> "bool" :
        """
        Gets and sets if the text box is read-only or not. If it is read-only the user
        cannot edit the text.
        """
        return _core.TextBoxCommandInput__set_isReadOnly(self, *args)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.TextBoxCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.TextBoxCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.TextBoxCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.TextBoxCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.TextBoxCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.TextBoxCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.TextBoxCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.TextBoxCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.TextBoxCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.TextBoxCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.TextBoxCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.TextBoxCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.TextBoxCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.TextBoxCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.TextBoxCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.TextBoxCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.TextBoxCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.TextBoxCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.TextBoxCommandInput__get_isValid(self)
TextBoxCommandInput_swigregister = _core.TextBoxCommandInput_swigregister
TextBoxCommandInput_swigregister(TextBoxCommandInput)

def TextBoxCommandInput_classType() -> "char const *" :
  return _core.TextBoxCommandInput_classType()
TextBoxCommandInput_classType = _core.TextBoxCommandInput_classType

TextBoxCommandInput.__swig_getmethods__["formattedText"] = TextBoxCommandInput._get_formattedText
TextBoxCommandInput.__swig_setmethods__["formattedText"] = TextBoxCommandInput._set_formattedText
TextBoxCommandInput.formattedText = property(TextBoxCommandInput._get_formattedText, TextBoxCommandInput._set_formattedText, doc="Gets and sets the formatted text displayed in the dialog. Formatted text includes\nany html formatting that has been defined. For example, you can use basic html formatting such as\n<b>Bold</b>, <i>Italic</i>, and <br /> for a line break.")

TextBoxCommandInput.__swig_getmethods__["text"] = TextBoxCommandInput._get_text
TextBoxCommandInput.__swig_setmethods__["text"] = TextBoxCommandInput._set_text
TextBoxCommandInput.text = property(TextBoxCommandInput._get_text, TextBoxCommandInput._set_text, doc="Gets and sets the text in the text box. This returns the string\nas seen in the text box with any formatting stripped out.")

TextBoxCommandInput.__swig_getmethods__["numRows"] = TextBoxCommandInput._get_numRows
TextBoxCommandInput.__swig_setmethods__["numRows"] = TextBoxCommandInput._set_numRows
TextBoxCommandInput.numRows = property(TextBoxCommandInput._get_numRows, TextBoxCommandInput._set_numRows, doc="Gets and sets the height of the text box as defined by the number of rows of\ntext that can be displayed. If the text is larger than will fit in the box\na scroll bar will automatically be displayed.")

TextBoxCommandInput.__swig_getmethods__["isReadOnly"] = TextBoxCommandInput._get_isReadOnly
TextBoxCommandInput.__swig_setmethods__["isReadOnly"] = TextBoxCommandInput._set_isReadOnly
TextBoxCommandInput.isReadOnly = property(TextBoxCommandInput._get_isReadOnly, TextBoxCommandInput._set_isReadOnly, doc="Gets and sets if the text box is read-only or not. If it is read-only the user\ncannot edit the text.")

TextBoxCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TextBoxCommandInput) else None
TextBoxCommandInput.cast = lambda arg: arg if isinstance(arg, TextBoxCommandInput) else None

class TextCommandPalette(Palette):
    """
    <p class='api'>Represents the palette that is the Text Command window in Fusion 360. You can obtain the
    Text Command palette by using the itemById method of the Palettes object and using 
    'TextCommands' as the ID. Below is some sample code that illustrates making sure the palette is visible
    and writing some text to it.</p>
    <pre class='api-code'><span style='color:blue'># Get the palette that represents the TEXT COMMANDS window.</span>
    textPalette = ui.palettes.itemById('TextCommands')
    <span style = 'color:blue' ># Make sure the palette is visible.</span>
    if not textPalette.isVisible:
    textPalette.isVisible = True
    < span style= 'color:blue' ># Write some text.</span>
    textPalette.writeText('This is a text message.')</ pre >
    """
    __swig_setmethods__ = {}
    for _s in [Palette]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TextCommandPalette, name, value)
    __swig_getmethods__ = {}
    for _s in [Palette]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TextCommandPalette, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::TextCommandPalette *" : return _core.TextCommandPalette___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.TextCommandPalette___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.TextCommandPalette___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.TextCommandPalette_classType
    if _newclass:classType = staticmethod(_core.TextCommandPalette_classType)
    __swig_destroy__ = _core.delete_TextCommandPalette
    __del__ = lambda self : None;
    def writeText(self, *args) -> "bool" :
        """
        <p class='api'>Write the specified text to the TEXT COMMAND window. Below is some sample code that 
        illustrates making sure the palette is visible and writing some text to it.</p>
        <pre class='api-code'><span style='color:blue'># Get the palette that represents the TEXT COMMANDS window.</span>
        textPalette = ui.palettes.itemById('TextCommands')
        <span style = 'color:blue' ># Make sure the palette is visible.</span>
        if not textPalette.isVisible:
        textPalette.isVisible = True
        < span style= 'color:blue' ># Write some text.</span>
        textPalette.writeText('This is a text message.')</ pre > 
        text : The text to write to the Text Command window. 
        Returns true if successful.
        """
        return _core.TextCommandPalette_writeText(self, *args)

    def _get_id(self) -> "std::string" :
        """Gets The unique, language independent, ID of this palette."""
        return _core.TextCommandPalette__get_id(self)

    def _get_isVisible(self) -> "bool" :
        """Gets and sets whether this palette is currently being displayed in the user interface."""
        return _core.TextCommandPalette__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets and sets whether this palette is currently being displayed in the user interface."""
        return _core.TextCommandPalette__set_isVisible(self, *args)

    def _get_htmlFileURL(self) -> "std::string" :
        """Gets and sets the URL to the html file currently being displayed. This can be local or on the web."""
        return _core.TextCommandPalette__get_htmlFileURL(self)

    def _set_htmlFileURL(self, *args) -> "bool" :
        """Gets and sets the URL to the html file currently being displayed. This can be local or on the web."""
        return _core.TextCommandPalette__set_htmlFileURL(self, *args)

    def sendInfoToHTML(self, *args) -> "std::string" :
        """
        <p>Sends the string to the JavaScript associated with the loaded HTML. A variation of the
        event handler below should be implemented in the JavaScript associated with the HTML to
        receive the data. The event will be triggered by Fusion 360 whenever the sendInfoToHTML method 
        is called.</p>
        <pre class='api-code'>window.fusionJavaScriptHandler = {
        handle: function(actionString, dataString){
        confirm('Action from Fusion: ' + actionString);
        confirm('Data from Fusion: ' + dataString);
        // Build up JSON return string.
        var result = {};
        result.status = 'OK';
        var response = JSON.stringify(result);
        return response;
        }
        };</pre> 
        <p>Your JavaScript code should always return something in response because an empty string
        response is assumed to be a failure.</p> 
        action : The 'action' string to pass to the JavaScript associated with the HTML. This string can be 
        anything but will typically be JSON formatted information. 
        data : The 'data' string to pass to the JavaScript associated with the HTML. This string can be 
        anything but will typically be JSON formatted information. 
        Returns a string that can be anything that your JavaScript code generates. The JavaScript
        should always return some content because an empty string is used to indicate a failure.
        If useNewWebBrowser flag is set to true while creating palette control then this API call
        would be asynchronous and empty string is returned. Response would come in data field of HTMLEvent with action
        equal to 'response'
        """
        return _core.TextCommandPalette_sendInfoToHTML(self, *args)

    def _get_incomingFromHTML(self) -> "adsk::core::Ptr< adsk::core::HTMLEvent >" :
        """
        This event is fired when the JavaScript associated with the HTML calls the 
        adsk.fusionSendData function. This allows the HTML to communicate with the add-in by
        passing information to the add-in.
        """
        return _core.TextCommandPalette__get_incomingFromHTML(self)

    def _get_closed(self) -> "adsk::core::Ptr< adsk::core::UserInterfaceGeneralEvent >" :
        """
        This event is fired when the user clicks the 'Close' button on the palette. You can choose
        if the 'Close' button is available or not when you initially create the palette. When a
        palette is closed, it still exists but is change to invisible so you can still interact with it and
        retrieve any needed information and can make it visible again. Use the deleteMe method to
        delete the palette.
        """
        return _core.TextCommandPalette__get_closed(self)

    def _get_name(self) -> "std::string" :
        """
        Gets and set the name of the palette as seen in the user interface. The name of native palletes
        cannot be set.
        """
        return _core.TextCommandPalette__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """
        Gets and set the name of the palette as seen in the user interface. The name of native palletes
        cannot be set.
        """
        return _core.TextCommandPalette__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this palette. Fusion 360 native palettes cannot be deleted. Use the
        isNative property to determine if this is a native or API created palette. 
        Returns true if the delete was successful.
        """
        return _core.TextCommandPalette_deleteMe(self)

    def _get_isNative(self) -> "bool" :
        """
        Indicates if this is one of the standard Fusion 360 palettes or a custom palette
        created through the API. If true, it is a standard Fusion 360 palette and will
        have some restrictions on changing its properties and cannot be deleted.
        """
        return _core.TextCommandPalette__get_isNative(self)

    def _get_dockingOption(self) -> "adsk::core::PaletteDockingOptions" :
        """Defines the docking behavior for this palette. This controls how the user is allowed to dock the palette."""
        return _core.TextCommandPalette__get_dockingOption(self)

    def _set_dockingOption(self, *args) -> "bool" :
        """Defines the docking behavior for this palette. This controls how the user is allowed to dock the palette."""
        return _core.TextCommandPalette__set_dockingOption(self, *args)

    def _get_dockingState(self) -> "adsk::core::PaletteDockingStates" :
        """Gets and sets how the palette is currented docked."""
        return _core.TextCommandPalette__get_dockingState(self)

    def _set_dockingState(self, *args) -> "bool" :
        """Gets and sets how the palette is currented docked."""
        return _core.TextCommandPalette__set_dockingState(self, *args)

    def _get_width(self) -> "int" :
        """
        Gets and sets the width of the palette. Setting this property may not always set the width. Depending on
        how the palette is docked or snapped, the width may not be editable.
        """
        return _core.TextCommandPalette__get_width(self)

    def _set_width(self, *args) -> "bool" :
        """
        Gets and sets the width of the palette. Setting this property may not always set the width. Depending on
        how the palette is docked or snapped, the width may not be editable.
        """
        return _core.TextCommandPalette__set_width(self, *args)

    def _get_height(self) -> "int" :
        """
        Gets and sets the height of the palette. Setting this property may not always set the height. Depending on
        how the palette is docked or snapped, the height may not be editable.
        """
        return _core.TextCommandPalette__get_height(self)

    def _set_height(self, *args) -> "bool" :
        """
        Gets and sets the height of the palette. Setting this property may not always set the height. Depending on
        how the palette is docked or snapped, the height may not be editable.
        """
        return _core.TextCommandPalette__set_height(self, *args)

    def setPosition(self, *args) -> "bool" :
        """
        Sets the position of the palette. If the palette is docked or snapped, this will result in changing it
        to be floating. 
        left : The position of the left side of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the left side of the screen and not the 
        Fusion 360 window. 
        top : The position of the top of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the top of the screen and not the 
        Fusion 360 window. 
        Returns true if setting the position was successful.
        """
        return _core.TextCommandPalette_setPosition(self, *args)

    def setSize(self, *args) -> "bool" :
        """
        Sets the size of the palette. This is best used for a floating palette because either the width or
        height can be locked when a palette is docked. 
        width : Specifies the width of the palette. Depending on how the palette is docked or snapped, the width 
        may not be editable. 
        height : Specifies the height of the palette. Depending on how the palette is docked or snapped, the height 
        may not be editable. 
        Returns true if the sizing was succesful. It is still considered a success even if the width or
        height could not be changed because of how the palette is docked or snapped.
        """
        return _core.TextCommandPalette_setSize(self, *args)

    def _get_left(self) -> "int" :
        """
        Gets and sets the left side of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the left side of the screen and not the 
        Fusion 360 window.
        """
        return _core.TextCommandPalette__get_left(self)

    def _set_left(self, *args) -> "bool" :
        """
        Gets and sets the left side of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the left side of the screen and not the 
        Fusion 360 window.
        """
        return _core.TextCommandPalette__set_left(self, *args)

    def _get_top(self) -> "int" :
        """
        Gets and sets the top of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the top of the screen and not the 
        Fusion 360 window.
        """
        return _core.TextCommandPalette__get_top(self)

    def _set_top(self, *args) -> "bool" :
        """
        Gets and sets the top of the palette relative to screen space and in pixels. Because palettes can be
        positioned outside of the Fusion 360 window, a value of zero indicates the top of the screen and not the 
        Fusion 360 window.
        """
        return _core.TextCommandPalette__set_top(self, *args)

    def snapTo(self, *args) -> "bool" :
        """
        Snaps this palette to another palette. 
        palette : Specifies the palette to snap to. 
        snapOption : Specifies how this palette should be snapped to the other palette. 
        Returns true if the palette was successfully snapped to the other palette.
        """
        return _core.TextCommandPalette_snapTo(self, *args)

    def setMinimumSize(self, *args) -> "bool" :
        """
        Sets the minimum size of the palette. The user cannot resize it to be smaller than
        this size. This does not change the current size of the palette unless the palette
        is already smaller than this size.
        Calling this method and setting the width and height to zero, removes the minimum
        size restriction. 
        width : Specifies the minimum width of the palette. 
        height : Specifies the minimum height of the palette. 
        Returns true if setting the minimum size was succesful.
        """
        return _core.TextCommandPalette_setMinimumSize(self, *args)

    def setMaximumSize(self, *args) -> "bool" :
        """
        Sets the maximum size of the palette. The user cannot resize it to be larger than
        this size. This does not change the current size of the palette unless the palette
        is already larger than this size.
        Calling this method and setting the width and height to zero, removes the maximum
        size restriction. 
        width : Specifies the maximum width of the palette. 
        height : Specifies the maximum height of the palette. 
        Returns true if setting the maximum size was succesful.
        """
        return _core.TextCommandPalette_setMaximumSize(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.TextCommandPalette__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.TextCommandPalette__get_isValid(self)
TextCommandPalette_swigregister = _core.TextCommandPalette_swigregister
TextCommandPalette_swigregister(TextCommandPalette)

def TextCommandPalette_classType() -> "char const *" :
  return _core.TextCommandPalette_classType()
TextCommandPalette_classType = _core.TextCommandPalette_classType

TextCommandPalette.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TextCommandPalette) else None
TextCommandPalette.cast = lambda arg: arg if isinstance(arg, TextCommandPalette) else None

class Torus(Surface):
    """
    Transient torus. A transient torus is not displayed or saved in a document. 
    A transient torus is used as a wrapper to work with raw torus information. 
    A transient torus is a full torus with no boundaries.
    They are created statically using the create method of the Torus class.
    """
    __swig_setmethods__ = {}
    for _s in [Surface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Torus, name, value)
    __swig_getmethods__ = {}
    for _s in [Surface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Torus, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Torus *" : return _core.Torus___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.Torus___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.Torus___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.Torus_classType
    if _newclass:classType = staticmethod(_core.Torus_classType)
    __swig_getmethods__["create"] = lambda x: _core.Torus_create
    if _newclass:create = staticmethod(_core.Torus_create)
    __swig_destroy__ = _core.delete_Torus
    __del__ = lambda self : None;
    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets the origin point (center) of the torus."""
        return _core.Torus__get_origin(self)

    def _set_origin(self, *args) -> "bool" :
        """Gets and sets the origin point (center) of the torus."""
        return _core.Torus__set_origin(self, *args)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Gets and sets the center axis of the torus."""
        return _core.Torus__get_axis(self)

    def _set_axis(self, *args) -> "bool" :
        """Gets and sets the center axis of the torus."""
        return _core.Torus__set_axis(self, *args)

    def _get_majorRadius(self) -> "double" :
        """Gets and sets the major radius of the torus."""
        return _core.Torus__get_majorRadius(self)

    def _set_majorRadius(self, *args) -> "bool" :
        """Gets and sets the major radius of the torus."""
        return _core.Torus__set_majorRadius(self, *args)

    def _get_minorRadius(self) -> "double" :
        """Gets and sets the minor radius of the torus."""
        return _core.Torus__get_minorRadius(self)

    def _set_minorRadius(self, *args) -> "bool" :
        """Gets and sets the minor radius of the torus."""
        return _core.Torus__set_minorRadius(self, *args)

    def getData(self) -> "bool" :
        """
        Gets all of the data defining the torus. 
        origin : The output origin point (center) of the torus. 
        axis : The output center axis of the torus. 
        majorRadius : The output major radius of the torus. 
        minorRadius : The output minor radius of the torus. 
        Returns true if successful.
        """
        return _core.Torus_getData(self)

    def set(self, *args) -> "bool" :
        """
        Sets all of the data defining the torus. 
        origin : The origin point (center) of the torus. 
        axis : The center axis of the torus. 
        majorRadius : The major radius of the torus. 
        minorRadius : The minor radius of the torus. 
        Returns true if successful.
        """
        return _core.Torus_set(self, *args)

    def copy(self) -> "adsk::core::Ptr< adsk::core::Torus >" :
        """
        Creates and returns an independent copy of this Torus object. 
        Returns a new Torus object that is a copy of this Torus object.
        """
        return _core.Torus_copy(self)

    def _get_surfaceType(self) -> "adsk::core::SurfaceTypes" :
        """Returns the surface type."""
        return _core.Torus__get_surfaceType(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >" :
        """Returns the surface evaluator."""
        return _core.Torus__get_evaluator(self)

    def transformBy(self, *args) -> "bool" :
        """
        Updates this surface by transforming it with a given input matrix. 
        matrix : A 3D matrix that defines the transform to apply to the surface. 
        Returns true if the transform was successful.
        """
        return _core.Torus_transformBy(self, *args)

    def _get_objectType(self) -> "char const *" : return _core.Torus__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.Torus__get_isValid(self)
Torus_swigregister = _core.Torus_swigregister
Torus_swigregister(Torus)

def Torus_classType() -> "char const *" :
  return _core.Torus_classType()
Torus_classType = _core.Torus_classType

def Torus_create(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Vector3D > const &" :
  return _core.Torus_create(*args)
Torus_create = _core.Torus_create

Torus.__swig_getmethods__["origin"] = Torus._get_origin
Torus.__swig_setmethods__["origin"] = Torus._set_origin
Torus.origin = property(Torus._get_origin, Torus._set_origin, doc="Gets and sets the origin point (center) of the torus.")

Torus.__swig_getmethods__["axis"] = Torus._get_axis
Torus.__swig_setmethods__["axis"] = Torus._set_axis
Torus.axis = property(Torus._get_axis, Torus._set_axis, doc="Gets and sets the center axis of the torus.")

Torus.__swig_getmethods__["majorRadius"] = Torus._get_majorRadius
Torus.__swig_setmethods__["majorRadius"] = Torus._set_majorRadius
Torus.majorRadius = property(Torus._get_majorRadius, Torus._set_majorRadius, doc="Gets and sets the major radius of the torus.")

Torus.__swig_getmethods__["minorRadius"] = Torus._get_minorRadius
Torus.__swig_setmethods__["minorRadius"] = Torus._set_minorRadius
Torus.minorRadius = property(Torus._get_minorRadius, Torus._set_minorRadius, doc="Gets and sets the minor radius of the torus.")

Torus.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Torus) else None
Torus.cast = lambda arg: arg if isinstance(arg, Torus) else None

class UserInterfaceGeneralEvent(Event):
    """
    A UserInterfaceGeneralEvent is used for user-interface related events that don't
    require any additional information beyond getting the event itself.
    """
    __swig_setmethods__ = {}
    for _s in [Event]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UserInterfaceGeneralEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UserInterfaceGeneralEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::UserInterfaceGeneralEvent *" : return _core.UserInterfaceGeneralEvent___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.UserInterfaceGeneralEvent___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.UserInterfaceGeneralEvent___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.UserInterfaceGeneralEvent_classType
    if _newclass:classType = staticmethod(_core.UserInterfaceGeneralEvent_classType)
    __swig_destroy__ = _core.delete_UserInterfaceGeneralEvent
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Add a handler to be notified when the event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.UserInterfaceGeneralEvent_add(self, *args)

    def remove(self, *args) -> "bool" :
        """
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.UserInterfaceGeneralEvent_remove(self, *args)

    def _get_name(self) -> "std::string" :
        """The name of the event - e.g. 'DocumentOpening'"""
        return _core.UserInterfaceGeneralEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.UserInterfaceGeneralEvent__get_sender(self)

    def _get_objectType(self) -> "char const *" : return _core.UserInterfaceGeneralEvent__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.UserInterfaceGeneralEvent__get_isValid(self)
UserInterfaceGeneralEvent_swigregister = _core.UserInterfaceGeneralEvent_swigregister
UserInterfaceGeneralEvent_swigregister(UserInterfaceGeneralEvent)

def UserInterfaceGeneralEvent_classType() -> "char const *" :
  return _core.UserInterfaceGeneralEvent_classType()
UserInterfaceGeneralEvent_classType = _core.UserInterfaceGeneralEvent_classType

UserInterfaceGeneralEvent.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, UserInterfaceGeneralEvent) else None
UserInterfaceGeneralEvent.cast = lambda arg: arg if isinstance(arg, UserInterfaceGeneralEvent) else None

class UserInterfaceGeneralEventArgs(EventArgs):
    """The UserInterfaceGeneralEventArgs is passed when a UserInterfaceGeneralEvent is fired."""
    __swig_setmethods__ = {}
    for _s in [EventArgs]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UserInterfaceGeneralEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UserInterfaceGeneralEventArgs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::UserInterfaceGeneralEventArgs *" : return _core.UserInterfaceGeneralEventArgs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.UserInterfaceGeneralEventArgs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.UserInterfaceGeneralEventArgs___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.UserInterfaceGeneralEventArgs_classType
    if _newclass:classType = staticmethod(_core.UserInterfaceGeneralEventArgs_classType)
    __swig_destroy__ = _core.delete_UserInterfaceGeneralEventArgs
    __del__ = lambda self : None;
    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >" :
        """The event that the firing is in response to."""
        return _core.UserInterfaceGeneralEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *" : return _core.UserInterfaceGeneralEventArgs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.UserInterfaceGeneralEventArgs__get_isValid(self)
UserInterfaceGeneralEventArgs_swigregister = _core.UserInterfaceGeneralEventArgs_swigregister
UserInterfaceGeneralEventArgs_swigregister(UserInterfaceGeneralEventArgs)

def UserInterfaceGeneralEventArgs_classType() -> "char const *" :
  return _core.UserInterfaceGeneralEventArgs_classType()
UserInterfaceGeneralEventArgs_classType = _core.UserInterfaceGeneralEventArgs_classType

UserInterfaceGeneralEventArgs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, UserInterfaceGeneralEventArgs) else None
UserInterfaceGeneralEventArgs.cast = lambda arg: arg if isinstance(arg, UserInterfaceGeneralEventArgs) else None

class ValidateInputsEvent(Event):
    """An event endpoint that supports the connection to client implemented ValidateInputsEventHandlers."""
    __swig_setmethods__ = {}
    for _s in [Event]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ValidateInputsEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ValidateInputsEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ValidateInputsEvent *" : return _core.ValidateInputsEvent___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ValidateInputsEvent___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ValidateInputsEvent___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ValidateInputsEvent_classType
    if _newclass:classType = staticmethod(_core.ValidateInputsEvent_classType)
    __swig_destroy__ = _core.delete_ValidateInputsEvent
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Adds an event handler to this event endpoint. 
        handler : The client implemented ValidateInputsEventHandler to be called when this event is triggered. 
        Returns true if the handler was successfully added to the set of event handlers.
        """
        return _core.ValidateInputsEvent_add(self, *args)

    def remove(self, *args) -> "bool" :
        """
        Removes a handler from this event endpoint. 
        handler : A ValidateInputsEventHandler that was previously added to this event with the add method. 
        Returns true if the handler was found and removed from the set of event handlers.
        """
        return _core.ValidateInputsEvent_remove(self, *args)

    def _get_name(self) -> "std::string" :
        """The name of the event - e.g. 'DocumentOpening'"""
        return _core.ValidateInputsEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.ValidateInputsEvent__get_sender(self)

    def _get_objectType(self) -> "char const *" : return _core.ValidateInputsEvent__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ValidateInputsEvent__get_isValid(self)
ValidateInputsEvent_swigregister = _core.ValidateInputsEvent_swigregister
ValidateInputsEvent_swigregister(ValidateInputsEvent)

def ValidateInputsEvent_classType() -> "char const *" :
  return _core.ValidateInputsEvent_classType()
ValidateInputsEvent_classType = _core.ValidateInputsEvent_classType

ValidateInputsEvent.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ValidateInputsEvent) else None
ValidateInputsEvent.cast = lambda arg: arg if isinstance(arg, ValidateInputsEvent) else None

class ValidateInputsEventArgs(EventArgs):
    """Provides a set of arguments from a firing ValidateInputsEvent to a ValidateInputsEventHandler's notify callback method."""
    __swig_setmethods__ = {}
    for _s in [EventArgs]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ValidateInputsEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ValidateInputsEventArgs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ValidateInputsEventArgs *" : return _core.ValidateInputsEventArgs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ValidateInputsEventArgs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ValidateInputsEventArgs___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ValidateInputsEventArgs_classType
    if _newclass:classType = staticmethod(_core.ValidateInputsEventArgs_classType)
    __swig_destroy__ = _core.delete_ValidateInputsEventArgs
    __del__ = lambda self : None;
    def _get_areInputsValid(self) -> "bool" :
        """
        Used during the AreInputsValid event to get or set if all inputs are valid
        and the OK button should be enabled.
        """
        return _core.ValidateInputsEventArgs__get_areInputsValid(self)

    def _set_areInputsValid(self, *args) -> "bool" :
        """
        Used during the AreInputsValid event to get or set if all inputs are valid
        and the OK button should be enabled.
        """
        return _core.ValidateInputsEventArgs__set_areInputsValid(self, *args)

    def _get_inputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Returns the collection of command inputs that are associated with the command this event is being fired for."""
        return _core.ValidateInputsEventArgs__get_inputs(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >" :
        """The event that the firing is in response to."""
        return _core.ValidateInputsEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *" : return _core.ValidateInputsEventArgs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ValidateInputsEventArgs__get_isValid(self)
ValidateInputsEventArgs_swigregister = _core.ValidateInputsEventArgs_swigregister
ValidateInputsEventArgs_swigregister(ValidateInputsEventArgs)

def ValidateInputsEventArgs_classType() -> "char const *" :
  return _core.ValidateInputsEventArgs_classType()
ValidateInputsEventArgs_classType = _core.ValidateInputsEventArgs_classType

ValidateInputsEventArgs.__swig_getmethods__["areInputsValid"] = ValidateInputsEventArgs._get_areInputsValid
ValidateInputsEventArgs.__swig_setmethods__["areInputsValid"] = ValidateInputsEventArgs._set_areInputsValid
ValidateInputsEventArgs.areInputsValid = property(ValidateInputsEventArgs._get_areInputsValid, ValidateInputsEventArgs._set_areInputsValid, doc="Used during the AreInputsValid event to get or set if all inputs are valid\nand the OK button should be enabled.")

ValidateInputsEventArgs.__swig_getmethods__["inputs"] = ValidateInputsEventArgs._get_inputs
ValidateInputsEventArgs.inputs = property(ValidateInputsEventArgs._get_inputs, doc="Returns the collection of command inputs that are associated with the command this event is being fired for.")

ValidateInputsEventArgs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ValidateInputsEventArgs) else None
ValidateInputsEventArgs.cast = lambda arg: arg if isinstance(arg, ValidateInputsEventArgs) else None

class ValueCommandInput(CommandInput):
    """Provides a command input to get a unit based value from the user."""
    __swig_setmethods__ = {}
    for _s in [CommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ValueCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [CommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ValueCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::ValueCommandInput *" : return _core.ValueCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.ValueCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.ValueCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.ValueCommandInput_classType
    if _newclass:classType = staticmethod(_core.ValueCommandInput_classType)
    __swig_destroy__ = _core.delete_ValueCommandInput
    __del__ = lambda self : None;
    def _get_value(self) -> "double" :
        """
        Gets or sets the value associated with this input. The value is always in
        the database units of the unit type specified. For example, if the unit type is 'inch'
        this value is in centimeters since centimeters are the database length unit. When setting the
        value it is converted into a string using the unit type and displayed in the input box.
        When getting the value, the current expression string is evaluated and the database value
        for the unit type is returned.
        The isValidExpression property should be checked before using this
        value within the command because if the expression can't be evaluated
        there isn't a valid value. Fusion 360 won't allow the execution of a command
        that contains ValueCommandInput object with invalid expressions so you can
        dependably use the value in the execute event of the command.
        """
        return _core.ValueCommandInput__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """
        Gets or sets the value associated with this input. The value is always in
        the database units of the unit type specified. For example, if the unit type is 'inch'
        this value is in centimeters since centimeters are the database length unit. When setting the
        value it is converted into a string using the unit type and displayed in the input box.
        When getting the value, the current expression string is evaluated and the database value
        for the unit type is returned.
        The isValidExpression property should be checked before using this
        value within the command because if the expression can't be evaluated
        there isn't a valid value. Fusion 360 won't allow the execution of a command
        that contains ValueCommandInput object with invalid expressions so you can
        dependably use the value in the execute event of the command.
        """
        return _core.ValueCommandInput__set_value(self, *args)

    def _get_expression(self) -> "std::string" :
        """
        Gets or sets the expression displayed in the input field. This can contain equations and
        references to parameters. It is evaluated using the specified unit type.
        """
        return _core.ValueCommandInput__get_expression(self)

    def _set_expression(self, *args) -> "bool" :
        """
        Gets or sets the expression displayed in the input field. This can contain equations and
        references to parameters. It is evaluated using the specified unit type.
        """
        return _core.ValueCommandInput__set_expression(self, *args)

    def _get_unitType(self) -> "std::string" :
        """Gets and sets the unit type that is used when evaluating the user's input."""
        return _core.ValueCommandInput__get_unitType(self)

    def _set_unitType(self, *args) -> "bool" :
        """Gets and sets the unit type that is used when evaluating the user's input."""
        return _core.ValueCommandInput__set_unitType(self, *args)

    def _get_isValidExpression(self) -> "bool" :
        """
        Returns true if the current expression is valid and can be evaluated. If this
        is false, the value returned should be ignored because there currently is
        not a valid value.
        """
        return _core.ValueCommandInput__get_isValidExpression(self)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.ValueCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.ValueCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.ValueCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.ValueCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.ValueCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.ValueCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.ValueCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.ValueCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.ValueCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.ValueCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.ValueCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.ValueCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.ValueCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.ValueCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.ValueCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.ValueCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.ValueCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.ValueCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.ValueCommandInput__get_isValid(self)
ValueCommandInput_swigregister = _core.ValueCommandInput_swigregister
ValueCommandInput_swigregister(ValueCommandInput)

def ValueCommandInput_classType() -> "char const *" :
  return _core.ValueCommandInput_classType()
ValueCommandInput_classType = _core.ValueCommandInput_classType

ValueCommandInput.__swig_getmethods__["value"] = ValueCommandInput._get_value
ValueCommandInput.__swig_setmethods__["value"] = ValueCommandInput._set_value
ValueCommandInput.value = property(ValueCommandInput._get_value, ValueCommandInput._set_value, doc="Gets or sets the value associated with this input. The value is always in\nthe database units of the unit type specified. For example, if the unit type is 'inch'\nthis value is in centimeters since centimeters are the database length unit. When setting the\nvalue it is converted into a string using the unit type and displayed in the input box.\nWhen getting the value, the current expression string is evaluated and the database value\nfor the unit type is returned.\nThe isValidExpression property should be checked before using this\nvalue within the command because if the expression can't be evaluated\nthere isn't a valid value. Fusion 360 won't allow the execution of a command\nthat contains ValueCommandInput object with invalid expressions so you can\ndependably use the value in the execute event of the command.")

ValueCommandInput.__swig_getmethods__["expression"] = ValueCommandInput._get_expression
ValueCommandInput.__swig_setmethods__["expression"] = ValueCommandInput._set_expression
ValueCommandInput.expression = property(ValueCommandInput._get_expression, ValueCommandInput._set_expression, doc="Gets or sets the expression displayed in the input field. This can contain equations and\nreferences to parameters. It is evaluated using the specified unit type.")

ValueCommandInput.__swig_getmethods__["unitType"] = ValueCommandInput._get_unitType
ValueCommandInput.__swig_setmethods__["unitType"] = ValueCommandInput._set_unitType
ValueCommandInput.unitType = property(ValueCommandInput._get_unitType, ValueCommandInput._set_unitType, doc="Gets and sets the unit type that is used when evaluating the user's input.")

ValueCommandInput.__swig_getmethods__["isValidExpression"] = ValueCommandInput._get_isValidExpression
ValueCommandInput.isValidExpression = property(ValueCommandInput._get_isValidExpression, doc="Returns true if the current expression is valid and can be evaluated. If this\nis false, the value returned should be ignored because there currently is\nnot a valid value.")

ValueCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ValueCommandInput) else None
ValueCommandInput.cast = lambda arg: arg if isinstance(arg, ValueCommandInput) else None

class WebRequestEvent(Event):
    """
    A WebRequestEvent represents an event that occurs in reaction to a Fusion 360 protocol handler
    in a web page. For example, insertedFromURL and openedFromURL
    """
    __swig_setmethods__ = {}
    for _s in [Event]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WebRequestEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WebRequestEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::WebRequestEvent *" : return _core.WebRequestEvent___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.WebRequestEvent___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.WebRequestEvent___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.WebRequestEvent_classType
    if _newclass:classType = staticmethod(_core.WebRequestEvent_classType)
    __swig_destroy__ = _core.delete_WebRequestEvent
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Add a handler to be notified when the event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.WebRequestEvent_add(self, *args)

    def remove(self, *args) -> "bool" :
        """
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.WebRequestEvent_remove(self, *args)

    def _get_name(self) -> "std::string" :
        """The name of the event - e.g. 'DocumentOpening'"""
        return _core.WebRequestEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.WebRequestEvent__get_sender(self)

    def _get_objectType(self) -> "char const *" : return _core.WebRequestEvent__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.WebRequestEvent__get_isValid(self)
WebRequestEvent_swigregister = _core.WebRequestEvent_swigregister
WebRequestEvent_swigregister(WebRequestEvent)

def WebRequestEvent_classType() -> "char const *" :
  return _core.WebRequestEvent_classType()
WebRequestEvent_classType = _core.WebRequestEvent_classType

WebRequestEvent.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, WebRequestEvent) else None
WebRequestEvent.cast = lambda arg: arg if isinstance(arg, WebRequestEvent) else None

class WebRequestEventArgs(EventArgs):
    """
    The WebRequestEventArgs provides information associated with a web request event. These
    are events fired as a result of a Fusion 360 protocol handler being invoked from a web page.
    Note that some properties are not available on every event.
    """
    __swig_setmethods__ = {}
    for _s in [EventArgs]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WebRequestEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WebRequestEventArgs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::WebRequestEventArgs *" : return _core.WebRequestEventArgs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.WebRequestEventArgs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.WebRequestEventArgs___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.WebRequestEventArgs_classType
    if _newclass:classType = staticmethod(_core.WebRequestEventArgs_classType)
    __swig_destroy__ = _core.delete_WebRequestEventArgs
    __del__ = lambda self : None;
    def _get_isCanceled(self) -> "bool" :
        """
        Used during the insertingFromURL and openingFromURL events to get or set 
        if the insert or open should be allowed to continue. This defaults to false,
        which will allow the operation to continue as normal. 
        This property should be ignored for all events besides the insertingFromURL and
        openingFromURL events.
        """
        return _core.WebRequestEventArgs__get_isCanceled(self)

    def _set_isCanceled(self, *args) -> "bool" :
        """
        Used during the insertingFromURL and openingFromURL events to get or set 
        if the insert or open should be allowed to continue. This defaults to false,
        which will allow the operation to continue as normal. 
        This property should be ignored for all events besides the insertingFromURL and
        openingFromURL events.
        """
        return _core.WebRequestEventArgs__set_isCanceled(self, *args)

    def _get_file(self) -> "std::string" :
        """Returns the value specified as the 'file' parameter in the URL."""
        return _core.WebRequestEventArgs__get_file(self)

    def _get_properties(self) -> "std::string" :
        """
        Returns the value specified as the 'properties' parameter in the URL. This
        will be decoded and should be in JSON format if it was properly provided
        by the web page. It can be an empty string if the 'properties' parameter was
        not specified in the URL.
        """
        return _core.WebRequestEventArgs__get_properties(self)

    def _get_id(self) -> "std::string" :
        """
        Returns the value specified as the 'id' parameter in the URL. This
        will be decoded. It can be an empty string if the 'id' parameter was
        not specified in the URL.
        """
        return _core.WebRequestEventArgs__get_id(self)

    def _get_privateInfo(self) -> "std::string" :
        """
        Returns the value specified as the 'privateInfo' parameter in the URL. This
        will be decoded and can be an empty string if the 'privateInfo' parameter was
        not specified in the URL.
        """
        return _core.WebRequestEventArgs__get_privateInfo(self)

    def _get_occurrenceOrDocument(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Used during the insertedFromURL or openedFromURL events and returns the Document (openedFromURL)
        or Occurrence (insertedFromURL) that was just created.
        """
        return _core.WebRequestEventArgs__get_occurrenceOrDocument(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >" :
        """The event that the firing is in response to."""
        return _core.WebRequestEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *" : return _core.WebRequestEventArgs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.WebRequestEventArgs__get_isValid(self)
WebRequestEventArgs_swigregister = _core.WebRequestEventArgs_swigregister
WebRequestEventArgs_swigregister(WebRequestEventArgs)

def WebRequestEventArgs_classType() -> "char const *" :
  return _core.WebRequestEventArgs_classType()
WebRequestEventArgs_classType = _core.WebRequestEventArgs_classType

WebRequestEventArgs.__swig_getmethods__["isCanceled"] = WebRequestEventArgs._get_isCanceled
WebRequestEventArgs.__swig_setmethods__["isCanceled"] = WebRequestEventArgs._set_isCanceled
WebRequestEventArgs.isCanceled = property(WebRequestEventArgs._get_isCanceled, WebRequestEventArgs._set_isCanceled, doc="Used during the insertingFromURL and openingFromURL events to get or set\nif the insert or open should be allowed to continue. This defaults to false,\nwhich will allow the operation to continue as normal.\nThis property should be ignored for all events besides the insertingFromURL and\nopeningFromURL events.")

WebRequestEventArgs.__swig_getmethods__["file"] = WebRequestEventArgs._get_file
WebRequestEventArgs.file = property(WebRequestEventArgs._get_file, doc="Returns the value specified as the 'file' parameter in the URL.")

WebRequestEventArgs.__swig_getmethods__["properties"] = WebRequestEventArgs._get_properties
WebRequestEventArgs.properties = property(WebRequestEventArgs._get_properties, doc="Returns the value specified as the 'properties' parameter in the URL. This\nwill be decoded and should be in JSON format if it was properly provided\nby the web page. It can be an empty string if the 'properties' parameter was\nnot specified in the URL.")

WebRequestEventArgs.__swig_getmethods__["id"] = WebRequestEventArgs._get_id
WebRequestEventArgs.id = property(WebRequestEventArgs._get_id, doc="Returns the value specified as the 'id' parameter in the URL. This\nwill be decoded. It can be an empty string if the 'id' parameter was\nnot specified in the URL.")

WebRequestEventArgs.__swig_getmethods__["privateInfo"] = WebRequestEventArgs._get_privateInfo
WebRequestEventArgs.privateInfo = property(WebRequestEventArgs._get_privateInfo, doc="Returns the value specified as the 'privateInfo' parameter in the URL. This\nwill be decoded and can be an empty string if the 'privateInfo' parameter was\nnot specified in the URL.")

WebRequestEventArgs.__swig_getmethods__["occurrenceOrDocument"] = WebRequestEventArgs._get_occurrenceOrDocument
WebRequestEventArgs.occurrenceOrDocument = property(WebRequestEventArgs._get_occurrenceOrDocument, doc="Used during the insertedFromURL or openedFromURL events and returns the Document (openedFromURL)\nor Occurrence (insertedFromURL) that was just created.")

WebRequestEventArgs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, WebRequestEventArgs) else None
WebRequestEventArgs.cast = lambda arg: arg if isinstance(arg, WebRequestEventArgs) else None

class WorkspaceEvent(Event):
    """A WorkspaceEvent represents a workspace related event. For example, workspaceActivate or workspaceDeactivate."""
    __swig_setmethods__ = {}
    for _s in [Event]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WorkspaceEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WorkspaceEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::WorkspaceEvent *" : return _core.WorkspaceEvent___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.WorkspaceEvent___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.WorkspaceEvent___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.WorkspaceEvent_classType
    if _newclass:classType = staticmethod(_core.WorkspaceEvent_classType)
    __swig_destroy__ = _core.delete_WorkspaceEvent
    __del__ = lambda self : None;
    def add(self, *args) -> "bool" :
        """
        Add a handler to be notified when the event occurs. 
        handler : The handler object to be called when this event is fired. 
        Returns true if the addition of the handler was successful.
        """
        return _core.WorkspaceEvent_add(self, *args)

    def remove(self, *args) -> "bool" :
        """
        Removes a handler from the event. 
        handler : The handler object to be removed from the event. 
        Returns true if removal of the handler was successful.
        """
        return _core.WorkspaceEvent_remove(self, *args)

    def _get_name(self) -> "std::string" :
        """The name of the event - e.g. 'DocumentOpening'"""
        return _core.WorkspaceEvent__get_name(self)

    def _get_sender(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The object that is firing the event. For example, in the case of a command 
        input event this will return the command.
        """
        return _core.WorkspaceEvent__get_sender(self)

    def _get_objectType(self) -> "char const *" : return _core.WorkspaceEvent__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.WorkspaceEvent__get_isValid(self)
WorkspaceEvent_swigregister = _core.WorkspaceEvent_swigregister
WorkspaceEvent_swigregister(WorkspaceEvent)

def WorkspaceEvent_classType() -> "char const *" :
  return _core.WorkspaceEvent_classType()
WorkspaceEvent_classType = _core.WorkspaceEvent_classType

WorkspaceEvent.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, WorkspaceEvent) else None
WorkspaceEvent.cast = lambda arg: arg if isinstance(arg, WorkspaceEvent) else None

class WorkspaceEventArgs(EventArgs):
    """The WorkspaceEventArgs provides information associated with a workspace event."""
    __swig_setmethods__ = {}
    for _s in [EventArgs]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WorkspaceEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WorkspaceEventArgs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::WorkspaceEventArgs *" : return _core.WorkspaceEventArgs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.WorkspaceEventArgs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.WorkspaceEventArgs___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.WorkspaceEventArgs_classType
    if _newclass:classType = staticmethod(_core.WorkspaceEventArgs_classType)
    __swig_destroy__ = _core.delete_WorkspaceEventArgs
    __del__ = lambda self : None;
    def _get_workspace(self) -> "adsk::core::Ptr< adsk::core::Workspace >" :
        """Provides access to the workspace."""
        return _core.WorkspaceEventArgs__get_workspace(self)

    def _get_firingEvent(self) -> "adsk::core::Ptr< adsk::core::Event >" :
        """The event that the firing is in response to."""
        return _core.WorkspaceEventArgs__get_firingEvent(self)

    def _get_objectType(self) -> "char const *" : return _core.WorkspaceEventArgs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.WorkspaceEventArgs__get_isValid(self)
WorkspaceEventArgs_swigregister = _core.WorkspaceEventArgs_swigregister
WorkspaceEventArgs_swigregister(WorkspaceEventArgs)

def WorkspaceEventArgs_classType() -> "char const *" :
  return _core.WorkspaceEventArgs_classType()
WorkspaceEventArgs_classType = _core.WorkspaceEventArgs_classType

WorkspaceEventArgs.__swig_getmethods__["workspace"] = WorkspaceEventArgs._get_workspace
WorkspaceEventArgs.workspace = property(WorkspaceEventArgs._get_workspace, doc="Provides access to the workspace.")

WorkspaceEventArgs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, WorkspaceEventArgs) else None
WorkspaceEventArgs.cast = lambda arg: arg if isinstance(arg, WorkspaceEventArgs) else None

class FloatSliderCommandInput(SliderCommandInput):
    """Provides a command input to get the value of a slider from the user, the value type is float."""
    __swig_setmethods__ = {}
    for _s in [SliderCommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatSliderCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [SliderCommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FloatSliderCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::FloatSliderCommandInput *" : return _core.FloatSliderCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.FloatSliderCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.FloatSliderCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.FloatSliderCommandInput_classType
    if _newclass:classType = staticmethod(_core.FloatSliderCommandInput_classType)
    __swig_destroy__ = _core.delete_FloatSliderCommandInput
    __del__ = lambda self : None;
    def _get_valueOne(self) -> "double" :
        """
        Gets or sets the first value associated with this input. The value is always in
        the database units of the unit type specified. For example, if the unit type is 'inch'
        this value is in centimeters since centimeters are the database length unit. When setting the
        value it is converted into a string using the unit type and displayed in the input box.
        """
        return _core.FloatSliderCommandInput__get_valueOne(self)

    def _set_valueOne(self, *args) -> "bool" :
        """
        Gets or sets the first value associated with this input. The value is always in
        the database units of the unit type specified. For example, if the unit type is 'inch'
        this value is in centimeters since centimeters are the database length unit. When setting the
        value it is converted into a string using the unit type and displayed in the input box.
        """
        return _core.FloatSliderCommandInput__set_valueOne(self, *args)

    def _get_valueTwo(self) -> "double" :
        """
        Gets or sets the second value associated with this input. The value is always in
        the database units of the unit type specified. For example, if the unit type is 'inch'
        this value is in centimeters since centimeters are the database length unit. When setting the
        value it is converted into a string using the unit type and displayed in the input box.
        This property is only available when the hasTwoSliders property returns true.
        """
        return _core.FloatSliderCommandInput__get_valueTwo(self)

    def _set_valueTwo(self, *args) -> "bool" :
        """
        Gets or sets the second value associated with this input. The value is always in
        the database units of the unit type specified. For example, if the unit type is 'inch'
        this value is in centimeters since centimeters are the database length unit. When setting the
        value it is converted into a string using the unit type and displayed in the input box.
        This property is only available when the hasTwoSliders property returns true.
        """
        return _core.FloatSliderCommandInput__set_valueTwo(self, *args)

    def _get_minimumValue(self) -> "double" :
        """
        Gets and sets minimum value of the slider in database units. 
        Gets a failure when set if the value of this command input was added by value list.
        """
        return _core.FloatSliderCommandInput__get_minimumValue(self)

    def _set_minimumValue(self, *args) -> "bool" :
        """
        Gets and sets minimum value of the slider in database units. 
        Gets a failure when set if the value of this command input was added by value list.
        """
        return _core.FloatSliderCommandInput__set_minimumValue(self, *args)

    def _get_maximumValue(self) -> "double" :
        """
        Gets and sets maximum value of the slider in database units. 
        Gets a failure when set if the value of this command input was added by value list.
        """
        return _core.FloatSliderCommandInput__get_maximumValue(self)

    def _set_maximumValue(self, *args) -> "bool" :
        """
        Gets and sets maximum value of the slider in database units. 
        Gets a failure when set if the value of this command input was added by value list.
        """
        return _core.FloatSliderCommandInput__set_maximumValue(self, *args)

    def _get_valueList(self) -> "std::vector< double,std::allocator< double > >" :
        """
        Gets the value list of the slider. This property is valid when this input represents a list type of slider command input.
        Otherwise an empty list will be returned.
        """
        return _core.FloatSliderCommandInput__get_valueList(self)

    def _get_spinStep(self) -> "double" :
        """
        Gets and sets the spin step value in the unit type set by the unitType argument. 
        The value should be more than zero. This is the amount the slider will advance
        when the user clicks the spin button beside the value.
        """
        return _core.FloatSliderCommandInput__get_spinStep(self)

    def _set_spinStep(self, *args) -> "bool" :
        """
        Gets and sets the spin step value in the unit type set by the unitType argument. 
        The value should be more than zero. This is the amount the slider will advance
        when the user clicks the spin button beside the value.
        """
        return _core.FloatSliderCommandInput__set_spinStep(self, *args)

    def _get_expressionOne(self) -> "std::string" :
        """
        Uses an expression to set the value in the first input field. This can contain equations and
        is evaluated using the specified unit type.
        """
        return _core.FloatSliderCommandInput__get_expressionOne(self)

    def _set_expressionOne(self, *args) -> "bool" :
        """
        Uses an expression to set the value in the first input field. This can contain equations and
        is evaluated using the specified unit type.
        """
        return _core.FloatSliderCommandInput__set_expressionOne(self, *args)

    def _get_expressionTwo(self) -> "std::string" :
        """
        Uses an expression to set the value in the second input field. This can contain equations and
        is evaluated using the specified unit type.
        This property is only available when the hasTwoSliders property returns true.
        """
        return _core.FloatSliderCommandInput__get_expressionTwo(self)

    def _set_expressionTwo(self, *args) -> "bool" :
        """
        Uses an expression to set the value in the second input field. This can contain equations and
        is evaluated using the specified unit type.
        This property is only available when the hasTwoSliders property returns true.
        """
        return _core.FloatSliderCommandInput__set_expressionTwo(self, *args)

    def _get_unitType(self) -> "std::string" :
        """Gets and sets the unit type that is used when evaluating the user's input."""
        return _core.FloatSliderCommandInput__get_unitType(self)

    def _set_unitType(self, *args) -> "bool" :
        """Gets and sets the unit type that is used when evaluating the user's input."""
        return _core.FloatSliderCommandInput__set_unitType(self, *args)

    def _get_hasTwoSliders(self) -> "bool" :
        """Gets if the command input has two sliders."""
        return _core.FloatSliderCommandInput__get_hasTwoSliders(self)

    def setText(self, *args) -> "bool" :
        """
        Sets the text of the slider. Both the left and the right text should be set. 
        left : Indicates the text on the left side of the slider. 
        right : Indicates the text on the right side of the slider. 
        Returns true if successful.
        """
        return _core.FloatSliderCommandInput_setText(self, *args)

    def getText(self, *args) -> "std::string" :
        """
        Gets the texts of the slider if text has been defined. 
        isLeft : Indicates to get the left or right text. 
        Returns the left or right text of the slider.
        """
        return _core.FloatSliderCommandInput_getText(self, *args)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.FloatSliderCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.FloatSliderCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.FloatSliderCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.FloatSliderCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.FloatSliderCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.FloatSliderCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.FloatSliderCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.FloatSliderCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.FloatSliderCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.FloatSliderCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.FloatSliderCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.FloatSliderCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.FloatSliderCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.FloatSliderCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.FloatSliderCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.FloatSliderCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.FloatSliderCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.FloatSliderCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.FloatSliderCommandInput__get_isValid(self)
FloatSliderCommandInput_swigregister = _core.FloatSliderCommandInput_swigregister
FloatSliderCommandInput_swigregister(FloatSliderCommandInput)

def FloatSliderCommandInput_classType() -> "char const *" :
  return _core.FloatSliderCommandInput_classType()
FloatSliderCommandInput_classType = _core.FloatSliderCommandInput_classType

FloatSliderCommandInput.__swig_getmethods__["valueOne"] = FloatSliderCommandInput._get_valueOne
FloatSliderCommandInput.__swig_setmethods__["valueOne"] = FloatSliderCommandInput._set_valueOne
FloatSliderCommandInput.valueOne = property(FloatSliderCommandInput._get_valueOne, FloatSliderCommandInput._set_valueOne, doc="Gets or sets the first value associated with this input. The value is always in\nthe database units of the unit type specified. For example, if the unit type is 'inch'\nthis value is in centimeters since centimeters are the database length unit. When setting the\nvalue it is converted into a string using the unit type and displayed in the input box.")

FloatSliderCommandInput.__swig_getmethods__["valueTwo"] = FloatSliderCommandInput._get_valueTwo
FloatSliderCommandInput.__swig_setmethods__["valueTwo"] = FloatSliderCommandInput._set_valueTwo
FloatSliderCommandInput.valueTwo = property(FloatSliderCommandInput._get_valueTwo, FloatSliderCommandInput._set_valueTwo, doc="Gets or sets the second value associated with this input. The value is always in\nthe database units of the unit type specified. For example, if the unit type is 'inch'\nthis value is in centimeters since centimeters are the database length unit. When setting the\nvalue it is converted into a string using the unit type and displayed in the input box.\nThis property is only available when the hasTwoSliders property returns true.")

FloatSliderCommandInput.__swig_getmethods__["minimumValue"] = FloatSliderCommandInput._get_minimumValue
FloatSliderCommandInput.__swig_setmethods__["minimumValue"] = FloatSliderCommandInput._set_minimumValue
FloatSliderCommandInput.minimumValue = property(FloatSliderCommandInput._get_minimumValue, FloatSliderCommandInput._set_minimumValue, doc="Gets and sets minimum value of the slider in database units.\nGets a failure when set if the value of this command input was added by value list.")

FloatSliderCommandInput.__swig_getmethods__["maximumValue"] = FloatSliderCommandInput._get_maximumValue
FloatSliderCommandInput.__swig_setmethods__["maximumValue"] = FloatSliderCommandInput._set_maximumValue
FloatSliderCommandInput.maximumValue = property(FloatSliderCommandInput._get_maximumValue, FloatSliderCommandInput._set_maximumValue, doc="Gets and sets maximum value of the slider in database units.\nGets a failure when set if the value of this command input was added by value list.")

FloatSliderCommandInput.__swig_getmethods__["valueList"] = FloatSliderCommandInput._get_valueList
FloatSliderCommandInput.valueList = property(FloatSliderCommandInput._get_valueList, doc="Gets the value list of the slider. This property is valid when this input represents a list type of slider command input.\nOtherwise an empty list will be returned.")

FloatSliderCommandInput.__swig_getmethods__["spinStep"] = FloatSliderCommandInput._get_spinStep
FloatSliderCommandInput.__swig_setmethods__["spinStep"] = FloatSliderCommandInput._set_spinStep
FloatSliderCommandInput.spinStep = property(FloatSliderCommandInput._get_spinStep, FloatSliderCommandInput._set_spinStep, doc="Gets and sets the spin step value in the unit type set by the unitType argument.\nThe value should be more than zero. This is the amount the slider will advance\nwhen the user clicks the spin button beside the value.")

FloatSliderCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FloatSliderCommandInput) else None
FloatSliderCommandInput.cast = lambda arg: arg if isinstance(arg, FloatSliderCommandInput) else None

class IntegerSliderCommandInput(SliderCommandInput):
    """Provides a command input to get the value of a slider from the user, the value type is integer."""
    __swig_setmethods__ = {}
    for _s in [SliderCommandInput]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntegerSliderCommandInput, name, value)
    __swig_getmethods__ = {}
    for _s in [SliderCommandInput]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntegerSliderCommandInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::IntegerSliderCommandInput *" : return _core.IntegerSliderCommandInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _core.IntegerSliderCommandInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _core.IntegerSliderCommandInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _core.IntegerSliderCommandInput_classType
    if _newclass:classType = staticmethod(_core.IntegerSliderCommandInput_classType)
    __swig_destroy__ = _core.delete_IntegerSliderCommandInput
    __del__ = lambda self : None;
    def _get_valueOne(self) -> "int" :
        """Gets or sets the value associated with the first slider."""
        return _core.IntegerSliderCommandInput__get_valueOne(self)

    def _set_valueOne(self, *args) -> "bool" :
        """Gets or sets the value associated with the first slider."""
        return _core.IntegerSliderCommandInput__set_valueOne(self, *args)

    def _get_valueTwo(self) -> "int" :
        """
        If the hasTwoSliders property is true, this returns the value associated with 
        the second slider.
        """
        return _core.IntegerSliderCommandInput__get_valueTwo(self)

    def _set_valueTwo(self, *args) -> "bool" :
        """
        If the hasTwoSliders property is true, this returns the value associated with 
        the second slider.
        """
        return _core.IntegerSliderCommandInput__set_valueTwo(self, *args)

    def _get_minimumValue(self) -> "int" :
        """
        Gets and sets minimum value of the slider. This will fail if there is a value list because the
        minimum and maximum values are defined by the value list.
        """
        return _core.IntegerSliderCommandInput__get_minimumValue(self)

    def _set_minimumValue(self, *args) -> "bool" :
        """
        Gets and sets minimum value of the slider. This will fail if there is a value list because the
        minimum and maximum values are defined by the value list.
        """
        return _core.IntegerSliderCommandInput__set_minimumValue(self, *args)

    def _get_maximumValue(self) -> "int" :
        """
        Gets and sets maximum value of the slider. This will fail if there is a value list because the
        minimum and maximum values are defined by the value list.
        """
        return _core.IntegerSliderCommandInput__get_maximumValue(self)

    def _set_maximumValue(self, *args) -> "bool" :
        """
        Gets and sets maximum value of the slider. This will fail if there is a value list because the
        minimum and maximum values are defined by the value list.
        """
        return _core.IntegerSliderCommandInput__set_maximumValue(self, *args)

    def _get_valueList(self) -> "std::vector< int,std::allocator< int > >" :
        """Gets the value list of the slider. The list is empty if this command input was not added by value list."""
        return _core.IntegerSliderCommandInput__get_valueList(self)

    def _get_spinStep(self) -> "size_t" :
        """
        Gets and sets the spin step. This defines the amount the slider moves when the user clicks the spin
        button beside the value. The spin step should be more than zero.
        """
        return _core.IntegerSliderCommandInput__get_spinStep(self)

    def _set_spinStep(self, *args) -> "bool" :
        """
        Gets and sets the spin step. This defines the amount the slider moves when the user clicks the spin
        button beside the value. The spin step should be more than zero.
        """
        return _core.IntegerSliderCommandInput__set_spinStep(self, *args)

    def _get_expressionOne(self) -> "std::string" :
        """
        Uses an expression to set the value in the first input field. This can contain equations and
        is evaluated using the specified unit type.
        """
        return _core.IntegerSliderCommandInput__get_expressionOne(self)

    def _set_expressionOne(self, *args) -> "bool" :
        """
        Uses an expression to set the value in the first input field. This can contain equations and
        is evaluated using the specified unit type.
        """
        return _core.IntegerSliderCommandInput__set_expressionOne(self, *args)

    def _get_expressionTwo(self) -> "std::string" :
        """
        Uses an expression to set the value in the second input field. This can contain equations and
        is evaluated using the specified unit type.
        This property is only available when the hasTwoSliders property returns true.
        """
        return _core.IntegerSliderCommandInput__get_expressionTwo(self)

    def _set_expressionTwo(self, *args) -> "bool" :
        """
        Uses an expression to set the value in the second input field. This can contain equations and
        is evaluated using the specified unit type.
        This property is only available when the hasTwoSliders property returns true.
        """
        return _core.IntegerSliderCommandInput__set_expressionTwo(self, *args)

    def _get_unitType(self) -> "std::string" :
        """Gets and sets the unit type that is used when evaluating the user's input."""
        return _core.IntegerSliderCommandInput__get_unitType(self)

    def _set_unitType(self, *args) -> "bool" :
        """Gets and sets the unit type that is used when evaluating the user's input."""
        return _core.IntegerSliderCommandInput__set_unitType(self, *args)

    def _get_hasTwoSliders(self) -> "bool" :
        """Gets if the command input has two sliders."""
        return _core.IntegerSliderCommandInput__get_hasTwoSliders(self)

    def setText(self, *args) -> "bool" :
        """
        Sets the text of the slider. Both the left and the right text should be set. 
        left : Indicates the text on the left side of the slider. 
        right : Indicates the text on the right side of the slider. 
        Returns true if successful.
        """
        return _core.IntegerSliderCommandInput_setText(self, *args)

    def getText(self, *args) -> "std::string" :
        """
        Gets the texts of the slider if text has been defined. 
        isLeft : Indicates to get the left or right text. 
        Returns the left or right text of the slider.
        """
        return _core.IntegerSliderCommandInput_getText(self, *args)

    def _get_commandInputs(self) -> "adsk::core::Ptr< adsk::core::CommandInputs >" :
        """Gets the CommandInputs class of the parent, which can be a Command, GroupCommandInput or TabCommandInput."""
        return _core.IntegerSliderCommandInput__get_commandInputs(self)

    def _get_id(self) -> "std::string" :
        """Gets the unique identifier for this input in the command's CommandInputs."""
        return _core.IntegerSliderCommandInput__get_id(self)

    def _get_name(self) -> "std::string" :
        """Gets the user visible name of this input."""
        return _core.IntegerSliderCommandInput__get_name(self)

    def _get_isEnabled(self) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.IntegerSliderCommandInput__get_isEnabled(self)

    def _set_isEnabled(self, *args) -> "bool" :
        """Gets or sets if this input is currently enabled or disabled for user interaction."""
        return _core.IntegerSliderCommandInput__set_isEnabled(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.IntegerSliderCommandInput__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """Gets or sets if this input will be visible to the user."""
        return _core.IntegerSliderCommandInput__set_isVisible(self, *args)

    def _get_parentCommand(self) -> "adsk::core::Ptr< adsk::core::Command >" :
        """Gets the parent Command."""
        return _core.IntegerSliderCommandInput__get_parentCommand(self)

    def _get_isFullWidth(self) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.IntegerSliderCommandInput__get_isFullWidth(self)

    def _set_isFullWidth(self, *args) -> "bool" :
        """
        Gets or sets if this input fills the entire width of the dialog. If
        true, the name is ignored and the input control will fill the entire width of the command dialog.
        The default value for this property in a new command input if false, or not to fill the width.
        This property does not apply to GroupCommandInputs or TabCommandInputs.
        """
        return _core.IntegerSliderCommandInput__set_isFullWidth(self, *args)

    def _get_toolClipFilename(self) -> "std::string" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.IntegerSliderCommandInput__get_toolClipFilename(self)

    def _set_toolClipFilename(self, *args) -> "bool" :
        """
        Gets or sets the full filename of the image file (png) used for the tool clip.
        The tooltip is always shown but as the user hovers over the control it will progressively display 
        the tool clip and description text.
        """
        return _core.IntegerSliderCommandInput__set_toolClipFilename(self, *args)

    def _get_tooltip(self) -> "std::string" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.IntegerSliderCommandInput__get_tooltip(self)

    def _set_tooltip(self, *args) -> "bool" :
        """
        Gets or sets the base tooltip string. This is always shown for commands. If the tooltip description 
        and/or tool clip are also specified then the tooltip will progressively display more information as the 
        user hovers the mouse over the control.
        """
        return _core.IntegerSliderCommandInput__set_tooltip(self, *args)

    def _get_tooltipDescription(self) -> "std::string" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.IntegerSliderCommandInput__get_tooltipDescription(self)

    def _set_tooltipDescription(self, *args) -> "bool" :
        """
        Gets or sets additional text to display progressively along with the tooltip. The text for the description 
        can contain some basic html formatting tags to format the tags. For example the br tag can be used to 
        create multiple paragraphs. The tooltip is always shown but as the user hovers over the control it will 
        progressively display the tool clip and description text.
        """
        return _core.IntegerSliderCommandInput__set_tooltipDescription(self, *args)

    def _get_parentCommandInput(self) -> "adsk::core::Ptr< adsk::core::CommandInput >" :
        """
        Gets the parent CommandInput if this commandInput is the child of a TabCommandInput or GroupCommandInput. 
        Returns null if their is no parent.
        """
        return _core.IntegerSliderCommandInput__get_parentCommandInput(self)

    def _get_objectType(self) -> "char const *" : return _core.IntegerSliderCommandInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _core.IntegerSliderCommandInput__get_isValid(self)
IntegerSliderCommandInput_swigregister = _core.IntegerSliderCommandInput_swigregister
IntegerSliderCommandInput_swigregister(IntegerSliderCommandInput)

def IntegerSliderCommandInput_classType() -> "char const *" :
  return _core.IntegerSliderCommandInput_classType()
IntegerSliderCommandInput_classType = _core.IntegerSliderCommandInput_classType

IntegerSliderCommandInput.__swig_getmethods__["valueOne"] = IntegerSliderCommandInput._get_valueOne
IntegerSliderCommandInput.__swig_setmethods__["valueOne"] = IntegerSliderCommandInput._set_valueOne
IntegerSliderCommandInput.valueOne = property(IntegerSliderCommandInput._get_valueOne, IntegerSliderCommandInput._set_valueOne, doc="Gets or sets the value associated with the first slider.")

IntegerSliderCommandInput.__swig_getmethods__["valueTwo"] = IntegerSliderCommandInput._get_valueTwo
IntegerSliderCommandInput.__swig_setmethods__["valueTwo"] = IntegerSliderCommandInput._set_valueTwo
IntegerSliderCommandInput.valueTwo = property(IntegerSliderCommandInput._get_valueTwo, IntegerSliderCommandInput._set_valueTwo, doc="If the hasTwoSliders property is true, this returns the value associated with\nthe second slider.")

IntegerSliderCommandInput.__swig_getmethods__["minimumValue"] = IntegerSliderCommandInput._get_minimumValue
IntegerSliderCommandInput.__swig_setmethods__["minimumValue"] = IntegerSliderCommandInput._set_minimumValue
IntegerSliderCommandInput.minimumValue = property(IntegerSliderCommandInput._get_minimumValue, IntegerSliderCommandInput._set_minimumValue, doc="Gets and sets minimum value of the slider. This will fail if there is a value list because the\nminimum and maximum values are defined by the value list.")

IntegerSliderCommandInput.__swig_getmethods__["maximumValue"] = IntegerSliderCommandInput._get_maximumValue
IntegerSliderCommandInput.__swig_setmethods__["maximumValue"] = IntegerSliderCommandInput._set_maximumValue
IntegerSliderCommandInput.maximumValue = property(IntegerSliderCommandInput._get_maximumValue, IntegerSliderCommandInput._set_maximumValue, doc="Gets and sets maximum value of the slider. This will fail if there is a value list because the\nminimum and maximum values are defined by the value list.")

IntegerSliderCommandInput.__swig_getmethods__["valueList"] = IntegerSliderCommandInput._get_valueList
IntegerSliderCommandInput.valueList = property(IntegerSliderCommandInput._get_valueList, doc="Gets the value list of the slider. The list is empty if this command input was not added by value list.")

IntegerSliderCommandInput.__swig_getmethods__["spinStep"] = IntegerSliderCommandInput._get_spinStep
IntegerSliderCommandInput.__swig_setmethods__["spinStep"] = IntegerSliderCommandInput._set_spinStep
IntegerSliderCommandInput.spinStep = property(IntegerSliderCommandInput._get_spinStep, IntegerSliderCommandInput._set_spinStep, doc="Gets and sets the spin step. This defines the amount the slider moves when the user clicks the spin\nbutton beside the value. The spin step should be more than zero.")

IntegerSliderCommandInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, IntegerSliderCommandInput) else None
IntegerSliderCommandInput.cast = lambda arg: arg if isinstance(arg, IntegerSliderCommandInput) else None

# This file is compatible with both classic and new-style classes.


