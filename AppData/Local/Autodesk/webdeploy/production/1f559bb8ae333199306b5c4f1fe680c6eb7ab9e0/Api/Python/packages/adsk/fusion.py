# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_fusion', [dirname(__file__)])
        except ImportError:
            import _fusion
            return _fusion
        if fp is not None:
            try:
                _mod = imp.load_module('_fusion', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _fusion = swig_import_helper()
    del swig_import_helper
else:
    import _fusion
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fusion.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self) -> "PyObject *" : return _fusion.SwigPyIterator_value(self)
    def incr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" : return _fusion.SwigPyIterator_incr(self, n)
    def decr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" : return _fusion.SwigPyIterator_decr(self, n)
    def distance(self, *args) -> "ptrdiff_t" : return _fusion.SwigPyIterator_distance(self, *args)
    def equal(self, *args) -> "bool" : return _fusion.SwigPyIterator_equal(self, *args)
    def copy(self) -> "swig::SwigPyIterator *" : return _fusion.SwigPyIterator_copy(self)
    def next(self) -> "PyObject *" : return _fusion.SwigPyIterator_next(self)
    def __next__(self) -> "PyObject *" : return _fusion.SwigPyIterator___next__(self)
    def previous(self) -> "PyObject *" : return _fusion.SwigPyIterator_previous(self)
    def advance(self, *args) -> "swig::SwigPyIterator *" : return _fusion.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args) -> "bool" : return _fusion.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args) -> "bool" : return _fusion.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args) -> "swig::SwigPyIterator &" : return _fusion.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args) -> "swig::SwigPyIterator &" : return _fusion.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args) -> "swig::SwigPyIterator *" : return _fusion.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args) -> "ptrdiff_t" : return _fusion.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _fusion.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class DoubleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.DoubleVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.DoubleVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.DoubleVector___bool__(self)
    def __len__(self) -> "std::vector< double >::size_type" : return _fusion.DoubleVector___len__(self)
    def pop(self) -> "std::vector< double >::value_type" : return _fusion.DoubleVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< double,std::allocator< double > > *" : return _fusion.DoubleVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.DoubleVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.DoubleVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.DoubleVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< double >::value_type const &" : return _fusion.DoubleVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.DoubleVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.DoubleVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.DoubleVector_empty(self)
    def size(self) -> "std::vector< double >::size_type" : return _fusion.DoubleVector_size(self)
    def clear(self) -> "void" : return _fusion.DoubleVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.DoubleVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< double >::allocator_type" : return _fusion.DoubleVector_get_allocator(self)
    def begin(self) -> "std::vector< double >::iterator" : return _fusion.DoubleVector_begin(self)
    def end(self) -> "std::vector< double >::iterator" : return _fusion.DoubleVector_end(self)
    def rbegin(self) -> "std::vector< double >::reverse_iterator" : return _fusion.DoubleVector_rbegin(self)
    def rend(self) -> "std::vector< double >::reverse_iterator" : return _fusion.DoubleVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.DoubleVector_pop_back(self)
    def erase(self, *args) -> "std::vector< double >::iterator" : return _fusion.DoubleVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_DoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.DoubleVector_push_back(self, *args)
    def front(self) -> "std::vector< double >::value_type const &" : return _fusion.DoubleVector_front(self)
    def back(self) -> "std::vector< double >::value_type const &" : return _fusion.DoubleVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.DoubleVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.DoubleVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.DoubleVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.DoubleVector_reserve(self, *args)
    def capacity(self) -> "std::vector< double >::size_type" : return _fusion.DoubleVector_capacity(self)
    __swig_destroy__ = _fusion.delete_DoubleVector
    __del__ = lambda self : None;
DoubleVector_swigregister = _fusion.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class IntVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.IntVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.IntVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.IntVector___bool__(self)
    def __len__(self) -> "std::vector< int >::size_type" : return _fusion.IntVector___len__(self)
    def pop(self) -> "std::vector< int >::value_type" : return _fusion.IntVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< int,std::allocator< int > > *" : return _fusion.IntVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.IntVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.IntVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.IntVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< int >::value_type const &" : return _fusion.IntVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.IntVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.IntVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.IntVector_empty(self)
    def size(self) -> "std::vector< int >::size_type" : return _fusion.IntVector_size(self)
    def clear(self) -> "void" : return _fusion.IntVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.IntVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< int >::allocator_type" : return _fusion.IntVector_get_allocator(self)
    def begin(self) -> "std::vector< int >::iterator" : return _fusion.IntVector_begin(self)
    def end(self) -> "std::vector< int >::iterator" : return _fusion.IntVector_end(self)
    def rbegin(self) -> "std::vector< int >::reverse_iterator" : return _fusion.IntVector_rbegin(self)
    def rend(self) -> "std::vector< int >::reverse_iterator" : return _fusion.IntVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.IntVector_pop_back(self)
    def erase(self, *args) -> "std::vector< int >::iterator" : return _fusion.IntVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_IntVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.IntVector_push_back(self, *args)
    def front(self) -> "std::vector< int >::value_type const &" : return _fusion.IntVector_front(self)
    def back(self) -> "std::vector< int >::value_type const &" : return _fusion.IntVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.IntVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.IntVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.IntVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.IntVector_reserve(self, *args)
    def capacity(self) -> "std::vector< int >::size_type" : return _fusion.IntVector_capacity(self)
    __swig_destroy__ = _fusion.delete_IntVector
    __del__ = lambda self : None;
IntVector_swigregister = _fusion.IntVector_swigregister
IntVector_swigregister(IntVector)

class UintVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UintVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UintVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.UintVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.UintVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.UintVector___bool__(self)
    def __len__(self) -> "std::vector< size_t >::size_type" : return _fusion.UintVector___len__(self)
    def pop(self) -> "std::vector< size_t >::value_type" : return _fusion.UintVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< size_t,std::allocator< size_t > > *" : return _fusion.UintVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.UintVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.UintVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.UintVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< size_t >::value_type const &" : return _fusion.UintVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.UintVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.UintVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.UintVector_empty(self)
    def size(self) -> "std::vector< size_t >::size_type" : return _fusion.UintVector_size(self)
    def clear(self) -> "void" : return _fusion.UintVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.UintVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< size_t >::allocator_type" : return _fusion.UintVector_get_allocator(self)
    def begin(self) -> "std::vector< size_t >::iterator" : return _fusion.UintVector_begin(self)
    def end(self) -> "std::vector< size_t >::iterator" : return _fusion.UintVector_end(self)
    def rbegin(self) -> "std::vector< size_t >::reverse_iterator" : return _fusion.UintVector_rbegin(self)
    def rend(self) -> "std::vector< size_t >::reverse_iterator" : return _fusion.UintVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.UintVector_pop_back(self)
    def erase(self, *args) -> "std::vector< size_t >::iterator" : return _fusion.UintVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_UintVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.UintVector_push_back(self, *args)
    def front(self) -> "std::vector< size_t >::value_type const &" : return _fusion.UintVector_front(self)
    def back(self) -> "std::vector< size_t >::value_type const &" : return _fusion.UintVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.UintVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.UintVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.UintVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.UintVector_reserve(self, *args)
    def capacity(self) -> "std::vector< size_t >::size_type" : return _fusion.UintVector_capacity(self)
    __swig_destroy__ = _fusion.delete_UintVector
    __del__ = lambda self : None;
UintVector_swigregister = _fusion.UintVector_swigregister
UintVector_swigregister(UintVector)

class StringVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.StringVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.StringVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.StringVector___bool__(self)
    def __len__(self) -> "std::vector< std::string >::size_type" : return _fusion.StringVector___len__(self)
    def pop(self) -> "std::vector< std::string >::value_type" : return _fusion.StringVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< std::string,std::allocator< std::string > > *" : return _fusion.StringVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.StringVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.StringVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.StringVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &" : return _fusion.StringVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.StringVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.StringVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.StringVector_empty(self)
    def size(self) -> "std::vector< std::string >::size_type" : return _fusion.StringVector_size(self)
    def clear(self) -> "void" : return _fusion.StringVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.StringVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< std::string >::allocator_type" : return _fusion.StringVector_get_allocator(self)
    def begin(self) -> "std::vector< std::string >::iterator" : return _fusion.StringVector_begin(self)
    def end(self) -> "std::vector< std::string >::iterator" : return _fusion.StringVector_end(self)
    def rbegin(self) -> "std::vector< std::string >::reverse_iterator" : return _fusion.StringVector_rbegin(self)
    def rend(self) -> "std::vector< std::string >::reverse_iterator" : return _fusion.StringVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.StringVector_pop_back(self)
    def erase(self, *args) -> "std::vector< std::string >::iterator" : return _fusion.StringVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_StringVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.StringVector_push_back(self, *args)
    def front(self) -> "std::vector< std::string >::value_type const &" : return _fusion.StringVector_front(self)
    def back(self) -> "std::vector< std::string >::value_type const &" : return _fusion.StringVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.StringVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.StringVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.StringVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.StringVector_reserve(self, *args)
    def capacity(self) -> "std::vector< std::string >::size_type" : return _fusion.StringVector_capacity(self)
    __swig_destroy__ = _fusion.delete_StringVector
    __del__ = lambda self : None;
StringVector_swigregister = _fusion.StringVector_swigregister
StringVector_swigregister(StringVector)

class ShortVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShortVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ShortVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.ShortVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.ShortVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.ShortVector___bool__(self)
    def __len__(self) -> "std::vector< short >::size_type" : return _fusion.ShortVector___len__(self)
    def pop(self) -> "std::vector< short >::value_type" : return _fusion.ShortVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< short,std::allocator< short > > *" : return _fusion.ShortVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.ShortVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.ShortVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.ShortVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< short >::value_type const &" : return _fusion.ShortVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.ShortVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.ShortVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.ShortVector_empty(self)
    def size(self) -> "std::vector< short >::size_type" : return _fusion.ShortVector_size(self)
    def clear(self) -> "void" : return _fusion.ShortVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.ShortVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< short >::allocator_type" : return _fusion.ShortVector_get_allocator(self)
    def begin(self) -> "std::vector< short >::iterator" : return _fusion.ShortVector_begin(self)
    def end(self) -> "std::vector< short >::iterator" : return _fusion.ShortVector_end(self)
    def rbegin(self) -> "std::vector< short >::reverse_iterator" : return _fusion.ShortVector_rbegin(self)
    def rend(self) -> "std::vector< short >::reverse_iterator" : return _fusion.ShortVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.ShortVector_pop_back(self)
    def erase(self, *args) -> "std::vector< short >::iterator" : return _fusion.ShortVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_ShortVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.ShortVector_push_back(self, *args)
    def front(self) -> "std::vector< short >::value_type const &" : return _fusion.ShortVector_front(self)
    def back(self) -> "std::vector< short >::value_type const &" : return _fusion.ShortVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.ShortVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.ShortVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.ShortVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.ShortVector_reserve(self, *args)
    def capacity(self) -> "std::vector< short >::size_type" : return _fusion.ShortVector_capacity(self)
    __swig_destroy__ = _fusion.delete_ShortVector
    __del__ = lambda self : None;
ShortVector_swigregister = _fusion.ShortVector_swigregister
ShortVector_swigregister(ShortVector)

class FloatVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FloatVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.FloatVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.FloatVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.FloatVector___bool__(self)
    def __len__(self) -> "std::vector< float >::size_type" : return _fusion.FloatVector___len__(self)
    def pop(self) -> "std::vector< float >::value_type" : return _fusion.FloatVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< float,std::allocator< float > > *" : return _fusion.FloatVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.FloatVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.FloatVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.FloatVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< float >::value_type const &" : return _fusion.FloatVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.FloatVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.FloatVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.FloatVector_empty(self)
    def size(self) -> "std::vector< float >::size_type" : return _fusion.FloatVector_size(self)
    def clear(self) -> "void" : return _fusion.FloatVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.FloatVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< float >::allocator_type" : return _fusion.FloatVector_get_allocator(self)
    def begin(self) -> "std::vector< float >::iterator" : return _fusion.FloatVector_begin(self)
    def end(self) -> "std::vector< float >::iterator" : return _fusion.FloatVector_end(self)
    def rbegin(self) -> "std::vector< float >::reverse_iterator" : return _fusion.FloatVector_rbegin(self)
    def rend(self) -> "std::vector< float >::reverse_iterator" : return _fusion.FloatVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.FloatVector_pop_back(self)
    def erase(self, *args) -> "std::vector< float >::iterator" : return _fusion.FloatVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_FloatVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.FloatVector_push_back(self, *args)
    def front(self) -> "std::vector< float >::value_type const &" : return _fusion.FloatVector_front(self)
    def back(self) -> "std::vector< float >::value_type const &" : return _fusion.FloatVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.FloatVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.FloatVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.FloatVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.FloatVector_reserve(self, *args)
    def capacity(self) -> "std::vector< float >::size_type" : return _fusion.FloatVector_capacity(self)
    __swig_destroy__ = _fusion.delete_FloatVector
    __del__ = lambda self : None;
FloatVector_swigregister = _fusion.FloatVector_swigregister
FloatVector_swigregister(FloatVector)

class Base(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Base, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Base, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::core::Base *" : return _fusion.Base___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Base___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Base___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Base_classType
    if _newclass:classType = staticmethod(_fusion.Base_classType)
    __swig_destroy__ = _fusion.delete_Base
    __del__ = lambda self : None;
    def _get_objectType(self) -> "char const *" : return _fusion.Base__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Base__get_isValid(self)
Base_swigregister = _fusion.Base_swigregister
Base_swigregister(Base)

def Base_classType() -> "char const *" :
  return _fusion.Base_classType()
Base_classType = _fusion.Base_classType

Base.__swig_getmethods__["objectType"] = Base._get_objectType
Base.objectType = property(Base._get_objectType, doc="Returns a string indicating the type of the object.")

Base.__swig_getmethods__["isValid"] = Base._get_isValid
Base.isValid = property(Base._get_isValid, doc="Indicates if this object is still valid, i.e. hasn't been deleted or some other action done to invalidate the reference.")

import adsk.core
class PointContainment(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PointContainment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PointContainment, name)
    __repr__ = _swig_repr
    PointInsidePointContainment = _fusion.PointContainment_PointInsidePointContainment
    PointOnPointContainment = _fusion.PointContainment_PointOnPointContainment
    PointOutsidePointContainment = _fusion.PointContainment_PointOutsidePointContainment
    UnknownPointContainment = _fusion.PointContainment_UnknownPointContainment
    def __init__(self): 
        this = _fusion.new_PointContainment()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_PointContainment
    __del__ = lambda self : None;
PointContainment_swigregister = _fusion.PointContainment_swigregister
PointContainment_swigregister(PointContainment)

class BRepConvertOptions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepConvertOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BRepConvertOptions, name)
    __repr__ = _swig_repr
    ProceduralToNURBSConversion = _fusion.BRepConvertOptions_ProceduralToNURBSConversion
    AnalyticsToNURBSConversion = _fusion.BRepConvertOptions_AnalyticsToNURBSConversion
    PlanesToNURBSConversion = _fusion.BRepConvertOptions_PlanesToNURBSConversion
    SplitPeriodicFacesConversion = _fusion.BRepConvertOptions_SplitPeriodicFacesConversion
    def __init__(self): 
        this = _fusion.new_BRepConvertOptions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_BRepConvertOptions
    __del__ = lambda self : None;
BRepConvertOptions_swigregister = _fusion.BRepConvertOptions_swigregister
BRepConvertOptions_swigregister(BRepConvertOptions)

class OffsetCornerTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OffsetCornerTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OffsetCornerTypes, name)
    __repr__ = _swig_repr
    CircularOffsetCornerType = _fusion.OffsetCornerTypes_CircularOffsetCornerType
    LinearOffsetCornerType = _fusion.OffsetCornerTypes_LinearOffsetCornerType
    ExtendedOffsetCornerType = _fusion.OffsetCornerTypes_ExtendedOffsetCornerType
    def __init__(self): 
        this = _fusion.new_OffsetCornerTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_OffsetCornerTypes
    __del__ = lambda self : None;
OffsetCornerTypes_swigregister = _fusion.OffsetCornerTypes_swigregister
OffsetCornerTypes_swigregister(OffsetCornerTypes)

class BooleanTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BooleanTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BooleanTypes, name)
    __repr__ = _swig_repr
    DifferenceBooleanType = _fusion.BooleanTypes_DifferenceBooleanType
    IntersectionBooleanType = _fusion.BooleanTypes_IntersectionBooleanType
    UnionBooleanType = _fusion.BooleanTypes_UnionBooleanType
    def __init__(self): 
        this = _fusion.new_BooleanTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_BooleanTypes
    __del__ = lambda self : None;
BooleanTypes_swigregister = _fusion.BooleanTypes_swigregister
BooleanTypes_swigregister(BooleanTypes)

class BRepEntityTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepEntityTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BRepEntityTypes, name)
    __repr__ = _swig_repr
    BRepBodyEntityType = _fusion.BRepEntityTypes_BRepBodyEntityType
    BRepFaceEntityType = _fusion.BRepEntityTypes_BRepFaceEntityType
    BRepEdgeEntityType = _fusion.BRepEntityTypes_BRepEdgeEntityType
    BRepVertexEntityType = _fusion.BRepEntityTypes_BRepVertexEntityType
    def __init__(self): 
        this = _fusion.new_BRepEntityTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_BRepEntityTypes
    __del__ = lambda self : None;
BRepEntityTypes_swigregister = _fusion.BRepEntityTypes_swigregister
BRepEntityTypes_swigregister(BRepEntityTypes)

class CalculationAccuracy(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CalculationAccuracy, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CalculationAccuracy, name)
    __repr__ = _swig_repr
    LowCalculationAccuracy = _fusion.CalculationAccuracy_LowCalculationAccuracy
    MediumCalculationAccuracy = _fusion.CalculationAccuracy_MediumCalculationAccuracy
    HighCalculationAccuracy = _fusion.CalculationAccuracy_HighCalculationAccuracy
    VeryHighCalculationAccuracy = _fusion.CalculationAccuracy_VeryHighCalculationAccuracy
    def __init__(self): 
        this = _fusion.new_CalculationAccuracy()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_CalculationAccuracy
    __del__ = lambda self : None;
CalculationAccuracy_swigregister = _fusion.CalculationAccuracy_swigregister
CalculationAccuracy_swigregister(CalculationAccuracy)

class JointDirections(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, JointDirections, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, JointDirections, name)
    __repr__ = _swig_repr
    XAxisJointDirection = _fusion.JointDirections_XAxisJointDirection
    YAxisJointDirection = _fusion.JointDirections_YAxisJointDirection
    ZAxisJointDirection = _fusion.JointDirections_ZAxisJointDirection
    CustomJointDirection = _fusion.JointDirections_CustomJointDirection
    def __init__(self): 
        this = _fusion.new_JointDirections()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_JointDirections
    __del__ = lambda self : None;
JointDirections_swigregister = _fusion.JointDirections_swigregister
JointDirections_swigregister(JointDirections)

class FeatureHealthStates(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FeatureHealthStates, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FeatureHealthStates, name)
    __repr__ = _swig_repr
    HealthyFeatureHealthState = _fusion.FeatureHealthStates_HealthyFeatureHealthState
    WarningFeatureHealthState = _fusion.FeatureHealthStates_WarningFeatureHealthState
    ErrorFeatureHealthState = _fusion.FeatureHealthStates_ErrorFeatureHealthState
    SuppressedFeatureHealthState = _fusion.FeatureHealthStates_SuppressedFeatureHealthState
    RolledBackFeatureHealthState = _fusion.FeatureHealthStates_RolledBackFeatureHealthState
    UnknownFeatureHealthState = _fusion.FeatureHealthStates_UnknownFeatureHealthState
    def __init__(self): 
        this = _fusion.new_FeatureHealthStates()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_FeatureHealthStates
    __del__ = lambda self : None;
FeatureHealthStates_swigregister = _fusion.FeatureHealthStates_swigregister
FeatureHealthStates_swigregister(FeatureHealthStates)

class JointKeyPointTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, JointKeyPointTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, JointKeyPointTypes, name)
    __repr__ = _swig_repr
    StartKeyPoint = _fusion.JointKeyPointTypes_StartKeyPoint
    MiddleKeyPoint = _fusion.JointKeyPointTypes_MiddleKeyPoint
    EndKeyPoint = _fusion.JointKeyPointTypes_EndKeyPoint
    CenterKeyPoint = _fusion.JointKeyPointTypes_CenterKeyPoint
    def __init__(self): 
        this = _fusion.new_JointKeyPointTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_JointKeyPointTypes
    __del__ = lambda self : None;
JointKeyPointTypes_swigregister = _fusion.JointKeyPointTypes_swigregister
JointKeyPointTypes_swigregister(JointKeyPointTypes)

class JointGeometryTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, JointGeometryTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, JointGeometryTypes, name)
    __repr__ = _swig_repr
    JointConstructionPointGeometry = _fusion.JointGeometryTypes_JointConstructionPointGeometry
    JointSketchPointGeometry = _fusion.JointGeometryTypes_JointSketchPointGeometry
    JointBRepVertexGeometry = _fusion.JointGeometryTypes_JointBRepVertexGeometry
    JointBRepEdgeGeometry = _fusion.JointGeometryTypes_JointBRepEdgeGeometry
    JointSketchCurveGeometry = _fusion.JointGeometryTypes_JointSketchCurveGeometry
    JointProfileGeometry = _fusion.JointGeometryTypes_JointProfileGeometry
    JointPlanarBRepFaceGeometry = _fusion.JointGeometryTypes_JointPlanarBRepFaceGeometry
    JointNonPlanarBRepFaceGeometry = _fusion.JointGeometryTypes_JointNonPlanarBRepFaceGeometry
    JointBetweenTwoPlanesGeometry = _fusion.JointGeometryTypes_JointBetweenTwoPlanesGeometry
    def __init__(self): 
        this = _fusion.new_JointGeometryTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_JointGeometryTypes
    __del__ = lambda self : None;
JointGeometryTypes_swigregister = _fusion.JointGeometryTypes_swigregister
JointGeometryTypes_swigregister(JointGeometryTypes)

class JointTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, JointTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, JointTypes, name)
    __repr__ = _swig_repr
    RigidJointType = _fusion.JointTypes_RigidJointType
    RevoluteJointType = _fusion.JointTypes_RevoluteJointType
    SliderJointType = _fusion.JointTypes_SliderJointType
    CylindricalJointType = _fusion.JointTypes_CylindricalJointType
    PinSlotJointType = _fusion.JointTypes_PinSlotJointType
    PlanarJointType = _fusion.JointTypes_PlanarJointType
    BallJointType = _fusion.JointTypes_BallJointType
    def __init__(self): 
        this = _fusion.new_JointTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_JointTypes
    __del__ = lambda self : None;
JointTypes_swigregister = _fusion.JointTypes_swigregister
JointTypes_swigregister(JointTypes)

class ExtentDirections(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExtentDirections, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExtentDirections, name)
    __repr__ = _swig_repr
    PositiveExtentDirection = _fusion.ExtentDirections_PositiveExtentDirection
    NegativeExtentDirection = _fusion.ExtentDirections_NegativeExtentDirection
    SymmetricExtentDirection = _fusion.ExtentDirections_SymmetricExtentDirection
    def __init__(self): 
        this = _fusion.new_ExtentDirections()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_ExtentDirections
    __del__ = lambda self : None;
ExtentDirections_swigregister = _fusion.ExtentDirections_swigregister
ExtentDirections_swigregister(ExtentDirections)

class FeatureOperations(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FeatureOperations, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FeatureOperations, name)
    __repr__ = _swig_repr
    JoinFeatureOperation = _fusion.FeatureOperations_JoinFeatureOperation
    CutFeatureOperation = _fusion.FeatureOperations_CutFeatureOperation
    IntersectFeatureOperation = _fusion.FeatureOperations_IntersectFeatureOperation
    NewBodyFeatureOperation = _fusion.FeatureOperations_NewBodyFeatureOperation
    NewComponentFeatureOperation = _fusion.FeatureOperations_NewComponentFeatureOperation
    def __init__(self): 
        this = _fusion.new_FeatureOperations()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_FeatureOperations
    __del__ = lambda self : None;
FeatureOperations_swigregister = _fusion.FeatureOperations_swigregister
FeatureOperations_swigregister(FeatureOperations)

class PatternEntityTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PatternEntityTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PatternEntityTypes, name)
    __repr__ = _swig_repr
    FacesPatternType = _fusion.PatternEntityTypes_FacesPatternType
    FeaturesPatternType = _fusion.PatternEntityTypes_FeaturesPatternType
    BodiesPatternType = _fusion.PatternEntityTypes_BodiesPatternType
    OccurrencesPatternType = _fusion.PatternEntityTypes_OccurrencesPatternType
    def __init__(self): 
        this = _fusion.new_PatternEntityTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_PatternEntityTypes
    __del__ = lambda self : None;
PatternEntityTypes_swigregister = _fusion.PatternEntityTypes_swigregister
PatternEntityTypes_swigregister(PatternEntityTypes)

class FeatureExtentTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FeatureExtentTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FeatureExtentTypes, name)
    __repr__ = _swig_repr
    OneSideFeatureExtentType = _fusion.FeatureExtentTypes_OneSideFeatureExtentType
    TwoSidesFeatureExtentType = _fusion.FeatureExtentTypes_TwoSidesFeatureExtentType
    SymmetricFeatureExtentType = _fusion.FeatureExtentTypes_SymmetricFeatureExtentType
    def __init__(self): 
        this = _fusion.new_FeatureExtentTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_FeatureExtentTypes
    __del__ = lambda self : None;
FeatureExtentTypes_swigregister = _fusion.FeatureExtentTypes_swigregister
FeatureExtentTypes_swigregister(FeatureExtentTypes)

class HoleTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HoleTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HoleTypes, name)
    __repr__ = _swig_repr
    SimpleHoleType = _fusion.HoleTypes_SimpleHoleType
    CounterboreHoleType = _fusion.HoleTypes_CounterboreHoleType
    CountersinkHoleType = _fusion.HoleTypes_CountersinkHoleType
    def __init__(self): 
        this = _fusion.new_HoleTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_HoleTypes
    __del__ = lambda self : None;
HoleTypes_swigregister = _fusion.HoleTypes_swigregister
HoleTypes_swigregister(HoleTypes)

class HoleEdgePositions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HoleEdgePositions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HoleEdgePositions, name)
    __repr__ = _swig_repr
    EdgeStartPointPosition = _fusion.HoleEdgePositions_EdgeStartPointPosition
    EdgeMidPointPosition = _fusion.HoleEdgePositions_EdgeMidPointPosition
    EdgeEndPointPosition = _fusion.HoleEdgePositions_EdgeEndPointPosition
    def __init__(self): 
        this = _fusion.new_HoleEdgePositions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_HoleEdgePositions
    __del__ = lambda self : None;
HoleEdgePositions_swigregister = _fusion.HoleEdgePositions_swigregister
HoleEdgePositions_swigregister(HoleEdgePositions)

class ChamferTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChamferTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ChamferTypes, name)
    __repr__ = _swig_repr
    EqualDistanceChamferType = _fusion.ChamferTypes_EqualDistanceChamferType
    TwoDistancesChamferType = _fusion.ChamferTypes_TwoDistancesChamferType
    DistanceAndAngleChamferType = _fusion.ChamferTypes_DistanceAndAngleChamferType
    def __init__(self): 
        this = _fusion.new_ChamferTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_ChamferTypes
    __del__ = lambda self : None;
ChamferTypes_swigregister = _fusion.ChamferTypes_swigregister
ChamferTypes_swigregister(ChamferTypes)

class ChainedCurveOptions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChainedCurveOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ChainedCurveOptions, name)
    __repr__ = _swig_repr
    noChainedCurves = _fusion.ChainedCurveOptions_noChainedCurves
    connectedChainedCurves = _fusion.ChainedCurveOptions_connectedChainedCurves
    tangentChainedCurves = _fusion.ChainedCurveOptions_tangentChainedCurves
    openEdgesChainedCurves = _fusion.ChainedCurveOptions_openEdgesChainedCurves
    tangentAndOpenEdgesChainedCurves = _fusion.ChainedCurveOptions_tangentAndOpenEdgesChainedCurves
    def __init__(self): 
        this = _fusion.new_ChainedCurveOptions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_ChainedCurveOptions
    __del__ = lambda self : None;
ChainedCurveOptions_swigregister = _fusion.ChainedCurveOptions_swigregister
ChainedCurveOptions_swigregister(ChainedCurveOptions)

class SweepOrientationTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SweepOrientationTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SweepOrientationTypes, name)
    __repr__ = _swig_repr
    ParallelOrientationType = _fusion.SweepOrientationTypes_ParallelOrientationType
    PerpendicularOrientationType = _fusion.SweepOrientationTypes_PerpendicularOrientationType
    def __init__(self): 
        this = _fusion.new_SweepOrientationTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_SweepOrientationTypes
    __del__ = lambda self : None;
SweepOrientationTypes_swigregister = _fusion.SweepOrientationTypes_swigregister
SweepOrientationTypes_swigregister(SweepOrientationTypes)

class SweepProfileScalingOptions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SweepProfileScalingOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SweepProfileScalingOptions, name)
    __repr__ = _swig_repr
    SweepProfileScaleOption = _fusion.SweepProfileScalingOptions_SweepProfileScaleOption
    SweepProfileStretchOption = _fusion.SweepProfileScalingOptions_SweepProfileStretchOption
    SweepProfileNoScalingOption = _fusion.SweepProfileScalingOptions_SweepProfileNoScalingOption
    def __init__(self): 
        this = _fusion.new_SweepProfileScalingOptions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_SweepProfileScalingOptions
    __del__ = lambda self : None;
SweepProfileScalingOptions_swigregister = _fusion.SweepProfileScalingOptions_swigregister
SweepProfileScalingOptions_swigregister(SweepProfileScalingOptions)

class PatternComputeOptions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PatternComputeOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PatternComputeOptions, name)
    __repr__ = _swig_repr
    OptimizedPatternCompute = _fusion.PatternComputeOptions_OptimizedPatternCompute
    IdenticalPatternCompute = _fusion.PatternComputeOptions_IdenticalPatternCompute
    AdjustPatternCompute = _fusion.PatternComputeOptions_AdjustPatternCompute
    def __init__(self): 
        this = _fusion.new_PatternComputeOptions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_PatternComputeOptions
    __del__ = lambda self : None;
PatternComputeOptions_swigregister = _fusion.PatternComputeOptions_swigregister
PatternComputeOptions_swigregister(PatternComputeOptions)

class PatternDistanceType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PatternDistanceType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PatternDistanceType, name)
    __repr__ = _swig_repr
    ExtentPatternDistanceType = _fusion.PatternDistanceType_ExtentPatternDistanceType
    SpacingPatternDistanceType = _fusion.PatternDistanceType_SpacingPatternDistanceType
    def __init__(self): 
        this = _fusion.new_PatternDistanceType()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_PatternDistanceType
    __del__ = lambda self : None;
PatternDistanceType_swigregister = _fusion.PatternDistanceType_swigregister
PatternDistanceType_swigregister(PatternDistanceType)

class ThreadLocations(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThreadLocations, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ThreadLocations, name)
    __repr__ = _swig_repr
    HighEndThreadLocation = _fusion.ThreadLocations_HighEndThreadLocation
    LowEndThreadLocation = _fusion.ThreadLocations_LowEndThreadLocation
    def __init__(self): 
        this = _fusion.new_ThreadLocations()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_ThreadLocations
    __del__ = lambda self : None;
ThreadLocations_swigregister = _fusion.ThreadLocations_swigregister
ThreadLocations_swigregister(ThreadLocations)

class SplitFaceSplitTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SplitFaceSplitTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SplitFaceSplitTypes, name)
    __repr__ = _swig_repr
    surfaceIntersectionSplitType = _fusion.SplitFaceSplitTypes_surfaceIntersectionSplitType
    alongVectorSplitType = _fusion.SplitFaceSplitTypes_alongVectorSplitType
    closestPointSplitType = _fusion.SplitFaceSplitTypes_closestPointSplitType
    def __init__(self): 
        this = _fusion.new_SplitFaceSplitTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_SplitFaceSplitTypes
    __del__ = lambda self : None;
SplitFaceSplitTypes_swigregister = _fusion.SplitFaceSplitTypes_swigregister
SplitFaceSplitTypes_swigregister(SplitFaceSplitTypes)

class SilhouetteSplitOperations(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SilhouetteSplitOperations, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SilhouetteSplitOperations, name)
    __repr__ = _swig_repr
    SilhouetteSplitFacesOnlyOperation = _fusion.SilhouetteSplitOperations_SilhouetteSplitFacesOnlyOperation
    SilhouetteSplitShelledBodyOperation = _fusion.SilhouetteSplitOperations_SilhouetteSplitShelledBodyOperation
    SilhouetteSplitSolidBodyOperation = _fusion.SilhouetteSplitOperations_SilhouetteSplitSolidBodyOperation
    def __init__(self): 
        this = _fusion.new_SilhouetteSplitOperations()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_SilhouetteSplitOperations
    __del__ = lambda self : None;
SilhouetteSplitOperations_swigregister = _fusion.SilhouetteSplitOperations_swigregister
SilhouetteSplitOperations_swigregister(SilhouetteSplitOperations)

class CoilFeatureTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoilFeatureTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CoilFeatureTypes, name)
    __repr__ = _swig_repr
    RevolutionsAndHeightCoilFeatureType = _fusion.CoilFeatureTypes_RevolutionsAndHeightCoilFeatureType
    RevolutionsAndPitchCoilFeatureType = _fusion.CoilFeatureTypes_RevolutionsAndPitchCoilFeatureType
    HeightAndPitchCoilFeatureType = _fusion.CoilFeatureTypes_HeightAndPitchCoilFeatureType
    SpiralCoilFeatureType = _fusion.CoilFeatureTypes_SpiralCoilFeatureType
    def __init__(self): 
        this = _fusion.new_CoilFeatureTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_CoilFeatureTypes
    __del__ = lambda self : None;
CoilFeatureTypes_swigregister = _fusion.CoilFeatureTypes_swigregister
CoilFeatureTypes_swigregister(CoilFeatureTypes)

class CoilFeatureSectionTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoilFeatureSectionTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CoilFeatureSectionTypes, name)
    __repr__ = _swig_repr
    CircularCoilFeatureSectionType = _fusion.CoilFeatureSectionTypes_CircularCoilFeatureSectionType
    SquareCoilFeatureSectionType = _fusion.CoilFeatureSectionTypes_SquareCoilFeatureSectionType
    TriangularExternalCoilFeatureSectionType = _fusion.CoilFeatureSectionTypes_TriangularExternalCoilFeatureSectionType
    TriangularInternalCoilFeatureSectionType = _fusion.CoilFeatureSectionTypes_TriangularInternalCoilFeatureSectionType
    def __init__(self): 
        this = _fusion.new_CoilFeatureSectionTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_CoilFeatureSectionTypes
    __del__ = lambda self : None;
CoilFeatureSectionTypes_swigregister = _fusion.CoilFeatureSectionTypes_swigregister
CoilFeatureSectionTypes_swigregister(CoilFeatureSectionTypes)

class CoilFeatureSectionPositions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoilFeatureSectionPositions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CoilFeatureSectionPositions, name)
    __repr__ = _swig_repr
    InsideCoilFeatureSectionPosition = _fusion.CoilFeatureSectionPositions_InsideCoilFeatureSectionPosition
    OnCenterCoilFeatureSectionPosition = _fusion.CoilFeatureSectionPositions_OnCenterCoilFeatureSectionPosition
    OutsideCoilFeatureSectionPosition = _fusion.CoilFeatureSectionPositions_OutsideCoilFeatureSectionPosition
    def __init__(self): 
        this = _fusion.new_CoilFeatureSectionPositions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_CoilFeatureSectionPositions
    __del__ = lambda self : None;
CoilFeatureSectionPositions_swigregister = _fusion.CoilFeatureSectionPositions_swigregister
CoilFeatureSectionPositions_swigregister(CoilFeatureSectionPositions)

class SurfaceContinuityTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SurfaceContinuityTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SurfaceContinuityTypes, name)
    __repr__ = _swig_repr
    ConnectedSurfaceContinuityType = _fusion.SurfaceContinuityTypes_ConnectedSurfaceContinuityType
    TangentSurfaceContinuityType = _fusion.SurfaceContinuityTypes_TangentSurfaceContinuityType
    CurvatureSurfaceContinuityType = _fusion.SurfaceContinuityTypes_CurvatureSurfaceContinuityType
    def __init__(self): 
        this = _fusion.new_SurfaceContinuityTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_SurfaceContinuityTypes
    __del__ = lambda self : None;
SurfaceContinuityTypes_swigregister = _fusion.SurfaceContinuityTypes_swigregister
SurfaceContinuityTypes_swigregister(SurfaceContinuityTypes)

class SurfaceExtendTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SurfaceExtendTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SurfaceExtendTypes, name)
    __repr__ = _swig_repr
    NaturalSurfaceExtendType = _fusion.SurfaceExtendTypes_NaturalSurfaceExtendType
    TangentSurfaceExtendType = _fusion.SurfaceExtendTypes_TangentSurfaceExtendType
    PerpendicularSurfaceExtendType = _fusion.SurfaceExtendTypes_PerpendicularSurfaceExtendType
    def __init__(self): 
        this = _fusion.new_SurfaceExtendTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_SurfaceExtendTypes
    __del__ = lambda self : None;
SurfaceExtendTypes_swigregister = _fusion.SurfaceExtendTypes_swigregister
SurfaceExtendTypes_swigregister(SurfaceExtendTypes)

class DistanceUnits(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DistanceUnits, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DistanceUnits, name)
    __repr__ = _swig_repr
    MillimeterDistanceUnits = _fusion.DistanceUnits_MillimeterDistanceUnits
    CentimeterDistanceUnits = _fusion.DistanceUnits_CentimeterDistanceUnits
    MeterDistanceUnits = _fusion.DistanceUnits_MeterDistanceUnits
    InchDistanceUnits = _fusion.DistanceUnits_InchDistanceUnits
    FootDistanceUnits = _fusion.DistanceUnits_FootDistanceUnits
    def __init__(self): 
        this = _fusion.new_DistanceUnits()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_DistanceUnits
    __del__ = lambda self : None;
DistanceUnits_swigregister = _fusion.DistanceUnits_swigregister
DistanceUnits_swigregister(DistanceUnits)

class DefaultDesignTypeOptions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DefaultDesignTypeOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DefaultDesignTypeOptions, name)
    __repr__ = _swig_repr
    PromptForDesignTypeOption = _fusion.DefaultDesignTypeOptions_PromptForDesignTypeOption
    DirectDesignTypeOption = _fusion.DefaultDesignTypeOptions_DirectDesignTypeOption
    ParametricDesignTypeOption = _fusion.DefaultDesignTypeOptions_ParametricDesignTypeOption
    def __init__(self): 
        this = _fusion.new_DefaultDesignTypeOptions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_DefaultDesignTypeOptions
    __del__ = lambda self : None;
DefaultDesignTypeOptions_swigregister = _fusion.DefaultDesignTypeOptions_swigregister
DefaultDesignTypeOptions_swigregister(DefaultDesignTypeOptions)

class DefaultWorkspaces(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DefaultWorkspaces, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DefaultWorkspaces, name)
    __repr__ = _swig_repr
    ModelWorkspace = _fusion.DefaultWorkspaces_ModelWorkspace
    SculptWorkspace = _fusion.DefaultWorkspaces_SculptWorkspace
    PatchWorkspace = _fusion.DefaultWorkspaces_PatchWorkspace
    def __init__(self): 
        this = _fusion.new_DefaultWorkspaces()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_DefaultWorkspaces
    __del__ = lambda self : None;
DefaultWorkspaces_swigregister = _fusion.DefaultWorkspaces_swigregister
DefaultWorkspaces_swigregister(DefaultWorkspaces)

class DesignTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DesignTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DesignTypes, name)
    __repr__ = _swig_repr
    DirectDesignType = _fusion.DesignTypes_DirectDesignType
    ParametricDesignType = _fusion.DesignTypes_ParametricDesignType
    def __init__(self): 
        this = _fusion.new_DesignTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_DesignTypes
    __del__ = lambda self : None;
DesignTypes_swigregister = _fusion.DesignTypes_swigregister
DesignTypes_swigregister(DesignTypes)

class ExpressionError(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpressionError, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExpressionError, name)
    __repr__ = _swig_repr
    CyclicParameterReferenceError = _fusion.ExpressionError_CyclicParameterReferenceError
    def __init__(self): 
        this = _fusion.new_ExpressionError()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_ExpressionError
    __del__ = lambda self : None;
ExpressionError_swigregister = _fusion.ExpressionError_swigregister
ExpressionError_swigregister(ExpressionError)

class DeleteMeError(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DeleteMeError, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DeleteMeError, name)
    __repr__ = _swig_repr
    ParameterReferencedByOtherParameterError = _fusion.DeleteMeError_ParameterReferencedByOtherParameterError
    def __init__(self): 
        this = _fusion.new_DeleteMeError()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_DeleteMeError
    __del__ = lambda self : None;
DeleteMeError_swigregister = _fusion.DeleteMeError_swigregister
DeleteMeError_swigregister(DeleteMeError)

class MeshRefinementSettings(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MeshRefinementSettings, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MeshRefinementSettings, name)
    __repr__ = _swig_repr
    MeshRefinementHigh = _fusion.MeshRefinementSettings_MeshRefinementHigh
    MeshRefinementMedium = _fusion.MeshRefinementSettings_MeshRefinementMedium
    MeshRefinementLow = _fusion.MeshRefinementSettings_MeshRefinementLow
    MeshRefinementCustom = _fusion.MeshRefinementSettings_MeshRefinementCustom
    def __init__(self): 
        this = _fusion.new_MeshRefinementSettings()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_MeshRefinementSettings
    __del__ = lambda self : None;
MeshRefinementSettings_swigregister = _fusion.MeshRefinementSettings_swigregister
MeshRefinementSettings_swigregister(MeshRefinementSettings)

class CustomGraphicsCullModes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsCullModes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsCullModes, name)
    __repr__ = _swig_repr
    CustomGraphicsCullFront = _fusion.CustomGraphicsCullModes_CustomGraphicsCullFront
    CustomGraphicsCullBack = _fusion.CustomGraphicsCullModes_CustomGraphicsCullBack
    CustomGraphicsCullNone = _fusion.CustomGraphicsCullModes_CustomGraphicsCullNone
    def __init__(self): 
        this = _fusion.new_CustomGraphicsCullModes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_CustomGraphicsCullModes
    __del__ = lambda self : None;
CustomGraphicsCullModes_swigregister = _fusion.CustomGraphicsCullModes_swigregister
CustomGraphicsCullModes_swigregister(CustomGraphicsCullModes)

class CustomGraphicsBillBoardStyles(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsBillBoardStyles, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsBillBoardStyles, name)
    __repr__ = _swig_repr
    ScreenBillBoardStyle = _fusion.CustomGraphicsBillBoardStyles_ScreenBillBoardStyle
    AxialBillBoardStyle = _fusion.CustomGraphicsBillBoardStyles_AxialBillBoardStyle
    RightReadingBillBoardStyle = _fusion.CustomGraphicsBillBoardStyles_RightReadingBillBoardStyle
    def __init__(self): 
        this = _fusion.new_CustomGraphicsBillBoardStyles()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_CustomGraphicsBillBoardStyles
    __del__ = lambda self : None;
CustomGraphicsBillBoardStyles_swigregister = _fusion.CustomGraphicsBillBoardStyles_swigregister
CustomGraphicsBillBoardStyles_swigregister(CustomGraphicsBillBoardStyles)

class ViewCorners(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ViewCorners, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ViewCorners, name)
    __repr__ = _swig_repr
    upperLeftViewCorner = _fusion.ViewCorners_upperLeftViewCorner
    upperRightViewCorner = _fusion.ViewCorners_upperRightViewCorner
    lowerLeftViewCorner = _fusion.ViewCorners_lowerLeftViewCorner
    lowerRightViewCorner = _fusion.ViewCorners_lowerRightViewCorner
    def __init__(self): 
        this = _fusion.new_ViewCorners()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_ViewCorners
    __del__ = lambda self : None;
ViewCorners_swigregister = _fusion.ViewCorners_swigregister
ViewCorners_swigregister(ViewCorners)

class CustomGraphicsPointTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsPointTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsPointTypes, name)
    __repr__ = _swig_repr
    UserDefinedCustomGraphicsPointType = _fusion.CustomGraphicsPointTypes_UserDefinedCustomGraphicsPointType
    PointCloudCustomGraphicsPointType = _fusion.CustomGraphicsPointTypes_PointCloudCustomGraphicsPointType
    def __init__(self): 
        this = _fusion.new_CustomGraphicsPointTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_CustomGraphicsPointTypes
    __del__ = lambda self : None;
CustomGraphicsPointTypes_swigregister = _fusion.CustomGraphicsPointTypes_swigregister
CustomGraphicsPointTypes_swigregister(CustomGraphicsPointTypes)

class LineStylePatterns(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LineStylePatterns, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LineStylePatterns, name)
    __repr__ = _swig_repr
    continuousLineStylePattern = _fusion.LineStylePatterns_continuousLineStylePattern
    centerLineStylePattern = _fusion.LineStylePatterns_centerLineStylePattern
    dashedLineStylePattern = _fusion.LineStylePatterns_dashedLineStylePattern
    dotLineStylePattern = _fusion.LineStylePatterns_dotLineStylePattern
    hiddenLineStylePattern = _fusion.LineStylePatterns_hiddenLineStylePattern
    phantomLineStylePattern = _fusion.LineStylePatterns_phantomLineStylePattern
    tracksLineStylePattern = _fusion.LineStylePatterns_tracksLineStylePattern
    zigzagLineStylePattern = _fusion.LineStylePatterns_zigzagLineStylePattern
    def __init__(self): 
        this = _fusion.new_LineStylePatterns()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_LineStylePatterns
    __del__ = lambda self : None;
LineStylePatterns_swigregister = _fusion.LineStylePatterns_swigregister
LineStylePatterns_swigregister(LineStylePatterns)

class MeshUnits(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MeshUnits, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MeshUnits, name)
    __repr__ = _swig_repr
    CentimeterMeshUnit = _fusion.MeshUnits_CentimeterMeshUnit
    MillimeterMeshUnit = _fusion.MeshUnits_MillimeterMeshUnit
    MeterMeshUnit = _fusion.MeshUnits_MeterMeshUnit
    InchMeshUnit = _fusion.MeshUnits_InchMeshUnit
    FootMeshUnit = _fusion.MeshUnits_FootMeshUnit
    def __init__(self): 
        this = _fusion.new_MeshUnits()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_MeshUnits
    __del__ = lambda self : None;
MeshUnits_swigregister = _fusion.MeshUnits_swigregister
MeshUnits_swigregister(MeshUnits)

class TriangleMeshQualityOptions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TriangleMeshQualityOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TriangleMeshQualityOptions, name)
    __repr__ = _swig_repr
    LowQualityTriangleMesh = _fusion.TriangleMeshQualityOptions_LowQualityTriangleMesh
    NormalQualityTriangleMesh = _fusion.TriangleMeshQualityOptions_NormalQualityTriangleMesh
    HighQualityTriangleMesh = _fusion.TriangleMeshQualityOptions_HighQualityTriangleMesh
    VeryHighQualityTriangleMesh = _fusion.TriangleMeshQualityOptions_VeryHighQualityTriangleMesh
    def __init__(self): 
        this = _fusion.new_TriangleMeshQualityOptions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_TriangleMeshQualityOptions
    __del__ = lambda self : None;
TriangleMeshQualityOptions_swigregister = _fusion.TriangleMeshQualityOptions_swigregister
TriangleMeshQualityOptions_swigregister(TriangleMeshQualityOptions)

class SurfaceProjectTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SurfaceProjectTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SurfaceProjectTypes, name)
    __repr__ = _swig_repr
    ClosestPointSurfaceProjectType = _fusion.SurfaceProjectTypes_ClosestPointSurfaceProjectType
    AlongVectorSurfaceProjectType = _fusion.SurfaceProjectTypes_AlongVectorSurfaceProjectType
    def __init__(self): 
        this = _fusion.new_SurfaceProjectTypes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_SurfaceProjectTypes
    __del__ = lambda self : None;
SurfaceProjectTypes_swigregister = _fusion.SurfaceProjectTypes_swigregister
SurfaceProjectTypes_swigregister(SurfaceProjectTypes)

class TextStyles(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TextStyles, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TextStyles, name)
    __repr__ = _swig_repr
    TextStyleBold = _fusion.TextStyles_TextStyleBold
    TextStyleItalic = _fusion.TextStyles_TextStyleItalic
    TextStyleUnderline = _fusion.TextStyles_TextStyleUnderline
    def __init__(self): 
        this = _fusion.new_TextStyles()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_TextStyles
    __del__ = lambda self : None;
TextStyles_swigregister = _fusion.TextStyles_swigregister
TextStyles_swigregister(TextStyles)

class DimensionOrientations(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DimensionOrientations, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DimensionOrientations, name)
    __repr__ = _swig_repr
    AlignedDimensionOrientation = _fusion.DimensionOrientations_AlignedDimensionOrientation
    HorizontalDimensionOrientation = _fusion.DimensionOrientations_HorizontalDimensionOrientation
    VerticalDimensionOrientation = _fusion.DimensionOrientations_VerticalDimensionOrientation
    def __init__(self): 
        this = _fusion.new_DimensionOrientations()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fusion.delete_DimensionOrientations
    __del__ = lambda self : None;
DimensionOrientations_swigregister = _fusion.DimensionOrientations_swigregister
DimensionOrientations_swigregister(DimensionOrientations)

class AsBuiltJointVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AsBuiltJointVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AsBuiltJointVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.AsBuiltJointVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.AsBuiltJointVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.AsBuiltJointVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::size_type" : return _fusion.AsBuiltJointVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::value_type" : return _fusion.AsBuiltJointVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint >,std::allocator< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > > > *" : return _fusion.AsBuiltJointVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.AsBuiltJointVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.AsBuiltJointVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.AsBuiltJointVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::value_type const &" : return _fusion.AsBuiltJointVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.AsBuiltJointVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.AsBuiltJointVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.AsBuiltJointVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::size_type" : return _fusion.AsBuiltJointVector_size(self)
    def clear(self) -> "void" : return _fusion.AsBuiltJointVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.AsBuiltJointVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::allocator_type" : return _fusion.AsBuiltJointVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::iterator" : return _fusion.AsBuiltJointVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::iterator" : return _fusion.AsBuiltJointVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::reverse_iterator" : return _fusion.AsBuiltJointVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::reverse_iterator" : return _fusion.AsBuiltJointVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.AsBuiltJointVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::iterator" : return _fusion.AsBuiltJointVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_AsBuiltJointVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.AsBuiltJointVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::value_type const &" : return _fusion.AsBuiltJointVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::value_type const &" : return _fusion.AsBuiltJointVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.AsBuiltJointVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.AsBuiltJointVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.AsBuiltJointVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.AsBuiltJointVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > >::size_type" : return _fusion.AsBuiltJointVector_capacity(self)
    __swig_destroy__ = _fusion.delete_AsBuiltJointVector
    __del__ = lambda self : None;
AsBuiltJointVector_swigregister = _fusion.AsBuiltJointVector_swigregister
AsBuiltJointVector_swigregister(AsBuiltJointVector)

class BRepBodyVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepBodyVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BRepBodyVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.BRepBodyVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.BRepBodyVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.BRepBodyVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::size_type" : return _fusion.BRepBodyVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::value_type" : return _fusion.BRepBodyVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > > *" : return _fusion.BRepBodyVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.BRepBodyVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.BRepBodyVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.BRepBodyVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::value_type const &" : return _fusion.BRepBodyVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.BRepBodyVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.BRepBodyVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.BRepBodyVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::size_type" : return _fusion.BRepBodyVector_size(self)
    def clear(self) -> "void" : return _fusion.BRepBodyVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.BRepBodyVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::allocator_type" : return _fusion.BRepBodyVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::iterator" : return _fusion.BRepBodyVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::iterator" : return _fusion.BRepBodyVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::reverse_iterator" : return _fusion.BRepBodyVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::reverse_iterator" : return _fusion.BRepBodyVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.BRepBodyVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::iterator" : return _fusion.BRepBodyVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_BRepBodyVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.BRepBodyVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::value_type const &" : return _fusion.BRepBodyVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::value_type const &" : return _fusion.BRepBodyVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.BRepBodyVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.BRepBodyVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.BRepBodyVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.BRepBodyVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody > >::size_type" : return _fusion.BRepBodyVector_capacity(self)
    __swig_destroy__ = _fusion.delete_BRepBodyVector
    __del__ = lambda self : None;
BRepBodyVector_swigregister = _fusion.BRepBodyVector_swigregister
BRepBodyVector_swigregister(BRepBodyVector)

class BRepEdgeVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepEdgeVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BRepEdgeVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.BRepEdgeVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.BRepEdgeVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.BRepEdgeVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::size_type" : return _fusion.BRepEdgeVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::value_type" : return _fusion.BRepEdgeVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepEdge > > > *" : return _fusion.BRepEdgeVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.BRepEdgeVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.BRepEdgeVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.BRepEdgeVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::value_type const &" : return _fusion.BRepEdgeVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.BRepEdgeVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.BRepEdgeVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.BRepEdgeVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::size_type" : return _fusion.BRepEdgeVector_size(self)
    def clear(self) -> "void" : return _fusion.BRepEdgeVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.BRepEdgeVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::allocator_type" : return _fusion.BRepEdgeVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::iterator" : return _fusion.BRepEdgeVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::iterator" : return _fusion.BRepEdgeVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::reverse_iterator" : return _fusion.BRepEdgeVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::reverse_iterator" : return _fusion.BRepEdgeVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.BRepEdgeVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::iterator" : return _fusion.BRepEdgeVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_BRepEdgeVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.BRepEdgeVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::value_type const &" : return _fusion.BRepEdgeVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::value_type const &" : return _fusion.BRepEdgeVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.BRepEdgeVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.BRepEdgeVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.BRepEdgeVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.BRepEdgeVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepEdge > >::size_type" : return _fusion.BRepEdgeVector_capacity(self)
    __swig_destroy__ = _fusion.delete_BRepEdgeVector
    __del__ = lambda self : None;
BRepEdgeVector_swigregister = _fusion.BRepEdgeVector_swigregister
BRepEdgeVector_swigregister(BRepEdgeVector)

class BRepFaceVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepFaceVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BRepFaceVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.BRepFaceVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.BRepFaceVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.BRepFaceVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::size_type" : return _fusion.BRepFaceVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::value_type" : return _fusion.BRepFaceVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepFace > > > *" : return _fusion.BRepFaceVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.BRepFaceVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.BRepFaceVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.BRepFaceVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::value_type const &" : return _fusion.BRepFaceVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.BRepFaceVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.BRepFaceVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.BRepFaceVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::size_type" : return _fusion.BRepFaceVector_size(self)
    def clear(self) -> "void" : return _fusion.BRepFaceVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.BRepFaceVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::allocator_type" : return _fusion.BRepFaceVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::iterator" : return _fusion.BRepFaceVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::iterator" : return _fusion.BRepFaceVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::reverse_iterator" : return _fusion.BRepFaceVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::reverse_iterator" : return _fusion.BRepFaceVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.BRepFaceVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::iterator" : return _fusion.BRepFaceVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_BRepFaceVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.BRepFaceVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::value_type const &" : return _fusion.BRepFaceVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::value_type const &" : return _fusion.BRepFaceVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.BRepFaceVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.BRepFaceVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.BRepFaceVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.BRepFaceVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace > >::size_type" : return _fusion.BRepFaceVector_capacity(self)
    __swig_destroy__ = _fusion.delete_BRepFaceVector
    __del__ = lambda self : None;
BRepFaceVector_swigregister = _fusion.BRepFaceVector_swigregister
BRepFaceVector_swigregister(BRepFaceVector)

class ConstructionAxisVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionAxisVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionAxisVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.ConstructionAxisVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.ConstructionAxisVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.ConstructionAxisVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::size_type" : return _fusion.ConstructionAxisVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::value_type" : return _fusion.ConstructionAxisVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis >,std::allocator< adsk::core::Ptr< adsk::fusion::ConstructionAxis > > > *" : return _fusion.ConstructionAxisVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.ConstructionAxisVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.ConstructionAxisVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.ConstructionAxisVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::value_type const &" : return _fusion.ConstructionAxisVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.ConstructionAxisVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.ConstructionAxisVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.ConstructionAxisVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::size_type" : return _fusion.ConstructionAxisVector_size(self)
    def clear(self) -> "void" : return _fusion.ConstructionAxisVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.ConstructionAxisVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::allocator_type" : return _fusion.ConstructionAxisVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::iterator" : return _fusion.ConstructionAxisVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::iterator" : return _fusion.ConstructionAxisVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::reverse_iterator" : return _fusion.ConstructionAxisVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::reverse_iterator" : return _fusion.ConstructionAxisVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.ConstructionAxisVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::iterator" : return _fusion.ConstructionAxisVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_ConstructionAxisVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.ConstructionAxisVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::value_type const &" : return _fusion.ConstructionAxisVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::value_type const &" : return _fusion.ConstructionAxisVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.ConstructionAxisVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.ConstructionAxisVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.ConstructionAxisVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.ConstructionAxisVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis > >::size_type" : return _fusion.ConstructionAxisVector_capacity(self)
    __swig_destroy__ = _fusion.delete_ConstructionAxisVector
    __del__ = lambda self : None;
ConstructionAxisVector_swigregister = _fusion.ConstructionAxisVector_swigregister
ConstructionAxisVector_swigregister(ConstructionAxisVector)

class ConstructionPlaneVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPlaneVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPlaneVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.ConstructionPlaneVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.ConstructionPlaneVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.ConstructionPlaneVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::size_type" : return _fusion.ConstructionPlaneVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::value_type" : return _fusion.ConstructionPlaneVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane >,std::allocator< adsk::core::Ptr< adsk::fusion::ConstructionPlane > > > *" : return _fusion.ConstructionPlaneVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.ConstructionPlaneVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.ConstructionPlaneVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.ConstructionPlaneVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::value_type const &" : return _fusion.ConstructionPlaneVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.ConstructionPlaneVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.ConstructionPlaneVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.ConstructionPlaneVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::size_type" : return _fusion.ConstructionPlaneVector_size(self)
    def clear(self) -> "void" : return _fusion.ConstructionPlaneVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.ConstructionPlaneVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::allocator_type" : return _fusion.ConstructionPlaneVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::iterator" : return _fusion.ConstructionPlaneVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::iterator" : return _fusion.ConstructionPlaneVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::reverse_iterator" : return _fusion.ConstructionPlaneVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::reverse_iterator" : return _fusion.ConstructionPlaneVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.ConstructionPlaneVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::iterator" : return _fusion.ConstructionPlaneVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_ConstructionPlaneVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.ConstructionPlaneVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::value_type const &" : return _fusion.ConstructionPlaneVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::value_type const &" : return _fusion.ConstructionPlaneVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.ConstructionPlaneVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.ConstructionPlaneVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.ConstructionPlaneVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.ConstructionPlaneVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane > >::size_type" : return _fusion.ConstructionPlaneVector_capacity(self)
    __swig_destroy__ = _fusion.delete_ConstructionPlaneVector
    __del__ = lambda self : None;
ConstructionPlaneVector_swigregister = _fusion.ConstructionPlaneVector_swigregister
ConstructionPlaneVector_swigregister(ConstructionPlaneVector)

class ConstructionPointVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPointVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPointVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.ConstructionPointVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.ConstructionPointVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.ConstructionPointVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::size_type" : return _fusion.ConstructionPointVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::value_type" : return _fusion.ConstructionPointVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint >,std::allocator< adsk::core::Ptr< adsk::fusion::ConstructionPoint > > > *" : return _fusion.ConstructionPointVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.ConstructionPointVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.ConstructionPointVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.ConstructionPointVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::value_type const &" : return _fusion.ConstructionPointVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.ConstructionPointVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.ConstructionPointVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.ConstructionPointVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::size_type" : return _fusion.ConstructionPointVector_size(self)
    def clear(self) -> "void" : return _fusion.ConstructionPointVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.ConstructionPointVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::allocator_type" : return _fusion.ConstructionPointVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::iterator" : return _fusion.ConstructionPointVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::iterator" : return _fusion.ConstructionPointVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::reverse_iterator" : return _fusion.ConstructionPointVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::reverse_iterator" : return _fusion.ConstructionPointVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.ConstructionPointVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::iterator" : return _fusion.ConstructionPointVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_ConstructionPointVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.ConstructionPointVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::value_type const &" : return _fusion.ConstructionPointVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::value_type const &" : return _fusion.ConstructionPointVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.ConstructionPointVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.ConstructionPointVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.ConstructionPointVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.ConstructionPointVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint > >::size_type" : return _fusion.ConstructionPointVector_capacity(self)
    __swig_destroy__ = _fusion.delete_ConstructionPointVector
    __del__ = lambda self : None;
ConstructionPointVector_swigregister = _fusion.ConstructionPointVector_swigregister
ConstructionPointVector_swigregister(ConstructionPointVector)

class JointVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, JointVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, JointVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.JointVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.JointVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.JointVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::size_type" : return _fusion.JointVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::value_type" : return _fusion.JointVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint >,std::allocator< adsk::core::Ptr< adsk::fusion::Joint > > > *" : return _fusion.JointVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.JointVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.JointVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.JointVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::value_type const &" : return _fusion.JointVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.JointVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.JointVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.JointVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::size_type" : return _fusion.JointVector_size(self)
    def clear(self) -> "void" : return _fusion.JointVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.JointVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::allocator_type" : return _fusion.JointVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::iterator" : return _fusion.JointVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::iterator" : return _fusion.JointVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::reverse_iterator" : return _fusion.JointVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::reverse_iterator" : return _fusion.JointVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.JointVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::iterator" : return _fusion.JointVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_JointVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.JointVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::value_type const &" : return _fusion.JointVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::value_type const &" : return _fusion.JointVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.JointVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.JointVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.JointVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.JointVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint > >::size_type" : return _fusion.JointVector_capacity(self)
    __swig_destroy__ = _fusion.delete_JointVector
    __del__ = lambda self : None;
JointVector_swigregister = _fusion.JointVector_swigregister
JointVector_swigregister(JointVector)

class JointOriginVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, JointOriginVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, JointOriginVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.JointOriginVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.JointOriginVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.JointOriginVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::size_type" : return _fusion.JointOriginVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::value_type" : return _fusion.JointOriginVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin >,std::allocator< adsk::core::Ptr< adsk::fusion::JointOrigin > > > *" : return _fusion.JointOriginVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.JointOriginVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.JointOriginVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.JointOriginVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::value_type const &" : return _fusion.JointOriginVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.JointOriginVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.JointOriginVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.JointOriginVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::size_type" : return _fusion.JointOriginVector_size(self)
    def clear(self) -> "void" : return _fusion.JointOriginVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.JointOriginVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::allocator_type" : return _fusion.JointOriginVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::iterator" : return _fusion.JointOriginVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::iterator" : return _fusion.JointOriginVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::reverse_iterator" : return _fusion.JointOriginVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::reverse_iterator" : return _fusion.JointOriginVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.JointOriginVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::iterator" : return _fusion.JointOriginVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_JointOriginVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.JointOriginVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::value_type const &" : return _fusion.JointOriginVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::value_type const &" : return _fusion.JointOriginVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.JointOriginVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.JointOriginVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.JointOriginVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.JointOriginVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin > >::size_type" : return _fusion.JointOriginVector_capacity(self)
    __swig_destroy__ = _fusion.delete_JointOriginVector
    __del__ = lambda self : None;
JointOriginVector_swigregister = _fusion.JointOriginVector_swigregister
JointOriginVector_swigregister(JointOriginVector)

class MeshBodyVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MeshBodyVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MeshBodyVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.MeshBodyVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.MeshBodyVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.MeshBodyVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::size_type" : return _fusion.MeshBodyVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::value_type" : return _fusion.MeshBodyVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody >,std::allocator< adsk::core::Ptr< adsk::fusion::MeshBody > > > *" : return _fusion.MeshBodyVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.MeshBodyVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.MeshBodyVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.MeshBodyVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::value_type const &" : return _fusion.MeshBodyVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.MeshBodyVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.MeshBodyVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.MeshBodyVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::size_type" : return _fusion.MeshBodyVector_size(self)
    def clear(self) -> "void" : return _fusion.MeshBodyVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.MeshBodyVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::allocator_type" : return _fusion.MeshBodyVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::iterator" : return _fusion.MeshBodyVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::iterator" : return _fusion.MeshBodyVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::reverse_iterator" : return _fusion.MeshBodyVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::reverse_iterator" : return _fusion.MeshBodyVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.MeshBodyVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::iterator" : return _fusion.MeshBodyVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_MeshBodyVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.MeshBodyVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::value_type const &" : return _fusion.MeshBodyVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::value_type const &" : return _fusion.MeshBodyVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.MeshBodyVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.MeshBodyVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.MeshBodyVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.MeshBodyVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody > >::size_type" : return _fusion.MeshBodyVector_capacity(self)
    __swig_destroy__ = _fusion.delete_MeshBodyVector
    __del__ = lambda self : None;
MeshBodyVector_swigregister = _fusion.MeshBodyVector_swigregister
MeshBodyVector_swigregister(MeshBodyVector)

class OccurrenceVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OccurrenceVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OccurrenceVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.OccurrenceVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.OccurrenceVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.OccurrenceVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::size_type" : return _fusion.OccurrenceVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::value_type" : return _fusion.OccurrenceVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence >,std::allocator< adsk::core::Ptr< adsk::fusion::Occurrence > > > *" : return _fusion.OccurrenceVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.OccurrenceVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.OccurrenceVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.OccurrenceVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::value_type const &" : return _fusion.OccurrenceVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.OccurrenceVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.OccurrenceVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.OccurrenceVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::size_type" : return _fusion.OccurrenceVector_size(self)
    def clear(self) -> "void" : return _fusion.OccurrenceVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.OccurrenceVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::allocator_type" : return _fusion.OccurrenceVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::iterator" : return _fusion.OccurrenceVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::iterator" : return _fusion.OccurrenceVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::reverse_iterator" : return _fusion.OccurrenceVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::reverse_iterator" : return _fusion.OccurrenceVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.OccurrenceVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::iterator" : return _fusion.OccurrenceVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_OccurrenceVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.OccurrenceVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::value_type const &" : return _fusion.OccurrenceVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::value_type const &" : return _fusion.OccurrenceVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.OccurrenceVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.OccurrenceVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.OccurrenceVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.OccurrenceVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence > >::size_type" : return _fusion.OccurrenceVector_capacity(self)
    __swig_destroy__ = _fusion.delete_OccurrenceVector
    __del__ = lambda self : None;
OccurrenceVector_swigregister = _fusion.OccurrenceVector_swigregister
OccurrenceVector_swigregister(OccurrenceVector)

class RigidGroupVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RigidGroupVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RigidGroupVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.RigidGroupVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.RigidGroupVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.RigidGroupVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::size_type" : return _fusion.RigidGroupVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::value_type" : return _fusion.RigidGroupVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup >,std::allocator< adsk::core::Ptr< adsk::fusion::RigidGroup > > > *" : return _fusion.RigidGroupVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.RigidGroupVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.RigidGroupVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.RigidGroupVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::value_type const &" : return _fusion.RigidGroupVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.RigidGroupVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.RigidGroupVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.RigidGroupVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::size_type" : return _fusion.RigidGroupVector_size(self)
    def clear(self) -> "void" : return _fusion.RigidGroupVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.RigidGroupVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::allocator_type" : return _fusion.RigidGroupVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::iterator" : return _fusion.RigidGroupVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::iterator" : return _fusion.RigidGroupVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::reverse_iterator" : return _fusion.RigidGroupVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::reverse_iterator" : return _fusion.RigidGroupVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.RigidGroupVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::iterator" : return _fusion.RigidGroupVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_RigidGroupVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.RigidGroupVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::value_type const &" : return _fusion.RigidGroupVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::value_type const &" : return _fusion.RigidGroupVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.RigidGroupVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.RigidGroupVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.RigidGroupVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.RigidGroupVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup > >::size_type" : return _fusion.RigidGroupVector_capacity(self)
    __swig_destroy__ = _fusion.delete_RigidGroupVector
    __del__ = lambda self : None;
RigidGroupVector_swigregister = _fusion.RigidGroupVector_swigregister
RigidGroupVector_swigregister(RigidGroupVector)

class SketchVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SketchVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.SketchVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.SketchVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.SketchVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::size_type" : return _fusion.SketchVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::value_type" : return _fusion.SketchVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch >,std::allocator< adsk::core::Ptr< adsk::fusion::Sketch > > > *" : return _fusion.SketchVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.SketchVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.SketchVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.SketchVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::value_type const &" : return _fusion.SketchVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.SketchVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.SketchVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.SketchVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::size_type" : return _fusion.SketchVector_size(self)
    def clear(self) -> "void" : return _fusion.SketchVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.SketchVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::allocator_type" : return _fusion.SketchVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::iterator" : return _fusion.SketchVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::iterator" : return _fusion.SketchVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::reverse_iterator" : return _fusion.SketchVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::reverse_iterator" : return _fusion.SketchVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.SketchVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::iterator" : return _fusion.SketchVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_SketchVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.SketchVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::value_type const &" : return _fusion.SketchVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::value_type const &" : return _fusion.SketchVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.SketchVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.SketchVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.SketchVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.SketchVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch > >::size_type" : return _fusion.SketchVector_capacity(self)
    __swig_destroy__ = _fusion.delete_SketchVector
    __del__ = lambda self : None;
SketchVector_swigregister = _fusion.SketchVector_swigregister
SketchVector_swigregister(SketchVector)

class SketchEntityVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchEntityVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SketchEntityVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.SketchEntityVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.SketchEntityVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.SketchEntityVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::size_type" : return _fusion.SketchEntityVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::value_type" : return _fusion.SketchEntityVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity >,std::allocator< adsk::core::Ptr< adsk::fusion::SketchEntity > > > *" : return _fusion.SketchEntityVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.SketchEntityVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.SketchEntityVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.SketchEntityVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::value_type const &" : return _fusion.SketchEntityVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.SketchEntityVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.SketchEntityVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.SketchEntityVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::size_type" : return _fusion.SketchEntityVector_size(self)
    def clear(self) -> "void" : return _fusion.SketchEntityVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.SketchEntityVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::allocator_type" : return _fusion.SketchEntityVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::iterator" : return _fusion.SketchEntityVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::iterator" : return _fusion.SketchEntityVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::reverse_iterator" : return _fusion.SketchEntityVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::reverse_iterator" : return _fusion.SketchEntityVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.SketchEntityVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::iterator" : return _fusion.SketchEntityVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_SketchEntityVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.SketchEntityVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::value_type const &" : return _fusion.SketchEntityVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::value_type const &" : return _fusion.SketchEntityVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.SketchEntityVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.SketchEntityVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.SketchEntityVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.SketchEntityVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity > >::size_type" : return _fusion.SketchEntityVector_capacity(self)
    __swig_destroy__ = _fusion.delete_SketchEntityVector
    __del__ = lambda self : None;
SketchEntityVector_swigregister = _fusion.SketchEntityVector_swigregister
SketchEntityVector_swigregister(SketchEntityVector)

class SketchCurveVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchCurveVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SketchCurveVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.SketchCurveVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.SketchCurveVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.SketchCurveVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::size_type" : return _fusion.SketchCurveVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::value_type" : return _fusion.SketchCurveVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve >,std::allocator< adsk::core::Ptr< adsk::fusion::SketchCurve > > > *" : return _fusion.SketchCurveVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.SketchCurveVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.SketchCurveVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.SketchCurveVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::value_type const &" : return _fusion.SketchCurveVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.SketchCurveVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.SketchCurveVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.SketchCurveVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::size_type" : return _fusion.SketchCurveVector_size(self)
    def clear(self) -> "void" : return _fusion.SketchCurveVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.SketchCurveVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::allocator_type" : return _fusion.SketchCurveVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::iterator" : return _fusion.SketchCurveVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::iterator" : return _fusion.SketchCurveVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::reverse_iterator" : return _fusion.SketchCurveVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::reverse_iterator" : return _fusion.SketchCurveVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.SketchCurveVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::iterator" : return _fusion.SketchCurveVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_SketchCurveVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.SketchCurveVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::value_type const &" : return _fusion.SketchCurveVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::value_type const &" : return _fusion.SketchCurveVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.SketchCurveVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.SketchCurveVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.SketchCurveVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.SketchCurveVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve > >::size_type" : return _fusion.SketchCurveVector_capacity(self)
    __swig_destroy__ = _fusion.delete_SketchCurveVector
    __del__ = lambda self : None;
SketchCurveVector_swigregister = _fusion.SketchCurveVector_swigregister
SketchCurveVector_swigregister(SketchCurveVector)

class SketchLineVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchLineVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SketchLineVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.SketchLineVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.SketchLineVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.SketchLineVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::size_type" : return _fusion.SketchLineVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::value_type" : return _fusion.SketchLineVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine >,std::allocator< adsk::core::Ptr< adsk::fusion::SketchLine > > > *" : return _fusion.SketchLineVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.SketchLineVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.SketchLineVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.SketchLineVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::value_type const &" : return _fusion.SketchLineVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.SketchLineVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.SketchLineVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.SketchLineVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::size_type" : return _fusion.SketchLineVector_size(self)
    def clear(self) -> "void" : return _fusion.SketchLineVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.SketchLineVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::allocator_type" : return _fusion.SketchLineVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::iterator" : return _fusion.SketchLineVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::iterator" : return _fusion.SketchLineVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::reverse_iterator" : return _fusion.SketchLineVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::reverse_iterator" : return _fusion.SketchLineVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.SketchLineVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::iterator" : return _fusion.SketchLineVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_SketchLineVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.SketchLineVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::value_type const &" : return _fusion.SketchLineVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::value_type const &" : return _fusion.SketchLineVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.SketchLineVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.SketchLineVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.SketchLineVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.SketchLineVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine > >::size_type" : return _fusion.SketchLineVector_capacity(self)
    __swig_destroy__ = _fusion.delete_SketchLineVector
    __del__ = lambda self : None;
SketchLineVector_swigregister = _fusion.SketchLineVector_swigregister
SketchLineVector_swigregister(SketchLineVector)

class Matrix3DVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix3DVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix3DVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.Matrix3DVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.Matrix3DVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.Matrix3DVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::size_type" : return _fusion.Matrix3DVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::value_type" : return _fusion.Matrix3DVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D >,std::allocator< adsk::core::Ptr< adsk::core::Matrix3D > > > *" : return _fusion.Matrix3DVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.Matrix3DVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.Matrix3DVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.Matrix3DVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::value_type const &" : return _fusion.Matrix3DVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.Matrix3DVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.Matrix3DVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.Matrix3DVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::size_type" : return _fusion.Matrix3DVector_size(self)
    def clear(self) -> "void" : return _fusion.Matrix3DVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.Matrix3DVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::allocator_type" : return _fusion.Matrix3DVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::iterator" : return _fusion.Matrix3DVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::iterator" : return _fusion.Matrix3DVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::reverse_iterator" : return _fusion.Matrix3DVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::reverse_iterator" : return _fusion.Matrix3DVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.Matrix3DVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::iterator" : return _fusion.Matrix3DVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_Matrix3DVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.Matrix3DVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::value_type const &" : return _fusion.Matrix3DVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::value_type const &" : return _fusion.Matrix3DVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.Matrix3DVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.Matrix3DVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.Matrix3DVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.Matrix3DVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Matrix3D > >::size_type" : return _fusion.Matrix3DVector_capacity(self)
    __swig_destroy__ = _fusion.delete_Matrix3DVector
    __del__ = lambda self : None;
Matrix3DVector_swigregister = _fusion.Matrix3DVector_swigregister
Matrix3DVector_swigregister(Matrix3DVector)

class Curve3DVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Curve3DVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Curve3DVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.Curve3DVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.Curve3DVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.Curve3DVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::size_type" : return _fusion.Curve3DVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::value_type" : return _fusion.Curve3DVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D >,std::allocator< adsk::core::Ptr< adsk::core::Curve3D > > > *" : return _fusion.Curve3DVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.Curve3DVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.Curve3DVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.Curve3DVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::value_type const &" : return _fusion.Curve3DVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.Curve3DVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.Curve3DVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.Curve3DVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::size_type" : return _fusion.Curve3DVector_size(self)
    def clear(self) -> "void" : return _fusion.Curve3DVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.Curve3DVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::allocator_type" : return _fusion.Curve3DVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::iterator" : return _fusion.Curve3DVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::iterator" : return _fusion.Curve3DVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::reverse_iterator" : return _fusion.Curve3DVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::reverse_iterator" : return _fusion.Curve3DVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.Curve3DVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::iterator" : return _fusion.Curve3DVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_Curve3DVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.Curve3DVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::value_type const &" : return _fusion.Curve3DVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::value_type const &" : return _fusion.Curve3DVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.Curve3DVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.Curve3DVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.Curve3DVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.Curve3DVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D > >::size_type" : return _fusion.Curve3DVector_capacity(self)
    __swig_destroy__ = _fusion.delete_Curve3DVector
    __del__ = lambda self : None;
Curve3DVector_swigregister = _fusion.Curve3DVector_swigregister
Curve3DVector_swigregister(Curve3DVector)

class ValueInputVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ValueInputVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ValueInputVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _fusion.ValueInputVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _fusion.ValueInputVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _fusion.ValueInputVector___bool__(self)
    def __len__(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::size_type" : return _fusion.ValueInputVector___len__(self)
    def pop(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::value_type" : return _fusion.ValueInputVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput >,std::allocator< adsk::core::Ptr< adsk::core::ValueInput > > > *" : return _fusion.ValueInputVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _fusion.ValueInputVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _fusion.ValueInputVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _fusion.ValueInputVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::value_type const &" : return _fusion.ValueInputVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _fusion.ValueInputVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _fusion.ValueInputVector_append(self, *args)
    def empty(self) -> "bool" : return _fusion.ValueInputVector_empty(self)
    def size(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::size_type" : return _fusion.ValueInputVector_size(self)
    def clear(self) -> "void" : return _fusion.ValueInputVector_clear(self)
    def swap(self, *args) -> "void" : return _fusion.ValueInputVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::allocator_type" : return _fusion.ValueInputVector_get_allocator(self)
    def begin(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::iterator" : return _fusion.ValueInputVector_begin(self)
    def end(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::iterator" : return _fusion.ValueInputVector_end(self)
    def rbegin(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::reverse_iterator" : return _fusion.ValueInputVector_rbegin(self)
    def rend(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::reverse_iterator" : return _fusion.ValueInputVector_rend(self)
    def pop_back(self) -> "void" : return _fusion.ValueInputVector_pop_back(self)
    def erase(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::iterator" : return _fusion.ValueInputVector_erase(self, *args)
    def __init__(self, *args): 
        this = _fusion.new_ValueInputVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _fusion.ValueInputVector_push_back(self, *args)
    def front(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::value_type const &" : return _fusion.ValueInputVector_front(self)
    def back(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::value_type const &" : return _fusion.ValueInputVector_back(self)
    def assign(self, *args) -> "void" : return _fusion.ValueInputVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _fusion.ValueInputVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _fusion.ValueInputVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _fusion.ValueInputVector_reserve(self, *args)
    def capacity(self) -> "std::vector< adsk::core::Ptr< adsk::core::ValueInput > >::size_type" : return _fusion.ValueInputVector_capacity(self)
    __swig_destroy__ = _fusion.delete_ValueInputVector
    __del__ = lambda self : None;
ValueInputVector_swigregister = _fusion.ValueInputVector_swigregister
ValueInputVector_swigregister(ValueInputVector)

class AreaProperties(Base):
    """The Area properties of a sketch profile or planar surface."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AreaProperties, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AreaProperties, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::AreaProperties *" : return _fusion.AreaProperties___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.AreaProperties___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.AreaProperties___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.AreaProperties_classType
    if _newclass:classType = staticmethod(_fusion.AreaProperties_classType)
    __swig_destroy__ = _fusion.delete_AreaProperties
    __del__ = lambda self : None;
    def _get_area(self) -> "double" :
        """Gets the area in the square centimeters."""
        return _fusion.AreaProperties__get_area(self)

    def _get_centroid(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        Gets the centroid where the units are centimeters.
        The Location is relative to the sketch origin for a profile or relative to the world coordinate system for a planar face.
        """
        return _fusion.AreaProperties__get_centroid(self)

    def _get_perimeter(self) -> "double" :
        """
        Gets the perimeter in centimeters.
        The perimeter is the sum of the length of all the curves or edges of the profile or planar surface
        """
        return _fusion.AreaProperties__get_perimeter(self)

    def _get_rotationToPrincipal(self) -> "double" :
        """Gets the angle of rotation of the principal axes."""
        return _fusion.AreaProperties__get_rotationToPrincipal(self)

    def _get_accuracy(self) -> "adsk::fusion::CalculationAccuracy" :
        """Returns the accuracy that was used for the calculation."""
        return _fusion.AreaProperties__get_accuracy(self)

    def getPrincipalAxes(self) -> "bool" :
        """
        Method that returns the principal axes. 
        xAxis : The output Vector3D object that indicates the direction of the x axis. 
        yAxis : The output Vector3D object that indicates the direction of the y axis. 
        Returns true if successful
        """
        return _fusion.AreaProperties_getPrincipalAxes(self)

    def getMomentsOfInertia(self) -> "bool" :
        """
        Method that, for a sketch, returns the moments of inertia about the sketch origin. 
        For a planar face, this method returns the moments about the world coordinate system origin.
        Unit for returned values is kg/cm^2. 
        ixx : Output Double that returns the XX partial moment. 
        iyy : Output Double that returns the YY partial moment. 
        izz : Output Double that returns the ZZ partial moment. 
        ixy : Output Double that returns the XY partial moment. 
        iyz : Output Double that returns the YZ partial moment. 
        ixz : Output Double that returns the XZ partial moment. 
        Returns true if successful
        """
        return _fusion.AreaProperties_getMomentsOfInertia(self)

    def getCentroidMomentsOfInertia(self) -> "bool" :
        """
        Method that returns the moments of inertia about the centroid. Unit for returned values is kg/cm^2. 
        ixx : Output Double that returns the XX partial moment. 
        iyy : Output Double that returns the YY partial moment. 
        izz : Output Double that returns the ZZ partial moment. 
        ixy : Output Double that returns the XY partial moment. 
        iyz : Output Double that returns the YZ partial moment. 
        ixz : Output Double that returns the XZ partial moment. 
        Returns true if successful
        """
        return _fusion.AreaProperties_getCentroidMomentsOfInertia(self)

    def getPrincipalMomentsOfInertia(self) -> "bool" :
        """
        Method that returns the moments of inertia about the principal axes. Unit for returned values is kg/cm^2. 
        i1 : Output Double that specifies the first moment of inertia. 
        i2 : Output Double that specifies the second moment of inertia. 
        i3 : Output Double that specifies the third moment of inertia. 
        Returns true if successful
        """
        return _fusion.AreaProperties_getPrincipalMomentsOfInertia(self)

    def getRadiusOfGyration(self) -> "bool" :
        """
        Method that returns the radius of gyration about the principal axes. Unit for returned values is cm. 
        kxx : Output Double that returns the X partial radius of gyration. 
        kyy : Output Double that returns the Y partial radius of gyration. 
        kzz : Output Double that returns the Z partial radius of gyration. 
        Returns true if successful
        """
        return _fusion.AreaProperties_getRadiusOfGyration(self)

    def _get_objectType(self) -> "char const *" : return _fusion.AreaProperties__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.AreaProperties__get_isValid(self)
AreaProperties_swigregister = _fusion.AreaProperties_swigregister
AreaProperties_swigregister(AreaProperties)

def AreaProperties_classType() -> "char const *" :
  return _fusion.AreaProperties_classType()
AreaProperties_classType = _fusion.AreaProperties_classType

AreaProperties.__swig_getmethods__["area"] = AreaProperties._get_area
AreaProperties.area = property(AreaProperties._get_area, doc="Gets the area in the square centimeters.")

AreaProperties.__swig_getmethods__["centroid"] = AreaProperties._get_centroid
AreaProperties.centroid = property(AreaProperties._get_centroid, doc="Gets the centroid where the units are centimeters.\nThe Location is relative to the sketch origin for a profile or relative to the world coordinate system for a planar face.")

AreaProperties.__swig_getmethods__["perimeter"] = AreaProperties._get_perimeter
AreaProperties.perimeter = property(AreaProperties._get_perimeter, doc="Gets the perimeter in centimeters.\nThe perimeter is the sum of the length of all the curves or edges of the profile or planar surface")

AreaProperties.__swig_getmethods__["rotationToPrincipal"] = AreaProperties._get_rotationToPrincipal
AreaProperties.rotationToPrincipal = property(AreaProperties._get_rotationToPrincipal, doc="Gets the angle of rotation of the principal axes.")

AreaProperties.__swig_getmethods__["accuracy"] = AreaProperties._get_accuracy
AreaProperties.accuracy = property(AreaProperties._get_accuracy, doc="Returns the accuracy that was used for the calculation.")

AreaProperties.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, AreaProperties) else None
AreaProperties.cast = lambda arg: arg if isinstance(arg, AreaProperties) else None

class AsBuiltJoint(Base):
    """Represent an as-built joint."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AsBuiltJoint, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AsBuiltJoint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::AsBuiltJoint *" : return _fusion.AsBuiltJoint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.AsBuiltJoint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.AsBuiltJoint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.AsBuiltJoint_classType
    if _newclass:classType = staticmethod(_fusion.AsBuiltJoint_classType)
    __swig_destroy__ = _fusion.delete_AsBuiltJoint
    __del__ = lambda self : None;
    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this AsBuiltJoint."""
        return _fusion.AsBuiltJoint__get_parentComponent(self)

    def _get_name(self) -> "std::string" :
        """
        The name of the as-built joint as it is displayed in the timeline and the browser. The
        name can be changed.
        """
        return _fusion.AsBuiltJoint__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """
        The name of the as-built joint as it is displayed in the timeline and the browser. The
        name can be changed.
        """
        return _fusion.AsBuiltJoint__set_name(self, *args)

    def _get_occurrenceOne(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """Specifies the first of two occurrences the joint is between."""
        return _fusion.AsBuiltJoint__get_occurrenceOne(self)

    def _get_occurrenceTwo(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """Specifies the second of two occurrences the joint is between."""
        return _fusion.AsBuiltJoint__get_occurrenceTwo(self)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::fusion::JointGeometry >" :
        """
        Specifies the position of the joint. Getting this property will return null and
        setting it will be ignored in the case where the joint motion is rigid.
        """
        return _fusion.AsBuiltJoint__get_geometry(self)

    def _set_geometry(self, *args) -> "bool" :
        """
        Specifies the position of the joint. Getting this property will return null and
        setting it will be ignored in the case where the joint motion is rigid.
        """
        return _fusion.AsBuiltJoint__set_geometry(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this as-built joint. 
        Returns true if the delete was successful.
        """
        return _fusion.AsBuiltJoint_deleteMe(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this as-built joint."""
        return _fusion.AsBuiltJoint__get_timelineObject(self)

    def _get_jointMotion(self) -> "adsk::core::Ptr< adsk::fusion::JointMotion >" :
        """Returns a JointMotion object that defines the motion relationship between the two geometries."""
        return _fusion.AsBuiltJoint__get_jointMotion(self)

    def setAsRigidJointMotion(self) -> "bool" :
        """
        Redefines the relationship between the two joint geometries as a rigid joint. 
        Returns true if successful.
        """
        return _fusion.AsBuiltJoint_setAsRigidJointMotion(self)

    def setAsRevoluteJointMotion(self, *args) -> "bool" :
        """
        Redefines the relationship between the two joint geometries as a revolute joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        geometry : Redefines the joint geometry. If not provided, the existing geometry is used. This argument is 
        required if the current joint motion is rigid. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived
        from. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJoint_setAsRevoluteJointMotion(self, *args)

    def setAsSliderJointMotion(self, *args) -> "bool" :
        """
        Redefines the relationship between the two joint geometries as a slider joint. 
        sliderDirection : Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the 
        customSliderDirectionEntity argument must also be provided. 
        geometry : Redefines the joint geometry. If not provided, the existing geometry is used. This argument is 
        required if the current joint motion is rigid. 
        customSliderDirectionEntity : If the sliderDirection is CustomJointDirection this argument is used to specify the entity that defines
        the custom slider direction. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJoint_setAsSliderJointMotion(self, *args)

    def setAsCylindricalJointMotion(self, *args) -> "bool" :
        """
        Redefines the relationship between the two joint geometries as a cylindrical joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        geometry : Redefines the joint geometry. If not provided, the existing geometry is used. This argument is 
        required if the current joint motion is rigid. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived
        from. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJoint_setAsCylindricalJointMotion(self, *args)

    def setAsPinSlotJointMotion(self, *args) -> "bool" :
        """
        Redefines the relationship between the two joint geometries as a pin-slot joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        slideDirection : Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the 
        customSlideDirectionEntity argument must also be provided. 
        geometry : Redefines the joint geometry. If not provided, the existing geometry is used. This argument is 
        required if the current joint motion is rigid. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived 
        customSlideDirectionEntity : If the slideDirection is CustomJointDirection this argument is used to specify the entity that defines
        the custom slide direction. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJoint_setAsPinSlotJointMotion(self, *args)

    def setAsPlanarJointMotion(self, *args) -> "bool" :
        """
        Redefines the relationship between the two joint geometries as a planar joint. 
        normalDirection : Defines the direction of the normal of the single degree of rotation.
        This can be set to XAxisJointDirection, YAxisJointDirection, ZAxisJointDirection, 
        or CustomJointDirection. If set to CustomJointDirection then the customNormalDirectionEntity
        argument must also be provided. 
        geometry : Redefines the joint geometry. If not provided, the existing geometry is used. This argument is 
        required if the current joint motion is rigid. 
        customNormalDirectionEntity : If the normalDirection is CustomJointDirection this argument is used to specify the entity that defines
        the direction of the normal. This can be several types of entities that can define a direction. 
        customPrimarySlideDirection : This arguments defines the direction of the primary slide direction. A default primary slide direction 
        is automatically chosen and will be used if this argument is not provided or is null. The secondary slide
        direction is automatically inferred from the normal and primary slide directions. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJoint_setAsPlanarJointMotion(self, *args)

    def setAsBallJointMotion(self, *args) -> "bool" :
        """
        Redefines the relationship between the two joint geometries as a ball joint. 
        pitchDirection : Defines the direction the pitch angle is measured from. This can be ZAxisJointDirection or CustomJointDirection. If
        CustomJointDirection is specified then you must also provide a value for the customPitchDirection argument. 
        yawDirection : Defines the direction the yaw is measured from. This can be XAxisJointDirection or CustomJointDirection. If
        CustomJointDirection is specified then you must also provide a value for the customYawDirection argument. 
        geometry : Redefines the joint geometry. If not provided, the existing geometry is used. This argument is 
        required if the current joint motion is rigid. 
        customPitchDirection : If the pitchDirection argument is customPitchDirection this argument is used to define the direction the pitch
        angel is measured from. This can be several types of entities that can define a direction. 
        customYawDirection : If the yawDirection argument is customPitchDirection this argument is used to define the direction the yaw
        angel is measured from. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJoint_setAsBallJointMotion(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoint >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.AsBuiltJoint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.AsBuiltJoint_createForAssemblyContext(self, *args)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.AsBuiltJoint__get_assemblyContext(self)

    def _get_isSuppressed(self) -> "bool" :
        """Gets and sets if this as-built joint is suppressed."""
        return _fusion.AsBuiltJoint__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """Gets and sets if this as-built joint is suppressed."""
        return _fusion.AsBuiltJoint__set_isSuppressed(self, *args)

    def _get_isLightBulbOn(self) -> "bool" :
        """
        Gets and sets if the light bulb of this as-built joint as displayed in the browser is on or off.
        A joint will only be visible if the light bulb is switched on. However,
        the light bulb can be on and the joint still invisible if a higher level occurrence 
        in the assembly context is not visible because its light bulb is off or the joints folder
        is light bulb is off.
        """
        return _fusion.AsBuiltJoint__get_isLightBulbOn(self)

    def _set_isLightBulbOn(self, *args) -> "bool" :
        """
        Gets and sets if the light bulb of this as-built joint as displayed in the browser is on or off.
        A joint will only be visible if the light bulb is switched on. However,
        the light bulb can be on and the joint still invisible if a higher level occurrence 
        in the assembly context is not visible because its light bulb is off or the joints folder
        is light bulb is off.
        """
        return _fusion.AsBuiltJoint__set_isLightBulbOn(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        Gets whether the as-built joint is visible. To change the visibility see the isLightBulbOn property.
        This property is affected by the assembly context.
        """
        return _fusion.AsBuiltJoint__get_isVisible(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this as-built joint."""
        return _fusion.AsBuiltJoint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.AsBuiltJoint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.AsBuiltJoint__get_isValid(self)
AsBuiltJoint_swigregister = _fusion.AsBuiltJoint_swigregister
AsBuiltJoint_swigregister(AsBuiltJoint)

def AsBuiltJoint_classType() -> "char const *" :
  return _fusion.AsBuiltJoint_classType()
AsBuiltJoint_classType = _fusion.AsBuiltJoint_classType

AsBuiltJoint.__swig_getmethods__["parentComponent"] = AsBuiltJoint._get_parentComponent
AsBuiltJoint.parentComponent = property(AsBuiltJoint._get_parentComponent, doc="Returns the parent component that owns this AsBuiltJoint.")

AsBuiltJoint.__swig_getmethods__["name"] = AsBuiltJoint._get_name
AsBuiltJoint.__swig_setmethods__["name"] = AsBuiltJoint._set_name
AsBuiltJoint.name = property(AsBuiltJoint._get_name, AsBuiltJoint._set_name, doc="The name of the as-built joint as it is displayed in the timeline and the browser. The\nname can be changed.")

AsBuiltJoint.__swig_getmethods__["occurrenceOne"] = AsBuiltJoint._get_occurrenceOne
AsBuiltJoint.occurrenceOne = property(AsBuiltJoint._get_occurrenceOne, doc="Specifies the first of two occurrences the joint is between.")

AsBuiltJoint.__swig_getmethods__["occurrenceTwo"] = AsBuiltJoint._get_occurrenceTwo
AsBuiltJoint.occurrenceTwo = property(AsBuiltJoint._get_occurrenceTwo, doc="Specifies the second of two occurrences the joint is between.")

AsBuiltJoint.__swig_getmethods__["geometry"] = AsBuiltJoint._get_geometry
AsBuiltJoint.__swig_setmethods__["geometry"] = AsBuiltJoint._set_geometry
AsBuiltJoint.geometry = property(AsBuiltJoint._get_geometry, AsBuiltJoint._set_geometry, doc="Specifies the position of the joint. Getting this property will return null and\nsetting it will be ignored in the case where the joint motion is rigid.")

AsBuiltJoint.__swig_getmethods__["timelineObject"] = AsBuiltJoint._get_timelineObject
AsBuiltJoint.timelineObject = property(AsBuiltJoint._get_timelineObject, doc="Returns the timeline object associated with this as-built joint.")

AsBuiltJoint.__swig_getmethods__["jointMotion"] = AsBuiltJoint._get_jointMotion
AsBuiltJoint.jointMotion = property(AsBuiltJoint._get_jointMotion, doc="Returns a JointMotion object that defines the motion relationship between the two geometries.")

AsBuiltJoint.__swig_getmethods__["nativeObject"] = AsBuiltJoint._get_nativeObject
AsBuiltJoint.nativeObject = property(AsBuiltJoint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

AsBuiltJoint.__swig_getmethods__["assemblyContext"] = AsBuiltJoint._get_assemblyContext
AsBuiltJoint.assemblyContext = property(AsBuiltJoint._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")

AsBuiltJoint.__swig_getmethods__["isSuppressed"] = AsBuiltJoint._get_isSuppressed
AsBuiltJoint.__swig_setmethods__["isSuppressed"] = AsBuiltJoint._set_isSuppressed
AsBuiltJoint.isSuppressed = property(AsBuiltJoint._get_isSuppressed, AsBuiltJoint._set_isSuppressed, doc="Gets and sets if this as-built joint is suppressed.")

AsBuiltJoint.__swig_getmethods__["isLightBulbOn"] = AsBuiltJoint._get_isLightBulbOn
AsBuiltJoint.__swig_setmethods__["isLightBulbOn"] = AsBuiltJoint._set_isLightBulbOn
AsBuiltJoint.isLightBulbOn = property(AsBuiltJoint._get_isLightBulbOn, AsBuiltJoint._set_isLightBulbOn, doc="Gets and sets if the light bulb of this as-built joint as displayed in the browser is on or off.\nA joint will only be visible if the light bulb is switched on. However,\nthe light bulb can be on and the joint still invisible if a higher level occurrence\nin the assembly context is not visible because its light bulb is off or the joints folder\nis light bulb is off.")

AsBuiltJoint.__swig_getmethods__["isVisible"] = AsBuiltJoint._get_isVisible
AsBuiltJoint.isVisible = property(AsBuiltJoint._get_isVisible, doc="Gets whether the as-built joint is visible. To change the visibility see the isLightBulbOn property.\nThis property is affected by the assembly context.")

AsBuiltJoint.__swig_getmethods__["attributes"] = AsBuiltJoint._get_attributes
AsBuiltJoint.attributes = property(AsBuiltJoint._get_attributes, doc="Returns the collection of attributes associated with this as-built joint.")

AsBuiltJoint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, AsBuiltJoint) else None
AsBuiltJoint.cast = lambda arg: arg if isinstance(arg, AsBuiltJoint) else None

class AsBuiltJointInput(Base):
    """Defines all of the information needed to create an as-built joint."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AsBuiltJointInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AsBuiltJointInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::AsBuiltJointInput *" : return _fusion.AsBuiltJointInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.AsBuiltJointInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.AsBuiltJointInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.AsBuiltJointInput_classType
    if _newclass:classType = staticmethod(_fusion.AsBuiltJointInput_classType)
    __swig_destroy__ = _fusion.delete_AsBuiltJointInput
    __del__ = lambda self : None;
    def _get_occurrenceOne(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """Specifies the first of two occurrences the joint is between."""
        return _fusion.AsBuiltJointInput__get_occurrenceOne(self)

    def _set_occurrenceOne(self, *args) -> "bool" :
        """Specifies the first of two occurrences the joint is between."""
        return _fusion.AsBuiltJointInput__set_occurrenceOne(self, *args)

    def _get_occurrenceTwo(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """Specifies the second of two occurrences the joint is between."""
        return _fusion.AsBuiltJointInput__get_occurrenceTwo(self)

    def _set_occurrenceTwo(self, *args) -> "bool" :
        """Specifies the second of two occurrences the joint is between."""
        return _fusion.AsBuiltJointInput__set_occurrenceTwo(self, *args)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::fusion::JointGeometry >" :
        """Specifies the position of the joint."""
        return _fusion.AsBuiltJointInput__get_geometry(self)

    def _set_geometry(self, *args) -> "bool" :
        """Specifies the position of the joint."""
        return _fusion.AsBuiltJointInput__set_geometry(self, *args)

    def setAsRigidJointMotion(self) -> "bool" :
        """
        Defines the relationship between the two joint geometries as a rigid joint. 
        Returns true if successful.
        """
        return _fusion.AsBuiltJointInput_setAsRigidJointMotion(self)

    def setAsRevoluteJointMotion(self, *args) -> "bool" :
        """
        Defines the relationship between the two joint geometries as a revolute joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived
        from. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJointInput_setAsRevoluteJointMotion(self, *args)

    def setAsSliderJointMotion(self, *args) -> "bool" :
        """
        Defines the relationship between the two joint geometries as a slider joint. 
        sliderDirection : Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the 
        customSliderDirectionEntity argument must also be provided. 
        customSliderDirectionEntity : If the sliderDirection is CustomJointDirection this argument is used to specify the entity that defines
        the custom slider direction. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJointInput_setAsSliderJointMotion(self, *args)

    def setAsCylindricalJointMotion(self, *args) -> "bool" :
        """
        Defines the relationship between the two joint geometries as a cylindrical joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived
        from. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJointInput_setAsCylindricalJointMotion(self, *args)

    def setAsPinSlotJointMotion(self, *args) -> "bool" :
        """
        Defines the relationship between the two joint geometries as a pin-slot joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        slideDirection : Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the 
        customSlideDirectionEntity argument must also be provided. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived 
        customSlideDirectionEntity : If the slideDirection is CustomJointDirection this argument is used to specify the entity that defines
        the custom slide direction. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJointInput_setAsPinSlotJointMotion(self, *args)

    def setAsPlanarJointMotion(self, *args) -> "bool" :
        """
        Defines the relationship between the two joint geometries as a planar joint. 
        normalDirection : Defines the direction of the normal of the single degree of rotation.
        This can be set to XAxisJointDirection, YAxisJointDirection, ZAxisJointDirection, 
        or CustomJointDirection. If set to CustomJointDirection then the customNormalDirectionEntity
        argument must also be provided. 
        customNormalDirectionEntity : If the normalDirection is CustomJointDirection this argument is used to specify the entity that defines
        the direction of the normal. This can be several types of entities that can define a direction. 
        customPrimarySlideDirection : This arguments defines the direction of the primary slide direction. A default primary slide direction 
        is automatically chosen and will be used if this argument is not provided or is null. The secondary slide
        direction is automatically inferred from the normal and primary slide directions. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJointInput_setAsPlanarJointMotion(self, *args)

    def setAsBallJointMotion(self, *args) -> "bool" :
        """
        Defines the relationship between the two joint geometries as a ball joint. 
        pitchDirection : Defines the direction the pitch angle is measured from. This can be ZAxisJointDirection or CustomJointDirection. If
        CustomJointDirection is specified then you must also provide a value for the customPitchDirection argument. 
        yawDirection : Defines the direction the yaw is measured from. This can be XAxisJointDirection or CustomJointDirection. If
        CustomJointDirection is specified then you must also provide a value for the customYawDirection argument. 
        customPitchDirection : If the pitchDirection argument is customPitchDirection this argument is used to define the direction the pitch
        angel is measured from. This can be several types of entities that can define a direction. 
        customYawDirection : If the yawDirection argument is customPitchDirection this argument is used to define the direction the yaw
        angel is measured from. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.AsBuiltJointInput_setAsBallJointMotion(self, *args)

    def _get_jointMotion(self) -> "adsk::core::Ptr< adsk::fusion::JointMotion >" :
        """
        Returns one of the objects derived from JointMotion that defines how the motion between
        the two joint geometries is defined. Can be null if the motion hasn't yet been defined.
        """
        return _fusion.AsBuiltJointInput__get_jointMotion(self)

    def _get_objectType(self) -> "char const *" : return _fusion.AsBuiltJointInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.AsBuiltJointInput__get_isValid(self)
AsBuiltJointInput_swigregister = _fusion.AsBuiltJointInput_swigregister
AsBuiltJointInput_swigregister(AsBuiltJointInput)

def AsBuiltJointInput_classType() -> "char const *" :
  return _fusion.AsBuiltJointInput_classType()
AsBuiltJointInput_classType = _fusion.AsBuiltJointInput_classType

AsBuiltJointInput.__swig_getmethods__["occurrenceOne"] = AsBuiltJointInput._get_occurrenceOne
AsBuiltJointInput.__swig_setmethods__["occurrenceOne"] = AsBuiltJointInput._set_occurrenceOne
AsBuiltJointInput.occurrenceOne = property(AsBuiltJointInput._get_occurrenceOne, AsBuiltJointInput._set_occurrenceOne, doc="Specifies the first of two occurrences the joint is between.")

AsBuiltJointInput.__swig_getmethods__["occurrenceTwo"] = AsBuiltJointInput._get_occurrenceTwo
AsBuiltJointInput.__swig_setmethods__["occurrenceTwo"] = AsBuiltJointInput._set_occurrenceTwo
AsBuiltJointInput.occurrenceTwo = property(AsBuiltJointInput._get_occurrenceTwo, AsBuiltJointInput._set_occurrenceTwo, doc="Specifies the second of two occurrences the joint is between.")

AsBuiltJointInput.__swig_getmethods__["geometry"] = AsBuiltJointInput._get_geometry
AsBuiltJointInput.__swig_setmethods__["geometry"] = AsBuiltJointInput._set_geometry
AsBuiltJointInput.geometry = property(AsBuiltJointInput._get_geometry, AsBuiltJointInput._set_geometry, doc="Specifies the position of the joint.")

AsBuiltJointInput.__swig_getmethods__["jointMotion"] = AsBuiltJointInput._get_jointMotion
AsBuiltJointInput.jointMotion = property(AsBuiltJointInput._get_jointMotion, doc="Returns one of the objects derived from JointMotion that defines how the motion between\nthe two joint geometries is defined. Can be null if the motion hasn't yet been defined.")

AsBuiltJointInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, AsBuiltJointInput) else None
AsBuiltJointInput.cast = lambda arg: arg if isinstance(arg, AsBuiltJointInput) else None

class AsBuiltJointList(Base):
    """A list of as-built joints."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AsBuiltJointList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AsBuiltJointList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::AsBuiltJointList *" : return _fusion.AsBuiltJointList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.AsBuiltJointList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.AsBuiltJointList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.AsBuiltJointList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoint >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.AsBuiltJointList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.AsBuiltJointList_classType
    if _newclass:classType = staticmethod(_fusion.AsBuiltJointList_classType)
    __swig_destroy__ = _fusion.delete_AsBuiltJointList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoint >" :
        """
        Function that returns the specified as-built joint using an index into the list. 
        index : The index of the item within the list to return. The first item in the list has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.AsBuiltJointList_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoint >" :
        """
        Function that returns the specified as-built joint using a name. 
        name : The name of the item within the list to return. 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.AsBuiltJointList_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns number of as-built joints in the list."""
        return _fusion.AsBuiltJointList__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.AsBuiltJointList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.AsBuiltJointList__get_isValid(self)
AsBuiltJointList_swigregister = _fusion.AsBuiltJointList_swigregister
AsBuiltJointList_swigregister(AsBuiltJointList)

def AsBuiltJointList_classType() -> "char const *" :
  return _fusion.AsBuiltJointList_classType()
AsBuiltJointList_classType = _fusion.AsBuiltJointList_classType

AsBuiltJointList.__swig_getmethods__["count"] = AsBuiltJointList._get_count
AsBuiltJointList.count = property(AsBuiltJointList._get_count, doc="Returns number of as-built joints in the list.")

AsBuiltJointList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, AsBuiltJointList) else None
AsBuiltJointList.cast = lambda arg: arg if isinstance(arg, AsBuiltJointList) else None

class AsBuiltJoints(Base):
    """
    The collection of as-built joints in this component. This provides access to all existing 
    as-built joints and supports the ability to create new as-built joints.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AsBuiltJoints, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AsBuiltJoints, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::AsBuiltJoints *" : return _fusion.AsBuiltJoints___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.AsBuiltJoints___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.AsBuiltJoints___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.AsBuiltJoints___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoint >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.AsBuiltJoints___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.AsBuiltJoints_classType
    if _newclass:classType = staticmethod(_fusion.AsBuiltJoints_classType)
    __swig_destroy__ = _fusion.delete_AsBuiltJoints
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoint >" :
        """
        Function that returns the specified as-built joint using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.AsBuiltJoints_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoint >" :
        """
        Function that returns the specified as-built joint using a name. 
        name : The name of the item within the collection to return. 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.AsBuiltJoints_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns number of joint origins in the collection."""
        return _fusion.AsBuiltJoints__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::AsBuiltJointInput >" :
        """
        Creates an AsBuiltJointInput object which is used to collect all of the information needed
        to create an as-built joint. This object is equivalent to the as-built joint dialog in the 
        user-interface in that it doesn't represent an actual joint but just the information needed
        to create an as-built joint. Once this is fully defined the add method can be called, passing
        this object in to create the actual joint. 
        occurrenceOne : Specifies the first of two occurrences the joint is between. 
        occurrenceTwo : Specifies the second of two occurrences the joint is between. 
        geometry : Specifies the geometry of where the joint will be positioned. If the as-built joint is
        a rigid joint, this argument should be null because no geometry is needed. 
        Returns the new AsBuiltJointInput object or null in the case of failure.
        """
        return _fusion.AsBuiltJoints_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoint >" :
        """
        Creates a new as-built joint. 
        input : An AsBuiltJointInput object that was created using the AsBuiltJoints.createInput method and then fully defined
        using the properties and methods on the AsBuiltJointInput object. 
        Returns the new AsBuiltJoint object or null in the case of failure.
        """
        return _fusion.AsBuiltJoints_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.AsBuiltJoints__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.AsBuiltJoints__get_isValid(self)
AsBuiltJoints_swigregister = _fusion.AsBuiltJoints_swigregister
AsBuiltJoints_swigregister(AsBuiltJoints)

def AsBuiltJoints_classType() -> "char const *" :
  return _fusion.AsBuiltJoints_classType()
AsBuiltJoints_classType = _fusion.AsBuiltJoints_classType

AsBuiltJoints.__swig_getmethods__["count"] = AsBuiltJoints._get_count
AsBuiltJoints.count = property(AsBuiltJoints._get_count, doc="Returns number of joint origins in the collection.")

AsBuiltJoints.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, AsBuiltJoints) else None
AsBuiltJoints.cast = lambda arg: arg if isinstance(arg, AsBuiltJoints) else None

class BaseComponent(Base):
    """
    The BaseComponent object that defines all of the common design data
    and is the base class for the product specific components.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BaseComponent, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BaseComponent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BaseComponent *" : return _fusion.BaseComponent___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BaseComponent___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BaseComponent___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BaseComponent_classType
    if _newclass:classType = staticmethod(_fusion.BaseComponent_classType)
    __swig_destroy__ = _fusion.delete_BaseComponent
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """
        Property that gets and sets the name of this component. This is the name
        shown in the browser for each occurrence referencing this component.
        """
        return _fusion.BaseComponent__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """
        Property that gets and sets the name of this component. This is the name
        shown in the browser for each occurrence referencing this component.
        """
        return _fusion.BaseComponent__set_name(self, *args)

    def _get_occurrences(self) -> "adsk::core::Ptr< adsk::fusion::Occurrences >" :
        """
        Property that returns the Occurrences collection associated with this component.
        This provides access to the occurrences at the top-level of this component and provides
        the functionality to add new occurrences.
        """
        return _fusion.BaseComponent__get_occurrences(self)

    def occurrencesByComponent(self, *args) -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >" :
        """
        Returns all occurrences at the top-level of this component that reference the specified component.
        The returned list is read-only. 
        component : The component that is being referenced by the occurrences that will be returned. 
        The occurrences referenced by the specified component.
        """
        return _fusion.BaseComponent_occurrencesByComponent(self, *args)

    def _get_allOccurrences(self) -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >" :
        """
        Returns all of the occurrences in the assembly regardless of their level within the assembly structure.
        The returned list is read-only.
        """
        return _fusion.BaseComponent__get_allOccurrences(self)

    def allOccurrencesByComponent(self, *args) -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >" :
        """
        Returns all occurrences, at any level of the assembly, that reference the specified component.
        The returned list is read-only. 
        component : The component that is being referenced by the occurrences that will be returned. 
        The occurrences referenced by the specified component.
        """
        return _fusion.BaseComponent_allOccurrencesByComponent(self, *args)

    def _get_constructionPlanes(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlanes >" :
        """
        Returns the construction planes collection associated with this component.
        This provides access to the existing construction planes and supports
        the creation of new construction planes.
        """
        return _fusion.BaseComponent__get_constructionPlanes(self)

    def _get_constructionAxes(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxes >" :
        """
        Returns the construction axes collection associated with this component.
        This provides access to the existing construction axes and supports
        the creation of new construction axes.
        """
        return _fusion.BaseComponent__get_constructionAxes(self)

    def _get_constructionPoints(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoints >" :
        """
        Returns the construction points collection associated with this component.
        This provides access to the existing construction points and supports
        the creation of new construction points.
        """
        return _fusion.BaseComponent__get_constructionPoints(self)

    def _get_bRepBodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """Returns the B-Rep bodies collection associated with this component."""
        return _fusion.BaseComponent__get_bRepBodies(self)

    def _get_parentDesign(self) -> "adsk::core::Ptr< adsk::fusion::Design >" :
        """Returns the parent product this component is owned by."""
        return _fusion.BaseComponent__get_parentDesign(self)

    def findBRepUsingRay(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Finds all the B-Rep entities that are intersected by the specified ray. This can return BRepFace, BrepEdge,
        and BRepVertex objects. 
        originPoint : Input point that defines the origin of the ray. The search for entities begins at this point. 
        rayDirection : Input vector that defines the direction of the ray. The ray is infinite so the length of the vector is ignored. 
        entityType : The type of B-Rep entity wanted. You can also take advantage of B-Rep topology to infer other intersections. For example,
        If you get a BRepEdge it implies that the faces the edge connects were also intersected. If a BRepVertex is returned it 
        implies the edges that the vertex connects were intersected and the faces that the edges connect were intersected. 
        proximityTolerance : Optional argument that specifies the tolerance for the search. All entities within this distance from the ray and of the specified type will be returned. If not specified a default small tolerance is used. 
        visibleEntitiesOnly : Optional argument that indicates whether or not invisible entities should be included in the search. Defaults to True indicating that invisible entities will be ignored. 
        hitPoints : An ObjectCollection of Point3D objects that represent the coordinates where the ray hit the found entity. There will be the same number of hit points as returned entities
        and they will be in the collections in the same order. In other words, hit point 1 corresponds with found entity 1, hit point 2 corresponds with found entity 2, and so on.
        Because of the proximity tolerance the hitPoint may not actually lie on the entity but will be within the proximity tolerance to it.
        It's an optional out argument, returns the hit points if an existing ObjectCollection is input. You can create a new ObjectCollection by using
        the static create method on the ObjectCollection class. 
        Returns an ObjectCollection containing the entities found. The returned collection can be empty indicating nothing was found. The points are returned
        in an order where they are arranged based on their distance from the origin point where the closest point is first. If an entity is hit more than
        once, the entity is returned once for the first intersection.
        """
        return _fusion.BaseComponent_findBRepUsingRay(self, *args)

    def findBRepUsingPoint(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Finds all the entities of the specified type at the specified location. 
        point : Input coordinate that specifies the component space point at which to find the entities. 
        entityType : The type of B-Rep entity wanted. You can also take advantage of B-Rep topology to infer other that other entities were found. For example,
        If you get a BRepEdge it implies that the faces the edge connects were also found. If a BRepVertex is returned it 
        implies the edges that the vertex connects were found and the faces that the edges connect were found. 
        proximityTolerance : Specifies the tolerance for the search. All entities within this distance from the search point that match the filter will be returned. If not specified a default tolerance is used. 
        visibleEntitiesOnly : indicates whether or not invisible objects should be included in the search. Defaults to True indicating that invisible objects will be ignored. 
        Returns an ObjectCollection containing the entities found. The returned collection can be empty indicating nothing was found.
        """
        return _fusion.BaseComponent_findBRepUsingPoint(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.BaseComponent__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BaseComponent__get_isValid(self)
BaseComponent_swigregister = _fusion.BaseComponent_swigregister
BaseComponent_swigregister(BaseComponent)

def BaseComponent_classType() -> "char const *" :
  return _fusion.BaseComponent_classType()
BaseComponent_classType = _fusion.BaseComponent_classType

BaseComponent.__swig_getmethods__["name"] = BaseComponent._get_name
BaseComponent.__swig_setmethods__["name"] = BaseComponent._set_name
BaseComponent.name = property(BaseComponent._get_name, BaseComponent._set_name, doc="Property that gets and sets the name of this component. This is the name\nshown in the browser for each occurrence referencing this component.")

BaseComponent.__swig_getmethods__["occurrences"] = BaseComponent._get_occurrences
BaseComponent.occurrences = property(BaseComponent._get_occurrences, doc="Property that returns the Occurrences collection associated with this component.\nThis provides access to the occurrences at the top-level of this component and provides\nthe functionality to add new occurrences.")

BaseComponent.__swig_getmethods__["allOccurrences"] = BaseComponent._get_allOccurrences
BaseComponent.allOccurrences = property(BaseComponent._get_allOccurrences, doc="Returns all of the occurrences in the assembly regardless of their level within the assembly structure.\nThe returned list is read-only.")

BaseComponent.__swig_getmethods__["constructionPlanes"] = BaseComponent._get_constructionPlanes
BaseComponent.constructionPlanes = property(BaseComponent._get_constructionPlanes, doc="Returns the construction planes collection associated with this component.\nThis provides access to the existing construction planes and supports\nthe creation of new construction planes.")

BaseComponent.__swig_getmethods__["constructionAxes"] = BaseComponent._get_constructionAxes
BaseComponent.constructionAxes = property(BaseComponent._get_constructionAxes, doc="Returns the construction axes collection associated with this component.\nThis provides access to the existing construction axes and supports\nthe creation of new construction axes.")

BaseComponent.__swig_getmethods__["constructionPoints"] = BaseComponent._get_constructionPoints
BaseComponent.constructionPoints = property(BaseComponent._get_constructionPoints, doc="Returns the construction points collection associated with this component.\nThis provides access to the existing construction points and supports\nthe creation of new construction points.")

BaseComponent.__swig_getmethods__["bRepBodies"] = BaseComponent._get_bRepBodies
BaseComponent.bRepBodies = property(BaseComponent._get_bRepBodies, doc="Returns the B-Rep bodies collection associated with this component.")

BaseComponent.__swig_getmethods__["parentDesign"] = BaseComponent._get_parentDesign
BaseComponent.parentDesign = property(BaseComponent._get_parentDesign, doc="Returns the parent product this component is owned by.")

BaseComponent.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BaseComponent) else None
BaseComponent.cast = lambda arg: arg if isinstance(arg, BaseComponent) else None

class BaseFeatures(Base):
    """The BaseFeature class represents a direct edit feature within a parametric design."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BaseFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BaseFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BaseFeatures *" : return _fusion.BaseFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BaseFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BaseFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.BaseFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.BaseFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BaseFeatures_classType
    if _newclass:classType = staticmethod(_fusion.BaseFeatures_classType)
    __swig_destroy__ = _fusion.delete_BaseFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        Function that returns the specified base feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BaseFeatures_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        Function that returns the specified base feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.BaseFeatures_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of base features in the collection."""
        return _fusion.BaseFeatures__get_count(self)

    def add(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        Creates a new empty base feature in the parent component. 
        Returns the new BaseFeature or null in the case of an error.
        """
        return _fusion.BaseFeatures_add(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BaseFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BaseFeatures__get_isValid(self)
BaseFeatures_swigregister = _fusion.BaseFeatures_swigregister
BaseFeatures_swigregister(BaseFeatures)

def BaseFeatures_classType() -> "char const *" :
  return _fusion.BaseFeatures_classType()
BaseFeatures_classType = _fusion.BaseFeatures_classType

BaseFeatures.__swig_getmethods__["count"] = BaseFeatures._get_count
BaseFeatures.count = property(BaseFeatures._get_count, doc="The number of base features in the collection.")

BaseFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BaseFeatures) else None
BaseFeatures.cast = lambda arg: arg if isinstance(arg, BaseFeatures) else None

class BoundaryFillFeatureInput(Base):
    """This class defines the methods and properties that pertain to the definition of a BoundaryFillFeatureInput."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoundaryFillFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BoundaryFillFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BoundaryFillFeatureInput *" : return _fusion.BoundaryFillFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BoundaryFillFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BoundaryFillFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BoundaryFillFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.BoundaryFillFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_BoundaryFillFeatureInput
    __del__ = lambda self : None;
    def _get_bRepCells(self) -> "adsk::core::Ptr< adsk::fusion::BRepCells >" :
        """
        Returns the collection of the valid cells that have been calculated based on the set of input tools.
        You use this collection to specify which cells you want included in the output.
        """
        return _fusion.BoundaryFillFeatureInput__get_bRepCells(self)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """Gets and sets the type of operation performed by the boundary fill feature."""
        return _fusion.BoundaryFillFeatureInput__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """Gets and sets the type of operation performed by the boundary fill feature."""
        return _fusion.BoundaryFillFeatureInput__set_operation(self, *args)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Boundary Fill is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the Boundary Fill) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.BoundaryFillFeatureInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, *args) -> "bool" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Boundary Fill is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the Boundary Fill) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.BoundaryFillFeatureInput__set_creationOccurrence(self, *args)

    def _get_tools(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the collection of one or more construction planes and open or closed 
        BRepBody objects that are used in calculating the possible closed boundaries.
        """
        return _fusion.BoundaryFillFeatureInput__get_tools(self)

    def _set_tools(self, *args) -> "bool" :
        """
        Gets and sets the collection of one or more construction planes and open or closed 
        BRepBody objects that are used in calculating the possible closed boundaries.
        """
        return _fusion.BoundaryFillFeatureInput__set_tools(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.BoundaryFillFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.BoundaryFillFeatureInput__set_targetBaseFeature(self, *args)

    def cancel(self) -> "bool" :
        """
        To determine the possible boundaries and allow you to choose which cells to keep, the boundary 
        fill feature does a partial compute when the input object is created. To do this it starts a boundary
        fill feature transaction and completes the transaction when you call the add method. If you don't 
        call the add method to finish the transaction it leaves Fusion 360 in a bad state and there will be undo
        problems and possibly a crash. If you have created a BoundFillFeatureInput object and don't want to finish
        the feature creation, you need to call the cancel method on the BoundaryFillFeatureInput object to 
        safely abort the current boundary fill transaction.
        """
        return _fusion.BoundaryFillFeatureInput_cancel(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BoundaryFillFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BoundaryFillFeatureInput__get_isValid(self)
BoundaryFillFeatureInput_swigregister = _fusion.BoundaryFillFeatureInput_swigregister
BoundaryFillFeatureInput_swigregister(BoundaryFillFeatureInput)

def BoundaryFillFeatureInput_classType() -> "char const *" :
  return _fusion.BoundaryFillFeatureInput_classType()
BoundaryFillFeatureInput_classType = _fusion.BoundaryFillFeatureInput_classType

BoundaryFillFeatureInput.__swig_getmethods__["bRepCells"] = BoundaryFillFeatureInput._get_bRepCells
BoundaryFillFeatureInput.bRepCells = property(BoundaryFillFeatureInput._get_bRepCells, doc="Returns the collection of the valid cells that have been calculated based on the set of input tools.\nYou use this collection to specify which cells you want included in the output.")

BoundaryFillFeatureInput.__swig_getmethods__["operation"] = BoundaryFillFeatureInput._get_operation
BoundaryFillFeatureInput.__swig_setmethods__["operation"] = BoundaryFillFeatureInput._set_operation
BoundaryFillFeatureInput.operation = property(BoundaryFillFeatureInput._get_operation, BoundaryFillFeatureInput._set_operation, doc="Gets and sets the type of operation performed by the boundary fill feature.")

BoundaryFillFeatureInput.__swig_getmethods__["creationOccurrence"] = BoundaryFillFeatureInput._get_creationOccurrence
BoundaryFillFeatureInput.__swig_setmethods__["creationOccurrence"] = BoundaryFillFeatureInput._set_creationOccurrence
BoundaryFillFeatureInput.creationOccurrence = property(BoundaryFillFeatureInput._get_creationOccurrence, BoundaryFillFeatureInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the Boundary Fill is created based on geometry (e.g. a profile and/or face(s))\nin another component AND (the Boundary Fill) is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI")

BoundaryFillFeatureInput.__swig_getmethods__["tools"] = BoundaryFillFeatureInput._get_tools
BoundaryFillFeatureInput.__swig_setmethods__["tools"] = BoundaryFillFeatureInput._set_tools
BoundaryFillFeatureInput.tools = property(BoundaryFillFeatureInput._get_tools, BoundaryFillFeatureInput._set_tools, doc="Gets and sets the collection of one or more construction planes and open or closed\nBRepBody objects that are used in calculating the possible closed boundaries.")

BoundaryFillFeatureInput.__swig_getmethods__["targetBaseFeature"] = BoundaryFillFeatureInput._get_targetBaseFeature
BoundaryFillFeatureInput.__swig_setmethods__["targetBaseFeature"] = BoundaryFillFeatureInput._set_targetBaseFeature
BoundaryFillFeatureInput.targetBaseFeature = property(BoundaryFillFeatureInput._get_targetBaseFeature, BoundaryFillFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

BoundaryFillFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BoundaryFillFeatureInput) else None
BoundaryFillFeatureInput.cast = lambda arg: arg if isinstance(arg, BoundaryFillFeatureInput) else None

class BoundaryFillFeatures(Base):
    """
    Collection that provides access to all of the existing boundary fill features in a component
    and supports the ability to create new boundary fill features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoundaryFillFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BoundaryFillFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BoundaryFillFeatures *" : return _fusion.BoundaryFillFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BoundaryFillFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BoundaryFillFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.BoundaryFillFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::BoundaryFillFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.BoundaryFillFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BoundaryFillFeatures_classType
    if _newclass:classType = staticmethod(_fusion.BoundaryFillFeatures_classType)
    __swig_destroy__ = _fusion.delete_BoundaryFillFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::BoundaryFillFeature >" :
        """
        Function that returns the specified boundary fill feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BoundaryFillFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of boundary fill features in the collection."""
        return _fusion.BoundaryFillFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::BoundaryFillFeatureInput >" :
        """
        Creates a BoundaryFillFeatureInput object. Use properties and methods on this object
        to define the boundary fill you want to create and then use the Add method, passing in 
        the BoundaryFillFeatureInput object.
        To determine the possible boundaries and allow you to choose which cells to keep, the boundary 
        fill feature does a partial compute when the input object is created. To do this it starts a boundary
        fill feature transaction and completes the transaction when you call the add method. If you don't 
        call the add method to finish the transaction it leaves Fusion 360 in a bad state and there will be undo
        problems and possibly a crash. If you have created a BoundFillFeatureInput object and don't want to finish
        the feature creation, you need to call the cancel method on the BoundaryFillFeatureInput object to 
        safely abort the current boundary fill transaction. 
        tools : A collection of one or more construction planes and open or closed BRepBody objects that will be 
        used in calculating the possible closed boundaries. 
        operation : The operation type to perform. 
        Returns the newly created BoundaryFillFeatureInput object or null if the creation failed.
        """
        return _fusion.BoundaryFillFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::BoundaryFillFeature >" :
        """
        Creates a new boundary fill feature. 
        input : A BoundaryFillFeatureInput object that defines the desired boundary fill feature. Use the createInput 
        method to create a new BoundaryFillFeatureInput object and then use methods on it 
        (the BoundaryFillFeatureInput object) to define the boundary fill feature. 
        Returns the newly created BoundaryFillFeature object or null if the creation failed.
        """
        return _fusion.BoundaryFillFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::BoundaryFillFeature >" :
        """
        Function that returns the specified boundary fill feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.BoundaryFillFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.BoundaryFillFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BoundaryFillFeatures__get_isValid(self)
BoundaryFillFeatures_swigregister = _fusion.BoundaryFillFeatures_swigregister
BoundaryFillFeatures_swigregister(BoundaryFillFeatures)

def BoundaryFillFeatures_classType() -> "char const *" :
  return _fusion.BoundaryFillFeatures_classType()
BoundaryFillFeatures_classType = _fusion.BoundaryFillFeatures_classType

BoundaryFillFeatures.__swig_getmethods__["count"] = BoundaryFillFeatures._get_count
BoundaryFillFeatures.count = property(BoundaryFillFeatures._get_count, doc="The number of boundary fill features in the collection.")

BoundaryFillFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BoundaryFillFeatures) else None
BoundaryFillFeatures.cast = lambda arg: arg if isinstance(arg, BoundaryFillFeatures) else None

class BoxFeatures(Base):
    """Collection that provides access to all of the existing box features in a design."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoxFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BoxFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BoxFeatures *" : return _fusion.BoxFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BoxFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BoxFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.BoxFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::BoxFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.BoxFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BoxFeatures_classType
    if _newclass:classType = staticmethod(_fusion.BoxFeatures_classType)
    __swig_destroy__ = _fusion.delete_BoxFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::BoxFeature >" :
        """
        Function that returns the specified box feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BoxFeatures_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::BoxFeature >" :
        """
        Function that returns the specified box feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.BoxFeatures_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of box features in the collection."""
        return _fusion.BoxFeatures__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BoxFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BoxFeatures__get_isValid(self)
BoxFeatures_swigregister = _fusion.BoxFeatures_swigregister
BoxFeatures_swigregister(BoxFeatures)

def BoxFeatures_classType() -> "char const *" :
  return _fusion.BoxFeatures_classType()
BoxFeatures_classType = _fusion.BoxFeatures_classType

BoxFeatures.__swig_getmethods__["count"] = BoxFeatures._get_count
BoxFeatures.count = property(BoxFeatures._get_count, doc="The number of box features in the collection.")

BoxFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BoxFeatures) else None
BoxFeatures.cast = lambda arg: arg if isinstance(arg, BoxFeatures) else None

class BRepBodies(Base):
    """
    The BRepBodies collection provides access to all of the B-Rep
    bodies within a component.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepBodies, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepBodies, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepBodies *" : return _fusion.BRepBodies___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepBodies___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepBodies___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.BRepBodies___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.BRepBodies___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepBodies_classType
    if _newclass:classType = staticmethod(_fusion.BRepBodies_classType)
    __swig_destroy__ = _fusion.delete_BRepBodies
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Function that returns the specified body using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepBodies_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Returns a specific body using the name of the body within the collection. 
        name : The name of the body, as seen in the browser, to return. 
        The BRepBody or null if a body with the defined name is not found.
        """
        return _fusion.BRepBodies_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of bodies in the collection."""
        return _fusion.BRepBodies__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Creates a new BRepBody object. The input can be a persisted or transient BRepBody and the
        result is a persisted BRepBody. In a model where the design history is ignored (direct edit model)
        the BRepBody is created within the component the BRepBodies collection was obtained from. In
        a model where the design history is captured (parametric model), the new BRepBody is created
        within the specified Base Feature.
        Because of a current limitation, if you want to create a BRepBody in a parametric model, 
        you must first call the edit method of the base feature, then use the add method to create 
        the body, and finally call the finishEdit method of the base feature. The base 
        feature must be in an 'edit' state to be able to add any additional items to it. 
        body : The input BRepBody. Typically this is a transient BRepBody but that's not a requirement. In 
        any case, there is not any association back to the original BRepBody. 
        targetBaseFeature : The BaseFeature object that this B-Rep body will be associated with. This is an optional
        requirement but is required when the model design history is being captured (parametric model) but is
        ignored otherwise (direct edit model). 
        Returns the newly created BRepBody or null if the creation failed.
        """
        return _fusion.BRepBodies_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepBodies__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepBodies__get_isValid(self)
BRepBodies_swigregister = _fusion.BRepBodies_swigregister
BRepBodies_swigregister(BRepBodies)

def BRepBodies_classType() -> "char const *" :
  return _fusion.BRepBodies_classType()
BRepBodies_classType = _fusion.BRepBodies_classType

BRepBodies.__swig_getmethods__["count"] = BRepBodies._get_count
BRepBodies.count = property(BRepBodies._get_count, doc="Returns the number of bodies in the collection.")

BRepBodies.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepBodies) else None
BRepBodies.cast = lambda arg: arg if isinstance(arg, BRepBodies) else None

class BRepBody(Base):
    """Represents a B-Rep (Boundary Representation) body."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepBody, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepBody, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepBody *" : return _fusion.BRepBody___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepBody___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepBody___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepBody_classType
    if _newclass:classType = staticmethod(_fusion.BRepBody_classType)
    __swig_destroy__ = _fusion.delete_BRepBody
    __del__ = lambda self : None;
    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the component this body is owned by."""
        return _fusion.BRepBody__get_parentComponent(self)

    def _get_lumps(self) -> "adsk::core::Ptr< adsk::fusion::BRepLumps >" :
        """Returns a collection of all of the lumps in the body."""
        return _fusion.BRepBody__get_lumps(self)

    def _get_shells(self) -> "adsk::core::Ptr< adsk::fusion::BRepShells >" :
        """Returns a collection of all of the shells in the body."""
        return _fusion.BRepBody__get_shells(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """Returns a collection of all of the faces in the body."""
        return _fusion.BRepBody__get_faces(self)

    def _get_edges(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdges >" :
        """Returns a collection of all of the edges in the body."""
        return _fusion.BRepBody__get_edges(self)

    def _get_vertices(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertices >" :
        """Returns a collection of all of the vertices in the body."""
        return _fusion.BRepBody__get_vertices(self)

    def _get_isSolid(self) -> "bool" :
        """Returns whether this body is closed (solid) or not."""
        return _fusion.BRepBody__get_isSolid(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of this body."""
        return _fusion.BRepBody__get_boundingBox(self)

    def _get_concaveEdges(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdges >" :
        """Returns all of the edges that connect concave faces."""
        return _fusion.BRepBody__get_concaveEdges(self)

    def _get_convexEdges(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdges >" :
        """Returns all of the edges that connect convex faces."""
        return _fusion.BRepBody__get_convexEdges(self)

    def _get_area(self) -> "double" :
        """Returns the area in cm ^ 2."""
        return _fusion.BRepBody__get_area(self)

    def _get_volume(self) -> "double" :
        """Returns the volume in cm ^ 3. Returns 0 in the case the body is not solid."""
        return _fusion.BRepBody__get_volume(self)

    def pointContainment(self, *args) -> "adsk::fusion::PointContainment" :
        """
        Determines the relationship of the input point with respect to this body. 
        point : The point to do the containment check for. 
        Returns a value from the PointContainment enum indicating the relationship of
        the input point to the body.
        """
        return _fusion.BRepBody_pointContainment(self, *args)

    def _get_isTransient(self) -> "bool" :
        """Indicates if this body is represented in the model or is transient."""
        return _fusion.BRepBody__get_isTransient(self)

    def _get_name(self) -> "std::string" :
        """
        Gets and sets the name of the body. 
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """
        Gets and sets the name of the body. 
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__set_name(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        Gets if this body is currently visible in the graphics window. Use the
        isLightBulbOn to change if the light bulb beside the body node in the 
        browser is on or not. Parent nodes in the browser can have their light
        bulb off which affects all of their children. This property indicates 
        the final result and whether this body is actually visible or not.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """
        Gets if this body is currently visible in the graphics window. Use the
        isLightBulbOn to change if the light bulb beside the body node in the 
        browser is on or not. Parent nodes in the browser can have their light
        bulb off which affects all of their children. This property indicates 
        the final result and whether this body is actually visible or not.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__set_isVisible(self, *args)

    def _get_isSelectable(self) -> "bool" :
        """
        Gets and sets if this body is selectable.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__get_isSelectable(self)

    def _set_isSelectable(self, *args) -> "bool" :
        """
        Gets and sets if this body is selectable.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__set_isSelectable(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the body.
        This property is only valid if the IsTransient property is false. 
        Returns true if the delete was successful.
        """
        return _fusion.BRepBody_deleteMe(self)

    def copy(self) -> "bool" :
        """
        Copies the body to the clipboard.
        This property is only valid if the IsTransient property is false. 
        Returns true if the copy was successful.
        """
        return _fusion.BRepBody_copy(self)

    def cut(self) -> "bool" :
        """
        Cuts the body to the clipboard.
        This property is only valid if the IsTransient property is false. 
        Returns true if the cut was successful.
        """
        return _fusion.BRepBody_cut(self)

    def _get_appearance(self) -> "adsk::core::Ptr< adsk::core::Appearance >" :
        """
        Read-write property that gets and sets the current appearance of the body. Setting this property will result in applying
        an override appearance to the body and the AppearanceSourceType property will return OverrideAppearanceSource. Setting
        this property to null will remove any override.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__get_appearance(self)

    def _set_appearance(self, *args) -> "bool" :
        """
        Read-write property that gets and sets the current appearance of the body. Setting this property will result in applying
        an override appearance to the body and the AppearanceSourceType property will return OverrideAppearanceSource. Setting
        this property to null will remove any override.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__set_appearance(self, *args)

    def _get_appearanceSourceType(self) -> "adsk::core::AppearanceSourceTypes" :
        """
        Read-write property that gets the source of the appearance for the body. If this returns OverrideAppearanceSource, an override exists
        on this body. The override can be removed by setting the Appearance property to null.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__get_appearanceSourceType(self)

    def _get_material(self) -> "adsk::core::Ptr< adsk::core::Material >" :
        """
        Gets and sets the material assigned to this body.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__get_material(self)

    def _set_material(self, *args) -> "bool" :
        """
        Gets and sets the material assigned to this body.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__set_material(self, *args)

    def _get_meshManager(self) -> "adsk::core::Ptr< adsk::fusion::MeshManager >" :
        """Returns the mesh manager object for this body."""
        return _fusion.BRepBody__get_meshManager(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        BRepBody object is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object. Also returns null in the case
        where this body is transient.
        """
        return _fusion.BRepBody__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BRepBody__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence.
        This method is only valid if the IsTransient property is false. 
        occurrence : The occurrence that defines the context for the created proxy. 
        Returns the new BRepBoy proxy or null if this isn't the NativeObject.
        """
        return _fusion.BRepBody_createForAssemblyContext(self, *args)

    def createComponent(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Creates a new component and occurrence within the component that currently owns this body.
        This body is moved into the new component and returned. The newly created component can be
        obtained by using the parentComponent property of the BRepBody object.
        This method is only valid if the IsTransient property is false. 
        Returns the BRrepBody in the new component or null in the case the creation failed.
        """
        return _fusion.BRepBody_createComponent(self)

    def moveToComponent(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Moves this body from it's current component into the root component or the component owned by the 
        specified occurrence. 
        target : The target can be either the root component or an occurrence. 
        In the case where an occurrence is specified, the body will be moved into the parent component of the target 
        occurrence and the target occurrence defines the transform of how the body will be copied so that the body 
        maintains it's same position with respect to the assembly. 
        Returns the moved BRepBody or null in the case the move failed.
        """
        return _fusion.BRepBody_moveToComponent(self, *args)

    def copyToComponent(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Creates a copy of this body into the specified target. 
        target : The target can be either the root component or an occurrence. 
        In the case where an occurrence is specified, the body will be copied into the parent component of the target 
        occurrence and the target occurrence defines the transform of how the body will be copied so that the body 
        maintains it's same position with respect to the assembly.
        If target is null, then a copy of the body is created in the owning component of the original body. 
        Returns the moved BRepBody or null in the case the move failed.
        """
        return _fusion.BRepBody_copyToComponent(self, *args)

    def _get_physicalProperties(self) -> "adsk::core::Ptr< adsk::fusion::PhysicalProperties >" :
        """
        Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc 
        of this body. Property values will be calulated using the 'LowCalculationAccuracy' setting when using this property
        to get the PhysicalProperties object. To specify a higher calculation tolerance, use the getPhysicalProperties method 
        on the Design class instead.
        """
        return _fusion.BRepBody__get_physicalProperties(self)

    def _get_isLightBulbOn(self) -> "bool" :
        """
        Gets and set if the light bulb beside the body node in the 
        browser is on or not. Parent nodes in the browser can have their light
        bulb off which affects all of their children so this property does not
        indicate if the body is actually visible, just that it should be visible
        if all of it's parent nodes are also visible. Use the isVisible property
        to determine if it's actually visible.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__get_isLightBulbOn(self)

    def _set_isLightBulbOn(self, *args) -> "bool" :
        """
        Gets and set if the light bulb beside the body node in the 
        browser is on or not. Parent nodes in the browser can have their light
        bulb off which affects all of their children so this property does not
        indicate if the body is actually visible, just that it should be visible
        if all of it's parent nodes are also visible. Use the isVisible property
        to determine if it's actually visible.
        This property is only valid if the IsTransient property is false.
        """
        return _fusion.BRepBody__set_isLightBulbOn(self, *args)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.BRepBody__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this body is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.BRepBody__get_baseFeature(self)

    def convert(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Creates a new body where the faces and edges are converted to different
        types of geometry based on the input options. This is particularly useful
        when you need a body made up entirely of NURBS surfaces.
        The tempId on the faces, edges, and vertices on the new body will match
        with the corresponding tempId on the original body. In cases where faces are
        split as a result of the conversion there can be more than one face or edge in
        the new body that matches to a single face or edge in the original body. The 
        findByTempId method will find the entity with the matching id. 
        options : Input options that define how the conversion should be done. These are
        bitwise options so they can be combined. 
        Returns the new converted body or null in the case of failure.
        """
        return _fusion.BRepBody_convert(self, *args)

    def findByTempId(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Base >,std::allocator< adsk::core::Ptr< adsk::core::Base > > >" :
        """
        Returns all of the faces, edges, or vertices that match the input ID. 
        tempId : The ID of the B-Rep entity to find. 
        Returns an array of entities that have the specified ID. This
        returns an array because it's possible that a body created by converting a
        body can have multiple entities with the same ID in the case where a curve
        or face was split. Returns an empty array in the case where no match is found.
        """
        return _fusion.BRepBody_findByTempId(self, *args)

    def _get_opacity(self) -> "double" :
        """
        Gets and sets the opacity override assigned to this body. A value of 1.0 specifies
        that is it completely opaque and a value of 0.0 specifies that is it completely transparent.
        This value is not necessarily related to what the user sees because the opacity is inherited.
        For example, if you this body is in a component and that component's opacity is set to something
        other than 1.0, the body will also be shown as slightly transparent even though the opacity 
        property for the body will return 1.0. Because the component that contains the body can be 
        referenced as an occurrence in other components and they can have different opacity settings, 
        it's possible that different instances of the same body can display using different opacity levels. 
        To get the opacity that it is being displayed with use the BrepBody.visibleOpacity property.
        This is the API equivalent of the 'Opacity Control' command available for the body in the browser.
        """
        return _fusion.BRepBody__get_opacity(self)

    def _set_opacity(self, *args) -> "bool" :
        """
        Gets and sets the opacity override assigned to this body. A value of 1.0 specifies
        that is it completely opaque and a value of 0.0 specifies that is it completely transparent.
        This value is not necessarily related to what the user sees because the opacity is inherited.
        For example, if you this body is in a component and that component's opacity is set to something
        other than 1.0, the body will also be shown as slightly transparent even though the opacity 
        property for the body will return 1.0. Because the component that contains the body can be 
        referenced as an occurrence in other components and they can have different opacity settings, 
        it's possible that different instances of the same body can display using different opacity levels. 
        To get the opacity that it is being displayed with use the BrepBody.visibleOpacity property.
        This is the API equivalent of the 'Opacity Control' command available for the body in the browser.
        """
        return _fusion.BRepBody__set_opacity(self, *args)

    def _get_visibleOpacity(self) -> "double" :
        """
        The user can set an override opacity for components and bodies these opacity overrides combine if
        children and parent components have overrides. This property returns the actual opacity that is
        being used to render the body. To set the opacity use the opacity property of the BRepBody object.
        """
        return _fusion.BRepBody__get_visibleOpacity(self)

    def _get_revisionId(self) -> "std::string" :
        """
        Returns the current revision ID of the body. This ID changes any time the body is modified in any way. By getting
        and saving the ID when you create any data that is dependent on the body, you can then compare the saved
        ID with the current ID to determine if the body has changed to know if you should update your data.
        """
        return _fusion.BRepBody__get_revisionId(self)

    def _get_wires(self) -> "adsk::core::Ptr< adsk::fusion::BRepWires >" :
        """Returns any wire bodies that exist within this body."""
        return _fusion.BRepBody__get_wires(self)

    def _get_isTemporary(self) -> "bool" :
        """Indicates if this body is represented in the model or is temporary."""
        return _fusion.BRepBody__get_isTemporary(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepBody__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepBody__get_isValid(self)
BRepBody_swigregister = _fusion.BRepBody_swigregister
BRepBody_swigregister(BRepBody)

def BRepBody_classType() -> "char const *" :
  return _fusion.BRepBody_classType()
BRepBody_classType = _fusion.BRepBody_classType

BRepBody.__swig_getmethods__["parentComponent"] = BRepBody._get_parentComponent
BRepBody.parentComponent = property(BRepBody._get_parentComponent, doc="Returns the component this body is owned by.")

BRepBody.__swig_getmethods__["lumps"] = BRepBody._get_lumps
BRepBody.lumps = property(BRepBody._get_lumps, doc="Returns a collection of all of the lumps in the body.")

BRepBody.__swig_getmethods__["shells"] = BRepBody._get_shells
BRepBody.shells = property(BRepBody._get_shells, doc="Returns a collection of all of the shells in the body.")

BRepBody.__swig_getmethods__["faces"] = BRepBody._get_faces
BRepBody.faces = property(BRepBody._get_faces, doc="Returns a collection of all of the faces in the body.")

BRepBody.__swig_getmethods__["edges"] = BRepBody._get_edges
BRepBody.edges = property(BRepBody._get_edges, doc="Returns a collection of all of the edges in the body.")

BRepBody.__swig_getmethods__["vertices"] = BRepBody._get_vertices
BRepBody.vertices = property(BRepBody._get_vertices, doc="Returns a collection of all of the vertices in the body.")

BRepBody.__swig_getmethods__["isSolid"] = BRepBody._get_isSolid
BRepBody.isSolid = property(BRepBody._get_isSolid, doc="Returns whether this body is closed (solid) or not.")

BRepBody.__swig_getmethods__["boundingBox"] = BRepBody._get_boundingBox
BRepBody.boundingBox = property(BRepBody._get_boundingBox, doc="Returns the bounding box of this body.")

BRepBody.__swig_getmethods__["concaveEdges"] = BRepBody._get_concaveEdges
BRepBody.concaveEdges = property(BRepBody._get_concaveEdges, doc="Returns all of the edges that connect concave faces.")

BRepBody.__swig_getmethods__["convexEdges"] = BRepBody._get_convexEdges
BRepBody.convexEdges = property(BRepBody._get_convexEdges, doc="Returns all of the edges that connect convex faces.")

BRepBody.__swig_getmethods__["area"] = BRepBody._get_area
BRepBody.area = property(BRepBody._get_area, doc="Returns the area in cm ^ 2.")

BRepBody.__swig_getmethods__["volume"] = BRepBody._get_volume
BRepBody.volume = property(BRepBody._get_volume, doc="Returns the volume in cm ^ 3. Returns 0 in the case the body is not solid.")

BRepBody.__swig_getmethods__["isTransient"] = BRepBody._get_isTransient
BRepBody.isTransient = property(BRepBody._get_isTransient, doc="Indicates if this body is represented in the model or is transient.")

BRepBody.__swig_getmethods__["name"] = BRepBody._get_name
BRepBody.__swig_setmethods__["name"] = BRepBody._set_name
BRepBody.name = property(BRepBody._get_name, BRepBody._set_name, doc="Gets and sets the name of the body.\nThis property is only valid if the IsTransient property is false.")

BRepBody.__swig_getmethods__["isVisible"] = BRepBody._get_isVisible
BRepBody.__swig_setmethods__["isVisible"] = BRepBody._set_isVisible
BRepBody.isVisible = property(BRepBody._get_isVisible, BRepBody._set_isVisible, doc="Gets if this body is currently visible in the graphics window. Use the\nisLightBulbOn to change if the light bulb beside the body node in the\nbrowser is on or not. Parent nodes in the browser can have their light\nbulb off which affects all of their children. This property indicates\nthe final result and whether this body is actually visible or not.\nThis property is only valid if the IsTransient property is false.")

BRepBody.__swig_getmethods__["isSelectable"] = BRepBody._get_isSelectable
BRepBody.__swig_setmethods__["isSelectable"] = BRepBody._set_isSelectable
BRepBody.isSelectable = property(BRepBody._get_isSelectable, BRepBody._set_isSelectable, doc="Gets and sets if this body is selectable.\nThis property is only valid if the IsTransient property is false.")

BRepBody.__swig_getmethods__["appearance"] = BRepBody._get_appearance
BRepBody.__swig_setmethods__["appearance"] = BRepBody._set_appearance
BRepBody.appearance = property(BRepBody._get_appearance, BRepBody._set_appearance, doc="Read-write property that gets and sets the current appearance of the body. Setting this property will result in applying\nan override appearance to the body and the AppearanceSourceType property will return OverrideAppearanceSource. Setting\nthis property to null will remove any override.\nThis property is only valid if the IsTransient property is false.")

BRepBody.__swig_getmethods__["appearanceSourceType"] = BRepBody._get_appearanceSourceType
BRepBody.appearanceSourceType = property(BRepBody._get_appearanceSourceType, doc="Read-write property that gets the source of the appearance for the body. If this returns OverrideAppearanceSource, an override exists\non this body. The override can be removed by setting the Appearance property to null.\nThis property is only valid if the IsTransient property is false.")

BRepBody.__swig_getmethods__["material"] = BRepBody._get_material
BRepBody.__swig_setmethods__["material"] = BRepBody._set_material
BRepBody.material = property(BRepBody._get_material, BRepBody._set_material, doc="Gets and sets the material assigned to this body.\nThis property is only valid if the IsTransient property is false.")

BRepBody.__swig_getmethods__["meshManager"] = BRepBody._get_meshManager
BRepBody.meshManager = property(BRepBody._get_meshManager, doc="Returns the mesh manager object for this body.")

BRepBody.__swig_getmethods__["assemblyContext"] = BRepBody._get_assemblyContext
BRepBody.assemblyContext = property(BRepBody._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nBRepBody object is acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object. Also returns null in the case\nwhere this body is transient.")

BRepBody.__swig_getmethods__["nativeObject"] = BRepBody._get_nativeObject
BRepBody.nativeObject = property(BRepBody._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

BRepBody.__swig_getmethods__["physicalProperties"] = BRepBody._get_physicalProperties
BRepBody.physicalProperties = property(BRepBody._get_physicalProperties, doc="Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc\nof this body. Property values will be calulated using the 'LowCalculationAccuracy' setting when using this property\nto get the PhysicalProperties object. To specify a higher calculation tolerance, use the getPhysicalProperties method\non the Design class instead.")

BRepBody.__swig_getmethods__["isLightBulbOn"] = BRepBody._get_isLightBulbOn
BRepBody.__swig_setmethods__["isLightBulbOn"] = BRepBody._set_isLightBulbOn
BRepBody.isLightBulbOn = property(BRepBody._get_isLightBulbOn, BRepBody._set_isLightBulbOn, doc="Gets and set if the light bulb beside the body node in the\nbrowser is on or not. Parent nodes in the browser can have their light\nbulb off which affects all of their children so this property does not\nindicate if the body is actually visible, just that it should be visible\nif all of it's parent nodes are also visible. Use the isVisible property\nto determine if it's actually visible.\nThis property is only valid if the IsTransient property is false.")

BRepBody.__swig_getmethods__["attributes"] = BRepBody._get_attributes
BRepBody.attributes = property(BRepBody._get_attributes, doc="Returns the collection of attributes associated with this face.")

BRepBody.__swig_getmethods__["baseFeature"] = BRepBody._get_baseFeature
BRepBody.baseFeature = property(BRepBody._get_baseFeature, doc="If this body is associated with a base feature, this property will return that base feature.\nIf it's not associated with a base feature, this property will return null.")

BRepBody.__swig_getmethods__["opacity"] = BRepBody._get_opacity
BRepBody.__swig_setmethods__["opacity"] = BRepBody._set_opacity
BRepBody.opacity = property(BRepBody._get_opacity, BRepBody._set_opacity, doc="Gets and sets the opacity override assigned to this body. A value of 1.0 specifies\nthat is it completely opaque and a value of 0.0 specifies that is it completely transparent.\nThis value is not necessarily related to what the user sees because the opacity is inherited.\nFor example, if you this body is in a component and that component's opacity is set to something\nother than 1.0, the body will also be shown as slightly transparent even though the opacity\nproperty for the body will return 1.0. Because the component that contains the body can be\nreferenced as an occurrence in other components and they can have different opacity settings,\nit's possible that different instances of the same body can display using different opacity levels.\nTo get the opacity that it is being displayed with use the BrepBody.visibleOpacity property.\nThis is the API equivalent of the 'Opacity Control' command available for the body in the browser.")

BRepBody.__swig_getmethods__["visibleOpacity"] = BRepBody._get_visibleOpacity
BRepBody.visibleOpacity = property(BRepBody._get_visibleOpacity, doc="The user can set an override opacity for components and bodies these opacity overrides combine if\nchildren and parent components have overrides. This property returns the actual opacity that is\nbeing used to render the body. To set the opacity use the opacity property of the BRepBody object.")

BRepBody.__swig_getmethods__["revisionId"] = BRepBody._get_revisionId
BRepBody.revisionId = property(BRepBody._get_revisionId, doc="Returns the current revision ID of the body. This ID changes any time the body is modified in any way. By getting\nand saving the ID when you create any data that is dependent on the body, you can then compare the saved\nID with the current ID to determine if the body has changed to know if you should update your data.")

BRepBody.__swig_getmethods__["wires"] = BRepBody._get_wires
BRepBody.wires = property(BRepBody._get_wires, doc="Returns any wire bodies that exist within this body.")

BRepBody.__swig_getmethods__["isTemporary"] = BRepBody._get_isTemporary
BRepBody.isTemporary = property(BRepBody._get_isTemporary, doc="Indicates if this body is represented in the model or is temporary.")

BRepBody.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepBody) else None
BRepBody.cast = lambda arg: arg if isinstance(arg, BRepBody) else None

class BRepCell(Base):
    """Object that represents an existing BRepCell."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepCell, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepCell, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepCell *" : return _fusion.BRepCell___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepCell___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepCell___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepCell_classType
    if _newclass:classType = staticmethod(_fusion.BRepCell_classType)
    __swig_destroy__ = _fusion.delete_BRepCell
    __del__ = lambda self : None;
    def _get_isSelected(self) -> "bool" :
        """
        Gets and sets whether the cell is selected. For a Trim feature a selected cell is removed, 
        whereas for a boundary fill feature, a selected cell is kept and used in the feature operation.
        """
        return _fusion.BRepCell__get_isSelected(self)

    def _set_isSelected(self, *args) -> "bool" :
        """
        Gets and sets whether the cell is selected. For a Trim feature a selected cell is removed, 
        whereas for a boundary fill feature, a selected cell is kept and used in the feature operation.
        """
        return _fusion.BRepCell__set_isSelected(self, *args)

    def _get_sourceTools(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """Returns the tools that we're using in the definition of this cell."""
        return _fusion.BRepCell__get_sourceTools(self)

    def _get_cellBody(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """Returns a BRepBody that represents this cell. This is a transient B-Rep body."""
        return _fusion.BRepCell__get_cellBody(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepCell__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepCell__get_isValid(self)
BRepCell_swigregister = _fusion.BRepCell_swigregister
BRepCell_swigregister(BRepCell)

def BRepCell_classType() -> "char const *" :
  return _fusion.BRepCell_classType()
BRepCell_classType = _fusion.BRepCell_classType

BRepCell.__swig_getmethods__["isSelected"] = BRepCell._get_isSelected
BRepCell.__swig_setmethods__["isSelected"] = BRepCell._set_isSelected
BRepCell.isSelected = property(BRepCell._get_isSelected, BRepCell._set_isSelected, doc="Gets and sets whether the cell is selected. For a Trim feature a selected cell is removed,\nwhereas for a boundary fill feature, a selected cell is kept and used in the feature operation.")

BRepCell.__swig_getmethods__["sourceTools"] = BRepCell._get_sourceTools
BRepCell.sourceTools = property(BRepCell._get_sourceTools, doc="Returns the tools that we're using in the definition of this cell.")

BRepCell.__swig_getmethods__["cellBody"] = BRepCell._get_cellBody
BRepCell.cellBody = property(BRepCell._get_cellBody, doc="Returns a BRepBody that represents this cell. This is a transient B-Rep body.")

BRepCell.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepCell) else None
BRepCell.cast = lambda arg: arg if isinstance(arg, BRepCell) else None

class BRepCells(Base):
    """Collection that provides access to all of the existing BRepCells defined by a BoundaryFillFeatureInput"""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepCells, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepCells, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepCells *" : return _fusion.BRepCells___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepCells___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepCells___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.BRepCells___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepCell >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.BRepCells___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepCells_classType
    if _newclass:classType = staticmethod(_fusion.BRepCells_classType)
    __swig_destroy__ = _fusion.delete_BRepCells
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepCell >" :
        """
        Function that returns the specified BRepCell using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepCells_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of BRepCells in the collection."""
        return _fusion.BRepCells__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepCells__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepCells__get_isValid(self)
BRepCells_swigregister = _fusion.BRepCells_swigregister
BRepCells_swigregister(BRepCells)

def BRepCells_classType() -> "char const *" :
  return _fusion.BRepCells_classType()
BRepCells_classType = _fusion.BRepCells_classType

BRepCells.__swig_getmethods__["count"] = BRepCells._get_count
BRepCells.count = property(BRepCells._get_count, doc="The number of BRepCells in the collection.")

BRepCells.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepCells) else None
BRepCells.cast = lambda arg: arg if isinstance(arg, BRepCells) else None

class BRepCoEdge(Base):
    """Represents the use of a BRepEdge by a BRepFace."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepCoEdge, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepCoEdge, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepCoEdge *" : return _fusion.BRepCoEdge___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepCoEdge___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepCoEdge___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepCoEdge_classType
    if _newclass:classType = staticmethod(_fusion.BRepCoEdge_classType)
    __swig_destroy__ = _fusion.delete_BRepCoEdge
    __del__ = lambda self : None;
    def _get_edge(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdge >" :
        """Returns the edge this co-edge is associated with."""
        return _fusion.BRepCoEdge__get_edge(self)

    def _get_loop(self) -> "adsk::core::Ptr< adsk::fusion::BRepLoop >" :
        """Returns the loop this co-edge is part of."""
        return _fusion.BRepCoEdge__get_loop(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator2D >" :
        """Returns a curve evaluator that can be used to perform geometric evaluations on the co-edge."""
        return _fusion.BRepCoEdge__get_evaluator(self)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Curve2D >" :
        """Returns a geometry object that represents the shape of this co-edge in parameter space of the parent face's surface."""
        return _fusion.BRepCoEdge__get_geometry(self)

    def _get_isOpposedToEdge(self) -> "bool" :
        """Indicates if the orientation of this co-edge is in the same direction or opposed to its associated edge."""
        return _fusion.BRepCoEdge__get_isOpposedToEdge(self)

    def _get_isParamReversed(self) -> "bool" :
        """
        Returns if the parametric direction of this co-edge is reversed
        from the parametric direction of the underlying curve obtained from the geometry property.
        A co-edge's parametric direction is from the start vertex to the end vertex.
        But the underlying curve geometry may have the opposite parameterization.
        This property indicates if the parameterization order of the evaluator obtained from
        this co-edge is reversed from the order of the geometry curve's evaluator.
        """
        return _fusion.BRepCoEdge__get_isParamReversed(self)

    def _get_next(self) -> "adsk::core::Ptr< adsk::fusion::BRepCoEdge >" :
        """Returns the next co-edge in the loop."""
        return _fusion.BRepCoEdge__get_next(self)

    def _get_body(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """Returns the body this co-edge is part of."""
        return _fusion.BRepCoEdge__get_body(self)

    def _get_partner(self) -> "adsk::core::Ptr< adsk::fusion::BRepCoEdge >" :
        """Returns the co-edge on the adjacent face"""
        return _fusion.BRepCoEdge__get_partner(self)

    def _get_previous(self) -> "adsk::core::Ptr< adsk::fusion::BRepCoEdge >" :
        """Returns the previous co-edge in the loop."""
        return _fusion.BRepCoEdge__get_previous(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        BRepCoEdge object is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.BRepCoEdge__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BRepCoEdge >" :
        """
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BRepCoEdge__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepCoEdge >" :
        """
        Returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context for the created proxy. 
        Returns the new BrepCoEdge proxy or null if this isn't the NativeObject.
        """
        return _fusion.BRepCoEdge_createForAssemblyContext(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepCoEdge__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepCoEdge__get_isValid(self)
BRepCoEdge_swigregister = _fusion.BRepCoEdge_swigregister
BRepCoEdge_swigregister(BRepCoEdge)

def BRepCoEdge_classType() -> "char const *" :
  return _fusion.BRepCoEdge_classType()
BRepCoEdge_classType = _fusion.BRepCoEdge_classType

BRepCoEdge.__swig_getmethods__["edge"] = BRepCoEdge._get_edge
BRepCoEdge.edge = property(BRepCoEdge._get_edge, doc="Returns the edge this co-edge is associated with.")

BRepCoEdge.__swig_getmethods__["loop"] = BRepCoEdge._get_loop
BRepCoEdge.loop = property(BRepCoEdge._get_loop, doc="Returns the loop this co-edge is part of.")

BRepCoEdge.__swig_getmethods__["evaluator"] = BRepCoEdge._get_evaluator
BRepCoEdge.evaluator = property(BRepCoEdge._get_evaluator, doc="Returns a curve evaluator that can be used to perform geometric evaluations on the co-edge.")

BRepCoEdge.__swig_getmethods__["geometry"] = BRepCoEdge._get_geometry
BRepCoEdge.geometry = property(BRepCoEdge._get_geometry, doc="Returns a geometry object that represents the shape of this co-edge in parameter space of the parent face's surface.")

BRepCoEdge.__swig_getmethods__["isOpposedToEdge"] = BRepCoEdge._get_isOpposedToEdge
BRepCoEdge.isOpposedToEdge = property(BRepCoEdge._get_isOpposedToEdge, doc="Indicates if the orientation of this co-edge is in the same direction or opposed to its associated edge.")

BRepCoEdge.__swig_getmethods__["isParamReversed"] = BRepCoEdge._get_isParamReversed
BRepCoEdge.isParamReversed = property(BRepCoEdge._get_isParamReversed, doc="Returns if the parametric direction of this co-edge is reversed\nfrom the parametric direction of the underlying curve obtained from the geometry property.\nA co-edge's parametric direction is from the start vertex to the end vertex.\nBut the underlying curve geometry may have the opposite parameterization.\nThis property indicates if the parameterization order of the evaluator obtained from\nthis co-edge is reversed from the order of the geometry curve's evaluator.")

BRepCoEdge.__swig_getmethods__["next"] = BRepCoEdge._get_next
BRepCoEdge.next = property(BRepCoEdge._get_next, doc="Returns the next co-edge in the loop.")

BRepCoEdge.__swig_getmethods__["body"] = BRepCoEdge._get_body
BRepCoEdge.body = property(BRepCoEdge._get_body, doc="Returns the body this co-edge is part of.")

BRepCoEdge.__swig_getmethods__["partner"] = BRepCoEdge._get_partner
BRepCoEdge.partner = property(BRepCoEdge._get_partner, doc="Returns the co-edge on the adjacent face")

BRepCoEdge.__swig_getmethods__["previous"] = BRepCoEdge._get_previous
BRepCoEdge.previous = property(BRepCoEdge._get_previous, doc="Returns the previous co-edge in the loop.")

BRepCoEdge.__swig_getmethods__["assemblyContext"] = BRepCoEdge._get_assemblyContext
BRepCoEdge.assemblyContext = property(BRepCoEdge._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nBRepCoEdge object is acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")

BRepCoEdge.__swig_getmethods__["nativeObject"] = BRepCoEdge._get_nativeObject
BRepCoEdge.nativeObject = property(BRepCoEdge._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

BRepCoEdge.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepCoEdge) else None
BRepCoEdge.cast = lambda arg: arg if isinstance(arg, BRepCoEdge) else None

class BRepCoEdges(Base):
    """BRepCoEdge Collection."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepCoEdges, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepCoEdges, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepCoEdges *" : return _fusion.BRepCoEdges___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepCoEdges___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepCoEdges___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.BRepCoEdges___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepCoEdge >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.BRepCoEdges___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepCoEdges_classType
    if _newclass:classType = staticmethod(_fusion.BRepCoEdges_classType)
    __swig_destroy__ = _fusion.delete_BRepCoEdges
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepCoEdge >" :
        """
        Function that returns the specified co-edge using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepCoEdges_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of co-edges in the collection."""
        return _fusion.BRepCoEdges__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepCoEdges__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepCoEdges__get_isValid(self)
BRepCoEdges_swigregister = _fusion.BRepCoEdges_swigregister
BRepCoEdges_swigregister(BRepCoEdges)

def BRepCoEdges_classType() -> "char const *" :
  return _fusion.BRepCoEdges_classType()
BRepCoEdges_classType = _fusion.BRepCoEdges_classType

BRepCoEdges.__swig_getmethods__["count"] = BRepCoEdges._get_count
BRepCoEdges.count = property(BRepCoEdges._get_count, doc="The number of co-edges in the collection.")

BRepCoEdges.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepCoEdges) else None
BRepCoEdges.cast = lambda arg: arg if isinstance(arg, BRepCoEdges) else None

class BRepEdge(Base):
    """Represents a one-dimensional topological element that can be used to bound a BRepFace A BRepEdge uses a single, connected and bounded subset of a curve for it geometry."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepEdge, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepEdge, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepEdge *" : return _fusion.BRepEdge___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepEdge___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepEdge___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepEdge_classType
    if _newclass:classType = staticmethod(_fusion.BRepEdge_classType)
    __swig_destroy__ = _fusion.delete_BRepEdge
    __del__ = lambda self : None;
    def _get_startVertex(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertex >" :
        """Returns the BRepVertex that bounds its low parameter end."""
        return _fusion.BRepEdge__get_startVertex(self)

    def _get_endVertex(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertex >" :
        """Returns the BRepVertex that bounds its high parameter end."""
        return _fusion.BRepEdge__get_endVertex(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """Returns the BRepFaces that are associated with this edge through its BRepCoEdges."""
        return _fusion.BRepEdge__get_faces(self)

    def _get_shell(self) -> "adsk::core::Ptr< adsk::fusion::BRepShell >" :
        """Returns the parent shell of the edge."""
        return _fusion.BRepEdge__get_shell(self)

    def _get_body(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """Returns the parent body of the edge."""
        return _fusion.BRepEdge__get_body(self)

    def _get_isDegenerate(self) -> "bool" :
        """
        Returns if the edge's geometry is degenerate.
        For example, the apex of a cone is a degerate edge.
        """
        return _fusion.BRepEdge__get_isDegenerate(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >" :
        """Returns CurveEvaluator3D for evaluation."""
        return _fusion.BRepEdge__get_evaluator(self)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Curve3D >" :
        """Returns the underlying curve geometry of the edge."""
        return _fusion.BRepEdge__get_geometry(self)

    def _get_isTolerant(self) -> "bool" :
        """
        Returns if the edge is tolerant.
        The tolerance used is available from the tolerance property.
        """
        return _fusion.BRepEdge__get_isTolerant(self)

    def _get_tolerance(self) -> "double" :
        """
        Returns the tolerance used by a tolerant edge.
        This value is only useful when isTolerant is true.
        """
        return _fusion.BRepEdge__get_tolerance(self)

    def _get_pointOnEdge(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        Returns a sample point guaranteed to lie on the edge's curve, within its boundaries,
        and not on a vertex (unless this is a degenerate edge).
        """
        return _fusion.BRepEdge__get_pointOnEdge(self)

    def _get_coEdges(self) -> "adsk::core::Ptr< adsk::fusion::BRepCoEdges >" :
        """Returns the BRepCoEdges on the edge."""
        return _fusion.BRepEdge__get_coEdges(self)

    def _get_isParamReversed(self) -> "bool" :
        """
        Returns if the parametric direction of this edge is reversed
        from the parametric direction of the underlying curve obtained from the geometry property.
        An edge's parametric direction is from the start vertex to the end vertex.
        But the underlying curve geometry may have the opposite parameterization.
        This property indicates if the parameterization order of the evaluator obtained from
        this edge is reversed from the order of the geometry curve's evaluator.
        """
        return _fusion.BRepEdge__get_isParamReversed(self)

    def _get_tangentiallyConnectedEdges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Returns a collection of edges that includes all of the edges tangentially connected
        to this edge. The result includes this edge. The edges are in the collection
        in their connected order.
        """
        return _fusion.BRepEdge__get_tangentiallyConnectedEdges(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        BRepEdge object is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.BRepEdge__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdge >" :
        """
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BRepEdge__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepEdge >" :
        """
        Returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context for the created proxy. 
        Returns the new BrepEdge proxy or null if this isn't the NativeObject.
        """
        return _fusion.BRepEdge_createForAssemblyContext(self, *args)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.BRepEdge__get_attributes(self)

    def _get_length(self) -> "double" :
        """Returns the length of the edge in centimeters."""
        return _fusion.BRepEdge__get_length(self)

    def _get_tempId(self) -> "int" :
        """
        Returns the temporary ID of this edge. This ID is only good while the document
        remains open and as long as the owning BRepBody is not modified in any way. 
        The findByTempId method of the BRepBody will return the entity in the body with the given ID.
        """
        return _fusion.BRepEdge__get_tempId(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of this edge."""
        return _fusion.BRepEdge__get_boundingBox(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepEdge__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepEdge__get_isValid(self)
BRepEdge_swigregister = _fusion.BRepEdge_swigregister
BRepEdge_swigregister(BRepEdge)

def BRepEdge_classType() -> "char const *" :
  return _fusion.BRepEdge_classType()
BRepEdge_classType = _fusion.BRepEdge_classType

BRepEdge.__swig_getmethods__["startVertex"] = BRepEdge._get_startVertex
BRepEdge.startVertex = property(BRepEdge._get_startVertex, doc="Returns the BRepVertex that bounds its low parameter end.")

BRepEdge.__swig_getmethods__["endVertex"] = BRepEdge._get_endVertex
BRepEdge.endVertex = property(BRepEdge._get_endVertex, doc="Returns the BRepVertex that bounds its high parameter end.")

BRepEdge.__swig_getmethods__["faces"] = BRepEdge._get_faces
BRepEdge.faces = property(BRepEdge._get_faces, doc="Returns the BRepFaces that are associated with this edge through its BRepCoEdges.")

BRepEdge.__swig_getmethods__["shell"] = BRepEdge._get_shell
BRepEdge.shell = property(BRepEdge._get_shell, doc="Returns the parent shell of the edge.")

BRepEdge.__swig_getmethods__["body"] = BRepEdge._get_body
BRepEdge.body = property(BRepEdge._get_body, doc="Returns the parent body of the edge.")

BRepEdge.__swig_getmethods__["isDegenerate"] = BRepEdge._get_isDegenerate
BRepEdge.isDegenerate = property(BRepEdge._get_isDegenerate, doc="Returns if the edge's geometry is degenerate.\nFor example, the apex of a cone is a degerate edge.")

BRepEdge.__swig_getmethods__["evaluator"] = BRepEdge._get_evaluator
BRepEdge.evaluator = property(BRepEdge._get_evaluator, doc="Returns CurveEvaluator3D for evaluation.")

BRepEdge.__swig_getmethods__["geometry"] = BRepEdge._get_geometry
BRepEdge.geometry = property(BRepEdge._get_geometry, doc="Returns the underlying curve geometry of the edge.")

BRepEdge.__swig_getmethods__["isTolerant"] = BRepEdge._get_isTolerant
BRepEdge.isTolerant = property(BRepEdge._get_isTolerant, doc="Returns if the edge is tolerant.\nThe tolerance used is available from the tolerance property.")

BRepEdge.__swig_getmethods__["tolerance"] = BRepEdge._get_tolerance
BRepEdge.tolerance = property(BRepEdge._get_tolerance, doc="Returns the tolerance used by a tolerant edge.\nThis value is only useful when isTolerant is true.")

BRepEdge.__swig_getmethods__["pointOnEdge"] = BRepEdge._get_pointOnEdge
BRepEdge.pointOnEdge = property(BRepEdge._get_pointOnEdge, doc="Returns a sample point guaranteed to lie on the edge's curve, within its boundaries,\nand not on a vertex (unless this is a degenerate edge).")

BRepEdge.__swig_getmethods__["coEdges"] = BRepEdge._get_coEdges
BRepEdge.coEdges = property(BRepEdge._get_coEdges, doc="Returns the BRepCoEdges on the edge.")

BRepEdge.__swig_getmethods__["isParamReversed"] = BRepEdge._get_isParamReversed
BRepEdge.isParamReversed = property(BRepEdge._get_isParamReversed, doc="Returns if the parametric direction of this edge is reversed\nfrom the parametric direction of the underlying curve obtained from the geometry property.\nAn edge's parametric direction is from the start vertex to the end vertex.\nBut the underlying curve geometry may have the opposite parameterization.\nThis property indicates if the parameterization order of the evaluator obtained from\nthis edge is reversed from the order of the geometry curve's evaluator.")

BRepEdge.__swig_getmethods__["tangentiallyConnectedEdges"] = BRepEdge._get_tangentiallyConnectedEdges
BRepEdge.tangentiallyConnectedEdges = property(BRepEdge._get_tangentiallyConnectedEdges, doc="Returns a collection of edges that includes all of the edges tangentially connected\nto this edge. The result includes this edge. The edges are in the collection\nin their connected order.")

BRepEdge.__swig_getmethods__["assemblyContext"] = BRepEdge._get_assemblyContext
BRepEdge.assemblyContext = property(BRepEdge._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nBRepEdge object is acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")

BRepEdge.__swig_getmethods__["nativeObject"] = BRepEdge._get_nativeObject
BRepEdge.nativeObject = property(BRepEdge._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

BRepEdge.__swig_getmethods__["attributes"] = BRepEdge._get_attributes
BRepEdge.attributes = property(BRepEdge._get_attributes, doc="Returns the collection of attributes associated with this face.")

BRepEdge.__swig_getmethods__["length"] = BRepEdge._get_length
BRepEdge.length = property(BRepEdge._get_length, doc="Returns the length of the edge in centimeters.")

BRepEdge.__swig_getmethods__["tempId"] = BRepEdge._get_tempId
BRepEdge.tempId = property(BRepEdge._get_tempId, doc="Returns the temporary ID of this edge. This ID is only good while the document\nremains open and as long as the owning BRepBody is not modified in any way.\nThe findByTempId method of the BRepBody will return the entity in the body with the given ID.")

BRepEdge.__swig_getmethods__["boundingBox"] = BRepEdge._get_boundingBox
BRepEdge.boundingBox = property(BRepEdge._get_boundingBox, doc="Returns the bounding box of this edge.")

BRepEdge.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepEdge) else None
BRepEdge.cast = lambda arg: arg if isinstance(arg, BRepEdge) else None

class BRepEdges(Base):
    """BRepEdge collection."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepEdges, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepEdges, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepEdges *" : return _fusion.BRepEdges___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepEdges___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepEdges___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.BRepEdges___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepEdge >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.BRepEdges___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepEdges_classType
    if _newclass:classType = staticmethod(_fusion.BRepEdges_classType)
    __swig_destroy__ = _fusion.delete_BRepEdges
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepEdge >" :
        """
        Function that returns the specified edge using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepEdges_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of edges in the collection."""
        return _fusion.BRepEdges__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepEdges__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepEdges__get_isValid(self)
BRepEdges_swigregister = _fusion.BRepEdges_swigregister
BRepEdges_swigregister(BRepEdges)

def BRepEdges_classType() -> "char const *" :
  return _fusion.BRepEdges_classType()
BRepEdges_classType = _fusion.BRepEdges_classType

BRepEdges.__swig_getmethods__["count"] = BRepEdges._get_count
BRepEdges.count = property(BRepEdges._get_count, doc="The number of edges in the collection.")

BRepEdges.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepEdges) else None
BRepEdges.cast = lambda arg: arg if isinstance(arg, BRepEdges) else None

class BRepFace(Base):
    """Represent a connected region on a single geometric surface."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepFace, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepFace, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepFace *" : return _fusion.BRepFace___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepFace___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepFace___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepFace_classType
    if _newclass:classType = staticmethod(_fusion.BRepFace_classType)
    __swig_destroy__ = _fusion.delete_BRepFace
    __del__ = lambda self : None;
    def _get_edges(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdges >" :
        """Returns the BRepEdges used by this face"""
        return _fusion.BRepFace__get_edges(self)

    def _get_vertices(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertices >" :
        """Returns the BRepVertices used by this face"""
        return _fusion.BRepFace__get_vertices(self)

    def _get_shell(self) -> "adsk::core::Ptr< adsk::fusion::BRepShell >" :
        """Returns the parent shell of the face."""
        return _fusion.BRepFace__get_shell(self)

    def _get_loops(self) -> "adsk::core::Ptr< adsk::fusion::BRepLoops >" :
        """Returns the BRepLoops owned by this face"""
        return _fusion.BRepFace__get_loops(self)

    def _get_body(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """Returns the parent body of the face."""
        return _fusion.BRepFace__get_body(self)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Surface >" :
        """Returns the underlying surface geometry of this face"""
        return _fusion.BRepFace__get_geometry(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::SurfaceEvaluator >" :
        """
        Returns a SurfaceEvaluator to allow geometric evaluations across the face's surface.
        This evaluator differs from the evaluator available from the Surface obtained from the geometry
        property by being bounded by the topological boundaries of this face.
        """
        return _fusion.BRepFace__get_evaluator(self)

    def _get_pointOnFace(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Returns a sample point guaranteed to lie on the face's surface, within the face's boundaries, and not on a boundary edge."""
        return _fusion.BRepFace__get_pointOnFace(self)

    def _get_tangentiallyConnectedFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the set of faces that are tengentially adjacent to this face.
        In other words, it is the set of faces that are adjacent to this face's edges
        and have a smooth transition across those edges.
        """
        return _fusion.BRepFace__get_tangentiallyConnectedFaces(self)

    def _get_meshManager(self) -> "adsk::core::Ptr< adsk::fusion::MeshManager >" :
        """Returns a MeshManager object that allows access to existing and new meshes of this face."""
        return _fusion.BRepFace__get_meshManager(self)

    def _get_appearance(self) -> "adsk::core::Ptr< adsk::core::Appearance >" :
        """
        Read-write property that gets and sets the current appearance of the face. Setting this property will result in applying
        an override appearance to the face and the AppearanceSourceType property will return OverrideAppearanceSource. Setting
        this property to null will remove any override.
        """
        return _fusion.BRepFace__get_appearance(self)

    def _set_appearance(self, *args) -> "bool" :
        """
        Read-write property that gets and sets the current appearance of the face. Setting this property will result in applying
        an override appearance to the face and the AppearanceSourceType property will return OverrideAppearanceSource. Setting
        this property to null will remove any override.
        """
        return _fusion.BRepFace__set_appearance(self, *args)

    def _get_appearanceSourceType(self) -> "adsk::core::AppearanceSourceTypes" :
        """
        Read-write property that gets the source of the appearance for the face. If this returns OverrideAppearanceSource, an override exists
        on this face. The override can be removed by setting the Appearance property to null.
        """
        return _fusion.BRepFace__get_appearanceSourceType(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        BRepFace object is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.BRepFace__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BRepFace >" :
        """
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BRepFace__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepFace >" :
        """
        Returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context for the created proxy. 
        Returns the new BRepFace proxy or null if this isn't the NativeObject.
        """
        return _fusion.BRepFace_createForAssemblyContext(self, *args)

    def _get_area(self) -> "double" :
        """Returns the area in cm ^ 2."""
        return _fusion.BRepFace__get_area(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of this face"""
        return _fusion.BRepFace__get_boundingBox(self)

    def _get_centroid(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Returns a point at the centroid (aka, geometric center) of the face."""
        return _fusion.BRepFace__get_centroid(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.BRepFace__get_attributes(self)

    def _get_tempId(self) -> "int" :
        """
        Returns the temporary ID of this face. This ID is only good while the document
        remains open and as long as the owning BRepBody is not modified in any way. 
        The findByTempId method of the BRepBody will return the entity in the body with the given ID.
        """
        return _fusion.BRepFace__get_tempId(self)

    def convert(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Creates a new body where this face and its edges are converted to different
        types of geometry based on the input options. 
        The tempId on the faces, edges, and vertices on the new body will match
        with the corresponding tempId on the original body. In cases where the face is
        split as a result of the conversion there can be more than one face or edge in
        the new body that matches to a single face or edge in the original body. 
        options : Input options that define how the conversion should be done. These are
        bitwise options so they can be combined. 
        Returns the new converted body or null in the case of failure.
        """
        return _fusion.BRepFace_convert(self, *args)

    def _get_isParamReversed(self) -> "bool" :
        """
        Gets if the normal of this face is reversed with respect to the surface geometry associated 
        with this face.
        """
        return _fusion.BRepFace__get_isParamReversed(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepFace__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepFace__get_isValid(self)
BRepFace_swigregister = _fusion.BRepFace_swigregister
BRepFace_swigregister(BRepFace)

def BRepFace_classType() -> "char const *" :
  return _fusion.BRepFace_classType()
BRepFace_classType = _fusion.BRepFace_classType

BRepFace.__swig_getmethods__["edges"] = BRepFace._get_edges
BRepFace.edges = property(BRepFace._get_edges, doc="Returns the BRepEdges used by this face")

BRepFace.__swig_getmethods__["vertices"] = BRepFace._get_vertices
BRepFace.vertices = property(BRepFace._get_vertices, doc="Returns the BRepVertices used by this face")

BRepFace.__swig_getmethods__["shell"] = BRepFace._get_shell
BRepFace.shell = property(BRepFace._get_shell, doc="Returns the parent shell of the face.")

BRepFace.__swig_getmethods__["loops"] = BRepFace._get_loops
BRepFace.loops = property(BRepFace._get_loops, doc="Returns the BRepLoops owned by this face")

BRepFace.__swig_getmethods__["body"] = BRepFace._get_body
BRepFace.body = property(BRepFace._get_body, doc="Returns the parent body of the face.")

BRepFace.__swig_getmethods__["geometry"] = BRepFace._get_geometry
BRepFace.geometry = property(BRepFace._get_geometry, doc="Returns the underlying surface geometry of this face")

BRepFace.__swig_getmethods__["evaluator"] = BRepFace._get_evaluator
BRepFace.evaluator = property(BRepFace._get_evaluator, doc="Returns a SurfaceEvaluator to allow geometric evaluations across the face's surface.\nThis evaluator differs from the evaluator available from the Surface obtained from the geometry\nproperty by being bounded by the topological boundaries of this face.")

BRepFace.__swig_getmethods__["pointOnFace"] = BRepFace._get_pointOnFace
BRepFace.pointOnFace = property(BRepFace._get_pointOnFace, doc="Returns a sample point guaranteed to lie on the face's surface, within the face's boundaries, and not on a boundary edge.")

BRepFace.__swig_getmethods__["tangentiallyConnectedFaces"] = BRepFace._get_tangentiallyConnectedFaces
BRepFace.tangentiallyConnectedFaces = property(BRepFace._get_tangentiallyConnectedFaces, doc="Returns the set of faces that are tengentially adjacent to this face.\nIn other words, it is the set of faces that are adjacent to this face's edges\nand have a smooth transition across those edges.")

BRepFace.__swig_getmethods__["meshManager"] = BRepFace._get_meshManager
BRepFace.meshManager = property(BRepFace._get_meshManager, doc="Returns a MeshManager object that allows access to existing and new meshes of this face.")

BRepFace.__swig_getmethods__["appearance"] = BRepFace._get_appearance
BRepFace.__swig_setmethods__["appearance"] = BRepFace._set_appearance
BRepFace.appearance = property(BRepFace._get_appearance, BRepFace._set_appearance, doc="Read-write property that gets and sets the current appearance of the face. Setting this property will result in applying\nan override appearance to the face and the AppearanceSourceType property will return OverrideAppearanceSource. Setting\nthis property to null will remove any override.")

BRepFace.__swig_getmethods__["appearanceSourceType"] = BRepFace._get_appearanceSourceType
BRepFace.appearanceSourceType = property(BRepFace._get_appearanceSourceType, doc="Read-write property that gets the source of the appearance for the face. If this returns OverrideAppearanceSource, an override exists\non this face. The override can be removed by setting the Appearance property to null.")

BRepFace.__swig_getmethods__["assemblyContext"] = BRepFace._get_assemblyContext
BRepFace.assemblyContext = property(BRepFace._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nBRepFace object is acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")

BRepFace.__swig_getmethods__["nativeObject"] = BRepFace._get_nativeObject
BRepFace.nativeObject = property(BRepFace._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

BRepFace.__swig_getmethods__["area"] = BRepFace._get_area
BRepFace.area = property(BRepFace._get_area, doc="Returns the area in cm ^ 2.")

BRepFace.__swig_getmethods__["boundingBox"] = BRepFace._get_boundingBox
BRepFace.boundingBox = property(BRepFace._get_boundingBox, doc="Returns the bounding box of this face")

BRepFace.__swig_getmethods__["centroid"] = BRepFace._get_centroid
BRepFace.centroid = property(BRepFace._get_centroid, doc="Returns a point at the centroid (aka, geometric center) of the face.")

BRepFace.__swig_getmethods__["attributes"] = BRepFace._get_attributes
BRepFace.attributes = property(BRepFace._get_attributes, doc="Returns the collection of attributes associated with this face.")

BRepFace.__swig_getmethods__["tempId"] = BRepFace._get_tempId
BRepFace.tempId = property(BRepFace._get_tempId, doc="Returns the temporary ID of this face. This ID is only good while the document\nremains open and as long as the owning BRepBody is not modified in any way.\nThe findByTempId method of the BRepBody will return the entity in the body with the given ID.")

BRepFace.__swig_getmethods__["isParamReversed"] = BRepFace._get_isParamReversed
BRepFace.isParamReversed = property(BRepFace._get_isParamReversed, doc="Gets if the normal of this face is reversed with respect to the surface geometry associated\nwith this face.")

BRepFace.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepFace) else None
BRepFace.cast = lambda arg: arg if isinstance(arg, BRepFace) else None

class BRepFaces(Base):
    """BRepFace collection."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepFaces, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepFaces, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepFaces *" : return _fusion.BRepFaces___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepFaces___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepFaces___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.BRepFaces___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepFace >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.BRepFaces___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepFaces_classType
    if _newclass:classType = staticmethod(_fusion.BRepFaces_classType)
    __swig_destroy__ = _fusion.delete_BRepFaces
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepFace >" :
        """
        Function that returns the specified face using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepFaces_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of faces in the collection."""
        return _fusion.BRepFaces__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepFaces__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepFaces__get_isValid(self)
BRepFaces_swigregister = _fusion.BRepFaces_swigregister
BRepFaces_swigregister(BRepFaces)

def BRepFaces_classType() -> "char const *" :
  return _fusion.BRepFaces_classType()
BRepFaces_classType = _fusion.BRepFaces_classType

BRepFaces.__swig_getmethods__["count"] = BRepFaces._get_count
BRepFaces.count = property(BRepFaces._get_count, doc="The number of faces in the collection.")

BRepFaces.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepFaces) else None
BRepFaces.cast = lambda arg: arg if isinstance(arg, BRepFaces) else None

class BRepLoop(Base):
    """Represents a connected portion of a BRepFace boundary. It consists of a chain of BRepCoEdges."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepLoop, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepLoop, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepLoop *" : return _fusion.BRepLoop___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepLoop___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepLoop___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepLoop_classType
    if _newclass:classType = staticmethod(_fusion.BRepLoop_classType)
    __swig_destroy__ = _fusion.delete_BRepLoop
    __del__ = lambda self : None;
    def _get_edges(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdges >" :
        """Returns the BRepEdges used by this loop"""
        return _fusion.BRepLoop__get_edges(self)

    def _get_coEdges(self) -> "adsk::core::Ptr< adsk::fusion::BRepCoEdges >" :
        """Returns the BRepCoEdges consisting this loop"""
        return _fusion.BRepLoop__get_coEdges(self)

    def _get_isOuter(self) -> "bool" :
        """Returns true of this loop is an outer loop of a face"""
        return _fusion.BRepLoop__get_isOuter(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of this loop"""
        return _fusion.BRepLoop__get_boundingBox(self)

    def _get_face(self) -> "adsk::core::Ptr< adsk::fusion::BRepFace >" :
        """Returns the parent face of the loop."""
        return _fusion.BRepLoop__get_face(self)

    def _get_body(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """Returns the parent body of the loop."""
        return _fusion.BRepLoop__get_body(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        BRepLoop object is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.BRepLoop__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BRepLoop >" :
        """
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BRepLoop__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepLoop >" :
        """
        Returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context for the created proxy. 
        Returns the new BrepLoop proxy or null if this isn't the NativeObject.
        """
        return _fusion.BRepLoop_createForAssemblyContext(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepLoop__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepLoop__get_isValid(self)
BRepLoop_swigregister = _fusion.BRepLoop_swigregister
BRepLoop_swigregister(BRepLoop)

def BRepLoop_classType() -> "char const *" :
  return _fusion.BRepLoop_classType()
BRepLoop_classType = _fusion.BRepLoop_classType

BRepLoop.__swig_getmethods__["edges"] = BRepLoop._get_edges
BRepLoop.edges = property(BRepLoop._get_edges, doc="Returns the BRepEdges used by this loop")

BRepLoop.__swig_getmethods__["coEdges"] = BRepLoop._get_coEdges
BRepLoop.coEdges = property(BRepLoop._get_coEdges, doc="Returns the BRepCoEdges consisting this loop")

BRepLoop.__swig_getmethods__["isOuter"] = BRepLoop._get_isOuter
BRepLoop.isOuter = property(BRepLoop._get_isOuter, doc="Returns true of this loop is an outer loop of a face")

BRepLoop.__swig_getmethods__["boundingBox"] = BRepLoop._get_boundingBox
BRepLoop.boundingBox = property(BRepLoop._get_boundingBox, doc="Returns the bounding box of this loop")

BRepLoop.__swig_getmethods__["face"] = BRepLoop._get_face
BRepLoop.face = property(BRepLoop._get_face, doc="Returns the parent face of the loop.")

BRepLoop.__swig_getmethods__["body"] = BRepLoop._get_body
BRepLoop.body = property(BRepLoop._get_body, doc="Returns the parent body of the loop.")

BRepLoop.__swig_getmethods__["assemblyContext"] = BRepLoop._get_assemblyContext
BRepLoop.assemblyContext = property(BRepLoop._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nBRepLoop object is acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")

BRepLoop.__swig_getmethods__["nativeObject"] = BRepLoop._get_nativeObject
BRepLoop.nativeObject = property(BRepLoop._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

BRepLoop.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepLoop) else None
BRepLoop.cast = lambda arg: arg if isinstance(arg, BRepLoop) else None

class BRepLoops(Base):
    """BRepLoop collection."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepLoops, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepLoops, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepLoops *" : return _fusion.BRepLoops___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepLoops___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepLoops___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.BRepLoops___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepLoop >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.BRepLoops___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepLoops_classType
    if _newclass:classType = staticmethod(_fusion.BRepLoops_classType)
    __swig_destroy__ = _fusion.delete_BRepLoops
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepLoop >" :
        """
        Function that returns the specified loop using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepLoops_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of loops in the collection."""
        return _fusion.BRepLoops__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepLoops__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepLoops__get_isValid(self)
BRepLoops_swigregister = _fusion.BRepLoops_swigregister
BRepLoops_swigregister(BRepLoops)

def BRepLoops_classType() -> "char const *" :
  return _fusion.BRepLoops_classType()
BRepLoops_classType = _fusion.BRepLoops_classType

BRepLoops.__swig_getmethods__["count"] = BRepLoops._get_count
BRepLoops.count = property(BRepLoops._get_count, doc="The number of loops in the collection.")

BRepLoops.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepLoops) else None
BRepLoops.cast = lambda arg: arg if isinstance(arg, BRepLoops) else None

class BRepLump(Base):
    """Represents an entirely connected set of entities. A BRepBody consists of BRepLumps."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepLump, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepLump, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepLump *" : return _fusion.BRepLump___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepLump___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepLump___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepLump_classType
    if _newclass:classType = staticmethod(_fusion.BRepLump_classType)
    __swig_destroy__ = _fusion.delete_BRepLump
    __del__ = lambda self : None;
    def _get_shells(self) -> "adsk::core::Ptr< adsk::fusion::BRepShells >" :
        """Returns the BRepShells owned by the lump"""
        return _fusion.BRepLump__get_shells(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """Returns the BRepFaces owned by the lump"""
        return _fusion.BRepLump__get_faces(self)

    def _get_edges(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdges >" :
        """Returns the BRepEdges owned by the lump"""
        return _fusion.BRepLump__get_edges(self)

    def _get_vertices(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertices >" :
        """Returns the BRepVertices owned by the lump"""
        return _fusion.BRepLump__get_vertices(self)

    def _get_body(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """Returns the immediate owner BRepBody of the lump"""
        return _fusion.BRepLump__get_body(self)

    def _get_isClosed(self) -> "bool" :
        """Returns true of the lump is closed"""
        return _fusion.BRepLump__get_isClosed(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of the lump"""
        return _fusion.BRepLump__get_boundingBox(self)

    def _get_area(self) -> "double" :
        """Returns the area in cm ^ 2."""
        return _fusion.BRepLump__get_area(self)

    def _get_volume(self) -> "double" :
        """Returns the volume in cm ^ 3. Returns 0 in the case the lump is not solid."""
        return _fusion.BRepLump__get_volume(self)

    def pointContainment(self, *args) -> "adsk::fusion::PointContainment" :
        """
        Determines the relationship of the input point with respect to this lump. 
        point : The point to do the containment check for. 
        Returns a value from the PointContainment enum indicating the relationship of
        the input point to the lump.
        """
        return _fusion.BRepLump_pointContainment(self, *args)

    def _get_meshManager(self) -> "adsk::core::Ptr< adsk::fusion::MeshManager >" :
        """Returns the mesh manager object for this lump."""
        return _fusion.BRepLump__get_meshManager(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly context that is directly referencing this
        object in an assembly. This is only valid in the case where this
        BRepLump object is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.BRepLump__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BRepLump >" :
        """
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BRepLump__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepLump >" :
        """
        Returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context for the created proxy. 
        Returns the new BrepLump proxy or null if this isn't the NativeObject.
        """
        return _fusion.BRepLump_createForAssemblyContext(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepLump__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepLump__get_isValid(self)
BRepLump_swigregister = _fusion.BRepLump_swigregister
BRepLump_swigregister(BRepLump)

def BRepLump_classType() -> "char const *" :
  return _fusion.BRepLump_classType()
BRepLump_classType = _fusion.BRepLump_classType

BRepLump.__swig_getmethods__["shells"] = BRepLump._get_shells
BRepLump.shells = property(BRepLump._get_shells, doc="Returns the BRepShells owned by the lump")

BRepLump.__swig_getmethods__["faces"] = BRepLump._get_faces
BRepLump.faces = property(BRepLump._get_faces, doc="Returns the BRepFaces owned by the lump")

BRepLump.__swig_getmethods__["edges"] = BRepLump._get_edges
BRepLump.edges = property(BRepLump._get_edges, doc="Returns the BRepEdges owned by the lump")

BRepLump.__swig_getmethods__["vertices"] = BRepLump._get_vertices
BRepLump.vertices = property(BRepLump._get_vertices, doc="Returns the BRepVertices owned by the lump")

BRepLump.__swig_getmethods__["body"] = BRepLump._get_body
BRepLump.body = property(BRepLump._get_body, doc="Returns the immediate owner BRepBody of the lump")

BRepLump.__swig_getmethods__["isClosed"] = BRepLump._get_isClosed
BRepLump.isClosed = property(BRepLump._get_isClosed, doc="Returns true of the lump is closed")

BRepLump.__swig_getmethods__["boundingBox"] = BRepLump._get_boundingBox
BRepLump.boundingBox = property(BRepLump._get_boundingBox, doc="Returns the bounding box of the lump")

BRepLump.__swig_getmethods__["area"] = BRepLump._get_area
BRepLump.area = property(BRepLump._get_area, doc="Returns the area in cm ^ 2.")

BRepLump.__swig_getmethods__["volume"] = BRepLump._get_volume
BRepLump.volume = property(BRepLump._get_volume, doc="Returns the volume in cm ^ 3. Returns 0 in the case the lump is not solid.")

BRepLump.__swig_getmethods__["meshManager"] = BRepLump._get_meshManager
BRepLump.meshManager = property(BRepLump._get_meshManager, doc="Returns the mesh manager object for this lump.")

BRepLump.__swig_getmethods__["assemblyContext"] = BRepLump._get_assemblyContext
BRepLump.assemblyContext = property(BRepLump._get_assemblyContext, doc="Returns the assembly context that is directly referencing this\nobject in an assembly. This is only valid in the case where this\nBRepLump object is acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")

BRepLump.__swig_getmethods__["nativeObject"] = BRepLump._get_nativeObject
BRepLump.nativeObject = property(BRepLump._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

BRepLump.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepLump) else None
BRepLump.cast = lambda arg: arg if isinstance(arg, BRepLump) else None

class BRepLumps(Base):
    """BRepLump collection."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepLumps, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepLumps, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepLumps *" : return _fusion.BRepLumps___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepLumps___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepLumps___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.BRepLumps___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepLump >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.BRepLumps___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepLumps_classType
    if _newclass:classType = staticmethod(_fusion.BRepLumps_classType)
    __swig_destroy__ = _fusion.delete_BRepLumps
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepLump >" :
        """
        Function that returns the specified lump using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepLumps_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of lumps in the collection."""
        return _fusion.BRepLumps__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepLumps__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepLumps__get_isValid(self)
BRepLumps_swigregister = _fusion.BRepLumps_swigregister
BRepLumps_swigregister(BRepLumps)

def BRepLumps_classType() -> "char const *" :
  return _fusion.BRepLumps_classType()
BRepLumps_classType = _fusion.BRepLumps_classType

BRepLumps.__swig_getmethods__["count"] = BRepLumps._get_count
BRepLumps.count = property(BRepLumps._get_count, doc="Returns the number of lumps in the collection.")

BRepLumps.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepLumps) else None
BRepLumps.cast = lambda arg: arg if isinstance(arg, BRepLumps) else None

class BRepShell(Base):
    """Represents an entirely connected set of BRepFaces. A BRepLump may contain multiple BRepShells."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepShell, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepShell, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepShell *" : return _fusion.BRepShell___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepShell___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepShell___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepShell_classType
    if _newclass:classType = staticmethod(_fusion.BRepShell_classType)
    __swig_destroy__ = _fusion.delete_BRepShell
    __del__ = lambda self : None;
    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """Returns the BRepFaces directly owned by this shell"""
        return _fusion.BRepShell__get_faces(self)

    def _get_edges(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdges >" :
        """returns the BRepEdges owned by this shell"""
        return _fusion.BRepShell__get_edges(self)

    def _get_vertices(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertices >" :
        """Returns the BRepVertices owned by this shell"""
        return _fusion.BRepShell__get_vertices(self)

    def _get_lump(self) -> "adsk::core::Ptr< adsk::fusion::BRepLump >" :
        """Returns the parent lump of this shell."""
        return _fusion.BRepShell__get_lump(self)

    def _get_body(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """Returns the parent body of the shell."""
        return _fusion.BRepShell__get_body(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of this shell"""
        return _fusion.BRepShell__get_boundingBox(self)

    def pointContainment(self, *args) -> "adsk::fusion::PointContainment" :
        """
        Determines the relationship of the input point with respect to this shell. 
        point : The point to do the containment check for. 
        Returns a value from the PointContainment enum indicating the relationship of
        the input point to the shell.
        """
        return _fusion.BRepShell_pointContainment(self, *args)

    def _get_isClosed(self) -> "bool" :
        """Returns true if this shell is closed"""
        return _fusion.BRepShell__get_isClosed(self)

    def _get_isVoid(self) -> "bool" :
        """Returns true if the faces of this shell bound a void or an empty space within an outer shell."""
        return _fusion.BRepShell__get_isVoid(self)

    def _get_area(self) -> "double" :
        """Returns the area in cm ^ 2."""
        return _fusion.BRepShell__get_area(self)

    def _get_volume(self) -> "double" :
        """Returns the volume in cm ^ 3. Returns 0 in the case the shell is not solid."""
        return _fusion.BRepShell__get_volume(self)

    def _get_meshManager(self) -> "adsk::core::Ptr< adsk::fusion::MeshManager >" :
        """Returns the mesh manager object for this shell."""
        return _fusion.BRepShell__get_meshManager(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        BRepShell object is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.BRepShell__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BRepShell >" :
        """
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BRepShell__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepShell >" :
        """
        Returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context for the created proxy. 
        Returns the new BrepShell proxy or null if this isn't the NativeObject.
        """
        return _fusion.BRepShell_createForAssemblyContext(self, *args)

    def _get_wire(self) -> "adsk::core::Ptr< adsk::fusion::BRepWire >" :
        """
        Returns the wire body, if any, that exists in this shell. Returns null if the
        shell doesn't have a wire body.
        """
        return _fusion.BRepShell__get_wire(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepShell__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepShell__get_isValid(self)
BRepShell_swigregister = _fusion.BRepShell_swigregister
BRepShell_swigregister(BRepShell)

def BRepShell_classType() -> "char const *" :
  return _fusion.BRepShell_classType()
BRepShell_classType = _fusion.BRepShell_classType

BRepShell.__swig_getmethods__["faces"] = BRepShell._get_faces
BRepShell.faces = property(BRepShell._get_faces, doc="Returns the BRepFaces directly owned by this shell")

BRepShell.__swig_getmethods__["edges"] = BRepShell._get_edges
BRepShell.edges = property(BRepShell._get_edges, doc="returns the BRepEdges owned by this shell")

BRepShell.__swig_getmethods__["vertices"] = BRepShell._get_vertices
BRepShell.vertices = property(BRepShell._get_vertices, doc="Returns the BRepVertices owned by this shell")

BRepShell.__swig_getmethods__["lump"] = BRepShell._get_lump
BRepShell.lump = property(BRepShell._get_lump, doc="Returns the parent lump of this shell.")

BRepShell.__swig_getmethods__["body"] = BRepShell._get_body
BRepShell.body = property(BRepShell._get_body, doc="Returns the parent body of the shell.")

BRepShell.__swig_getmethods__["boundingBox"] = BRepShell._get_boundingBox
BRepShell.boundingBox = property(BRepShell._get_boundingBox, doc="Returns the bounding box of this shell")

BRepShell.__swig_getmethods__["isClosed"] = BRepShell._get_isClosed
BRepShell.isClosed = property(BRepShell._get_isClosed, doc="Returns true if this shell is closed")

BRepShell.__swig_getmethods__["isVoid"] = BRepShell._get_isVoid
BRepShell.isVoid = property(BRepShell._get_isVoid, doc="Returns true if the faces of this shell bound a void or an empty space within an outer shell.")

BRepShell.__swig_getmethods__["area"] = BRepShell._get_area
BRepShell.area = property(BRepShell._get_area, doc="Returns the area in cm ^ 2.")

BRepShell.__swig_getmethods__["volume"] = BRepShell._get_volume
BRepShell.volume = property(BRepShell._get_volume, doc="Returns the volume in cm ^ 3. Returns 0 in the case the shell is not solid.")

BRepShell.__swig_getmethods__["meshManager"] = BRepShell._get_meshManager
BRepShell.meshManager = property(BRepShell._get_meshManager, doc="Returns the mesh manager object for this shell.")

BRepShell.__swig_getmethods__["assemblyContext"] = BRepShell._get_assemblyContext
BRepShell.assemblyContext = property(BRepShell._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nBRepShell object is acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")

BRepShell.__swig_getmethods__["nativeObject"] = BRepShell._get_nativeObject
BRepShell.nativeObject = property(BRepShell._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

BRepShell.__swig_getmethods__["wire"] = BRepShell._get_wire
BRepShell.wire = property(BRepShell._get_wire, doc="Returns the wire body, if any, that exists in this shell. Returns null if the\nshell doesn't have a wire body.")

BRepShell.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepShell) else None
BRepShell.cast = lambda arg: arg if isinstance(arg, BRepShell) else None

class BRepShells(Base):
    """BRepShell collection."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepShells, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepShells, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepShells *" : return _fusion.BRepShells___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepShells___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepShells___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.BRepShells___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepShell >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.BRepShells___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepShells_classType
    if _newclass:classType = staticmethod(_fusion.BRepShells_classType)
    __swig_destroy__ = _fusion.delete_BRepShells
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepShell >" :
        """
        Function that returns the specified shell using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepShells_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of shells in the collection."""
        return _fusion.BRepShells__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepShells__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepShells__get_isValid(self)
BRepShells_swigregister = _fusion.BRepShells_swigregister
BRepShells_swigregister(BRepShells)

def BRepShells_classType() -> "char const *" :
  return _fusion.BRepShells_classType()
BRepShells_classType = _fusion.BRepShells_classType

BRepShells.__swig_getmethods__["count"] = BRepShells._get_count
BRepShells.count = property(BRepShells._get_count, doc="The number of shells in the collection.")

BRepShells.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepShells) else None
BRepShells.cast = lambda arg: arg if isinstance(arg, BRepShells) else None

class BRepVertex(Base):
    """A 0-dimentional topological entity that bounds a BRepEdge."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepVertex, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepVertex, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepVertex *" : return _fusion.BRepVertex___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepVertex___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepVertex___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepVertex_classType
    if _newclass:classType = staticmethod(_fusion.BRepVertex_classType)
    __swig_destroy__ = _fusion.delete_BRepVertex
    __del__ = lambda self : None;
    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """Returns the BRepFaces that uses this vertex through BRepEdge"""
        return _fusion.BRepVertex__get_faces(self)

    def _get_edges(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdges >" :
        """Returns the BRepEdges bounded by this vertex"""
        return _fusion.BRepVertex__get_edges(self)

    def _get_isTolerant(self) -> "bool" :
        """
        Returns if the vertex is tolerant.
        The tolerance used is available from the tolerance property.
        """
        return _fusion.BRepVertex__get_isTolerant(self)

    def _get_tolerance(self) -> "double" :
        """
        Returns the tolerance used by a tolerant vertex.
        This value is only useful when isTolerant is true.
        """
        return _fusion.BRepVertex__get_tolerance(self)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Returns the underlying geometry point"""
        return _fusion.BRepVertex__get_geometry(self)

    def _get_shell(self) -> "adsk::core::Ptr< adsk::fusion::BRepShell >" :
        """Returns the parent shell."""
        return _fusion.BRepVertex__get_shell(self)

    def _get_body(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """Returns the parent body."""
        return _fusion.BRepVertex__get_body(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        BRepVertex object is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.BRepVertex__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertex >" :
        """
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BRepVertex__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepVertex >" :
        """
        Returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context for the created proxy. 
        Returns the new BrepVertex proxy or null if this isn't the NativeObject.
        """
        return _fusion.BRepVertex_createForAssemblyContext(self, *args)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.BRepVertex__get_attributes(self)

    def _get_tempId(self) -> "int" :
        """
        Returns the temporary ID of this vertex. This ID is only good while the document
        remains open and as long as the owning BRepBody is not modified in any way. 
        The findByTempId method of the BRepBody will return the entity in the body with the given ID.
        """
        return _fusion.BRepVertex__get_tempId(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepVertex__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepVertex__get_isValid(self)
BRepVertex_swigregister = _fusion.BRepVertex_swigregister
BRepVertex_swigregister(BRepVertex)

def BRepVertex_classType() -> "char const *" :
  return _fusion.BRepVertex_classType()
BRepVertex_classType = _fusion.BRepVertex_classType

BRepVertex.__swig_getmethods__["faces"] = BRepVertex._get_faces
BRepVertex.faces = property(BRepVertex._get_faces, doc="Returns the BRepFaces that uses this vertex through BRepEdge")

BRepVertex.__swig_getmethods__["edges"] = BRepVertex._get_edges
BRepVertex.edges = property(BRepVertex._get_edges, doc="Returns the BRepEdges bounded by this vertex")

BRepVertex.__swig_getmethods__["isTolerant"] = BRepVertex._get_isTolerant
BRepVertex.isTolerant = property(BRepVertex._get_isTolerant, doc="Returns if the vertex is tolerant.\nThe tolerance used is available from the tolerance property.")

BRepVertex.__swig_getmethods__["tolerance"] = BRepVertex._get_tolerance
BRepVertex.tolerance = property(BRepVertex._get_tolerance, doc="Returns the tolerance used by a tolerant vertex.\nThis value is only useful when isTolerant is true.")

BRepVertex.__swig_getmethods__["geometry"] = BRepVertex._get_geometry
BRepVertex.geometry = property(BRepVertex._get_geometry, doc="Returns the underlying geometry point")

BRepVertex.__swig_getmethods__["shell"] = BRepVertex._get_shell
BRepVertex.shell = property(BRepVertex._get_shell, doc="Returns the parent shell.")

BRepVertex.__swig_getmethods__["body"] = BRepVertex._get_body
BRepVertex.body = property(BRepVertex._get_body, doc="Returns the parent body.")

BRepVertex.__swig_getmethods__["assemblyContext"] = BRepVertex._get_assemblyContext
BRepVertex.assemblyContext = property(BRepVertex._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nBRepVertex object is acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")

BRepVertex.__swig_getmethods__["nativeObject"] = BRepVertex._get_nativeObject
BRepVertex.nativeObject = property(BRepVertex._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

BRepVertex.__swig_getmethods__["attributes"] = BRepVertex._get_attributes
BRepVertex.attributes = property(BRepVertex._get_attributes, doc="Returns the collection of attributes associated with this face.")

BRepVertex.__swig_getmethods__["tempId"] = BRepVertex._get_tempId
BRepVertex.tempId = property(BRepVertex._get_tempId, doc="Returns the temporary ID of this vertex. This ID is only good while the document\nremains open and as long as the owning BRepBody is not modified in any way.\nThe findByTempId method of the BRepBody will return the entity in the body with the given ID.")

BRepVertex.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepVertex) else None
BRepVertex.cast = lambda arg: arg if isinstance(arg, BRepVertex) else None

class BRepVertices(Base):
    """BRepVertex collection."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepVertices, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepVertices, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepVertices *" : return _fusion.BRepVertices___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepVertices___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepVertices___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.BRepVertices___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepVertex >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.BRepVertices___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepVertices_classType
    if _newclass:classType = staticmethod(_fusion.BRepVertices_classType)
    __swig_destroy__ = _fusion.delete_BRepVertices
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepVertex >" :
        """
        Function that returns the specified vertex using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepVertices_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of vertices in the collection."""
        return _fusion.BRepVertices__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepVertices__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepVertices__get_isValid(self)
BRepVertices_swigregister = _fusion.BRepVertices_swigregister
BRepVertices_swigregister(BRepVertices)

def BRepVertices_classType() -> "char const *" :
  return _fusion.BRepVertices_classType()
BRepVertices_classType = _fusion.BRepVertices_classType

BRepVertices.__swig_getmethods__["count"] = BRepVertices._get_count
BRepVertices.count = property(BRepVertices._get_count, doc="The number of vertices in the collection.")

BRepVertices.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepVertices) else None
BRepVertices.cast = lambda arg: arg if isinstance(arg, BRepVertices) else None

class BRepWire(Base):
    """
    Represents a single B-Rep wire body. A wire body consists of one or 
    more edges and their vertices.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepWire, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepWire, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepWire *" : return _fusion.BRepWire___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepWire___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepWire___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepWire_classType
    if _newclass:classType = staticmethod(_fusion.BRepWire_classType)
    __swig_destroy__ = _fusion.delete_BRepWire
    __del__ = lambda self : None;
    def _get_edges(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdges >" :
        """Returns the B-Rep edges associated with this wire body."""
        return _fusion.BRepWire__get_edges(self)

    def _get_vertices(self) -> "adsk::core::Ptr< adsk::fusion::BRepVertices >" :
        """Returns the B-Rep vertices associated with this wire body."""
        return _fusion.BRepWire__get_vertices(self)

    def _get_coEdges(self) -> "adsk::core::Ptr< adsk::fusion::BRepCoEdges >" :
        """
        Returns the co-edges associated with this wire body. The co-edges record
        the connections between the edges in the wire body.
        """
        return _fusion.BRepWire__get_coEdges(self)

    def _get_isPlanar(self) -> "bool" :
        """Indicates if this entities making up this wire body are planar and all lie on the same plane."""
        return _fusion.BRepWire__get_isPlanar(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """Returns the parent BRepBody object that contains this wire."""
        return _fusion.BRepWire__get_parent(self)

    def offsetPlanarWire(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Method that computes the offset for a planar wire. A BRepBody containing the resulting 
        BRepWire object(s) is returned. It's possible that the offset result of a single wire 
        can result in multiple wires. 
        planeNormal : Input Vector3D object that defines the positive direction of the
        plane the plane the wire lies on. This vector must be normal to the plane and is used to 
        determine the side to offset the curves to. A positive offset distance is in the direction 
        of the cross product (wire_tangent x wire_plane_normal). A negative offset is in the 
        opposite direction. 
        distance : The offset distance in centimeters. See the description for the Normal argument to see how 
        a positive or negative value for the distance specifies the direction of the offset. 
        cornerType : Specifies how the corners are connected when offseting the curves results in gaps in the corners.
        See the documentation of the enum for a detailed description of each option. 
        Returns a new temporary BRepBody that contains one or more wires that represent the offset.
        """
        return _fusion.BRepWire_offsetPlanarWire(self, *args)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        BRepFace object is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.BRepWire__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BRepWire >" :
        """
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BRepWire__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepWire >" :
        """
        Returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context for the created proxy. 
        Returns the new BRepWire proxy or null if this isn't the NativeObject.
        """
        return _fusion.BRepWire_createForAssemblyContext(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepWire__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepWire__get_isValid(self)
BRepWire_swigregister = _fusion.BRepWire_swigregister
BRepWire_swigregister(BRepWire)

def BRepWire_classType() -> "char const *" :
  return _fusion.BRepWire_classType()
BRepWire_classType = _fusion.BRepWire_classType

BRepWire.__swig_getmethods__["edges"] = BRepWire._get_edges
BRepWire.edges = property(BRepWire._get_edges, doc="Returns the B-Rep edges associated with this wire body.")

BRepWire.__swig_getmethods__["vertices"] = BRepWire._get_vertices
BRepWire.vertices = property(BRepWire._get_vertices, doc="Returns the B-Rep vertices associated with this wire body.")

BRepWire.__swig_getmethods__["coEdges"] = BRepWire._get_coEdges
BRepWire.coEdges = property(BRepWire._get_coEdges, doc="Returns the co-edges associated with this wire body. The co-edges record\nthe connections between the edges in the wire body.")

BRepWire.__swig_getmethods__["isPlanar"] = BRepWire._get_isPlanar
BRepWire.isPlanar = property(BRepWire._get_isPlanar, doc="Indicates if this entities making up this wire body are planar and all lie on the same plane.")

BRepWire.__swig_getmethods__["parent"] = BRepWire._get_parent
BRepWire.parent = property(BRepWire._get_parent, doc="Returns the parent BRepBody object that contains this wire.")

BRepWire.__swig_getmethods__["assemblyContext"] = BRepWire._get_assemblyContext
BRepWire.assemblyContext = property(BRepWire._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nBRepFace object is acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")

BRepWire.__swig_getmethods__["nativeObject"] = BRepWire._get_nativeObject
BRepWire.nativeObject = property(BRepWire._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

BRepWire.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepWire) else None
BRepWire.cast = lambda arg: arg if isinstance(arg, BRepWire) else None

class BRepWires(Base):
    """Provides access to B-Rep wire bodies."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BRepWires, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BRepWires, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BRepWires *" : return _fusion.BRepWires___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BRepWires___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BRepWires___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.BRepWires___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepWire >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.BRepWires___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BRepWires_classType
    if _newclass:classType = staticmethod(_fusion.BRepWires_classType)
    __swig_destroy__ = _fusion.delete_BRepWires
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepWire >" :
        """
        Function that returns the specified wire using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.BRepWires_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of B-Rep wire bodies in the collection."""
        return _fusion.BRepWires__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BRepWires__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BRepWires__get_isValid(self)
BRepWires_swigregister = _fusion.BRepWires_swigregister
BRepWires_swigregister(BRepWires)

def BRepWires_classType() -> "char const *" :
  return _fusion.BRepWires_classType()
BRepWires_classType = _fusion.BRepWires_classType

BRepWires.__swig_getmethods__["count"] = BRepWires._get_count
BRepWires.count = property(BRepWires._get_count, doc="The number of B-Rep wire bodies in the collection.")

BRepWires.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BRepWires) else None
BRepWires.cast = lambda arg: arg if isinstance(arg, BRepWires) else None

class ChamferFeatureInput(Base):
    """
    This class defines the methods and properties that pertain to the definition of a chamfer 
    feature.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChamferFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ChamferFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ChamferFeatureInput *" : return _fusion.ChamferFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ChamferFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ChamferFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ChamferFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.ChamferFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_ChamferFeatureInput
    __del__ = lambda self : None;
    def _get_edges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the collection of edges that will be chamfered. In order to access (get) the input edges
        of a chamfer, you must roll the timeline back to just before the chamfer feature
        whose edges you want to access.
        """
        return _fusion.ChamferFeatureInput__get_edges(self)

    def _set_edges(self, *args) -> "bool" :
        """
        Gets and sets the collection of edges that will be chamfered. In order to access (get) the input edges
        of a chamfer, you must roll the timeline back to just before the chamfer feature
        whose edges you want to access.
        """
        return _fusion.ChamferFeatureInput__set_edges(self, *args)

    def setToEqualDistance(self, *args) -> "bool" :
        """
        Adds a set of edges to this input. 
        distance : A ValueInput object that defines the size of the chamfer. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '2 in'). If no units are specified
        it is interpreted using the current default units for length. 
        Returns true if the set of edges was successfully added to the ChamferFeatureInput.
        """
        return _fusion.ChamferFeatureInput_setToEqualDistance(self, *args)

    def setToTwoDistances(self, *args) -> "bool" :
        """
        Adds a set of edges to this input. 
        distanceOne : A ValueInput object that defines the distanceOne of the chamfer. This distance 
        is along the face which is on the left of the selected edge.
        If the ValueInput uses a real then it is interpreted as centimeters.
        If it is a string then the units can be defined as part of the string (i.e. '2 in').
        If no units are specified it is interpreted using the current default units for length. 
        distanceTwo : A ValueInput object that defines the distanceTwo of the chamfer. This distance 
        is along the face which is on the right of the selected edge.
        If the ValueInput uses a real then it is interpreted as centimeters.
        If it is a string then the units can be defined as part of the string (i.e. '2 in').
        If no units are specified it is interpreted using the current default units for length. 
        Returns true if successful.
        """
        return _fusion.ChamferFeatureInput_setToTwoDistances(self, *args)

    def setToDistanceAndAngle(self, *args) -> "bool" :
        """
        Adds a set of edges to this input. 
        distance : A ValueInput object that defines the distance of the chamfer. This distance 
        is along the face which is on the right of the selected edge.
        If the ValueInput uses a real then it is interpreted as centimeters.
        If it is a string then the units can be defined as part of the string (i.e. '2 in').
        If no units are specified it is interpreted using the current default units for length. 
        angle : A valueInput object that defines the angle. The direction will be towards to the face 
        which is on the left of the selected edge. This can be a string or a value.
        If it's a string it is interpreted using the current document units and can include
        equations. For example all of the following are valid as long as they result in
        angle units; '45', '45 deg', 'a1 / 2'. If a value is input it is interpreted
        as radians. It cannot be negative. 
        Returns true if successful.
        """
        return _fusion.ChamferFeatureInput_setToDistanceAndAngle(self, *args)

    def _get_isTangentChain(self) -> "bool" :
        """
        Gets and sets if any edges that are tangentially connected to any of chamfered
        edges will also be included in the chamfer.
        """
        return _fusion.ChamferFeatureInput__get_isTangentChain(self)

    def _set_isTangentChain(self, *args) -> "bool" :
        """
        Gets and sets if any edges that are tangentially connected to any of chamfered
        edges will also be included in the chamfer.
        """
        return _fusion.ChamferFeatureInput__set_isTangentChain(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ChamferFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ChamferFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ChamferFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ChamferFeatureInput__get_isValid(self)
ChamferFeatureInput_swigregister = _fusion.ChamferFeatureInput_swigregister
ChamferFeatureInput_swigregister(ChamferFeatureInput)

def ChamferFeatureInput_classType() -> "char const *" :
  return _fusion.ChamferFeatureInput_classType()
ChamferFeatureInput_classType = _fusion.ChamferFeatureInput_classType

ChamferFeatureInput.__swig_getmethods__["edges"] = ChamferFeatureInput._get_edges
ChamferFeatureInput.__swig_setmethods__["edges"] = ChamferFeatureInput._set_edges
ChamferFeatureInput.edges = property(ChamferFeatureInput._get_edges, ChamferFeatureInput._set_edges, doc="Gets and sets the collection of edges that will be chamfered. In order to access (get) the input edges\nof a chamfer, you must roll the timeline back to just before the chamfer feature\nwhose edges you want to access.")

ChamferFeatureInput.__swig_getmethods__["isTangentChain"] = ChamferFeatureInput._get_isTangentChain
ChamferFeatureInput.__swig_setmethods__["isTangentChain"] = ChamferFeatureInput._set_isTangentChain
ChamferFeatureInput.isTangentChain = property(ChamferFeatureInput._get_isTangentChain, ChamferFeatureInput._set_isTangentChain, doc="Gets and sets if any edges that are tangentially connected to any of chamfered\nedges will also be included in the chamfer.")

ChamferFeatureInput.__swig_getmethods__["targetBaseFeature"] = ChamferFeatureInput._get_targetBaseFeature
ChamferFeatureInput.__swig_setmethods__["targetBaseFeature"] = ChamferFeatureInput._set_targetBaseFeature
ChamferFeatureInput.targetBaseFeature = property(ChamferFeatureInput._get_targetBaseFeature, ChamferFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

ChamferFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ChamferFeatureInput) else None
ChamferFeatureInput.cast = lambda arg: arg if isinstance(arg, ChamferFeatureInput) else None

class ChamferFeatures(Base):
    """
    Collection that provides access to all of the existing chamfer features in a component
    and supports the ability to create new chamfer features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChamferFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ChamferFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ChamferFeatures *" : return _fusion.ChamferFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ChamferFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ChamferFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.ChamferFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.ChamferFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ChamferFeatures_classType
    if _newclass:classType = staticmethod(_fusion.ChamferFeatures_classType)
    __swig_destroy__ = _fusion.delete_ChamferFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >" :
        """
        Function that returns the specified chamfer feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ChamferFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of chamfer features in the collection."""
        return _fusion.ChamferFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::ChamferFeatureInput >" :
        """
        Creates a ChamferFeatureInput object. Use properties and methods on this object
        to define the chamfer you want to create and then use the Add method, passing in 
        the ChamferFeatureInput object. 
        edges : The collection of edges that will be chamfered. 
        isTangentChain : Boolean indicating if all edges that are tangentially connected to any of the input edges should be included in the chamfer or not. 
        Returns the newly created ChamferFeatureInput object or null if the creation failed.
        """
        return _fusion.ChamferFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >" :
        """
        Creates a new chamfer feature. 
        input : A ChamferFeatureInput object that defines the desired chamfer. Use the createInput 
        method to create a new ChamferFeatureInput object and then use methods on it 
        (the ChamferFeatureInput object) to define the chamfer. 
        Returns the newly created ChamferFeature object or null if the creation failed.
        """
        return _fusion.ChamferFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >" :
        """
        Function that returns the specified chamfer feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.ChamferFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ChamferFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ChamferFeatures__get_isValid(self)
ChamferFeatures_swigregister = _fusion.ChamferFeatures_swigregister
ChamferFeatures_swigregister(ChamferFeatures)

def ChamferFeatures_classType() -> "char const *" :
  return _fusion.ChamferFeatures_classType()
ChamferFeatures_classType = _fusion.ChamferFeatures_classType

ChamferFeatures.__swig_getmethods__["count"] = ChamferFeatures._get_count
ChamferFeatures.count = property(ChamferFeatures._get_count, doc="The number of chamfer features in the collection.")

ChamferFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ChamferFeatures) else None
ChamferFeatures.cast = lambda arg: arg if isinstance(arg, ChamferFeatures) else None

class ChamferTypeDefinition(Base):
    """The base class for the classes that define how a chamfer can be defined."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChamferTypeDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ChamferTypeDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ChamferTypeDefinition *" : return _fusion.ChamferTypeDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ChamferTypeDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ChamferTypeDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ChamferTypeDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ChamferTypeDefinition_classType)
    __swig_destroy__ = _fusion.delete_ChamferTypeDefinition
    __del__ = lambda self : None;
    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >" :
        """Returns the feature that owns this chamfer type definition"""
        return _fusion.ChamferTypeDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ChamferTypeDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ChamferTypeDefinition__get_isValid(self)
ChamferTypeDefinition_swigregister = _fusion.ChamferTypeDefinition_swigregister
ChamferTypeDefinition_swigregister(ChamferTypeDefinition)

def ChamferTypeDefinition_classType() -> "char const *" :
  return _fusion.ChamferTypeDefinition_classType()
ChamferTypeDefinition_classType = _fusion.ChamferTypeDefinition_classType

ChamferTypeDefinition.__swig_getmethods__["parentFeature"] = ChamferTypeDefinition._get_parentFeature
ChamferTypeDefinition.parentFeature = property(ChamferTypeDefinition._get_parentFeature, doc="Returns the feature that owns this chamfer type definition")

ChamferTypeDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ChamferTypeDefinition) else None
ChamferTypeDefinition.cast = lambda arg: arg if isinstance(arg, ChamferTypeDefinition) else None

class CircularPatternFeatureInput(Base):
    """
    This class defines the methods and properties that pertain to the definition of a circular pattern 
    feature.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CircularPatternFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CircularPatternFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CircularPatternFeatureInput *" : return _fusion.CircularPatternFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CircularPatternFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CircularPatternFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CircularPatternFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.CircularPatternFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_CircularPatternFeatureInput
    __del__ = lambda self : None;
    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        """
        return _fusion.CircularPatternFeatureInput__get_inputEntities(self)

    def _set_inputEntities(self, *args) -> "bool" :
        """
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        """
        return _fusion.CircularPatternFeatureInput__set_inputEntities(self, *args)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the axis of circular pattern. This can be a sketch line, linear edge,
        construction axis, an edge/sketch curve that defines an axis (circle, etc.) or a face that defines an axis (cylinder, cone, torus, etc.).
        """
        return _fusion.CircularPatternFeatureInput__get_axis(self)

    def _set_axis(self, *args) -> "bool" :
        """
        Gets and sets the axis of circular pattern. This can be a sketch line, linear edge,
        construction axis, an edge/sketch curve that defines an axis (circle, etc.) or a face that defines an axis (cylinder, cone, torus, etc.).
        """
        return _fusion.CircularPatternFeatureInput__set_axis(self, *args)

    def _get_quantity(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets and sets quantity of the elements."""
        return _fusion.CircularPatternFeatureInput__get_quantity(self)

    def _set_quantity(self, *args) -> "bool" :
        """Gets and sets quantity of the elements."""
        return _fusion.CircularPatternFeatureInput__set_quantity(self, *args)

    def _get_totalAngle(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Gets and sets total angle. A negative angle can be used to reverse the direction.
        An angle of 360 degrees or 2 pi radians will create a full circular pattern.
        """
        return _fusion.CircularPatternFeatureInput__get_totalAngle(self)

    def _set_totalAngle(self, *args) -> "bool" :
        """
        Gets and sets total angle. A negative angle can be used to reverse the direction.
        An angle of 360 degrees or 2 pi radians will create a full circular pattern.
        """
        return _fusion.CircularPatternFeatureInput__set_totalAngle(self, *args)

    def _get_isSymmetric(self) -> "bool" :
        """Gets and sets if the angle extent is in one direction or symmetric."""
        return _fusion.CircularPatternFeatureInput__get_isSymmetric(self)

    def _set_isSymmetric(self, *args) -> "bool" :
        """Gets and sets if the angle extent is in one direction or symmetric."""
        return _fusion.CircularPatternFeatureInput__set_isSymmetric(self, *args)

    def _get_patternComputeOption(self) -> "adsk::fusion::PatternComputeOptions" :
        """
        Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        """
        return _fusion.CircularPatternFeatureInput__get_patternComputeOption(self)

    def _set_patternComputeOption(self, *args) -> "bool" :
        """
        Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        """
        return _fusion.CircularPatternFeatureInput__set_patternComputeOption(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.CircularPatternFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.CircularPatternFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CircularPatternFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CircularPatternFeatureInput__get_isValid(self)
CircularPatternFeatureInput_swigregister = _fusion.CircularPatternFeatureInput_swigregister
CircularPatternFeatureInput_swigregister(CircularPatternFeatureInput)

def CircularPatternFeatureInput_classType() -> "char const *" :
  return _fusion.CircularPatternFeatureInput_classType()
CircularPatternFeatureInput_classType = _fusion.CircularPatternFeatureInput_classType

CircularPatternFeatureInput.__swig_getmethods__["inputEntities"] = CircularPatternFeatureInput._get_inputEntities
CircularPatternFeatureInput.__swig_setmethods__["inputEntities"] = CircularPatternFeatureInput._set_inputEntities
CircularPatternFeatureInput.inputEntities = property(CircularPatternFeatureInput._get_inputEntities, CircularPatternFeatureInput._set_inputEntities, doc="Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.\nAll of the entities must be of a single type. For example, it can't contain features and occurrences\nbut only features or occurrences.")

CircularPatternFeatureInput.__swig_getmethods__["axis"] = CircularPatternFeatureInput._get_axis
CircularPatternFeatureInput.__swig_setmethods__["axis"] = CircularPatternFeatureInput._set_axis
CircularPatternFeatureInput.axis = property(CircularPatternFeatureInput._get_axis, CircularPatternFeatureInput._set_axis, doc="Gets and sets the axis of circular pattern. This can be a sketch line, linear edge,\nconstruction axis, an edge/sketch curve that defines an axis (circle, etc.) or a face that defines an axis (cylinder, cone, torus, etc.).")

CircularPatternFeatureInput.__swig_getmethods__["quantity"] = CircularPatternFeatureInput._get_quantity
CircularPatternFeatureInput.__swig_setmethods__["quantity"] = CircularPatternFeatureInput._set_quantity
CircularPatternFeatureInput.quantity = property(CircularPatternFeatureInput._get_quantity, CircularPatternFeatureInput._set_quantity, doc="Gets and sets quantity of the elements.")

CircularPatternFeatureInput.__swig_getmethods__["totalAngle"] = CircularPatternFeatureInput._get_totalAngle
CircularPatternFeatureInput.__swig_setmethods__["totalAngle"] = CircularPatternFeatureInput._set_totalAngle
CircularPatternFeatureInput.totalAngle = property(CircularPatternFeatureInput._get_totalAngle, CircularPatternFeatureInput._set_totalAngle, doc="Gets and sets total angle. A negative angle can be used to reverse the direction.\nAn angle of 360 degrees or 2 pi radians will create a full circular pattern.")

CircularPatternFeatureInput.__swig_getmethods__["isSymmetric"] = CircularPatternFeatureInput._get_isSymmetric
CircularPatternFeatureInput.__swig_setmethods__["isSymmetric"] = CircularPatternFeatureInput._set_isSymmetric
CircularPatternFeatureInput.isSymmetric = property(CircularPatternFeatureInput._get_isSymmetric, CircularPatternFeatureInput._set_isSymmetric, doc="Gets and sets if the angle extent is in one direction or symmetric.")

CircularPatternFeatureInput.__swig_getmethods__["patternComputeOption"] = CircularPatternFeatureInput._get_patternComputeOption
CircularPatternFeatureInput.__swig_setmethods__["patternComputeOption"] = CircularPatternFeatureInput._set_patternComputeOption
CircularPatternFeatureInput.patternComputeOption = property(CircularPatternFeatureInput._get_patternComputeOption, CircularPatternFeatureInput._set_patternComputeOption, doc="Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.\nThis property only applies when patterning features and is ignored in the direct modeling environment.")

CircularPatternFeatureInput.__swig_getmethods__["targetBaseFeature"] = CircularPatternFeatureInput._get_targetBaseFeature
CircularPatternFeatureInput.__swig_setmethods__["targetBaseFeature"] = CircularPatternFeatureInput._set_targetBaseFeature
CircularPatternFeatureInput.targetBaseFeature = property(CircularPatternFeatureInput._get_targetBaseFeature, CircularPatternFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

CircularPatternFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CircularPatternFeatureInput) else None
CircularPatternFeatureInput.cast = lambda arg: arg if isinstance(arg, CircularPatternFeatureInput) else None

class CircularPatternFeatures(Base):
    """
    Collection that provides access to all of the existing circular pattern features in a component
    and supports the ability to create new circular pattern features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CircularPatternFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CircularPatternFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CircularPatternFeatures *" : return _fusion.CircularPatternFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CircularPatternFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CircularPatternFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.CircularPatternFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::CircularPatternFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.CircularPatternFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CircularPatternFeatures_classType
    if _newclass:classType = staticmethod(_fusion.CircularPatternFeatures_classType)
    __swig_destroy__ = _fusion.delete_CircularPatternFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::CircularPatternFeature >" :
        """
        Function that returns the specified circular pattern feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.CircularPatternFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of circular pattern features in the collection."""
        return _fusion.CircularPatternFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::CircularPatternFeatureInput >" :
        """
        Creates a CircularPatternFeatureInput object. Use properties and methods on this object
        to define the circular pattern you want to create and then use the Add method, passing in 
        the CircularPatternFeatureInput object. 
        inputEntities : The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences. 
        axis : Input linear entity or the entity has axis that defines axis of circular pattern. This can be a sketch line, linear edge,
        construction axis, an edge/sketch curve that defines an axis (circle, etc.) or a face that defines an axis (cylinder, cone, torus, etc.). 
        Returns the newly created CircularPatternFeatureInput object or null if the creation failed.
        """
        return _fusion.CircularPatternFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::CircularPatternFeature >" :
        """
        Creates a new circular pattern feature. 
        input : A CircularPatternFeatureInput object that defines the desired circular pattern. Use the createInput 
        method to create a new CircularPatternFeatureInput object and then use methods on it 
        (the CircularPatternFeatureInput object) to define the circular pattern. 
        Returns the newly created CircularPatternFeature object or null if the creation failed.
        """
        return _fusion.CircularPatternFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::CircularPatternFeature >" :
        """
        Function that returns the specified circular pattern feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.CircularPatternFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CircularPatternFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CircularPatternFeatures__get_isValid(self)
CircularPatternFeatures_swigregister = _fusion.CircularPatternFeatures_swigregister
CircularPatternFeatures_swigregister(CircularPatternFeatures)

def CircularPatternFeatures_classType() -> "char const *" :
  return _fusion.CircularPatternFeatures_classType()
CircularPatternFeatures_classType = _fusion.CircularPatternFeatures_classType

CircularPatternFeatures.__swig_getmethods__["count"] = CircularPatternFeatures._get_count
CircularPatternFeatures.count = property(CircularPatternFeatures._get_count, doc="The number of circular pattern features in the collection.")

CircularPatternFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CircularPatternFeatures) else None
CircularPatternFeatures.cast = lambda arg: arg if isinstance(arg, CircularPatternFeatures) else None

class CoilFeatureInput(Base):
    """This class defines the methods and properties that pertain to the definition of a coil feature."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoilFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoilFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CoilFeatureInput *" : return _fusion.CoilFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CoilFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CoilFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CoilFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.CoilFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_CoilFeatureInput
    __del__ = lambda self : None;
    def setToRevolutionAndHeight(self, *args) -> "bool" :
        """
        Sets the coil type to RevolutionsAndHeightCoilType. 
        revolutions : A ValueInput object that defines the number of revolutions. 
        height : A ValueInput object that defines the height. 
        angle : A ValueInput object that defines angle. 
        Returns true if successful.
        """
        return _fusion.CoilFeatureInput_setToRevolutionAndHeight(self, *args)

    def setToRevolutionsAndPitch(self, *args) -> "bool" :
        """
        Sets the coil type to RevolutionsAndPitchCoilType. 
        revolutions : A ValueInput object that defines the number of revolutions. 
        pitch : A ValueInput object that defines the pitch. 
        angle : A ValueInput object that defines angle. 
        Returns true if successful.
        """
        return _fusion.CoilFeatureInput_setToRevolutionsAndPitch(self, *args)

    def setToHeightAndPitchCoil(self, *args) -> "bool" :
        """
        Sets the coil type to HeightAndPitchCoilType. 
        height : A ValueInput object that defines the height. 
        pitch : A ValueInput object that defines the pitch. 
        angle : A ValueInput object that defines angle. 
        Returns true if successful.
        """
        return _fusion.CoilFeatureInput_setToHeightAndPitchCoil(self, *args)

    def setToSpiral(self, *args) -> "bool" :
        """
        Sets the coil type to SpiralCoilType. 
        revolutions : A ValueInput object that defines the number of revolutions. 
        pitch : A ValueInput object that defines the pitch. 
        Returns true if successful.
        """
        return _fusion.CoilFeatureInput_setToSpiral(self, *args)

    def _get_isSolid(self) -> "bool" :
        """
        Specifies if the coil should be created as a solid or surface. This is
        initialized to true so a solid will be created if it's not changed.
        It only can be set to false in non-parametric modeling.
        """
        return _fusion.CoilFeatureInput__get_isSolid(self)

    def _set_isSolid(self, *args) -> "bool" :
        """
        Specifies if the coil should be created as a solid or surface. This is
        initialized to true so a solid will be created if it's not changed.
        It only can be set to false in non-parametric modeling.
        """
        return _fusion.CoilFeatureInput__set_isSolid(self, *args)

    def _get_revolutions(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets the revolutions number. Returns null in the case where the coilType property returns HeightAndPitchCoilType."""
        return _fusion.CoilFeatureInput__get_revolutions(self)

    def _get_height(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets the height. Returns null in the case where the coilType property returns RevolutionsAndPitchCoilType."""
        return _fusion.CoilFeatureInput__get_height(self)

    def _get_pitch(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets the pitch. Returns null in the case where the coilType property returns RevolutionsAndHeightCoilType or SpiralCoilType."""
        return _fusion.CoilFeatureInput__get_pitch(self)

    def _get_angle(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets the angle. Returns null in the case where the coilType property returns SpiralCoilType."""
        return _fusion.CoilFeatureInput__get_angle(self)

    def _get_coilType(self) -> "adsk::fusion::CoilFeatureTypes" :
        """Gets the type of the coil."""
        return _fusion.CoilFeatureInput__get_coilType(self)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """Gets and sets the type of operation performed by the coil."""
        return _fusion.CoilFeatureInput__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """Gets and sets the type of operation performed by the coil."""
        return _fusion.CoilFeatureInput__set_operation(self, *args)

    def _get_basePlane(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets and sets the base plane."""
        return _fusion.CoilFeatureInput__get_basePlane(self)

    def _set_basePlane(self, *args) -> "bool" :
        """Gets and sets the base plane."""
        return _fusion.CoilFeatureInput__set_basePlane(self, *args)

    def _get_isClockwiseRotation(self) -> "bool" :
        """
        Gets and sets whether the rotation is clockwise or counter-clockwise. A value of true indicates clockwise rotation.
        It defaults to true.
        """
        return _fusion.CoilFeatureInput__get_isClockwiseRotation(self)

    def _set_isClockwiseRotation(self, *args) -> "bool" :
        """
        Gets and sets whether the rotation is clockwise or counter-clockwise. A value of true indicates clockwise rotation.
        It defaults to true.
        """
        return _fusion.CoilFeatureInput__set_isClockwiseRotation(self, *args)

    def _get_diameter(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets and sets the diameter."""
        return _fusion.CoilFeatureInput__get_diameter(self)

    def _set_diameter(self, *args) -> "bool" :
        """Gets and sets the diameter."""
        return _fusion.CoilFeatureInput__set_diameter(self, *args)

    def _get_coilSectionType(self) -> "adsk::fusion::CoilFeatureSectionTypes" :
        """
        Gets the section type of the coil.
        It defaults to CircularCoilSectionType.
        """
        return _fusion.CoilFeatureInput__get_coilSectionType(self)

    def _set_coilSectionType(self, *args) -> "bool" :
        """
        Gets the section type of the coil.
        It defaults to CircularCoilSectionType.
        """
        return _fusion.CoilFeatureInput__set_coilSectionType(self, *args)

    def _get_coilSectionPosition(self) -> "adsk::fusion::CoilFeatureSectionPositions" :
        """
        Gets the section position of the coil.
        It defaults to InsideCoilSectionPosition.
        """
        return _fusion.CoilFeatureInput__get_coilSectionPosition(self)

    def _set_coilSectionPosition(self, *args) -> "bool" :
        """
        Gets the section position of the coil.
        It defaults to InsideCoilSectionPosition.
        """
        return _fusion.CoilFeatureInput__set_coilSectionPosition(self, *args)

    def _get_sectionSize(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets and sets the section size."""
        return _fusion.CoilFeatureInput__get_sectionSize(self)

    def _set_sectionSize(self, *args) -> "bool" :
        """Gets and sets the section size."""
        return _fusion.CoilFeatureInput__set_sectionSize(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.CoilFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.CoilFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CoilFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CoilFeatureInput__get_isValid(self)
CoilFeatureInput_swigregister = _fusion.CoilFeatureInput_swigregister
CoilFeatureInput_swigregister(CoilFeatureInput)

def CoilFeatureInput_classType() -> "char const *" :
  return _fusion.CoilFeatureInput_classType()
CoilFeatureInput_classType = _fusion.CoilFeatureInput_classType

CoilFeatureInput.__swig_getmethods__["isSolid"] = CoilFeatureInput._get_isSolid
CoilFeatureInput.__swig_setmethods__["isSolid"] = CoilFeatureInput._set_isSolid
CoilFeatureInput.isSolid = property(CoilFeatureInput._get_isSolid, CoilFeatureInput._set_isSolid, doc="Specifies if the coil should be created as a solid or surface. This is\ninitialized to true so a solid will be created if it's not changed.\nIt only can be set to false in non-parametric modeling.")

CoilFeatureInput.__swig_getmethods__["revolutions"] = CoilFeatureInput._get_revolutions
CoilFeatureInput.revolutions = property(CoilFeatureInput._get_revolutions, doc="Gets the revolutions number. Returns null in the case where the coilType property returns HeightAndPitchCoilType.")

CoilFeatureInput.__swig_getmethods__["height"] = CoilFeatureInput._get_height
CoilFeatureInput.height = property(CoilFeatureInput._get_height, doc="Gets the height. Returns null in the case where the coilType property returns RevolutionsAndPitchCoilType.")

CoilFeatureInput.__swig_getmethods__["pitch"] = CoilFeatureInput._get_pitch
CoilFeatureInput.pitch = property(CoilFeatureInput._get_pitch, doc="Gets the pitch. Returns null in the case where the coilType property returns RevolutionsAndHeightCoilType or SpiralCoilType.")

CoilFeatureInput.__swig_getmethods__["angle"] = CoilFeatureInput._get_angle
CoilFeatureInput.angle = property(CoilFeatureInput._get_angle, doc="Gets the angle. Returns null in the case where the coilType property returns SpiralCoilType.")

CoilFeatureInput.__swig_getmethods__["coilType"] = CoilFeatureInput._get_coilType
CoilFeatureInput.coilType = property(CoilFeatureInput._get_coilType, doc="Gets the type of the coil.")

CoilFeatureInput.__swig_getmethods__["operation"] = CoilFeatureInput._get_operation
CoilFeatureInput.__swig_setmethods__["operation"] = CoilFeatureInput._set_operation
CoilFeatureInput.operation = property(CoilFeatureInput._get_operation, CoilFeatureInput._set_operation, doc="Gets and sets the type of operation performed by the coil.")

CoilFeatureInput.__swig_getmethods__["basePlane"] = CoilFeatureInput._get_basePlane
CoilFeatureInput.__swig_setmethods__["basePlane"] = CoilFeatureInput._set_basePlane
CoilFeatureInput.basePlane = property(CoilFeatureInput._get_basePlane, CoilFeatureInput._set_basePlane, doc="Gets and sets the base plane.")

CoilFeatureInput.__swig_getmethods__["isClockwiseRotation"] = CoilFeatureInput._get_isClockwiseRotation
CoilFeatureInput.__swig_setmethods__["isClockwiseRotation"] = CoilFeatureInput._set_isClockwiseRotation
CoilFeatureInput.isClockwiseRotation = property(CoilFeatureInput._get_isClockwiseRotation, CoilFeatureInput._set_isClockwiseRotation, doc="Gets and sets whether the rotation is clockwise or counter-clockwise. A value of true indicates clockwise rotation.\nIt defaults to true.")

CoilFeatureInput.__swig_getmethods__["diameter"] = CoilFeatureInput._get_diameter
CoilFeatureInput.__swig_setmethods__["diameter"] = CoilFeatureInput._set_diameter
CoilFeatureInput.diameter = property(CoilFeatureInput._get_diameter, CoilFeatureInput._set_diameter, doc="Gets and sets the diameter.")

CoilFeatureInput.__swig_getmethods__["coilSectionType"] = CoilFeatureInput._get_coilSectionType
CoilFeatureInput.__swig_setmethods__["coilSectionType"] = CoilFeatureInput._set_coilSectionType
CoilFeatureInput.coilSectionType = property(CoilFeatureInput._get_coilSectionType, CoilFeatureInput._set_coilSectionType, doc="Gets the section type of the coil.\nIt defaults to CircularCoilSectionType.")

CoilFeatureInput.__swig_getmethods__["coilSectionPosition"] = CoilFeatureInput._get_coilSectionPosition
CoilFeatureInput.__swig_setmethods__["coilSectionPosition"] = CoilFeatureInput._set_coilSectionPosition
CoilFeatureInput.coilSectionPosition = property(CoilFeatureInput._get_coilSectionPosition, CoilFeatureInput._set_coilSectionPosition, doc="Gets the section position of the coil.\nIt defaults to InsideCoilSectionPosition.")

CoilFeatureInput.__swig_getmethods__["sectionSize"] = CoilFeatureInput._get_sectionSize
CoilFeatureInput.__swig_setmethods__["sectionSize"] = CoilFeatureInput._set_sectionSize
CoilFeatureInput.sectionSize = property(CoilFeatureInput._get_sectionSize, CoilFeatureInput._set_sectionSize, doc="Gets and sets the section size.")

CoilFeatureInput.__swig_getmethods__["targetBaseFeature"] = CoilFeatureInput._get_targetBaseFeature
CoilFeatureInput.__swig_setmethods__["targetBaseFeature"] = CoilFeatureInput._set_targetBaseFeature
CoilFeatureInput.targetBaseFeature = property(CoilFeatureInput._get_targetBaseFeature, CoilFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

CoilFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CoilFeatureInput) else None
CoilFeatureInput.cast = lambda arg: arg if isinstance(arg, CoilFeatureInput) else None

class CoilFeatures(Base):
    """
    Collection that provides access to all of the existing coil features in a design
    and supports the ability to create new coil features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoilFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoilFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CoilFeatures *" : return _fusion.CoilFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CoilFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CoilFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.CoilFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::CoilFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.CoilFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CoilFeatures_classType
    if _newclass:classType = staticmethod(_fusion.CoilFeatures_classType)
    __swig_destroy__ = _fusion.delete_CoilFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::CoilFeature >" :
        """
        Function that returns the specified coil feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.CoilFeatures_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::CoilFeature >" :
        """
        Function that returns the specified coil feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.CoilFeatures_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of coil features in the collection."""
        return _fusion.CoilFeatures__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.CoilFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CoilFeatures__get_isValid(self)
CoilFeatures_swigregister = _fusion.CoilFeatures_swigregister
CoilFeatures_swigregister(CoilFeatures)

def CoilFeatures_classType() -> "char const *" :
  return _fusion.CoilFeatures_classType()
CoilFeatures_classType = _fusion.CoilFeatures_classType

CoilFeatures.__swig_getmethods__["count"] = CoilFeatures._get_count
CoilFeatures.count = property(CoilFeatures._get_count, doc="The number of coil features in the collection.")

CoilFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CoilFeatures) else None
CoilFeatures.cast = lambda arg: arg if isinstance(arg, CoilFeatures) else None

class CombineFeatureInput(Base):
    """
    This class defines the methods and properties that pertain to the definition of a combine 
    feature.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CombineFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CombineFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CombineFeatureInput *" : return _fusion.CombineFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CombineFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CombineFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CombineFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.CombineFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_CombineFeatureInput
    __del__ = lambda self : None;
    def _get_targetBody(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """Gets and sets the BRep Body object that represents the blank body."""
        return _fusion.CombineFeatureInput__get_targetBody(self)

    def _set_targetBody(self, *args) -> "bool" :
        """Gets and sets the BRep Body object that represents the blank body."""
        return _fusion.CombineFeatureInput__set_targetBody(self, *args)

    def _get_toolBodies(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """Gets and sets the BRep Body objects that represent the tool bodies."""
        return _fusion.CombineFeatureInput__get_toolBodies(self)

    def _set_toolBodies(self, *args) -> "bool" :
        """Gets and sets the BRep Body objects that represent the tool bodies."""
        return _fusion.CombineFeatureInput__set_toolBodies(self, *args)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """
        Gets and sets the type of operation performed by the combine.
        The valid values are JoinFeatureOperation, CutFeatureOperation and IntersectFeatureOperation.
        The default value is JoinFeatureOperation.
        """
        return _fusion.CombineFeatureInput__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """
        Gets and sets the type of operation performed by the combine.
        The valid values are JoinFeatureOperation, CutFeatureOperation and IntersectFeatureOperation.
        The default value is JoinFeatureOperation.
        """
        return _fusion.CombineFeatureInput__set_operation(self, *args)

    def _get_isNewComponent(self) -> "bool" :
        """
        Gets and sets a boolean value for whether or not a new component will be created with the results. The default value is false.
        In Base feature environment NewComponent does not work.
        """
        return _fusion.CombineFeatureInput__get_isNewComponent(self)

    def _set_isNewComponent(self, *args) -> "bool" :
        """
        Gets and sets a boolean value for whether or not a new component will be created with the results. The default value is false.
        In Base feature environment NewComponent does not work.
        """
        return _fusion.CombineFeatureInput__set_isNewComponent(self, *args)

    def _get_isKeepToolBodies(self) -> "bool" :
        """Gets and sets a boolean value for whether or not the tool bodies are retrained after the combine results. The default value is false."""
        return _fusion.CombineFeatureInput__get_isKeepToolBodies(self)

    def _set_isKeepToolBodies(self, *args) -> "bool" :
        """Gets and sets a boolean value for whether or not the tool bodies are retrained after the combine results. The default value is false."""
        return _fusion.CombineFeatureInput__set_isKeepToolBodies(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.CombineFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.CombineFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CombineFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CombineFeatureInput__get_isValid(self)
CombineFeatureInput_swigregister = _fusion.CombineFeatureInput_swigregister
CombineFeatureInput_swigregister(CombineFeatureInput)

def CombineFeatureInput_classType() -> "char const *" :
  return _fusion.CombineFeatureInput_classType()
CombineFeatureInput_classType = _fusion.CombineFeatureInput_classType

CombineFeatureInput.__swig_getmethods__["targetBody"] = CombineFeatureInput._get_targetBody
CombineFeatureInput.__swig_setmethods__["targetBody"] = CombineFeatureInput._set_targetBody
CombineFeatureInput.targetBody = property(CombineFeatureInput._get_targetBody, CombineFeatureInput._set_targetBody, doc="Gets and sets the BRep Body object that represents the blank body.")

CombineFeatureInput.__swig_getmethods__["toolBodies"] = CombineFeatureInput._get_toolBodies
CombineFeatureInput.__swig_setmethods__["toolBodies"] = CombineFeatureInput._set_toolBodies
CombineFeatureInput.toolBodies = property(CombineFeatureInput._get_toolBodies, CombineFeatureInput._set_toolBodies, doc="Gets and sets the BRep Body objects that represent the tool bodies.")

CombineFeatureInput.__swig_getmethods__["operation"] = CombineFeatureInput._get_operation
CombineFeatureInput.__swig_setmethods__["operation"] = CombineFeatureInput._set_operation
CombineFeatureInput.operation = property(CombineFeatureInput._get_operation, CombineFeatureInput._set_operation, doc="Gets and sets the type of operation performed by the combine.\nThe valid values are JoinFeatureOperation, CutFeatureOperation and IntersectFeatureOperation.\nThe default value is JoinFeatureOperation.")

CombineFeatureInput.__swig_getmethods__["isNewComponent"] = CombineFeatureInput._get_isNewComponent
CombineFeatureInput.__swig_setmethods__["isNewComponent"] = CombineFeatureInput._set_isNewComponent
CombineFeatureInput.isNewComponent = property(CombineFeatureInput._get_isNewComponent, CombineFeatureInput._set_isNewComponent, doc="Gets and sets a boolean value for whether or not a new component will be created with the results. The default value is false.\nIn Base feature environment NewComponent does not work.")

CombineFeatureInput.__swig_getmethods__["isKeepToolBodies"] = CombineFeatureInput._get_isKeepToolBodies
CombineFeatureInput.__swig_setmethods__["isKeepToolBodies"] = CombineFeatureInput._set_isKeepToolBodies
CombineFeatureInput.isKeepToolBodies = property(CombineFeatureInput._get_isKeepToolBodies, CombineFeatureInput._set_isKeepToolBodies, doc="Gets and sets a boolean value for whether or not the tool bodies are retrained after the combine results. The default value is false.")

CombineFeatureInput.__swig_getmethods__["targetBaseFeature"] = CombineFeatureInput._get_targetBaseFeature
CombineFeatureInput.__swig_setmethods__["targetBaseFeature"] = CombineFeatureInput._set_targetBaseFeature
CombineFeatureInput.targetBaseFeature = property(CombineFeatureInput._get_targetBaseFeature, CombineFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

CombineFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CombineFeatureInput) else None
CombineFeatureInput.cast = lambda arg: arg if isinstance(arg, CombineFeatureInput) else None

class CombineFeatures(Base):
    """
    Collection that provides access to all of the existing Combine features in a component
    and supports the ability to create new Combine features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CombineFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CombineFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CombineFeatures *" : return _fusion.CombineFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CombineFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CombineFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.CombineFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::CombineFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.CombineFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CombineFeatures_classType
    if _newclass:classType = staticmethod(_fusion.CombineFeatures_classType)
    __swig_destroy__ = _fusion.delete_CombineFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::CombineFeature >" :
        """
        Function that returns the specified combine feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.CombineFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """
        The number of combine features in the collection. 
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.CombineFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::CombineFeatureInput >" :
        """
        Creates a CombineFeatureInput object. Use properties and methods on this object
        to define the combine you want to create and then use the Add method, passing in 
        the CombineFeatureInput object. 
        targetBody : A BRep body that represents the blank body. 
        toolBodies : An ObjectCollection containing one or more BRep bodies that represent tool bodies. 
        Returns the newly created CombineFeatureInput object or null if the creation failed.
        """
        return _fusion.CombineFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::CombineFeature >" :
        """
        Creates a new combine feature. 
        input : A CombineFeatureInput object that defines the desired combine. Use the createInput 
        method to create a new CombineFeatureInput object and then use methods on it 
        (the CombineFeatureInput object) to define the combine. 
        Returns the newly created CombineFeature object or null if the creation failed.
        This function returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.CombineFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::CombineFeature >" :
        """
        Function that returns the specified combine feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.CombineFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CombineFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CombineFeatures__get_isValid(self)
CombineFeatures_swigregister = _fusion.CombineFeatures_swigregister
CombineFeatures_swigregister(CombineFeatures)

def CombineFeatures_classType() -> "char const *" :
  return _fusion.CombineFeatures_classType()
CombineFeatures_classType = _fusion.CombineFeatures_classType

CombineFeatures.__swig_getmethods__["count"] = CombineFeatures._get_count
CombineFeatures.count = property(CombineFeatures._get_count, doc="The number of combine features in the collection.\nThis property returns nothing in the case where the feature is non-parametric.")

CombineFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CombineFeatures) else None
CombineFeatures.cast = lambda arg: arg if isinstance(arg, CombineFeatures) else None

class ComponentList(Base):
    """Provides a list of components."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ComponentList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ComponentList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ComponentList *" : return _fusion.ComponentList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ComponentList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ComponentList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.ComponentList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.ComponentList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ComponentList_classType
    if _newclass:classType = staticmethod(_fusion.ComponentList_classType)
    __swig_destroy__ = _fusion.delete_ComponentList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """
        Function that returns the specified component using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ComponentList_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of components in the collection."""
        return _fusion.ComponentList__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ComponentList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ComponentList__get_isValid(self)
ComponentList_swigregister = _fusion.ComponentList_swigregister
ComponentList_swigregister(ComponentList)

def ComponentList_classType() -> "char const *" :
  return _fusion.ComponentList_classType()
ComponentList_classType = _fusion.ComponentList_classType

ComponentList.__swig_getmethods__["count"] = ComponentList._get_count
ComponentList.count = property(ComponentList._get_count, doc="Returns the number of components in the collection.")

ComponentList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ComponentList) else None
ComponentList.cast = lambda arg: arg if isinstance(arg, ComponentList) else None

class Components(Base):
    """The Components collection object provides access to existing components in a design."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Components, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Components, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::Components *" : return _fusion.Components___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Components___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Components___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.Components___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.Components___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Components_classType
    if _newclass:classType = staticmethod(_fusion.Components_classType)
    __swig_destroy__ = _fusion.delete_Components
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """
        Function that returns the specified component using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.Components_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of components in the collection."""
        return _fusion.Components__get_count(self)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """
        Function that returns the specified component by name. 
        name : The name of the component within the collection to return. 
        Returns the specified component or null if the name is not found.
        """
        return _fusion.Components_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.Components__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Components__get_isValid(self)
Components_swigregister = _fusion.Components_swigregister
Components_swigregister(Components)

def Components_classType() -> "char const *" :
  return _fusion.Components_classType()
Components_classType = _fusion.Components_classType

Components.__swig_getmethods__["count"] = Components._get_count
Components.count = property(Components._get_count, doc="The number of components in the collection.")

Components.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Components) else None
Components.cast = lambda arg: arg if isinstance(arg, Components) else None

class ConstructionAxes(Base):
    """
    Provides access to the construction axes within a component and provides 
    methods to create new construction axes.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionAxes, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionAxes, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionAxes *" : return _fusion.ConstructionAxes___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionAxes___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionAxes___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.ConstructionAxes___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.ConstructionAxes___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionAxes_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionAxes_classType)
    __swig_destroy__ = _fusion.delete_ConstructionAxes
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >" :
        """
        Function that returns the specified construction axis using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ConstructionAxes_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >" :
        """
        Returns the specified construction axis using the name of the construction
        axis as it is displayed in the browser. 
        name : The name of the axis as it is displayed in the browser 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.ConstructionAxes_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of construction axes in the collection."""
        return _fusion.ConstructionAxes__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxisInput >" :
        """
        Create a ConstructionAxisInput object that is in turn used to create a ConstructionAxis. 
        occurrenceForCreation : A creation occurrence is needed if the input is in another component AND the 
        construction axis is not in the root component. The occurrenceForCreation is analogous 
        to the active occurrence in the UI. 
        Returns a ConstructionAxisInput object
        """
        return _fusion.ConstructionAxes_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >" :
        """
        Creates and adds a new ConstructionAxis using the creation parameters in the ConstructionAxisInput.
        If the ConstructionAxisInput was defined using the setByLine method then
        the add will only work in a direct edit model (do not capture design history) and will fail in a parametric model. 
        input : A ConstructionAxisInput object 
        Returns the newly created construction axis or null if the creation failed.
        """
        return _fusion.ConstructionAxes_add(self, *args)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """The component that owns this collection."""
        return _fusion.ConstructionAxes__get_component(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionAxes__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionAxes__get_isValid(self)
ConstructionAxes_swigregister = _fusion.ConstructionAxes_swigregister
ConstructionAxes_swigregister(ConstructionAxes)

def ConstructionAxes_classType() -> "char const *" :
  return _fusion.ConstructionAxes_classType()
ConstructionAxes_classType = _fusion.ConstructionAxes_classType

ConstructionAxes.__swig_getmethods__["count"] = ConstructionAxes._get_count
ConstructionAxes.count = property(ConstructionAxes._get_count, doc="The number of construction axes in the collection.")

ConstructionAxes.__swig_getmethods__["component"] = ConstructionAxes._get_component
ConstructionAxes.component = property(ConstructionAxes._get_component, doc="The component that owns this collection.")

ConstructionAxes.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionAxes) else None
ConstructionAxes.cast = lambda arg: arg if isinstance(arg, ConstructionAxes) else None

class ConstructionAxis(Base):
    """ConstructionAxis Object"""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionAxis, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionAxis, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionAxis *" : return _fusion.ConstructionAxis___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionAxis___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionAxis___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionAxis_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionAxis_classType)
    __swig_destroy__ = _fusion.delete_ConstructionAxis
    __del__ = lambda self : None;
    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::InfiniteLine3D >" :
        """
        Returns an infinite line that represents the position and orientation of the 
        construction axis. This geometry is defined in the AssemblyContext of this 
        ConstructionAxis.
        """
        return _fusion.ConstructionAxis__get_geometry(self)

    def _get_name(self) -> "std::string" :
        """The name of the construction axis as it is shown in the browser."""
        return _fusion.ConstructionAxis__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """The name of the construction axis as it is shown in the browser."""
        return _fusion.ConstructionAxis__set_name(self, *args)

    def _get_definition(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxisDefinition >" :
        """
        Returns the construction axis definition object which provides access to the information
        defining the construction axis.
        """
        return _fusion.ConstructionAxis__get_definition(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the construction axis. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ConstructionAxis_deleteMe(self)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this construction axis is parametric or not."""
        return _fusion.ConstructionAxis__get_isParametric(self)

    def _get_isDeletable(self) -> "bool" :
        """
        Indicates if this construction axis can be deleted. Base
        construction axes can not be deleted.
        """
        return _fusion.ConstructionAxis__get_isDeletable(self)

    def _get_isLightBulbOn(self) -> "bool" :
        """
        Indicates if the light bulb (as displayed in the browser) is on.
        A construction axis will only be visible if it's light bulb, and that of it's
        containing folder and parent component/s are also on.
        """
        return _fusion.ConstructionAxis__get_isLightBulbOn(self)

    def _set_isLightBulbOn(self, *args) -> "bool" :
        """
        Indicates if the light bulb (as displayed in the browser) is on.
        A construction axis will only be visible if it's light bulb, and that of it's
        containing folder and parent component/s are also on.
        """
        return _fusion.ConstructionAxis__set_isLightBulbOn(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        Gets if the construction plane is visible.
        This property is affected by the AssemblyContext of the construction axis.
        """
        return _fusion.ConstructionAxis__get_isVisible(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the parent component or base feature. If both the design and the construction 
        axis are parametric, the parent will be a component. If the design is parametric and 
        the construction axis is not, the parent will be a base feature. If
        the design is not parametric the parent will be a component.
        """
        return _fusion.ConstructionAxis__get_parent(self)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the component this construction plane belongs to."""
        return _fusion.ConstructionAxis__get_component(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this construction axis."""
        return _fusion.ConstructionAxis__get_timelineObject(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ConstructionAxis__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ConstructionAxis__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ConstructionAxis_createForAssemblyContext(self, *args)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this construction axis is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ConstructionAxis__get_baseFeature(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this construction axis."""
        return _fusion.ConstructionAxis__get_attributes(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of this construction axis."""
        return _fusion.ConstructionAxis__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ConstructionAxis__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionAxis__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionAxis__get_isValid(self)
ConstructionAxis_swigregister = _fusion.ConstructionAxis_swigregister
ConstructionAxis_swigregister(ConstructionAxis)

def ConstructionAxis_classType() -> "char const *" :
  return _fusion.ConstructionAxis_classType()
ConstructionAxis_classType = _fusion.ConstructionAxis_classType

ConstructionAxis.__swig_getmethods__["geometry"] = ConstructionAxis._get_geometry
ConstructionAxis.geometry = property(ConstructionAxis._get_geometry, doc="Returns an infinite line that represents the position and orientation of the\nconstruction axis. This geometry is defined in the AssemblyContext of this\nConstructionAxis.")

ConstructionAxis.__swig_getmethods__["name"] = ConstructionAxis._get_name
ConstructionAxis.__swig_setmethods__["name"] = ConstructionAxis._set_name
ConstructionAxis.name = property(ConstructionAxis._get_name, ConstructionAxis._set_name, doc="The name of the construction axis as it is shown in the browser.")

ConstructionAxis.__swig_getmethods__["definition"] = ConstructionAxis._get_definition
ConstructionAxis.definition = property(ConstructionAxis._get_definition, doc="Returns the construction axis definition object which provides access to the information\ndefining the construction axis.")

ConstructionAxis.__swig_getmethods__["isParametric"] = ConstructionAxis._get_isParametric
ConstructionAxis.isParametric = property(ConstructionAxis._get_isParametric, doc="Indicates if this construction axis is parametric or not.")

ConstructionAxis.__swig_getmethods__["isDeletable"] = ConstructionAxis._get_isDeletable
ConstructionAxis.isDeletable = property(ConstructionAxis._get_isDeletable, doc="Indicates if this construction axis can be deleted. Base\nconstruction axes can not be deleted.")

ConstructionAxis.__swig_getmethods__["isLightBulbOn"] = ConstructionAxis._get_isLightBulbOn
ConstructionAxis.__swig_setmethods__["isLightBulbOn"] = ConstructionAxis._set_isLightBulbOn
ConstructionAxis.isLightBulbOn = property(ConstructionAxis._get_isLightBulbOn, ConstructionAxis._set_isLightBulbOn, doc="Indicates if the light bulb (as displayed in the browser) is on.\nA construction axis will only be visible if it's light bulb, and that of it's\ncontaining folder and parent component/s are also on.")

ConstructionAxis.__swig_getmethods__["isVisible"] = ConstructionAxis._get_isVisible
ConstructionAxis.isVisible = property(ConstructionAxis._get_isVisible, doc="Gets if the construction plane is visible.\nThis property is affected by the AssemblyContext of the construction axis.")

ConstructionAxis.__swig_getmethods__["parent"] = ConstructionAxis._get_parent
ConstructionAxis.parent = property(ConstructionAxis._get_parent, doc="Returns the parent component or base feature. If both the design and the construction\naxis are parametric, the parent will be a component. If the design is parametric and\nthe construction axis is not, the parent will be a base feature. If\nthe design is not parametric the parent will be a component.")

ConstructionAxis.__swig_getmethods__["component"] = ConstructionAxis._get_component
ConstructionAxis.component = property(ConstructionAxis._get_component, doc="Returns the component this construction plane belongs to.")

ConstructionAxis.__swig_getmethods__["timelineObject"] = ConstructionAxis._get_timelineObject
ConstructionAxis.timelineObject = property(ConstructionAxis._get_timelineObject, doc="Returns the timeline object associated with this construction axis.")

ConstructionAxis.__swig_getmethods__["assemblyContext"] = ConstructionAxis._get_assemblyContext
ConstructionAxis.assemblyContext = property(ConstructionAxis._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")

ConstructionAxis.__swig_getmethods__["nativeObject"] = ConstructionAxis._get_nativeObject
ConstructionAxis.nativeObject = property(ConstructionAxis._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

ConstructionAxis.__swig_getmethods__["baseFeature"] = ConstructionAxis._get_baseFeature
ConstructionAxis.baseFeature = property(ConstructionAxis._get_baseFeature, doc="If this construction axis is associated with a base feature, this property will return that base feature.\nIf it's not associated with a base feature, this property will return null.")

ConstructionAxis.__swig_getmethods__["attributes"] = ConstructionAxis._get_attributes
ConstructionAxis.attributes = property(ConstructionAxis._get_attributes, doc="Returns the collection of attributes associated with this construction axis.")

ConstructionAxis.__swig_getmethods__["healthState"] = ConstructionAxis._get_healthState
ConstructionAxis.healthState = property(ConstructionAxis._get_healthState, doc="Returns the current health state of this construction axis.")

ConstructionAxis.__swig_getmethods__["errorOrWarningMessage"] = ConstructionAxis._get_errorOrWarningMessage
ConstructionAxis.errorOrWarningMessage = property(ConstructionAxis._get_errorOrWarningMessage, doc="Returns the error or warning message in the case where the healthState property returns either\nWarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.")

ConstructionAxis.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionAxis) else None
ConstructionAxis.cast = lambda arg: arg if isinstance(arg, ConstructionAxis) else None

class ConstructionAxisDefinition(Base):
    """
    A Base class to return the information (possibly parametric) used to 
    define a ConstructionAxis.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionAxisDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionAxisDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionAxisDefinition *" : return _fusion.ConstructionAxisDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionAxisDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionAxisDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionAxisDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionAxisDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionAxisDefinition
    __del__ = lambda self : None;
    def _get_parentConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >" :
        """Returns the ConstructionAxis object"""
        return _fusion.ConstructionAxisDefinition__get_parentConstructionAxis(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionAxisDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionAxisDefinition__get_isValid(self)
ConstructionAxisDefinition_swigregister = _fusion.ConstructionAxisDefinition_swigregister
ConstructionAxisDefinition_swigregister(ConstructionAxisDefinition)

def ConstructionAxisDefinition_classType() -> "char const *" :
  return _fusion.ConstructionAxisDefinition_classType()
ConstructionAxisDefinition_classType = _fusion.ConstructionAxisDefinition_classType

ConstructionAxisDefinition.__swig_getmethods__["parentConstructionAxis"] = ConstructionAxisDefinition._get_parentConstructionAxis
ConstructionAxisDefinition.parentConstructionAxis = property(ConstructionAxisDefinition._get_parentConstructionAxis, doc="Returns the ConstructionAxis object")

ConstructionAxisDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionAxisDefinition) else None
ConstructionAxisDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionAxisDefinition) else None

class ConstructionAxisInput(Base):
    """
    A ConstructionAxisInput is a throwaway object used to create a ConstructionAxis
    The usage pattern is:
    a. create a ConstructionAxisInput (ConstructionAxes.CreateInput)
    b. call one of the member functions to specify how the ConstructionAxis is created
    c. create the ConstructionAxis (call ConstructionAxes.Add)
    d. stop referencing the ConstructionAxisInput (so it gets deleted).
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionAxisInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionAxisInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionAxisInput *" : return _fusion.ConstructionAxisInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionAxisInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionAxisInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionAxisInput_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionAxisInput_classType)
    __swig_destroy__ = _fusion.delete_ConstructionAxisInput
    __del__ = lambda self : None;
    def setByLine(self, *args) -> "bool" :
        """
        This input method is for creating a non-parametric construction axis whose position
        in space is defined by an InfiniteLine3D object.
        This method of defining a construction axis is only valid when working in a direct edit model (do not capture design history).
        This is not valid when working in a parametric model and will fail. 
        line : An InFiniteLine3D object 
        Returns true if the creation of the ConstructionAxisInput is successful.
        """
        return _fusion.ConstructionAxisInput_setByLine(self, *args)

    def setByCircularFace(self, *args) -> "bool" :
        """
        This input method is for creating an axis coincident with the axis of a 
        cylindrical, conical or torus face.
        This can result in a parametric or non-parametric construction axis depending 
        on whether the parent component is parametric or is a direct edit component. 
        circularFace : The face from a cylinder, cone, or torus. 
        Returns true if the creation of the ConstructionAxisInput is successful.
        """
        return _fusion.ConstructionAxisInput_setByCircularFace(self, *args)

    def setByPerpendicularAtPoint(self, *args) -> "bool" :
        """
        This input method is for creating an axis that is normal to a face
        at a specified point. 
        face : A face (BRepFace object) to create the axis normal to. 
        pointEntity : A construction point, sketch point or vertex the axis is to pass thru 
        Returns true if the creation of the ConstructionAxisInput is successful.
        """
        return _fusion.ConstructionAxisInput_setByPerpendicularAtPoint(self, *args)

    def setByTwoPlanes(self, *args) -> "bool" :
        """
        This input method is for creating a construction axis coincident with the 
        intersection of two planes or planar faces.
        This will fail if the the two planes are parallel.
        This can result in a parametric or non-parametric construction axis depending 
        on whether the parent component is parametric or is a direct edit component. 
        planarEntityOne : The first planar face or construction plane to intersect 
        planarEntityTwo : The second planar face or construction plane to intersect 
        Returns true if the creation of the ConstructionAxisInput is successful.
        """
        return _fusion.ConstructionAxisInput_setByTwoPlanes(self, *args)

    def setByTwoPoints(self, *args) -> "bool" :
        """
        This input method is for creating a construction axis that passes through the two points 
        (work points, sketch points or vertices).
        This will fail if the the two points are coincident.
        This can result in a parametric or non-parametric construction axis depending 
        on whether the parent component is parametric or is a direct edit component. 
        pointEntityOne : The first construction point, sketch point or vertex the axis passes through 
        pointEntityTwo : The second construction point, sketch point or vertex the axis passes through 
        Returns true if the creation of the ConstructionAxisInput is successful.
        """
        return _fusion.ConstructionAxisInput_setByTwoPoints(self, *args)

    def setByEdge(self, *args) -> "bool" :
        """
        This input method is for creating a construction axis from a specified linear/circular edge
        or sketch curve.
        This can result in a parametric or non-parametric construction axis depending 
        on whether the parent component is parametric or is a direct edit component. 
        edgeEntity : A linear/circular edge, construction line, or sketch line 
        Returns true if the creation of the ConstructionAxisInput is successful.
        """
        return _fusion.ConstructionAxisInput_setByEdge(self, *args)

    def setByNormalToFaceAtPoint(self, *args) -> "bool" :
        """
        This input method if for creating a construction axis normal to a specified face 
        or sketch profile and that passes through a specified point. 
        This can result in a parametric or non-parametric construction axis depending 
        on whether the parent component is parametric or is a direct edit component. 
        face : The face (BRepFace object) to create the axis normal to. 
        pointEntity : A construction point, sketch point or vertex the axis passes through.
        This point does not have to lie on the face. 
        Returns true if the creation of the ConstructionAxisInput is successful.
        """
        return _fusion.ConstructionAxisInput_setByNormalToFaceAtPoint(self, *args)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs 
        to be specified when the ConstructionAxis is created based on geometry
        (e.g. a straight edge) in another component AND (the ConstructionAxis) is not in the 
        root component. The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ConstructionAxisInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, *args) -> "bool" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs 
        to be specified when the ConstructionAxis is created based on geometry
        (e.g. a straight edge) in another component AND (the ConstructionAxis) is not in the 
        root component. The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ConstructionAxisInput__set_creationOccurrence(self, *args)

    def _get_targetBaseOrFormFeature(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        When creating a construction axis that is owned by a base or form feature, set this property to the 
        base or form feature you want to associate the new construction plane with. By default, this is null,
        meaning it will not be associated with a base or form feature.
        Because of a current limitation, if you want to create a construction axis associated with a base
        or form feature, you must set this property AND call the edit method of the base or form feature,
        create the feature, and then call the finishEdit method of the base or form feature. The base or form
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ConstructionAxisInput__get_targetBaseOrFormFeature(self)

    def _set_targetBaseOrFormFeature(self, *args) -> "bool" :
        """
        When creating a construction axis that is owned by a base or form feature, set this property to the 
        base or form feature you want to associate the new construction plane with. By default, this is null,
        meaning it will not be associated with a base or form feature.
        Because of a current limitation, if you want to create a construction axis associated with a base
        or form feature, you must set this property AND call the edit method of the base or form feature,
        create the feature, and then call the finishEdit method of the base or form feature. The base or form
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ConstructionAxisInput__set_targetBaseOrFormFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionAxisInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionAxisInput__get_isValid(self)
ConstructionAxisInput_swigregister = _fusion.ConstructionAxisInput_swigregister
ConstructionAxisInput_swigregister(ConstructionAxisInput)

def ConstructionAxisInput_classType() -> "char const *" :
  return _fusion.ConstructionAxisInput_classType()
ConstructionAxisInput_classType = _fusion.ConstructionAxisInput_classType

ConstructionAxisInput.__swig_getmethods__["creationOccurrence"] = ConstructionAxisInput._get_creationOccurrence
ConstructionAxisInput.__swig_setmethods__["creationOccurrence"] = ConstructionAxisInput._set_creationOccurrence
ConstructionAxisInput.creationOccurrence = property(ConstructionAxisInput._get_creationOccurrence, ConstructionAxisInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs\nto be specified when the ConstructionAxis is created based on geometry\n(e.g. a straight edge) in another component AND (the ConstructionAxis) is not in the\nroot component. The CreationOccurrence is analogous to the active occurrence in the UI")

ConstructionAxisInput.__swig_getmethods__["targetBaseOrFormFeature"] = ConstructionAxisInput._get_targetBaseOrFormFeature
ConstructionAxisInput.__swig_setmethods__["targetBaseOrFormFeature"] = ConstructionAxisInput._set_targetBaseOrFormFeature
ConstructionAxisInput.targetBaseOrFormFeature = property(ConstructionAxisInput._get_targetBaseOrFormFeature, ConstructionAxisInput._set_targetBaseOrFormFeature, doc="When creating a construction axis that is owned by a base or form feature, set this property to the\nbase or form feature you want to associate the new construction plane with. By default, this is null,\nmeaning it will not be associated with a base or form feature.\nBecause of a current limitation, if you want to create a construction axis associated with a base\nor form feature, you must set this property AND call the edit method of the base or form feature,\ncreate the feature, and then call the finishEdit method of the base or form feature. The base or form\nfeature must be in an 'edit' state to be able to add any additional items to it.")

ConstructionAxisInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionAxisInput) else None
ConstructionAxisInput.cast = lambda arg: arg if isinstance(arg, ConstructionAxisInput) else None

class ConstructionPlane(Base):
    """ConstructionPlane Object"""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPlane, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPlane, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPlane *" : return _fusion.ConstructionPlane___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPlane___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPlane___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPlane_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPlane_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPlane
    __del__ = lambda self : None;
    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Plane >" :
        """
        Returns a plane that represents the position and orientation of the construction plane.
        This geometry is defined in the AssemblyContext of this ConstructionPlane.
        """
        return _fusion.ConstructionPlane__get_geometry(self)

    def _get_name(self) -> "std::string" :
        """Returns the name of the construction plane as it is shown in the browser."""
        return _fusion.ConstructionPlane__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the construction plane as it is shown in the browser."""
        return _fusion.ConstructionPlane__set_name(self, *args)

    def _get_definition(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlaneDefinition >" :
        """
        Returns the ConstructionPlaneDefinition object which provides access to the information
        defining this ConstructionPlane.
        """
        return _fusion.ConstructionPlane__get_definition(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the construction plane. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ConstructionPlane_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """
        Indicates if this construction plane can be deleted. Base
        construction planes can not be deleted.
        """
        return _fusion.ConstructionPlane__get_isDeletable(self)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this construction plane is parametric or not."""
        return _fusion.ConstructionPlane__get_isParametric(self)

    def _get_isLightBulbOn(self) -> "bool" :
        """
        Indicates if the light bulb (as displayed in the browser) is on.
        A construction plane will only be visible if it's light bulb, and that of it's
        containing folder and parent component/s are also on.
        """
        return _fusion.ConstructionPlane__get_isLightBulbOn(self)

    def _set_isLightBulbOn(self, *args) -> "bool" :
        """
        Indicates if the light bulb (as displayed in the browser) is on.
        A construction plane will only be visible if it's light bulb, and that of it's
        containing folder and parent component/s are also on.
        """
        return _fusion.ConstructionPlane__set_isLightBulbOn(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        Indicates if the construction plane is visible.
        This property is affected by the AssemblyContext of the construction plane.
        """
        return _fusion.ConstructionPlane__get_isVisible(self)

    def _get_displayBounds(self) -> "adsk::core::Ptr< adsk::core::BoundingBox2D >" :
        """
        Gets and sets the display size of the construction plane. The bounding
        box defines the min and max corners of the plane as defined in the 
        2D space of the construction plane.
        """
        return _fusion.ConstructionPlane__get_displayBounds(self)

    def _set_displayBounds(self, *args) -> "bool" :
        """
        Gets and sets the display size of the construction plane. The bounding
        box defines the min and max corners of the plane as defined in the 
        2D space of the construction plane.
        """
        return _fusion.ConstructionPlane__set_displayBounds(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the parent component or base feature. If both the design and the construction 
        plane are parametric, the parent will be a component. If the design is parametric and 
        the construction plane is not, the parent will be a base feature. If
        the design is not parametric the parent will be a component.
        """
        return _fusion.ConstructionPlane__get_parent(self)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the component this construction plane belongs to."""
        return _fusion.ConstructionPlane__get_component(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this construction plane."""
        return _fusion.ConstructionPlane__get_timelineObject(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ConstructionPlane__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        """
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ConstructionPlane__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ConstructionPlane_createForAssemblyContext(self, *args)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this construction plane is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ConstructionPlane__get_baseFeature(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this construction plane."""
        return _fusion.ConstructionPlane__get_attributes(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of this construction plane."""
        return _fusion.ConstructionPlane__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ConstructionPlane__get_errorOrWarningMessage(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >" :
        """
        Returns the current position and orientation of the construction plane as a matrix.
        For a parametric construction plane, this property is read-only. For a construction
        plane in a direct modeling model or in a base feature, this is read-write and can be
        used to reposition the constructions plane.
        """
        return _fusion.ConstructionPlane__get_transform(self)

    def _set_transform(self, *args) -> "bool" :
        """
        Returns the current position and orientation of the construction plane as a matrix.
        For a parametric construction plane, this property is read-only. For a construction
        plane in a direct modeling model or in a base feature, this is read-write and can be
        used to reposition the constructions plane.
        """
        return _fusion.ConstructionPlane__set_transform(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPlane__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPlane__get_isValid(self)
ConstructionPlane_swigregister = _fusion.ConstructionPlane_swigregister
ConstructionPlane_swigregister(ConstructionPlane)

def ConstructionPlane_classType() -> "char const *" :
  return _fusion.ConstructionPlane_classType()
ConstructionPlane_classType = _fusion.ConstructionPlane_classType

ConstructionPlane.__swig_getmethods__["geometry"] = ConstructionPlane._get_geometry
ConstructionPlane.geometry = property(ConstructionPlane._get_geometry, doc="Returns a plane that represents the position and orientation of the construction plane.\nThis geometry is defined in the AssemblyContext of this ConstructionPlane.")

ConstructionPlane.__swig_getmethods__["name"] = ConstructionPlane._get_name
ConstructionPlane.__swig_setmethods__["name"] = ConstructionPlane._set_name
ConstructionPlane.name = property(ConstructionPlane._get_name, ConstructionPlane._set_name, doc="Returns the name of the construction plane as it is shown in the browser.")

ConstructionPlane.__swig_getmethods__["definition"] = ConstructionPlane._get_definition
ConstructionPlane.definition = property(ConstructionPlane._get_definition, doc="Returns the ConstructionPlaneDefinition object which provides access to the information\ndefining this ConstructionPlane.")

ConstructionPlane.__swig_getmethods__["isDeletable"] = ConstructionPlane._get_isDeletable
ConstructionPlane.isDeletable = property(ConstructionPlane._get_isDeletable, doc="Indicates if this construction plane can be deleted. Base\nconstruction planes can not be deleted.")

ConstructionPlane.__swig_getmethods__["isParametric"] = ConstructionPlane._get_isParametric
ConstructionPlane.isParametric = property(ConstructionPlane._get_isParametric, doc="Indicates if this construction plane is parametric or not.")

ConstructionPlane.__swig_getmethods__["isLightBulbOn"] = ConstructionPlane._get_isLightBulbOn
ConstructionPlane.__swig_setmethods__["isLightBulbOn"] = ConstructionPlane._set_isLightBulbOn
ConstructionPlane.isLightBulbOn = property(ConstructionPlane._get_isLightBulbOn, ConstructionPlane._set_isLightBulbOn, doc="Indicates if the light bulb (as displayed in the browser) is on.\nA construction plane will only be visible if it's light bulb, and that of it's\ncontaining folder and parent component/s are also on.")

ConstructionPlane.__swig_getmethods__["isVisible"] = ConstructionPlane._get_isVisible
ConstructionPlane.isVisible = property(ConstructionPlane._get_isVisible, doc="Indicates if the construction plane is visible.\nThis property is affected by the AssemblyContext of the construction plane.")

ConstructionPlane.__swig_getmethods__["displayBounds"] = ConstructionPlane._get_displayBounds
ConstructionPlane.__swig_setmethods__["displayBounds"] = ConstructionPlane._set_displayBounds
ConstructionPlane.displayBounds = property(ConstructionPlane._get_displayBounds, ConstructionPlane._set_displayBounds, doc="Gets and sets the display size of the construction plane. The bounding\nbox defines the min and max corners of the plane as defined in the\n2D space of the construction plane.")

ConstructionPlane.__swig_getmethods__["parent"] = ConstructionPlane._get_parent
ConstructionPlane.parent = property(ConstructionPlane._get_parent, doc="Returns the parent component or base feature. If both the design and the construction\nplane are parametric, the parent will be a component. If the design is parametric and\nthe construction plane is not, the parent will be a base feature. If\nthe design is not parametric the parent will be a component.")

ConstructionPlane.__swig_getmethods__["component"] = ConstructionPlane._get_component
ConstructionPlane.component = property(ConstructionPlane._get_component, doc="Returns the component this construction plane belongs to.")

ConstructionPlane.__swig_getmethods__["timelineObject"] = ConstructionPlane._get_timelineObject
ConstructionPlane.timelineObject = property(ConstructionPlane._get_timelineObject, doc="Returns the timeline object associated with this construction plane.")

ConstructionPlane.__swig_getmethods__["assemblyContext"] = ConstructionPlane._get_assemblyContext
ConstructionPlane.assemblyContext = property(ConstructionPlane._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")

ConstructionPlane.__swig_getmethods__["nativeObject"] = ConstructionPlane._get_nativeObject
ConstructionPlane.nativeObject = property(ConstructionPlane._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

ConstructionPlane.__swig_getmethods__["baseFeature"] = ConstructionPlane._get_baseFeature
ConstructionPlane.baseFeature = property(ConstructionPlane._get_baseFeature, doc="If this construction plane is associated with a base feature, this property will return that base feature.\nIf it's not associated with a base feature, this property will return null.")

ConstructionPlane.__swig_getmethods__["attributes"] = ConstructionPlane._get_attributes
ConstructionPlane.attributes = property(ConstructionPlane._get_attributes, doc="Returns the collection of attributes associated with this construction plane.")

ConstructionPlane.__swig_getmethods__["healthState"] = ConstructionPlane._get_healthState
ConstructionPlane.healthState = property(ConstructionPlane._get_healthState, doc="Returns the current health state of this construction plane.")

ConstructionPlane.__swig_getmethods__["errorOrWarningMessage"] = ConstructionPlane._get_errorOrWarningMessage
ConstructionPlane.errorOrWarningMessage = property(ConstructionPlane._get_errorOrWarningMessage, doc="Returns the error or warning message in the case where the healthState property returns either\nWarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.")

ConstructionPlane.__swig_getmethods__["transform"] = ConstructionPlane._get_transform
ConstructionPlane.__swig_setmethods__["transform"] = ConstructionPlane._set_transform
ConstructionPlane.transform = property(ConstructionPlane._get_transform, ConstructionPlane._set_transform, doc="Returns the current position and orientation of the construction plane as a matrix.\nFor a parametric construction plane, this property is read-only. For a construction\nplane in a direct modeling model or in a base feature, this is read-write and can be\nused to reposition the constructions plane.")

ConstructionPlane.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPlane) else None
ConstructionPlane.cast = lambda arg: arg if isinstance(arg, ConstructionPlane) else None

class ConstructionPlaneDefinition(Base):
    """A Base class to return the information, possibly parametric, used to define the ConstructionPlane."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPlaneDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPlaneDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPlaneDefinition *" : return _fusion.ConstructionPlaneDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPlaneDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPlaneDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPlaneDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPlaneDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPlaneDefinition
    __del__ = lambda self : None;
    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        """Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPlaneDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPlaneDefinition__get_isValid(self)
ConstructionPlaneDefinition_swigregister = _fusion.ConstructionPlaneDefinition_swigregister
ConstructionPlaneDefinition_swigregister(ConstructionPlaneDefinition)

def ConstructionPlaneDefinition_classType() -> "char const *" :
  return _fusion.ConstructionPlaneDefinition_classType()
ConstructionPlaneDefinition_classType = _fusion.ConstructionPlaneDefinition_classType

ConstructionPlaneDefinition.__swig_getmethods__["parentConstructionPlane"] = ConstructionPlaneDefinition._get_parentConstructionPlane
ConstructionPlaneDefinition.parentConstructionPlane = property(ConstructionPlaneDefinition._get_parentConstructionPlane, doc="Returns the ConstructionPlane object")

ConstructionPlaneDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPlaneDefinition) else None
ConstructionPlaneDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneDefinition) else None

class ConstructionPlaneInput(Base):
    """
    A ConstructionPlaneInput is a throwaway object used to create a ConstructionPlane
    The usage pattern is:
    a. create a ConstructionPlaneInput (ConstructionPlanes.CreateInput)
    b. call one of the member functions to specify how the ConstructionPlane is created
    c. create the ConstructionPlane (call ConstructionPlanes.Add)
    d. stop referencing the ConstructionPlaneInput (so it gets deleted).
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPlaneInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPlaneInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPlaneInput *" : return _fusion.ConstructionPlaneInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPlaneInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPlaneInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPlaneInput_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPlaneInput_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPlaneInput
    __del__ = lambda self : None;
    def setByPlane(self, *args) -> "bool" :
        """
        This input method is for creating a non-parametric construction plane positioned in 
        space as defined by the input Plane object.
        This method of defining a construction plane is only valid when working in a direct edit model (do not capture design history).
        This is not valid when working in a parametric model and will fail. 
        plane : A transient plane object 
        Returns true if the creation of the ConstructionPlaneInput is successful.
        """
        return _fusion.ConstructionPlaneInput_setByPlane(self, *args)

    def setByOffset(self, *args) -> "bool" :
        """
        This input method is for creating a construction plane that is offset from a planar 
        face or construction plane at a specified distance. This can result in 
        a parametric or non-parametric construction plane depending on whether the parent 
        component is parametric or is a direct edit component. 
        planarEntity : A plane, planar face or construction plane from which to create the offset plane 
        offset : ValueInput object that specifies the offset distance for the plane 
        Returns true if the creation of the ConstructionPlaneInput is successful.
        """
        return _fusion.ConstructionPlaneInput_setByOffset(self, *args)

    def setByAngle(self, *args) -> "bool" :
        """
        This input method is for creating a construction plane through an edge, axis or line
        at a specified angle. This can result in a parametric or non-parametric construction
        plane depending on whether the parent component is parametric or is a direct edit 
        component. 
        linearEntity : The axis about which to rotate the plane 
        angle : The angle at which to create the plane 
        planarEntity : The planar face or construction plane the angle is measured from. 
        Returns true if the creation of the ConstructionPlaneInput is successful
        """
        return _fusion.ConstructionPlaneInput_setByAngle(self, *args)

    def setByTangent(self, *args) -> "bool" :
        """
        This input method is for creating a construction plane tangent to a cylindrical or 
        conical face at a specified point. This can result in a parametric or non-parametric construction
        plane depending on whether the parent component is parametric or is a direct edit 
        component. 
        tangentFace : A cylindrical or conical face to create the plane tangent to 
        angle : The angle relative to the planarEntity input at which to create the tangent plane 
        planarEntity : The planar face or construction plane the tangent is measured from. 
        Returns true if the creation of the ConstructionPlaneInput is successful
        """
        return _fusion.ConstructionPlaneInput_setByTangent(self, *args)

    def setByTwoPlanes(self, *args) -> "bool" :
        """
        This input method is for creating a construction plane at the midpoint between
        two planar faces or construction planes. This can result in a parametric or 
        non-parametric construction plane depending on whether the parent component is 
        parametric or is a direct edit component. 
        planarEntityOne : The first planar face or construction plane to create a bisecting plane between 
        planarEntityTwo : The second planar face or construction plane to create a bisecting plane between 
        Returns true if the creation of the ConstructionPlaneInput is successful.
        This will fail if the two planes are co-planar.
        """
        return _fusion.ConstructionPlaneInput_setByTwoPlanes(self, *args)

    def setByTwoEdges(self, *args) -> "bool" :
        """
        This input method is for creating a construction plane that passes through two
        coplanar linear entities or axes.
        Defines a plane by specifying two coplanar linear entities. This can result in a 
        parametric or non-parametric construction plane depending on whether the parent 
        component is parametric or is a direct edit component. 
        linearEntityOne : The first of two coplanar linear entities to define the plane 
        linearEntityTwo : The second of two coplanar linear entities to define the plane 
        Returns true if the creation of the ConstructionPlaneInput is successful.
        This will fail if the two linear entities are not coplanar.
        """
        return _fusion.ConstructionPlaneInput_setByTwoEdges(self, *args)

    def setByThreePoints(self, *args) -> "bool" :
        """
        This input method is for creating a construction plane through three points that
        define a triangle. This can result in a parametric or non-parametric construction 
        plane depending on whether the parent component is parametric or is a direct edit 
        component. 
        pointEntityOne : The first construction point, sketch point or vertex in the triangle 
        pointEntityTwo : The second construction point, sketch point or vertex in the triangle 
        pointEntityThree : The third construction point, sketch point or vertex in the triangle 
        Returns true if the creation of the ConstructionPlaneInput is successful.
        This will fail if the points do not form a triangle (no two
        points can be coincident and all three cannot be colinear).
        """
        return _fusion.ConstructionPlaneInput_setByThreePoints(self, *args)

    def setByTangentAtPoint(self, *args) -> "bool" :
        """
        This input method is for creating a construction plane tangent to a face 
        and aligned to a point. This can result in a parametric or non-parametric 
        construction plane depending on whether the parent component is parametric or is a 
        direct edit component. 
        tangentFace : A face to create the plane tangent to 
        pointEntity : A construction point, sketch point or vertex the tangent plane aligns to. 
        This point need not lie on the tangent face. 
        Returns true if the creation of the ConstructionPlaneInput is successful.
        """
        return _fusion.ConstructionPlaneInput_setByTangentAtPoint(self, *args)

    def setByDistanceOnPath(self, *args) -> "bool" :
        """
        This input method is for creating a construction plane normal to, and at 
        specified distance along, a path defined by an edge or sketch profile.
        This can result in a parametric or non-parametric 
        construction plane depending on whether the parent component is parametric or is a 
        direct edit component. 
        pathEntity : The path can be an edge, sketch curve, or a path of multiple entities. 
        distance : The distance is a value from 0 to 1 indicating the position along the path where 0
        is at the start and 1 is at the end. 
        Returns true if the creation of the ConstructionPlaneInput is successful.
        """
        return _fusion.ConstructionPlaneInput_setByDistanceOnPath(self, *args)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the ConstructionPlane is created based on geometry (e.g. a planarEntity)
        in another component AND (the ConstructionPlane) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ConstructionPlaneInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, *args) -> "bool" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the ConstructionPlane is created based on geometry (e.g. a planarEntity)
        in another component AND (the ConstructionPlane) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ConstructionPlaneInput__set_creationOccurrence(self, *args)

    def _get_targetBaseOrFormFeature(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        When creating a construction plane that is owned by a base or form feature, set this property to the 
        base or form feature you want to associate the new construction plane with. By default, this is null,
        meaning it will not be associated with a base or form feature.
        Because of a current limitation, if you want to create a construction plane associated with a base
        or form feature, you must set this property AND call the edit method of the base or form feature,
        create the feature, and then call the finishEdit method of the base or form feature. The base or form
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ConstructionPlaneInput__get_targetBaseOrFormFeature(self)

    def _set_targetBaseOrFormFeature(self, *args) -> "bool" :
        """
        When creating a construction plane that is owned by a base or form feature, set this property to the 
        base or form feature you want to associate the new construction plane with. By default, this is null,
        meaning it will not be associated with a base or form feature.
        Because of a current limitation, if you want to create a construction plane associated with a base
        or form feature, you must set this property AND call the edit method of the base or form feature,
        create the feature, and then call the finishEdit method of the base or form feature. The base or form
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ConstructionPlaneInput__set_targetBaseOrFormFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPlaneInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPlaneInput__get_isValid(self)
ConstructionPlaneInput_swigregister = _fusion.ConstructionPlaneInput_swigregister
ConstructionPlaneInput_swigregister(ConstructionPlaneInput)

def ConstructionPlaneInput_classType() -> "char const *" :
  return _fusion.ConstructionPlaneInput_classType()
ConstructionPlaneInput_classType = _fusion.ConstructionPlaneInput_classType

ConstructionPlaneInput.__swig_getmethods__["creationOccurrence"] = ConstructionPlaneInput._get_creationOccurrence
ConstructionPlaneInput.__swig_setmethods__["creationOccurrence"] = ConstructionPlaneInput._set_creationOccurrence
ConstructionPlaneInput.creationOccurrence = property(ConstructionPlaneInput._get_creationOccurrence, ConstructionPlaneInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the ConstructionPlane is created based on geometry (e.g. a planarEntity)\nin another component AND (the ConstructionPlane) is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI")

ConstructionPlaneInput.__swig_getmethods__["targetBaseOrFormFeature"] = ConstructionPlaneInput._get_targetBaseOrFormFeature
ConstructionPlaneInput.__swig_setmethods__["targetBaseOrFormFeature"] = ConstructionPlaneInput._set_targetBaseOrFormFeature
ConstructionPlaneInput.targetBaseOrFormFeature = property(ConstructionPlaneInput._get_targetBaseOrFormFeature, ConstructionPlaneInput._set_targetBaseOrFormFeature, doc="When creating a construction plane that is owned by a base or form feature, set this property to the\nbase or form feature you want to associate the new construction plane with. By default, this is null,\nmeaning it will not be associated with a base or form feature.\nBecause of a current limitation, if you want to create a construction plane associated with a base\nor form feature, you must set this property AND call the edit method of the base or form feature,\ncreate the feature, and then call the finishEdit method of the base or form feature. The base or form\nfeature must be in an 'edit' state to be able to add any additional items to it.")

ConstructionPlaneInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPlaneInput) else None
ConstructionPlaneInput.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneInput) else None

class ConstructionPlanes(Base):
    """
    Provides access to the construction planes within a component and provides 
    methods to create new construction planes.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPlanes, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPlanes, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPlanes *" : return _fusion.ConstructionPlanes___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPlanes___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPlanes___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.ConstructionPlanes___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.ConstructionPlanes___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPlanes_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPlanes_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPlanes
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        """
        Function that returns the specified construction plane using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ConstructionPlanes_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        """
        Returns the specified construction plane using the name of the construction
        plane as it is displayed in the browser. 
        name : The name of the construction plane as it is displayed in the browser 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.ConstructionPlanes_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of construction planes in the collection."""
        return _fusion.ConstructionPlanes__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlaneInput >" :
        """
        Create a ConstructionPlaneInput object that is in turn used to create a ConstructionPlane. 
        occurrenceForCreation : A creation occurrence is needed if the input is in another component AND the 
        construction plane is not in the root component. The occurrenceForCreation is analogous 
        to the active occurrence in the UI. 
        Returns a ConstructionPlaneInput object
        """
        return _fusion.ConstructionPlanes_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        """
        Creates and adds a new ConstructionPlane using the creation parameters in
        the ConstructionPlaneInput. 
        If the ConstructionPlaneInput was defined using the setByPlane method then
        the add will only work in a direct edit model (do not capture design history) and will fail in a parametric model. 
        input : A ConstructionPlaneInput object 
        Returns the newly created construction plane or null if the creation failed.
        """
        return _fusion.ConstructionPlanes_add(self, *args)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the component that owns this collection."""
        return _fusion.ConstructionPlanes__get_component(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPlanes__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPlanes__get_isValid(self)
ConstructionPlanes_swigregister = _fusion.ConstructionPlanes_swigregister
ConstructionPlanes_swigregister(ConstructionPlanes)

def ConstructionPlanes_classType() -> "char const *" :
  return _fusion.ConstructionPlanes_classType()
ConstructionPlanes_classType = _fusion.ConstructionPlanes_classType

ConstructionPlanes.__swig_getmethods__["count"] = ConstructionPlanes._get_count
ConstructionPlanes.count = property(ConstructionPlanes._get_count, doc="Returns the number of construction planes in the collection.")

ConstructionPlanes.__swig_getmethods__["component"] = ConstructionPlanes._get_component
ConstructionPlanes.component = property(ConstructionPlanes._get_component, doc="Returns the component that owns this collection.")

ConstructionPlanes.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPlanes) else None
ConstructionPlanes.cast = lambda arg: arg if isinstance(arg, ConstructionPlanes) else None

class ConstructionPoint(Base):
    """ConstructionPoint Object"""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPoint, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPoint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPoint *" : return _fusion.ConstructionPoint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPoint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPoint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPoint_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPoint_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPoint
    __del__ = lambda self : None;
    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        Returns a Point3D object that represents the position of the construction point.
        The returned geometry is in the AssemblyContext of this ConstructionPoint.
        """
        return _fusion.ConstructionPoint__get_geometry(self)

    def _get_name(self) -> "std::string" :
        """The name of the construction point as it is displayed in the browser."""
        return _fusion.ConstructionPoint__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """The name of the construction point as it is displayed in the browser."""
        return _fusion.ConstructionPoint__set_name(self, *args)

    def _get_definition(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPointDefinition >" :
        """
        Returns the construction point definition object which provides access to the 
        information defining the construction point.
        """
        return _fusion.ConstructionPoint__get_definition(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the construction point. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ConstructionPoint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """
        Indicates if this construction point can be deleted. The base
        construction point cannot be deleted.
        """
        return _fusion.ConstructionPoint__get_isDeletable(self)

    def _get_isLightBulbOn(self) -> "bool" :
        """
        Indicates if the light bulb (as displayed in the browser) is on.
        A construction point will only be visible if it's light bulb, and that of it's
        containing folder and parent component/s are also on.
        """
        return _fusion.ConstructionPoint__get_isLightBulbOn(self)

    def _set_isLightBulbOn(self, *args) -> "bool" :
        """
        Indicates if the light bulb (as displayed in the browser) is on.
        A construction point will only be visible if it's light bulb, and that of it's
        containing folder and parent component/s are also on.
        """
        return _fusion.ConstructionPoint__set_isLightBulbOn(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        Gets if the construction point is visible.
        This property is affected by the AssemblyContext of the construction point.
        """
        return _fusion.ConstructionPoint__get_isVisible(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the parent component or base feature. If both the design and the construction 
        point are parametric, the parent will be a component. If the design is parametric and 
        the construction point is not, the parent will be a base feature. If
        the design is not parametric the parent will be a component.
        """
        return _fusion.ConstructionPoint__get_parent(self)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the component this construction point belongs to."""
        return _fusion.ConstructionPoint__get_component(self)

    def _get_isParametric(self) -> "bool" :
        """Indicates if the construction point is parametric."""
        return _fusion.ConstructionPoint__get_isParametric(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this construction point."""
        return _fusion.ConstructionPoint__get_timelineObject(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ConstructionPoint__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >" :
        """
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ConstructionPoint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ConstructionPoint_createForAssemblyContext(self, *args)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this construction point is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ConstructionPoint__get_baseFeature(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this construction point."""
        return _fusion.ConstructionPoint__get_attributes(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of this construction point."""
        return _fusion.ConstructionPoint__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ConstructionPoint__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPoint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPoint__get_isValid(self)
ConstructionPoint_swigregister = _fusion.ConstructionPoint_swigregister
ConstructionPoint_swigregister(ConstructionPoint)

def ConstructionPoint_classType() -> "char const *" :
  return _fusion.ConstructionPoint_classType()
ConstructionPoint_classType = _fusion.ConstructionPoint_classType

ConstructionPoint.__swig_getmethods__["geometry"] = ConstructionPoint._get_geometry
ConstructionPoint.geometry = property(ConstructionPoint._get_geometry, doc="Returns a Point3D object that represents the position of the construction point.\nThe returned geometry is in the AssemblyContext of this ConstructionPoint.")

ConstructionPoint.__swig_getmethods__["name"] = ConstructionPoint._get_name
ConstructionPoint.__swig_setmethods__["name"] = ConstructionPoint._set_name
ConstructionPoint.name = property(ConstructionPoint._get_name, ConstructionPoint._set_name, doc="The name of the construction point as it is displayed in the browser.")

ConstructionPoint.__swig_getmethods__["definition"] = ConstructionPoint._get_definition
ConstructionPoint.definition = property(ConstructionPoint._get_definition, doc="Returns the construction point definition object which provides access to the\ninformation defining the construction point.")

ConstructionPoint.__swig_getmethods__["isDeletable"] = ConstructionPoint._get_isDeletable
ConstructionPoint.isDeletable = property(ConstructionPoint._get_isDeletable, doc="Indicates if this construction point can be deleted. The base\nconstruction point cannot be deleted.")

ConstructionPoint.__swig_getmethods__["isLightBulbOn"] = ConstructionPoint._get_isLightBulbOn
ConstructionPoint.__swig_setmethods__["isLightBulbOn"] = ConstructionPoint._set_isLightBulbOn
ConstructionPoint.isLightBulbOn = property(ConstructionPoint._get_isLightBulbOn, ConstructionPoint._set_isLightBulbOn, doc="Indicates if the light bulb (as displayed in the browser) is on.\nA construction point will only be visible if it's light bulb, and that of it's\ncontaining folder and parent component/s are also on.")

ConstructionPoint.__swig_getmethods__["isVisible"] = ConstructionPoint._get_isVisible
ConstructionPoint.isVisible = property(ConstructionPoint._get_isVisible, doc="Gets if the construction point is visible.\nThis property is affected by the AssemblyContext of the construction point.")

ConstructionPoint.__swig_getmethods__["parent"] = ConstructionPoint._get_parent
ConstructionPoint.parent = property(ConstructionPoint._get_parent, doc="Returns the parent component or base feature. If both the design and the construction\npoint are parametric, the parent will be a component. If the design is parametric and\nthe construction point is not, the parent will be a base feature. If\nthe design is not parametric the parent will be a component.")

ConstructionPoint.__swig_getmethods__["component"] = ConstructionPoint._get_component
ConstructionPoint.component = property(ConstructionPoint._get_component, doc="Returns the component this construction point belongs to.")

ConstructionPoint.__swig_getmethods__["isParametric"] = ConstructionPoint._get_isParametric
ConstructionPoint.isParametric = property(ConstructionPoint._get_isParametric, doc="Indicates if the construction point is parametric.")

ConstructionPoint.__swig_getmethods__["timelineObject"] = ConstructionPoint._get_timelineObject
ConstructionPoint.timelineObject = property(ConstructionPoint._get_timelineObject, doc="Returns the timeline object associated with this construction point.")

ConstructionPoint.__swig_getmethods__["assemblyContext"] = ConstructionPoint._get_assemblyContext
ConstructionPoint.assemblyContext = property(ConstructionPoint._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")

ConstructionPoint.__swig_getmethods__["nativeObject"] = ConstructionPoint._get_nativeObject
ConstructionPoint.nativeObject = property(ConstructionPoint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

ConstructionPoint.__swig_getmethods__["baseFeature"] = ConstructionPoint._get_baseFeature
ConstructionPoint.baseFeature = property(ConstructionPoint._get_baseFeature, doc="If this construction point is associated with a base feature, this property will return that base feature.\nIf it's not associated with a base feature, this property will return null.")

ConstructionPoint.__swig_getmethods__["attributes"] = ConstructionPoint._get_attributes
ConstructionPoint.attributes = property(ConstructionPoint._get_attributes, doc="Returns the collection of attributes associated with this construction point.")

ConstructionPoint.__swig_getmethods__["healthState"] = ConstructionPoint._get_healthState
ConstructionPoint.healthState = property(ConstructionPoint._get_healthState, doc="Returns the current health state of this construction point.")

ConstructionPoint.__swig_getmethods__["errorOrWarningMessage"] = ConstructionPoint._get_errorOrWarningMessage
ConstructionPoint.errorOrWarningMessage = property(ConstructionPoint._get_errorOrWarningMessage, doc="Returns the error or warning message in the case where the healthState property returns either\nWarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.")

ConstructionPoint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPoint) else None
ConstructionPoint.cast = lambda arg: arg if isinstance(arg, ConstructionPoint) else None

class ConstructionPointDefinition(Base):
    """
    A Base class to return the information (possibly parametric) used to 
    define a ConstructionPoint.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPointDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPointDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPointDefinition *" : return _fusion.ConstructionPointDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPointDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPointDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPointDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPointDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPointDefinition
    __del__ = lambda self : None;
    def _get_parentConstructionPoint(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >" :
        """Returns the ConstructionPoint object"""
        return _fusion.ConstructionPointDefinition__get_parentConstructionPoint(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPointDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPointDefinition__get_isValid(self)
ConstructionPointDefinition_swigregister = _fusion.ConstructionPointDefinition_swigregister
ConstructionPointDefinition_swigregister(ConstructionPointDefinition)

def ConstructionPointDefinition_classType() -> "char const *" :
  return _fusion.ConstructionPointDefinition_classType()
ConstructionPointDefinition_classType = _fusion.ConstructionPointDefinition_classType

ConstructionPointDefinition.__swig_getmethods__["parentConstructionPoint"] = ConstructionPointDefinition._get_parentConstructionPoint
ConstructionPointDefinition.parentConstructionPoint = property(ConstructionPointDefinition._get_parentConstructionPoint, doc="Returns the ConstructionPoint object")

ConstructionPointDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPointDefinition) else None
ConstructionPointDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPointDefinition) else None

class ConstructionPointInput(Base):
    """
    A ConstructionPointInput is a throwaway object used to create a ConstructionPoint
    The usage pattern is 
    a. create a ConstructionPointInput (ConstructionPoints.CreateInput)
    b. call one of the member functions to specify how the ConstructionPoint is created
    c. create the ConstructionPoint (call ConstructionPoints.Add)
    d. stop referencing the ConstructionPointInput (so it gets deleted).
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPointInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPointInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPointInput *" : return _fusion.ConstructionPointInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPointInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPointInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPointInput_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPointInput_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPointInput
    __del__ = lambda self : None;
    def setByTwoEdges(self, *args) -> "bool" :
        """
        This input method is for creating a construction point at the intersection of 
        the two linear edges or sketch lines.
        The edges can be B-Rep edges or sketch lines.
        This can result in a parametric or non-parametric construction point depending 
        on whether the parent component is parametric or is a direct edit component. 
        edgeOne : The first B-Rep edge or sketch line 
        edgeTwo : The second B-Rep edge or sketch line 
        Returns true if the creation of the ConstructionPointInput is successful.
        """
        return _fusion.ConstructionPointInput_setByTwoEdges(self, *args)

    def setByThreePlanes(self, *args) -> "bool" :
        """
        This input method is for creating a construction point at the intersection of the 
        three planes or planar faces.
        This can result in a parametric or non-parametric construction point depending 
        on whether the parent component is parametric or is a direct edit component. 
        planeOne : The first plane or planar face to intersect 
        planeTwo : The second plane or planar face to intersect 
        planeThree : The third plane or planar face to intersect 
        Returns true if the creation of the ConstructionPointInput is successful.
        """
        return _fusion.ConstructionPointInput_setByThreePlanes(self, *args)

    def setByEdgePlane(self, *args) -> "bool" :
        """
        This input method is for creating a construction point at the intersection of a 
        construction plane, planar face or sketch profile and a linear edge, construction axis
        or sketch line. 
        This can result in a parametric or non-parametric construction point depending 
        on whether the parent component is parametric or is a direct edit component. 
        edge : A linear B-Rep edge, construction axis or sketch line. 
        plane : A plane, planar B-Rep face or construction plane. 
        Returns true if the creation of the ConstructionPointInput is successful.
        """
        return _fusion.ConstructionPointInput_setByEdgePlane(self, *args)

    def setByCenter(self, *args) -> "bool" :
        """
        This input method is for creating a construction point at the center of a spherical
        face (sphere or torus), circular edge or sketch arc/circle
        This can result in a parametric or non-parametric construction point depending 
        on whether the parent component is parametric or is a direct edit component. 
        circularEntity : A spherical face (sphere or torus), circular edge or sketch arc/circle 
        Returns true if the creation of the ConstructionPointInput is successful.
        """
        return _fusion.ConstructionPointInput_setByCenter(self, *args)

    def setByPoint(self, *args) -> "bool" :
        """
        This input method is for creating a construction point on the specified point
        or vertex. The point can be either a B-Rep vertex, SketchPoint, or a Point3D object. 
        Providing a Point3D object is only valid when working in a direct edit model (do not capture design history).
        This is not valid when working in a parametric model and will fail.
        Even when providing a B-Rep vertex, or SketchPoint the result will be non-parametric 
        if the parent component is a direct edit component. 
        point : A B-Rep vertex, SketchPoint, or Point object 
        Returns true if the creation of the ConstructionPointInput is successful.
        """
        return _fusion.ConstructionPointInput_setByPoint(self, *args)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        In order for geometry to be transformed correctly, an occurrence for creation needs 
        to be specified when the ConstructionPoint is created based on geometry
        (e.g. a sketch point) in another component AND (the ConstructionPoint) is not in the 
        root component. The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ConstructionPointInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, *args) -> "bool" :
        """
        In order for geometry to be transformed correctly, an occurrence for creation needs 
        to be specified when the ConstructionPoint is created based on geometry
        (e.g. a sketch point) in another component AND (the ConstructionPoint) is not in the 
        root component. The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ConstructionPointInput__set_creationOccurrence(self, *args)

    def _get_targetBaseOrFormFeature(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        When creating a construction point that is owned by a base or form feature, set this property to the 
        base or form feature you want to associate the new construction point with. By default, this is null,
        meaning it will not be associated with a base or form feature.
        Because of a current limitation, if you want to create a construction point associated with a base
        or form feature, you must set this property AND call the edit method of the base or form feature,
        create the feature, and then call the finishEdit method of the base or form feature. The base or form
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ConstructionPointInput__get_targetBaseOrFormFeature(self)

    def _set_targetBaseOrFormFeature(self, *args) -> "bool" :
        """
        When creating a construction point that is owned by a base or form feature, set this property to the 
        base or form feature you want to associate the new construction point with. By default, this is null,
        meaning it will not be associated with a base or form feature.
        Because of a current limitation, if you want to create a construction point associated with a base
        or form feature, you must set this property AND call the edit method of the base or form feature,
        create the feature, and then call the finishEdit method of the base or form feature. The base or form
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ConstructionPointInput__set_targetBaseOrFormFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPointInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPointInput__get_isValid(self)
ConstructionPointInput_swigregister = _fusion.ConstructionPointInput_swigregister
ConstructionPointInput_swigregister(ConstructionPointInput)

def ConstructionPointInput_classType() -> "char const *" :
  return _fusion.ConstructionPointInput_classType()
ConstructionPointInput_classType = _fusion.ConstructionPointInput_classType

ConstructionPointInput.__swig_getmethods__["creationOccurrence"] = ConstructionPointInput._get_creationOccurrence
ConstructionPointInput.__swig_setmethods__["creationOccurrence"] = ConstructionPointInput._set_creationOccurrence
ConstructionPointInput.creationOccurrence = property(ConstructionPointInput._get_creationOccurrence, ConstructionPointInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an occurrence for creation needs\nto be specified when the ConstructionPoint is created based on geometry\n(e.g. a sketch point) in another component AND (the ConstructionPoint) is not in the\nroot component. The CreationOccurrence is analogous to the active occurrence in the UI")

ConstructionPointInput.__swig_getmethods__["targetBaseOrFormFeature"] = ConstructionPointInput._get_targetBaseOrFormFeature
ConstructionPointInput.__swig_setmethods__["targetBaseOrFormFeature"] = ConstructionPointInput._set_targetBaseOrFormFeature
ConstructionPointInput.targetBaseOrFormFeature = property(ConstructionPointInput._get_targetBaseOrFormFeature, ConstructionPointInput._set_targetBaseOrFormFeature, doc="When creating a construction point that is owned by a base or form feature, set this property to the\nbase or form feature you want to associate the new construction point with. By default, this is null,\nmeaning it will not be associated with a base or form feature.\nBecause of a current limitation, if you want to create a construction point associated with a base\nor form feature, you must set this property AND call the edit method of the base or form feature,\ncreate the feature, and then call the finishEdit method of the base or form feature. The base or form\nfeature must be in an 'edit' state to be able to add any additional items to it.")

ConstructionPointInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPointInput) else None
ConstructionPointInput.cast = lambda arg: arg if isinstance(arg, ConstructionPointInput) else None

class ConstructionPoints(Base):
    """
    Provides access to the construction points within a component and provides 
    methods to create new construction points.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPoints, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPoints, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPoints *" : return _fusion.ConstructionPoints___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPoints___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPoints___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.ConstructionPoints___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.ConstructionPoints___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPoints_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPoints_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPoints
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >" :
        """
        Function that returns the specified construction point using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ConstructionPoints_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >" :
        """
        Returns the specified construction point using the name of the construction
        point as it is displayed in the browser. 
        name : The name of the construction point as it is displayed in the browser. 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.ConstructionPoints_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of construction points in the collection."""
        return _fusion.ConstructionPoints__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionPointInput >" :
        """
        Create a ConstructionPointInput object that is in turn used
        to create a ConstructionPoint. 
        occurrenceForCreation : A creation occurrence is needed if the input is in another component AND the 
        construction point is not in the root component. The occurrenceForCreation is analogous 
        to the active occurrence in the UI. 
        Returns a ConstructionPointInput object
        """
        return _fusion.ConstructionPoints_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >" :
        """
        Creates a new construction point.
        If the ConstructionPointInput was defined using the setByPoint method using a Point3D object then
        the add will only work in a direct edit model (do not capture design history) and will fail in a parametric model. 
        input : A ConstructionPointInput object 
        Returns the newly created construction point or null if the creation failed.
        """
        return _fusion.ConstructionPoints_add(self, *args)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """The component that owns this collection."""
        return _fusion.ConstructionPoints__get_component(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPoints__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPoints__get_isValid(self)
ConstructionPoints_swigregister = _fusion.ConstructionPoints_swigregister
ConstructionPoints_swigregister(ConstructionPoints)

def ConstructionPoints_classType() -> "char const *" :
  return _fusion.ConstructionPoints_classType()
ConstructionPoints_classType = _fusion.ConstructionPoints_classType

ConstructionPoints.__swig_getmethods__["count"] = ConstructionPoints._get_count
ConstructionPoints.count = property(ConstructionPoints._get_count, doc="The number of construction points in the collection.")

ConstructionPoints.__swig_getmethods__["component"] = ConstructionPoints._get_component
ConstructionPoints.component = property(ConstructionPoints._get_component, doc="The component that owns this collection.")

ConstructionPoints.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPoints) else None
ConstructionPoints.cast = lambda arg: arg if isinstance(arg, ConstructionPoints) else None

class ContactSet(Base):
    """Represents a contact set in a design."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ContactSet, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ContactSet, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ContactSet *" : return _fusion.ContactSet___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ContactSet___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ContactSet___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ContactSet_classType
    if _newclass:classType = staticmethod(_fusion.ContactSet_classType)
    __swig_destroy__ = _fusion.delete_ContactSet
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Gets and sets the name of the contact set."""
        return _fusion.ContactSet__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Gets and sets the name of the contact set."""
        return _fusion.ContactSet__set_name(self, *args)

    def _get_occurencesAndBodies(self) -> "std::vector< adsk::core::Ptr< adsk::core::Base >,std::allocator< adsk::core::Ptr< adsk::core::Base > > >" :
        """Gets and sets the group of Occurrence and/or BRepBody objects that are part of this contact set."""
        return _fusion.ContactSet__get_occurencesAndBodies(self)

    def _set_occurencesAndBodies(self, *args) -> "bool" :
        """Gets and sets the group of Occurrence and/or BRepBody objects that are part of this contact set."""
        return _fusion.ContactSet__set_occurencesAndBodies(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this contact set from the design. 
        Returns true if the delete was succcessful.
        """
        return _fusion.ContactSet_deleteMe(self)

    def _get_isSuppressed(self) -> "bool" :
        """Gets and sets if this contact set is currently suppressed."""
        return _fusion.ContactSet__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """Gets and sets if this contact set is currently suppressed."""
        return _fusion.ContactSet__set_isSuppressed(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ContactSet__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ContactSet__get_isValid(self)
ContactSet_swigregister = _fusion.ContactSet_swigregister
ContactSet_swigregister(ContactSet)

def ContactSet_classType() -> "char const *" :
  return _fusion.ContactSet_classType()
ContactSet_classType = _fusion.ContactSet_classType

ContactSet.__swig_getmethods__["name"] = ContactSet._get_name
ContactSet.__swig_setmethods__["name"] = ContactSet._set_name
ContactSet.name = property(ContactSet._get_name, ContactSet._set_name, doc="Gets and sets the name of the contact set.")

ContactSet.__swig_getmethods__["occurencesAndBodies"] = ContactSet._get_occurencesAndBodies
ContactSet.__swig_setmethods__["occurencesAndBodies"] = ContactSet._set_occurencesAndBodies
ContactSet.occurencesAndBodies = property(ContactSet._get_occurencesAndBodies, ContactSet._set_occurencesAndBodies, doc="Gets and sets the group of Occurrence and/or BRepBody objects that are part of this contact set.")

ContactSet.__swig_getmethods__["isSuppressed"] = ContactSet._get_isSuppressed
ContactSet.__swig_setmethods__["isSuppressed"] = ContactSet._set_isSuppressed
ContactSet.isSuppressed = property(ContactSet._get_isSuppressed, ContactSet._set_isSuppressed, doc="Gets and sets if this contact set is currently suppressed.")

ContactSet.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ContactSet) else None
ContactSet.cast = lambda arg: arg if isinstance(arg, ContactSet) else None

class ContactSets(Base):
    """Provides access to the existing contact sets in a design and supports creating new contact sets."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ContactSets, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ContactSets, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ContactSets *" : return _fusion.ContactSets___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ContactSets___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ContactSets___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.ContactSets___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::ContactSet >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.ContactSets___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ContactSets_classType
    if _newclass:classType = staticmethod(_fusion.ContactSets_classType)
    __swig_destroy__ = _fusion.delete_ContactSets
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::ContactSet >" :
        """
        Returns the specified contact set using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ContactSets_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::ContactSet >" :
        """name :"""
        return _fusion.ContactSets_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of contacts sets in the design."""
        return _fusion.ContactSets__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::ContactSet >" :
        """
        Creates a new contact set for the provided occurrences and/or bodies. 
        occurrencesAndBodies : An array of Occurrence or BRepBody objects that will be included in the contact set.
        All occurrences and bodies must be in the context of the root component. 
        Returns the newly created ContactSet or null in the case of failure.
        """
        return _fusion.ContactSets_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ContactSets__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ContactSets__get_isValid(self)
ContactSets_swigregister = _fusion.ContactSets_swigregister
ContactSets_swigregister(ContactSets)

def ContactSets_classType() -> "char const *" :
  return _fusion.ContactSets_classType()
ContactSets_classType = _fusion.ContactSets_classType

ContactSets.__swig_getmethods__["count"] = ContactSets._get_count
ContactSets.count = property(ContactSets._get_count, doc="Returns the number of contacts sets in the design.")

ContactSets.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ContactSets) else None
ContactSets.cast = lambda arg: arg if isinstance(arg, ContactSets) else None

class CopyPasteBodies(Base):
    """
    Collection that provides access to all of the existing copy-paste features in a design.
    These are created in the UI by copying and then pasting a B-Rep body.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CopyPasteBodies, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CopyPasteBodies, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CopyPasteBodies *" : return _fusion.CopyPasteBodies___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CopyPasteBodies___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CopyPasteBodies___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.CopyPasteBodies___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::CopyPasteBody >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.CopyPasteBodies___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CopyPasteBodies_classType
    if _newclass:classType = staticmethod(_fusion.CopyPasteBodies_classType)
    __swig_destroy__ = _fusion.delete_CopyPasteBodies
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::CopyPasteBody >" :
        """
        Function that returns the specified Copy/Paste Body feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.CopyPasteBodies_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::CopyPasteBody >" :
        """
        Function that returns the specified Copy/Paste Body feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.CopyPasteBodies_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of Copy/Paste Body features in the collection."""
        return _fusion.CopyPasteBodies__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::CopyPasteBody >" :
        """
        Copies the specified body into the component that owns this CopyPasteBodies collection. 
        sourceBody : Either an ObjectCollection of BRepBodies or a single BRepBody object to copy. 
        Returns the newly created BRepBody object or null in the case of failure.
        """
        return _fusion.CopyPasteBodies_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CopyPasteBodies__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CopyPasteBodies__get_isValid(self)
CopyPasteBodies_swigregister = _fusion.CopyPasteBodies_swigregister
CopyPasteBodies_swigregister(CopyPasteBodies)

def CopyPasteBodies_classType() -> "char const *" :
  return _fusion.CopyPasteBodies_classType()
CopyPasteBodies_classType = _fusion.CopyPasteBodies_classType

CopyPasteBodies.__swig_getmethods__["count"] = CopyPasteBodies._get_count
CopyPasteBodies.count = property(CopyPasteBodies._get_count, doc="The number of Copy/Paste Body features in the collection.")

CopyPasteBodies.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CopyPasteBodies) else None
CopyPasteBodies.cast = lambda arg: arg if isinstance(arg, CopyPasteBodies) else None

class CustomGraphicsBillBoard(Base):
    """
    Used to specify if the orientation of custom graphics are defined relative to the screen instead of model space.
    This is commonly used for legends and symbols that you want to always face the user, even as the
    camera is rotated.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsBillBoard, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsBillBoard, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsBillBoard *" : return _fusion.CustomGraphicsBillBoard___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsBillBoard___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsBillBoard___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsBillBoard_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsBillBoard_classType)
    __swig_getmethods__["create"] = lambda x: _fusion.CustomGraphicsBillBoard_create
    if _newclass:create = staticmethod(_fusion.CustomGraphicsBillBoard_create)
    __swig_destroy__ = _fusion.delete_CustomGraphicsBillBoard
    __del__ = lambda self : None;
    def _get_anchorPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        Specifies the coordinate in model or view space that the graphics will anchor to. For graphics that
        represent a label, this will typically be the point where the label attaches to the model. A
        CustomGraphicsAnchorPoint can be created using the static create method on the CustomGraphicsAnchorPoint
        object.
        """
        return _fusion.CustomGraphicsBillBoard__get_anchorPoint(self)

    def _set_anchorPoint(self, *args) -> "bool" :
        """
        Specifies the coordinate in model or view space that the graphics will anchor to. For graphics that
        represent a label, this will typically be the point where the label attaches to the model. A
        CustomGraphicsAnchorPoint can be created using the static create method on the CustomGraphicsAnchorPoint
        object.
        """
        return _fusion.CustomGraphicsBillBoard__set_anchorPoint(self, *args)

    def _get_billBoardStyle(self) -> "adsk::fusion::CustomGraphicsBillBoardStyles" :
        """
        Specifies the type of billboarding to use. When a new CustomGraphicsBillBoard object is created
        this defaults to ScreenBillBoardStyle so the graphics will all be facing the view plane. It can also 
        be set to an arbitrary plane by setting this to AxialBillBoardStyle and can be defined so that it never
        appear backwards by setting it to RightReadingBillBoardStyle.
        """
        return _fusion.CustomGraphicsBillBoard__get_billBoardStyle(self)

    def _set_billBoardStyle(self, *args) -> "bool" :
        """
        Specifies the type of billboarding to use. When a new CustomGraphicsBillBoard object is created
        this defaults to ScreenBillBoardStyle so the graphics will all be facing the view plane. It can also 
        be set to an arbitrary plane by setting this to AxialBillBoardStyle and can be defined so that it never
        appear backwards by setting it to RightReadingBillBoardStyle.
        """
        return _fusion.CustomGraphicsBillBoard__set_billBoardStyle(self, *args)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        When the billBoardStyle property is set to AxialBillBoardStyle, this is used to control the direction
        of the graphics. Otherwise it uses the x axis of the view.
        """
        return _fusion.CustomGraphicsBillBoard__get_axis(self)

    def _set_axis(self, *args) -> "bool" :
        """
        When the billBoardStyle property is set to AxialBillBoardStyle, this is used to control the direction
        of the graphics. Otherwise it uses the x axis of the view.
        """
        return _fusion.CustomGraphicsBillBoard__set_axis(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsBillBoard__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsBillBoard__get_isValid(self)
CustomGraphicsBillBoard_swigregister = _fusion.CustomGraphicsBillBoard_swigregister
CustomGraphicsBillBoard_swigregister(CustomGraphicsBillBoard)

def CustomGraphicsBillBoard_classType() -> "char const *" :
  return _fusion.CustomGraphicsBillBoard_classType()
CustomGraphicsBillBoard_classType = _fusion.CustomGraphicsBillBoard_classType

def CustomGraphicsBillBoard_create(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &" :
  return _fusion.CustomGraphicsBillBoard_create(*args)
CustomGraphicsBillBoard_create = _fusion.CustomGraphicsBillBoard_create

CustomGraphicsBillBoard.__swig_getmethods__["anchorPoint"] = CustomGraphicsBillBoard._get_anchorPoint
CustomGraphicsBillBoard.__swig_setmethods__["anchorPoint"] = CustomGraphicsBillBoard._set_anchorPoint
CustomGraphicsBillBoard.anchorPoint = property(CustomGraphicsBillBoard._get_anchorPoint, CustomGraphicsBillBoard._set_anchorPoint, doc="Specifies the coordinate in model or view space that the graphics will anchor to. For graphics that\nrepresent a label, this will typically be the point where the label attaches to the model. A\nCustomGraphicsAnchorPoint can be created using the static create method on the CustomGraphicsAnchorPoint\nobject.")

CustomGraphicsBillBoard.__swig_getmethods__["billBoardStyle"] = CustomGraphicsBillBoard._get_billBoardStyle
CustomGraphicsBillBoard.__swig_setmethods__["billBoardStyle"] = CustomGraphicsBillBoard._set_billBoardStyle
CustomGraphicsBillBoard.billBoardStyle = property(CustomGraphicsBillBoard._get_billBoardStyle, CustomGraphicsBillBoard._set_billBoardStyle, doc="Specifies the type of billboarding to use. When a new CustomGraphicsBillBoard object is created\nthis defaults to ScreenBillBoardStyle so the graphics will all be facing the view plane. It can also\nbe set to an arbitrary plane by setting this to AxialBillBoardStyle and can be defined so that it never\nappear backwards by setting it to RightReadingBillBoardStyle.")

CustomGraphicsBillBoard.__swig_getmethods__["axis"] = CustomGraphicsBillBoard._get_axis
CustomGraphicsBillBoard.__swig_setmethods__["axis"] = CustomGraphicsBillBoard._set_axis
CustomGraphicsBillBoard.axis = property(CustomGraphicsBillBoard._get_axis, CustomGraphicsBillBoard._set_axis, doc="When the billBoardStyle property is set to AxialBillBoardStyle, this is used to control the direction\nof the graphics. Otherwise it uses the x axis of the view.")

CustomGraphicsBillBoard.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsBillBoard) else None
CustomGraphicsBillBoard.cast = lambda arg: arg if isinstance(arg, CustomGraphicsBillBoard) else None

class CustomGraphicsBRepEdges(Base):
    """A collection of CustomGraphicsBRepEdge objects associated with a specific CustomGraphics body object."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsBRepEdges, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsBRepEdges, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsBRepEdges *" : return _fusion.CustomGraphicsBRepEdges___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsBRepEdges___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsBRepEdges___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsBRepEdges_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsBRepEdges_classType)
    __swig_destroy__ = _fusion.delete_CustomGraphicsBRepEdges
    __del__ = lambda self : None;
    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsBRepEdges__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsBRepEdges__get_isValid(self)
CustomGraphicsBRepEdges_swigregister = _fusion.CustomGraphicsBRepEdges_swigregister
CustomGraphicsBRepEdges_swigregister(CustomGraphicsBRepEdges)

def CustomGraphicsBRepEdges_classType() -> "char const *" :
  return _fusion.CustomGraphicsBRepEdges_classType()
CustomGraphicsBRepEdges_classType = _fusion.CustomGraphicsBRepEdges_classType

CustomGraphicsBRepEdges.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsBRepEdges) else None
CustomGraphicsBRepEdges.cast = lambda arg: arg if isinstance(arg, CustomGraphicsBRepEdges) else None

class CustomGraphicsBRepFaces(Base):
    """A collection of CustomGraphicsBRepFace objects associated with a specific CustomGraphicsBRepBody object."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsBRepFaces, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsBRepFaces, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsBRepFaces *" : return _fusion.CustomGraphicsBRepFaces___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsBRepFaces___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsBRepFaces___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsBRepFaces_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsBRepFaces_classType)
    __swig_destroy__ = _fusion.delete_CustomGraphicsBRepFaces
    __del__ = lambda self : None;
    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsBRepFaces__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsBRepFaces__get_isValid(self)
CustomGraphicsBRepFaces_swigregister = _fusion.CustomGraphicsBRepFaces_swigregister
CustomGraphicsBRepFaces_swigregister(CustomGraphicsBRepFaces)

def CustomGraphicsBRepFaces_classType() -> "char const *" :
  return _fusion.CustomGraphicsBRepFaces_classType()
CustomGraphicsBRepFaces_classType = _fusion.CustomGraphicsBRepFaces_classType

CustomGraphicsBRepFaces.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsBRepFaces) else None
CustomGraphicsBRepFaces.cast = lambda arg: arg if isinstance(arg, CustomGraphicsBRepFaces) else None

class CustomGraphicsBRepVertices(Base):
    """A collection of CustomGraphicsBRepVertex objects associated with a specific CustomGraphics body object."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsBRepVertices, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsBRepVertices, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsBRepVertices *" : return _fusion.CustomGraphicsBRepVertices___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsBRepVertices___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsBRepVertices___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsBRepVertices_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsBRepVertices_classType)
    __swig_destroy__ = _fusion.delete_CustomGraphicsBRepVertices
    __del__ = lambda self : None;
    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsBRepVertices__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsBRepVertices__get_isValid(self)
CustomGraphicsBRepVertices_swigregister = _fusion.CustomGraphicsBRepVertices_swigregister
CustomGraphicsBRepVertices_swigregister(CustomGraphicsBRepVertices)

def CustomGraphicsBRepVertices_classType() -> "char const *" :
  return _fusion.CustomGraphicsBRepVertices_classType()
CustomGraphicsBRepVertices_classType = _fusion.CustomGraphicsBRepVertices_classType

CustomGraphicsBRepVertices.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsBRepVertices) else None
CustomGraphicsBRepVertices.cast = lambda arg: arg if isinstance(arg, CustomGraphicsBRepVertices) else None

class CustomGraphicsColorEffect(Base):
    """The base class for all custom graphics color effects."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsColorEffect, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsColorEffect, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsColorEffect *" : return _fusion.CustomGraphicsColorEffect___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsColorEffect___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsColorEffect___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsColorEffect_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsColorEffect_classType)
    __swig_destroy__ = _fusion.delete_CustomGraphicsColorEffect
    __del__ = lambda self : None;
    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsColorEffect__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsColorEffect__get_isValid(self)
CustomGraphicsColorEffect_swigregister = _fusion.CustomGraphicsColorEffect_swigregister
CustomGraphicsColorEffect_swigregister(CustomGraphicsColorEffect)

def CustomGraphicsColorEffect_classType() -> "char const *" :
  return _fusion.CustomGraphicsColorEffect_classType()
CustomGraphicsColorEffect_classType = _fusion.CustomGraphicsColorEffect_classType

CustomGraphicsColorEffect.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsColorEffect) else None
CustomGraphicsColorEffect.cast = lambda arg: arg if isinstance(arg, CustomGraphicsColorEffect) else None

class CustomGraphicsCoordinates(Base):
    """Represents coordinates that are used to define vertices in custom graphics."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsCoordinates, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsCoordinates, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsCoordinates *" : return _fusion.CustomGraphicsCoordinates___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsCoordinates___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsCoordinates___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsCoordinates_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsCoordinates_classType)
    __swig_getmethods__["create"] = lambda x: _fusion.CustomGraphicsCoordinates_create
    if _newclass:create = staticmethod(_fusion.CustomGraphicsCoordinates_create)
    __swig_destroy__ = _fusion.delete_CustomGraphicsCoordinates
    __del__ = lambda self : None;
    def _get_coordinates(self) -> "std::vector< double,std::allocator< double > >" :
        """
        Gets and sets the coordinate data associated with this CustomGraphicsCoordinates object.
        This data represents the x, y, z components of the coordinates where the unit of measure is centimeters.
        """
        return _fusion.CustomGraphicsCoordinates__get_coordinates(self)

    def _set_coordinates(self, *args) -> "bool" :
        """
        Gets and sets the coordinate data associated with this CustomGraphicsCoordinates object.
        This data represents the x, y, z components of the coordinates where the unit of measure is centimeters.
        """
        return _fusion.CustomGraphicsCoordinates__set_coordinates(self, *args)

    def _get_coordinateCount(self) -> "int" :
        """Returns the number of coordinates defined in the CustomGraphicsCoordinates object."""
        return _fusion.CustomGraphicsCoordinates__get_coordinateCount(self)

    def getCoordinate(self, *args) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        Gets the coordinate at the specified index. 
        index : The index of the coordinate to return. The first coordinate has an index of 0. 
        Returns the coordinate as a Point3D object.
        """
        return _fusion.CustomGraphicsCoordinates_getCoordinate(self, *args)

    def setCoordinate(self, *args) -> "bool" :
        """
        Sets the coordinate at the specified index. 
        index : The index of the coordinate to set. The first coordinate has an index of 0. 
        coordinate : The coordinate value as a Point3D object. 
        Returns true if setting the coordinate was successful.
        """
        return _fusion.CustomGraphicsCoordinates_setCoordinate(self, *args)

    def _get_colors(self) -> "std::vector< short,std::allocator< short > >" :
        """
        Gets and sets the colors assoicated with the coordinate data. This is used when a mesh is
        displayed using per-vertex coloring.
        The color at each vertex is represented by four values where they are the red, green, blue, 
        and alpha values. This should contain the same number of colors as vertices.
        """
        return _fusion.CustomGraphicsCoordinates__get_colors(self)

    def _set_colors(self, *args) -> "bool" :
        """
        Gets and sets the colors assoicated with the coordinate data. This is used when a mesh is
        displayed using per-vertex coloring.
        The color at each vertex is represented by four values where they are the red, green, blue, 
        and alpha values. This should contain the same number of colors as vertices.
        """
        return _fusion.CustomGraphicsCoordinates__set_colors(self, *args)

    def getColor(self, *args) -> "adsk::core::Ptr< adsk::core::Color >" :
        """
        Gets the color assigned to the coordinate at the specified index. 
        index : The index of the color to return. The first color has an index of 0. 
        Returns the color associated with the index. Can also return null in the case
        where there is no color assigned.
        """
        return _fusion.CustomGraphicsCoordinates_getColor(self, *args)

    def setColor(self, *args) -> "bool" :
        """
        Sets the color of the coordinate at the specified index. 
        index : The index of the coordinate to set. The first coordinate has an index of 0. 
        color : The color value as a Color object. 
        Returns true if setting the color was successful.
        """
        return _fusion.CustomGraphicsCoordinates_setColor(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsCoordinates__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsCoordinates__get_isValid(self)
CustomGraphicsCoordinates_swigregister = _fusion.CustomGraphicsCoordinates_swigregister
CustomGraphicsCoordinates_swigregister(CustomGraphicsCoordinates)

def CustomGraphicsCoordinates_classType() -> "char const *" :
  return _fusion.CustomGraphicsCoordinates_classType()
CustomGraphicsCoordinates_classType = _fusion.CustomGraphicsCoordinates_classType

def CustomGraphicsCoordinates_create(*args) -> "std::vector< double > const &" :
  return _fusion.CustomGraphicsCoordinates_create(*args)
CustomGraphicsCoordinates_create = _fusion.CustomGraphicsCoordinates_create

CustomGraphicsCoordinates.__swig_getmethods__["coordinates"] = CustomGraphicsCoordinates._get_coordinates
CustomGraphicsCoordinates.__swig_setmethods__["coordinates"] = CustomGraphicsCoordinates._set_coordinates
CustomGraphicsCoordinates.coordinates = property(CustomGraphicsCoordinates._get_coordinates, CustomGraphicsCoordinates._set_coordinates, doc="Gets and sets the coordinate data associated with this CustomGraphicsCoordinates object.\nThis data represents the x, y, z components of the coordinates where the unit of measure is centimeters.")

CustomGraphicsCoordinates.__swig_getmethods__["coordinateCount"] = CustomGraphicsCoordinates._get_coordinateCount
CustomGraphicsCoordinates.coordinateCount = property(CustomGraphicsCoordinates._get_coordinateCount, doc="Returns the number of coordinates defined in the CustomGraphicsCoordinates object.")

CustomGraphicsCoordinates.__swig_getmethods__["colors"] = CustomGraphicsCoordinates._get_colors
CustomGraphicsCoordinates.__swig_setmethods__["colors"] = CustomGraphicsCoordinates._set_colors
CustomGraphicsCoordinates.colors = property(CustomGraphicsCoordinates._get_colors, CustomGraphicsCoordinates._set_colors, doc="Gets and sets the colors assoicated with the coordinate data. This is used when a mesh is\ndisplayed using per-vertex coloring.\nThe color at each vertex is represented by four values where they are the red, green, blue,\nand alpha values. This should contain the same number of colors as vertices.")

CustomGraphicsCoordinates.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsCoordinates) else None
CustomGraphicsCoordinates.cast = lambda arg: arg if isinstance(arg, CustomGraphicsCoordinates) else None

class CustomGraphicsEntity(Base):
    """The base class for all visible and selectable custom graphics objects."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsEntity, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsEntity, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsEntity *" : return _fusion.CustomGraphicsEntity___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsEntity___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsEntity___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsEntity_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsEntity_classType)
    __swig_destroy__ = _fusion.delete_CustomGraphicsEntity
    __del__ = lambda self : None;
    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the custom graphics group. 
        Returns true if the deletion was successful.
        """
        return _fusion.CustomGraphicsEntity_deleteMe(self)

    def _get_isVisible(self) -> "bool" :
        """
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsEntity__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsEntity__set_isVisible(self, *args)

    def _get_isSelectable(self) -> "bool" :
        """
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsEntity__get_isSelectable(self)

    def _set_isSelectable(self, *args) -> "bool" :
        """
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsEntity__set_isSelectable(self, *args)

    def setOpacity(self, *args) -> "bool" :
        """
        Sets the opacity of the graphics entity. By default, when a new entity is it is
        completely opaque and does not override the opacity defined by the material. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if setting the opacity information was successful.
        """
        return _fusion.CustomGraphicsEntity_setOpacity(self, *args)

    def getOpacity(self) -> "bool" :
        """
        Gets the opacity of the graphics entity. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if getting the opacity information was successful.
        """
        return _fusion.CustomGraphicsEntity_getOpacity(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >" :
        """
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsEntity__get_transform(self)

    def _set_transform(self, *args) -> "bool" :
        """
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsEntity__set_transform(self, *args)

    def _get_depthPriority(self) -> "int" :
        """
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsEntity__get_depthPriority(self)

    def _set_depthPriority(self, *args) -> "bool" :
        """
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsEntity__set_depthPriority(self, *args)

    def _get_cullMode(self) -> "adsk::fusion::CustomGraphicsCullModes" :
        """
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsEntity__get_cullMode(self)

    def _set_cullMode(self, *args) -> "bool" :
        """
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsEntity__set_cullMode(self, *args)

    def _get_color(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsColorEffect >" :
        """
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsEntity__get_color(self)

    def _set_color(self, *args) -> "bool" :
        """
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsEntity__set_color(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the parent Component for a top-level group or the CustomGraphicsGroup object for 
        graphics entities and child groups.
        """
        return _fusion.CustomGraphicsEntity__get_parent(self)

    def _get_id(self) -> "std::string" :
        """
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsEntity__get_id(self)

    def _set_id(self, *args) -> "bool" :
        """
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsEntity__set_id(self, *args)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """
        Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.
        Depending on whether the graphics are drawn in model space or screen space this will return
        the bounding box in either centimeters (model) or pixels (screen). In the case where it
        returns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.
        """
        return _fusion.CustomGraphicsEntity__get_boundingBox(self)

    def _get_billBoarding(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBillBoard >" :
        """
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsEntity__get_billBoarding(self)

    def _set_billBoarding(self, *args) -> "bool" :
        """
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsEntity__set_billBoarding(self, *args)

    def _get_viewPlacement(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewPlacement >" :
        """
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsEntity__get_viewPlacement(self)

    def _set_viewPlacement(self, *args) -> "bool" :
        """
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsEntity__set_viewPlacement(self, *args)

    def _get_viewScale(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewScale >" :
        """
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsEntity__get_viewScale(self)

    def _set_viewScale(self, *args) -> "bool" :
        """
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsEntity__set_viewScale(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsEntity__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsEntity__get_isValid(self)
CustomGraphicsEntity_swigregister = _fusion.CustomGraphicsEntity_swigregister
CustomGraphicsEntity_swigregister(CustomGraphicsEntity)

def CustomGraphicsEntity_classType() -> "char const *" :
  return _fusion.CustomGraphicsEntity_classType()
CustomGraphicsEntity_classType = _fusion.CustomGraphicsEntity_classType

CustomGraphicsEntity.__swig_getmethods__["isVisible"] = CustomGraphicsEntity._get_isVisible
CustomGraphicsEntity.__swig_setmethods__["isVisible"] = CustomGraphicsEntity._set_isVisible
CustomGraphicsEntity.isVisible = property(CustomGraphicsEntity._get_isVisible, CustomGraphicsEntity._set_isVisible, doc="Gets and sets if the graphics entity is visible in the graphics window. By\ndefault, when a new entity is created it is visible.")

CustomGraphicsEntity.__swig_getmethods__["isSelectable"] = CustomGraphicsEntity._get_isSelectable
CustomGraphicsEntity.__swig_setmethods__["isSelectable"] = CustomGraphicsEntity._set_isSelectable
CustomGraphicsEntity.isSelectable = property(CustomGraphicsEntity._get_isSelectable, CustomGraphicsEntity._set_isSelectable, doc="Gets and sets if the graphics entity is selectable within the graphics window. By\ndefault, when a new entity is created it is selectable.")

CustomGraphicsEntity.__swig_getmethods__["transform"] = CustomGraphicsEntity._get_transform
CustomGraphicsEntity.__swig_setmethods__["transform"] = CustomGraphicsEntity._set_transform
CustomGraphicsEntity.transform = property(CustomGraphicsEntity._get_transform, CustomGraphicsEntity._set_transform, doc="Gets and sets the transform associated with the graphics entity. When a new graphics\nentity is created its default transform is an identity matrix which results in the graphics entity\nbeing displayed in model space using the original coordinate data used to define the entity.")

CustomGraphicsEntity.__swig_getmethods__["depthPriority"] = CustomGraphicsEntity._get_depthPriority
CustomGraphicsEntity.__swig_setmethods__["depthPriority"] = CustomGraphicsEntity._set_depthPriority
CustomGraphicsEntity.depthPriority = property(CustomGraphicsEntity._get_depthPriority, CustomGraphicsEntity._set_depthPriority, doc="Gets and sets the depth priority associated with the graphics entity. The depth priority defines\nhow one graphics entity will be drawn with respect to another entity. This is useful when there\nare entities that lie in the same space so it's ambiguous which should be drawn on the other. For\nexample, if you draw a curve on a planar mesh and want the curve to be completely visible. You can\nset the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh\nand will remain visible.\nWhen a new graphics entity is created it's default depth priority is 0.")

CustomGraphicsEntity.__swig_getmethods__["cullMode"] = CustomGraphicsEntity._get_cullMode
CustomGraphicsEntity.__swig_setmethods__["cullMode"] = CustomGraphicsEntity._set_cullMode
CustomGraphicsEntity.cullMode = property(CustomGraphicsEntity._get_cullMode, CustomGraphicsEntity._set_cullMode, doc="Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains\na mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used\nfor a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never\nvisible to the user.\nWhen a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize\nthe rendering of 'solid' meshes so the inside is not rendered.")

CustomGraphicsEntity.__swig_getmethods__["color"] = CustomGraphicsEntity._get_color
CustomGraphicsEntity.__swig_setmethods__["color"] = CustomGraphicsEntity._set_color
CustomGraphicsEntity.color = property(CustomGraphicsEntity._get_color, CustomGraphicsEntity._set_color, doc="Gets and sets the current color definition for this entity. The color of custom graphics can\nbe defined in many ways; solid color, simple material, and appearance.")

CustomGraphicsEntity.__swig_getmethods__["parent"] = CustomGraphicsEntity._get_parent
CustomGraphicsEntity.parent = property(CustomGraphicsEntity._get_parent, doc="Returns the parent Component for a top-level group or the CustomGraphicsGroup object for\ngraphics entities and child groups.")

CustomGraphicsEntity.__swig_getmethods__["id"] = CustomGraphicsEntity._get_id
CustomGraphicsEntity.__swig_setmethods__["id"] = CustomGraphicsEntity._set_id
CustomGraphicsEntity.id = property(CustomGraphicsEntity._get_id, CustomGraphicsEntity._set_id, doc="An id you can specify for the entity. By default, all new graphics entities do not have an id and\nthis property will return an empty string. But in cases where entities will be selected, assigning\nan id can make understanding what was selected much easier.")

CustomGraphicsEntity.__swig_getmethods__["boundingBox"] = CustomGraphicsEntity._get_boundingBox
CustomGraphicsEntity.boundingBox = property(CustomGraphicsEntity._get_boundingBox, doc="Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.\nDepending on whether the graphics are drawn in model space or screen space this will return\nthe bounding box in either centimeters (model) or pixels (screen). In the case where it\nreturns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.")

CustomGraphicsEntity.__swig_getmethods__["billBoarding"] = CustomGraphicsEntity._get_billBoarding
CustomGraphicsEntity.__swig_setmethods__["billBoarding"] = CustomGraphicsEntity._set_billBoarding
CustomGraphicsEntity.billBoarding = property(CustomGraphicsEntity._get_billBoarding, CustomGraphicsEntity._set_billBoarding, doc="Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding\nyou can set this property using a CustomGraphicsBillBoard objects that you statically create using\nthe create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity\nyou can set this property to null.\nBillboarding is used to specify that the orientation of custom graphics is defined relative to the\nscreen instead of model space. This is commonly used for legends and symbols that you want to\nalways face the user, even as the camera is rotated.")

CustomGraphicsEntity.__swig_getmethods__["viewPlacement"] = CustomGraphicsEntity._get_viewPlacement
CustomGraphicsEntity.__swig_setmethods__["viewPlacement"] = CustomGraphicsEntity._set_viewPlacement
CustomGraphicsEntity.viewPlacement = property(CustomGraphicsEntity._get_viewPlacement, CustomGraphicsEntity._set_viewPlacement, doc="Gets and sets the graphics view placement being applied to this graphics entity. A\nCustomGraphicsViewPlacement object can be created using the static create method of the\nclass. When assigned to a graphics entity the position of the graphics is defined\nrelative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).")

CustomGraphicsEntity.__swig_getmethods__["viewScale"] = CustomGraphicsEntity._get_viewScale
CustomGraphicsEntity.__swig_setmethods__["viewScale"] = CustomGraphicsEntity._set_viewScale
CustomGraphicsEntity.viewScale = property(CustomGraphicsEntity._get_viewScale, CustomGraphicsEntity._set_viewScale, doc="Gets and sets the graphics view scale being applied to this graphics entity. A\nCustomGraphicsViewScale object can be created using the static create method of the\nclass. When assigned to a graphics entity the size of the graphics entity is defined\nin view space (pixels) instead of model space (centimeters).")

CustomGraphicsEntity.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsEntity) else None
CustomGraphicsEntity.cast = lambda arg: arg if isinstance(arg, CustomGraphicsEntity) else None

class CustomGraphicsGroups(Base):
    """
    Provides access to a set of graphics groups that are either associated with a component or owned by another
    CustomGraphicsGroup object. This object also supports the creation of new custom graphics groups.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsGroups, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsGroups, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsGroups *" : return _fusion.CustomGraphicsGroups___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsGroups___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsGroups___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.CustomGraphicsGroups___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsGroup >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.CustomGraphicsGroups___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsGroups_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsGroups_classType)
    __swig_destroy__ = _fusion.delete_CustomGraphicsGroups
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsGroup >" :
        """
        Function that returns the specified graphics group using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.CustomGraphicsGroups_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of graphics groups in the collection."""
        return _fusion.CustomGraphicsGroups__get_count(self)

    def add(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsGroup >" :
        """
        Creates a new, empty CustomGraphicsGroup. 
        Returns the new CustomGraphicsGroup object or null in the case of a failure.
        """
        return _fusion.CustomGraphicsGroups_add(self)

    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsGroups__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsGroups__get_isValid(self)
CustomGraphicsGroups_swigregister = _fusion.CustomGraphicsGroups_swigregister
CustomGraphicsGroups_swigregister(CustomGraphicsGroups)

def CustomGraphicsGroups_classType() -> "char const *" :
  return _fusion.CustomGraphicsGroups_classType()
CustomGraphicsGroups_classType = _fusion.CustomGraphicsGroups_classType

CustomGraphicsGroups.__swig_getmethods__["count"] = CustomGraphicsGroups._get_count
CustomGraphicsGroups.count = property(CustomGraphicsGroups._get_count, doc="Returns the number of graphics groups in the collection.")

CustomGraphicsGroups.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsGroups) else None
CustomGraphicsGroups.cast = lambda arg: arg if isinstance(arg, CustomGraphicsGroups) else None

class CustomGraphicsViewPlacement(Base):
    """
    Positions custom graphics relative to one of the four corners of the view. Graphics positioned
    this way will always appear on top of the model graphics. This is typically used to display
    legends are small interactive tools.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsViewPlacement, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsViewPlacement, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsViewPlacement *" : return _fusion.CustomGraphicsViewPlacement___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsViewPlacement___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsViewPlacement___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsViewPlacement_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsViewPlacement_classType)
    __swig_getmethods__["create"] = lambda x: _fusion.CustomGraphicsViewPlacement_create
    if _newclass:create = staticmethod(_fusion.CustomGraphicsViewPlacement_create)
    __swig_destroy__ = _fusion.delete_CustomGraphicsViewPlacement
    __del__ = lambda self : None;
    def _get_anchorPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        Gets and sets the position within the defined graphics that serves as the anchor. This is the location
        on the graphics that is positioned at the specified view point.
        """
        return _fusion.CustomGraphicsViewPlacement__get_anchorPoint(self)

    def _set_anchorPoint(self, *args) -> "bool" :
        """
        Gets and sets the position within the defined graphics that serves as the anchor. This is the location
        on the graphics that is positioned at the specified view point.
        """
        return _fusion.CustomGraphicsViewPlacement__set_anchorPoint(self, *args)

    def _get_viewPoint(self) -> "adsk::core::Ptr< adsk::core::Point2D >" :
        """
        A 2D point in the view that defines the position of the graphics. This is relative to the corner
        and is in pixels. The x and y directions vary for each of the corners. These directions are only
        used to position the 2D point and do not affect the standard coordinate system the graphics were
        drawn in.
        upperLeftViewCorner - The x direction is to the right and y is down.
        upperRightViewCorner - The x direction is to the left and y is down.
        lowerLeftViewCorner - The x direction is to the right and y is up.
        lowerRightViewCorner - The x direction is to the left and y is up.
        """
        return _fusion.CustomGraphicsViewPlacement__get_viewPoint(self)

    def _set_viewPoint(self, *args) -> "bool" :
        """
        A 2D point in the view that defines the position of the graphics. This is relative to the corner
        and is in pixels. The x and y directions vary for each of the corners. These directions are only
        used to position the 2D point and do not affect the standard coordinate system the graphics were
        drawn in.
        upperLeftViewCorner - The x direction is to the right and y is down.
        upperRightViewCorner - The x direction is to the left and y is down.
        lowerLeftViewCorner - The x direction is to the right and y is up.
        lowerRightViewCorner - The x direction is to the left and y is up.
        """
        return _fusion.CustomGraphicsViewPlacement__set_viewPoint(self, *args)

    def _get_viewCorner(self) -> "adsk::fusion::ViewCorners" :
        """Gets and sets which corner the graphics are positioned relative to."""
        return _fusion.CustomGraphicsViewPlacement__get_viewCorner(self)

    def _set_viewCorner(self, *args) -> "bool" :
        """Gets and sets which corner the graphics are positioned relative to."""
        return _fusion.CustomGraphicsViewPlacement__set_viewCorner(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsViewPlacement__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsViewPlacement__get_isValid(self)
CustomGraphicsViewPlacement_swigregister = _fusion.CustomGraphicsViewPlacement_swigregister
CustomGraphicsViewPlacement_swigregister(CustomGraphicsViewPlacement)

def CustomGraphicsViewPlacement_classType() -> "char const *" :
  return _fusion.CustomGraphicsViewPlacement_classType()
CustomGraphicsViewPlacement_classType = _fusion.CustomGraphicsViewPlacement_classType

def CustomGraphicsViewPlacement_create(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &, adsk::core::Ptr< adsk::core::Point2D > const &" :
  return _fusion.CustomGraphicsViewPlacement_create(*args)
CustomGraphicsViewPlacement_create = _fusion.CustomGraphicsViewPlacement_create

CustomGraphicsViewPlacement.__swig_getmethods__["anchorPoint"] = CustomGraphicsViewPlacement._get_anchorPoint
CustomGraphicsViewPlacement.__swig_setmethods__["anchorPoint"] = CustomGraphicsViewPlacement._set_anchorPoint
CustomGraphicsViewPlacement.anchorPoint = property(CustomGraphicsViewPlacement._get_anchorPoint, CustomGraphicsViewPlacement._set_anchorPoint, doc="Gets and sets the position within the defined graphics that serves as the anchor. This is the location\non the graphics that is positioned at the specified view point.")

CustomGraphicsViewPlacement.__swig_getmethods__["viewPoint"] = CustomGraphicsViewPlacement._get_viewPoint
CustomGraphicsViewPlacement.__swig_setmethods__["viewPoint"] = CustomGraphicsViewPlacement._set_viewPoint
CustomGraphicsViewPlacement.viewPoint = property(CustomGraphicsViewPlacement._get_viewPoint, CustomGraphicsViewPlacement._set_viewPoint, doc="A 2D point in the view that defines the position of the graphics. This is relative to the corner\nand is in pixels. The x and y directions vary for each of the corners. These directions are only\nused to position the 2D point and do not affect the standard coordinate system the graphics were\ndrawn in.\nupperLeftViewCorner - The x direction is to the right and y is down.\nupperRightViewCorner - The x direction is to the left and y is down.\nlowerLeftViewCorner - The x direction is to the right and y is up.\nlowerRightViewCorner - The x direction is to the left and y is up.")

CustomGraphicsViewPlacement.__swig_getmethods__["viewCorner"] = CustomGraphicsViewPlacement._get_viewCorner
CustomGraphicsViewPlacement.__swig_setmethods__["viewCorner"] = CustomGraphicsViewPlacement._set_viewCorner
CustomGraphicsViewPlacement.viewCorner = property(CustomGraphicsViewPlacement._get_viewCorner, CustomGraphicsViewPlacement._set_viewCorner, doc="Gets and sets which corner the graphics are positioned relative to.")

CustomGraphicsViewPlacement.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsViewPlacement) else None
CustomGraphicsViewPlacement.cast = lambda arg: arg if isinstance(arg, CustomGraphicsViewPlacement) else None

class CustomGraphicsViewScale(Base):
    """
    Specifies that custom graphics are to be scaled relative to the view (pixels) and not model space.
    If this is applied to some custom graphics then they will stat the same size on the screen regardless
    of the user zooming in or out. This is commonly used for glyphs and other interactive widgets so they don't
    don't get too large or too small.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsViewScale, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsViewScale, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsViewScale *" : return _fusion.CustomGraphicsViewScale___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsViewScale___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsViewScale___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsViewScale_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsViewScale_classType)
    __swig_getmethods__["create"] = lambda x: _fusion.CustomGraphicsViewScale_create
    if _newclass:create = staticmethod(_fusion.CustomGraphicsViewScale_create)
    __swig_destroy__ = _fusion.delete_CustomGraphicsViewScale
    __del__ = lambda self : None;
    def _get_pixelScale(self) -> "double" :
        """
        Gets and sets the scale of the custom graphics relative to the view. If a custom graphics line is defined
        to be 100 units long it would usually display as 100 cm long. When it is view scaled with a pixel scale of
        1 it will display as 100 pixels long.
        """
        return _fusion.CustomGraphicsViewScale__get_pixelScale(self)

    def _set_pixelScale(self, *args) -> "bool" :
        """
        Gets and sets the scale of the custom graphics relative to the view. If a custom graphics line is defined
        to be 100 units long it would usually display as 100 cm long. When it is view scaled with a pixel scale of
        1 it will display as 100 pixels long.
        """
        return _fusion.CustomGraphicsViewScale__set_pixelScale(self, *args)

    def _get_anchorPoint(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        Gets and sets the point in the graphics that defines the origin of the scaling. The graphics will be scaled
        up or down relative to that point.
        """
        return _fusion.CustomGraphicsViewScale__get_anchorPoint(self)

    def _set_anchorPoint(self, *args) -> "bool" :
        """
        Gets and sets the point in the graphics that defines the origin of the scaling. The graphics will be scaled
        up or down relative to that point.
        """
        return _fusion.CustomGraphicsViewScale__set_anchorPoint(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsViewScale__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsViewScale__get_isValid(self)
CustomGraphicsViewScale_swigregister = _fusion.CustomGraphicsViewScale_swigregister
CustomGraphicsViewScale_swigregister(CustomGraphicsViewScale)

def CustomGraphicsViewScale_classType() -> "char const *" :
  return _fusion.CustomGraphicsViewScale_classType()
CustomGraphicsViewScale_classType = _fusion.CustomGraphicsViewScale_classType

def CustomGraphicsViewScale_create(*args) -> "adsk::core::Ptr< adsk::core::Point3D > const &" :
  return _fusion.CustomGraphicsViewScale_create(*args)
CustomGraphicsViewScale_create = _fusion.CustomGraphicsViewScale_create

CustomGraphicsViewScale.__swig_getmethods__["pixelScale"] = CustomGraphicsViewScale._get_pixelScale
CustomGraphicsViewScale.__swig_setmethods__["pixelScale"] = CustomGraphicsViewScale._set_pixelScale
CustomGraphicsViewScale.pixelScale = property(CustomGraphicsViewScale._get_pixelScale, CustomGraphicsViewScale._set_pixelScale, doc="Gets and sets the scale of the custom graphics relative to the view. If a custom graphics line is defined\nto be 100 units long it would usually display as 100 cm long. When it is view scaled with a pixel scale of\n1 it will display as 100 pixels long.")

CustomGraphicsViewScale.__swig_getmethods__["anchorPoint"] = CustomGraphicsViewScale._get_anchorPoint
CustomGraphicsViewScale.__swig_setmethods__["anchorPoint"] = CustomGraphicsViewScale._set_anchorPoint
CustomGraphicsViewScale.anchorPoint = property(CustomGraphicsViewScale._get_anchorPoint, CustomGraphicsViewScale._set_anchorPoint, doc="Gets and sets the point in the graphics that defines the origin of the scaling. The graphics will be scaled\nup or down relative to that point.")

CustomGraphicsViewScale.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsViewScale) else None
CustomGraphicsViewScale.cast = lambda arg: arg if isinstance(arg, CustomGraphicsViewScale) else None

class CutPasteBodies(Base):
    """
    Collection that provides access to all of the existing cut-paste features in a design.
    These are created in the UI by cutting and then pasting a B-Rep body.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CutPasteBodies, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CutPasteBodies, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CutPasteBodies *" : return _fusion.CutPasteBodies___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CutPasteBodies___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CutPasteBodies___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.CutPasteBodies___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::CutPasteBody >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.CutPasteBodies___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CutPasteBodies_classType
    if _newclass:classType = staticmethod(_fusion.CutPasteBodies_classType)
    __swig_destroy__ = _fusion.delete_CutPasteBodies
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::CutPasteBody >" :
        """
        Function that returns the specified Cut/Paste Body feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.CutPasteBodies_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::CutPasteBody >" :
        """
        Function that returns the specified Cut/Paste Body feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.CutPasteBodies_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of Cut/Paste Body features in the collection."""
        return _fusion.CutPasteBodies__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::CutPasteBody >" :
        """
        Cuts and copies the specififed body into the component that owns this CutPasteBodies collection. 
        This is effectively the equivalent of moving a body. 
        sourceBody : Either an ObjectCollection of BRepBodies or a single BRepBody object to cut. 
        Returns the newly created BRepBody object or null in the case of failure.
        """
        return _fusion.CutPasteBodies_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CutPasteBodies__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CutPasteBodies__get_isValid(self)
CutPasteBodies_swigregister = _fusion.CutPasteBodies_swigregister
CutPasteBodies_swigregister(CutPasteBodies)

def CutPasteBodies_classType() -> "char const *" :
  return _fusion.CutPasteBodies_classType()
CutPasteBodies_classType = _fusion.CutPasteBodies_classType

CutPasteBodies.__swig_getmethods__["count"] = CutPasteBodies._get_count
CutPasteBodies.count = property(CutPasteBodies._get_count, doc="The number of Cut/Paste Body features in the collection.")

CutPasteBodies.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CutPasteBodies) else None
CutPasteBodies.cast = lambda arg: arg if isinstance(arg, CutPasteBodies) else None

class CylinderFeatures(Base):
    """Collection that provides access to all of the existing cylinder features in a design."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CylinderFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CylinderFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CylinderFeatures *" : return _fusion.CylinderFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CylinderFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CylinderFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.CylinderFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::CylinderFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.CylinderFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CylinderFeatures_classType
    if _newclass:classType = staticmethod(_fusion.CylinderFeatures_classType)
    __swig_destroy__ = _fusion.delete_CylinderFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::CylinderFeature >" :
        """
        Function that returns the specified cylinder feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.CylinderFeatures_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::CylinderFeature >" :
        """
        Function that returns the specified cylinder feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.CylinderFeatures_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of cylinder features in the collection."""
        return _fusion.CylinderFeatures__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.CylinderFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CylinderFeatures__get_isValid(self)
CylinderFeatures_swigregister = _fusion.CylinderFeatures_swigregister
CylinderFeatures_swigregister(CylinderFeatures)

def CylinderFeatures_classType() -> "char const *" :
  return _fusion.CylinderFeatures_classType()
CylinderFeatures_classType = _fusion.CylinderFeatures_classType

CylinderFeatures.__swig_getmethods__["count"] = CylinderFeatures._get_count
CylinderFeatures.count = property(CylinderFeatures._get_count, doc="The number of cylinder features in the collection.")

CylinderFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CylinderFeatures) else None
CylinderFeatures.cast = lambda arg: arg if isinstance(arg, CylinderFeatures) else None

class DeleteFaceFeatures(Base):
    """
    Collection that provides access to all of the existing DeleteFaceFeature features in a component
    and supports the ability to create new DeleteFaceFeature features.
    The SurfaceDeleteFaceFeature and DeleteFaceFeature differ in that the SurfaceDeleteFaceFeature
    can delete any face without any restrictions. If the body is a solid, it will become a surface
    when the first face is deleted. The specified face is deleted without any other changes being
    made to the body. The DeleteFaceFeature deletes the specified face and also modifies the other faces
    in the body to heal or fill in the area of the deleted face. This means that a solid body will
    remain solid.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DeleteFaceFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DeleteFaceFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::DeleteFaceFeatures *" : return _fusion.DeleteFaceFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.DeleteFaceFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.DeleteFaceFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.DeleteFaceFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::DeleteFaceFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.DeleteFaceFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.DeleteFaceFeatures_classType
    if _newclass:classType = staticmethod(_fusion.DeleteFaceFeatures_classType)
    __swig_destroy__ = _fusion.delete_DeleteFaceFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::DeleteFaceFeature >" :
        """
        Function that returns the specified DeleteFaceFeature object using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.DeleteFaceFeatures_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::DeleteFaceFeature >" :
        """
        Function that returns the specified DeleteFaceFeature object using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.DeleteFaceFeatures_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of DeleteFaceFeature objects in the collection."""
        return _fusion.DeleteFaceFeatures__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::DeleteFaceFeature >" :
        """
        Creates a new SurfaceDeleteFace feature. This deletes the specified faces
        from their bodies and attempts to heal the body. The method will fail if
        the body cannot be healed. This is equivalent to selecting and deleting
        faces when in the Patch workspace. 
        facesToDelete : A single BRepFace or an ObjectCollection containing multiple BRepFace objects. 
        Returns the newly created DeleteFaceFeature object or null if the creation failed.
        """
        return _fusion.DeleteFaceFeatures_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.DeleteFaceFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.DeleteFaceFeatures__get_isValid(self)
DeleteFaceFeatures_swigregister = _fusion.DeleteFaceFeatures_swigregister
DeleteFaceFeatures_swigregister(DeleteFaceFeatures)

def DeleteFaceFeatures_classType() -> "char const *" :
  return _fusion.DeleteFaceFeatures_classType()
DeleteFaceFeatures_classType = _fusion.DeleteFaceFeatures_classType

DeleteFaceFeatures.__swig_getmethods__["count"] = DeleteFaceFeatures._get_count
DeleteFaceFeatures.count = property(DeleteFaceFeatures._get_count, doc="The number of DeleteFaceFeature objects in the collection.")

DeleteFaceFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DeleteFaceFeatures) else None
DeleteFaceFeatures.cast = lambda arg: arg if isinstance(arg, DeleteFaceFeatures) else None

class Design(adsk.core.Product):
    """
    Object that represents an open Fusion 360 design. This derives from the
    Design base class and adds the Fusion 360 specific functionality.
    """
    __swig_setmethods__ = {}
    for _s in [adsk.core.Product]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Design, name, value)
    __swig_getmethods__ = {}
    for _s in [adsk.core.Product]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Design, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::Design *" : return _fusion.Design___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Design___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Design___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Design_classType
    if _newclass:classType = staticmethod(_fusion.Design_classType)
    __swig_destroy__ = _fusion.delete_Design
    __del__ = lambda self : None;
    def _get_designType(self) -> "adsk::fusion::DesignTypes" :
        """
        Gets and sets the current design type (DirectDesignType or ParametricDesignType)
        Changing an exising design from ParametricDesignType to DirectDesignType will result in the timeline and all design
        history being removed and further operations will not be captured in the timeline.
        """
        return _fusion.Design__get_designType(self)

    def _set_designType(self, *args) -> "bool" :
        """
        Gets and sets the current design type (DirectDesignType or ParametricDesignType)
        Changing an exising design from ParametricDesignType to DirectDesignType will result in the timeline and all design
        history being removed and further operations will not be captured in the timeline.
        """
        return _fusion.Design__set_designType(self, *args)

    def _get_rootComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the root Component"""
        return _fusion.Design__get_rootComponent(self)

    def _get_allComponents(self) -> "adsk::core::Ptr< adsk::fusion::Components >" :
        """
        Returns the Components collection that provides access to existing components 
        in a design
        """
        return _fusion.Design__get_allComponents(self)

    def _get_activeEditObject(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the current edit target as seen in the user interface. This edit target
        is defined as the container object that will be added to if something is created.
        For example, a component can be an edit target so that when new bodies are created they
        are added to that component. A sketch can also be an edit target.
        """
        return _fusion.Design__get_activeEditObject(self)

    def _get_activeComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """
        Returns the component that is current being edited. This can return the root component
        or another component within the design.
        """
        return _fusion.Design__get_activeComponent(self)

    def _get_snapshots(self) -> "adsk::core::Ptr< adsk::fusion::Snapshots >" :
        """
        Returns the Snapshots object associated with this design which provides access to the 
        existing snapshots and the creation of new snapshots.
        """
        return _fusion.Design__get_snapshots(self)

    def _get_timeline(self) -> "adsk::core::Ptr< adsk::fusion::Timeline >" :
        """Returns the timeline associated with this design."""
        return _fusion.Design__get_timeline(self)

    def _get_userParameters(self) -> "adsk::core::Ptr< adsk::fusion::UserParameters >" :
        """Returns the collection of User Parameters in a design"""
        return _fusion.Design__get_userParameters(self)

    def _get_allParameters(self) -> "adsk::core::Ptr< adsk::fusion::ParameterList >" :
        """
        Returns a read only list of all parameters in the design. This includes
        the user parameters and model parameters from all components in this design. The parameters from Externally Referenced components
        are NOT included because they are in actuality, separate designs.
        """
        return _fusion.Design__get_allParameters(self)

    def _get_fusionUnitsManager(self) -> "adsk::core::Ptr< adsk::fusion::FusionUnitsManager >" :
        """
        Returns a specialized UnitsManager that can set the default length units and work 
        with parameters.
        """
        return _fusion.Design__get_fusionUnitsManager(self)

    def _get_exportManager(self) -> "adsk::core::Ptr< adsk::fusion::ExportManager >" :
        """
        Returns the ExportManager for this design. You use the ExportManager
        to export the current design in various formats.
        """
        return _fusion.Design__get_exportManager(self)

    def _get_isRootComponentActive(self) -> "bool" :
        """
        Gets whether the root component is the active edit target in the user interface.
        This is the same as checking the state of the radio button next to the root compoonent in the browser.
        To activate the root component use the ActivateRootComponent method.
        """
        return _fusion.Design__get_isRootComponentActive(self)

    def activateRootComponent(self) -> "bool" :
        """
        Makes the root component the active component in the user interface. This is the same
        as enabling the radio button next to the root component in the browser. 
        Returns true if the activation was successful.
        """
        return _fusion.Design_activateRootComponent(self)

    def _get_materials(self) -> "adsk::core::Ptr< adsk::core::Materials >" :
        """Returns the materials contained in this document."""
        return _fusion.Design__get_materials(self)

    def _get_appearances(self) -> "adsk::core::Ptr< adsk::core::Appearances >" :
        """Returns the appearances contained in this document."""
        return _fusion.Design__get_appearances(self)

    def createInterferenceInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::InterferenceInput >" :
        """
        Creates an InterferenceInput object. This object collects the entities and options that are
        used when calculating interference. To analyze interference you first create an InterferenceInput
        supplying the entities and set any other settings and then provide this object as input to the 
        analyzeInterference method. 
        entities : An ObjectCollection containing the BRepBody and/or Occurrence entities that will be used in the
        interference calculation. All entities must be in the context of the root component of the top-level design. 
        Returns an InterferenceInput object which you can use to set any other interference settings and then
        use as input to the analyzeInterference method to calculate the interference. Returns null if the
        creation failed.
        """
        return _fusion.Design_createInterferenceInput(self, *args)

    def analyzeInterference(self, *args) -> "adsk::core::Ptr< adsk::fusion::InterferenceResults >" :
        """
        Calculates the interference between the input bodies and/or occurrences. 
        input : An InterferenceInput that defines all of the necessary input needed to calculate the interference.
        An InterferenceInput object is created using the createInterferenceInput method. 
        Returns an InterferenceResults object that can be used to examine the interference results.
        """
        return _fusion.Design_analyzeInterference(self, *args)

    def _get_activeOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the occurrence that is currently activated, if any. This can return null in the case
        where no occurrence is activated and the root component is active.
        """
        return _fusion.Design__get_activeOccurrence(self)

    def areaProperties(self, *args) -> "adsk::core::Ptr< adsk::fusion::AreaProperties >" :
        """
        Returns the AreaProperties object that has properties for getting the area, perimeter, centroid, etc 
        for a collection of 2D sketch profiles and/or planar surfaces that all lie on the same plane. 
        inputs : A collection of one or more 2D sketch profile and/or planar surface input objects to perform the calculations on. 
        Supported input object types are 2D closed sketch profiles and planar surfaces. Object must all lie on the same plane.
        Calculation results reflect the sums of the input objects (i.e. total area of multiple sketch profiles) 
        accuracy : Specifies the desired level of computational accuracy of the property calculations.
        The default value of 'LowCalculationAccuracy' returns results within a +/- 1% error margin. 
        Returns an AreaProperties object that can be used to examine the area results.
        """
        return _fusion.Design_areaProperties(self, *args)

    def physicalProperties(self, *args) -> "adsk::core::Ptr< adsk::fusion::PhysicalProperties >" :
        """
        Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc 
        for a collection of 3D solid objects. 
        inputs : A collection of one or more 3D solid input objects to perform the calculations on. 
        Supported input object types are Components, Occurrences and BRepBodies.
        Calculation results reflect the sums of the input objects (i.e. total volume of multiple bodies) 
        accuracy : Specifies the desired level of computational accuracy of the property calculations.
        The default value of 'LowCalculationAccuracy' returns results within a +/- 1% error margin.
        """
        return _fusion.Design_physicalProperties(self, *args)

    def _get_contactSets(self) -> "adsk::core::Ptr< adsk::fusion::ContactSets >" :
        """Returns the contact sets associated with this design."""
        return _fusion.Design__get_contactSets(self)

    def _get_isContactAnalysisEnabled(self) -> "bool" :
        """
        Gets and sets whether contact analysis is enabled for all components. This
        is the equivalent of the 'Disable Contact / Enable Contact' command. If this
        if True then any contact analysis defined (either all or contact sets) is enabled.
        if False, then no contact analysis is performed.
        """
        return _fusion.Design__get_isContactAnalysisEnabled(self)

    def _set_isContactAnalysisEnabled(self, *args) -> "bool" :
        """
        Gets and sets whether contact analysis is enabled for all components. This
        is the equivalent of the 'Disable Contact / Enable Contact' command. If this
        if True then any contact analysis defined (either all or contact sets) is enabled.
        if False, then no contact analysis is performed.
        """
        return _fusion.Design__set_isContactAnalysisEnabled(self, *args)

    def _get_isContactSetAnalysis(self) -> "bool" :
        """
        Gets and sets whether contact analysis is done using contact sets
        or between all bodies, independent of any contact sets. If True and
        the isContactAnalysisEnabled property is True then contact analysis
        is performed using contact sets. If False and isContactAnalysisEnabled
        is True, then contact analysis is performed between all bodies. If
        isContactAnalysisEnabled is False then no contact analysis is performed.
        """
        return _fusion.Design__get_isContactSetAnalysis(self)

    def _set_isContactSetAnalysis(self, *args) -> "bool" :
        """
        Gets and sets whether contact analysis is done using contact sets
        or between all bodies, independent of any contact sets. If True and
        the isContactAnalysisEnabled property is True then contact analysis
        is performed using contact sets. If False and isContactAnalysisEnabled
        is True, then contact analysis is performed between all bodies. If
        isContactAnalysisEnabled is False then no contact analysis is performed.
        """
        return _fusion.Design__set_isContactSetAnalysis(self, *args)

    def _get_parentDocument(self) -> "adsk::core::Ptr< adsk::core::Document >" :
        """Returns the parent Document object."""
        return _fusion.Design__get_parentDocument(self)

    def _get_unitsManager(self) -> "adsk::core::Ptr< adsk::core::UnitsManager >" :
        """Returns the UnitsManager object associated with this product."""
        return _fusion.Design__get_unitsManager(self)

    def _get_workspaces(self) -> "adsk::core::Ptr< adsk::core::WorkspaceList >" :
        """Returns the workspaces associated with this product."""
        return _fusion.Design__get_workspaces(self)

    def _get_productType(self) -> "std::string" :
        """
        Returns the product type name of this product. A list of all of
        the possible product types can be obtained by using the 
        Application.supportedProductTypes property.
        """
        return _fusion.Design__get_productType(self)

    def findAttributes(self, *args) -> "std::vector< adsk::core::Ptr< adsk::core::Attribute >,std::allocator< adsk::core::Ptr< adsk::core::Attribute > > >" :
        """
        Find attributes attached to objects in this product that match the group and or attribute name.
        This does not find attributes attached directly to the Product or Document objects but finds the
        attributes attached to entities within the product.
        The search string for both the groupName and attributeName arguments can be either an absolute 
        name value, or a regular expression. With an absolute name, the search string must match the
        entire groupName or attributeName, including case. An empty string will match everything.
        For example if you have an attribute group named 'MyStuff' that contains the attribute 'Length1', 
        using the search string 'MyStuff' as the group name and 'Length1' as the attribute name will 
        find the attributes with those names. Searching for 'MyStuff' as the group name and '' as the
        attribute name will find all attributes that have 'MyStuff' as the group name.
        Regular expressions provide a more flexibile way of searching. To use a regular expression, 
        prefix the input string for the groupName or attributeName arguments with 're:'. The regular
        expression much match the entire group or attribute name. For example if you have a group that
        contains attributes named 'Length1', 'Length2', 'Width1', and 'Width2' and want to find any 
        of the length attributes you can use a regular expression using the string 're:Length.*'. For more
        information on attributes see the Attributes topic in the user manual. 
        groupName : The search string for the group name. See above for more details. 
        attributeName : The search string for the attribute name. See above for more details. 
        An array of Attribute objects that were found. An empty array is returned if no attributes were found.
        """
        return _fusion.Design_findAttributes(self, *args)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this product."""
        return _fusion.Design__get_attributes(self)

    def deleteEntities(self, *args) -> "bool" :
        """
        Deletes the specified set of entities that are associated with this product. 
        entities : An ObjectCollection containing the list of entities to delete. 
        Returns True if any of the entities provided in the list were deleted. If
        entities were specified that can't be deleted or aren't owned by this product,
        they are ignored.
        """
        return _fusion.Design_deleteEntities(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.Design__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Design__get_isValid(self)
Design_swigregister = _fusion.Design_swigregister
Design_swigregister(Design)

def Design_classType() -> "char const *" :
  return _fusion.Design_classType()
Design_classType = _fusion.Design_classType

Design.__swig_getmethods__["designType"] = Design._get_designType
Design.__swig_setmethods__["designType"] = Design._set_designType
Design.designType = property(Design._get_designType, Design._set_designType, doc="Gets and sets the current design type (DirectDesignType or ParametricDesignType)\nChanging an exising design from ParametricDesignType to DirectDesignType will result in the timeline and all design\nhistory being removed and further operations will not be captured in the timeline.")

Design.__swig_getmethods__["rootComponent"] = Design._get_rootComponent
Design.rootComponent = property(Design._get_rootComponent, doc="Returns the root Component")

Design.__swig_getmethods__["allComponents"] = Design._get_allComponents
Design.allComponents = property(Design._get_allComponents, doc="Returns the Components collection that provides access to existing components\nin a design")

Design.__swig_getmethods__["activeEditObject"] = Design._get_activeEditObject
Design.activeEditObject = property(Design._get_activeEditObject, doc="Returns the current edit target as seen in the user interface. This edit target\nis defined as the container object that will be added to if something is created.\nFor example, a component can be an edit target so that when new bodies are created they\nare added to that component. A sketch can also be an edit target.")

Design.__swig_getmethods__["activeComponent"] = Design._get_activeComponent
Design.activeComponent = property(Design._get_activeComponent, doc="Returns the component that is current being edited. This can return the root component\nor another component within the design.")

Design.__swig_getmethods__["snapshots"] = Design._get_snapshots
Design.snapshots = property(Design._get_snapshots, doc="Returns the Snapshots object associated with this design which provides access to the\nexisting snapshots and the creation of new snapshots.")

Design.__swig_getmethods__["timeline"] = Design._get_timeline
Design.timeline = property(Design._get_timeline, doc="Returns the timeline associated with this design.")

Design.__swig_getmethods__["userParameters"] = Design._get_userParameters
Design.userParameters = property(Design._get_userParameters, doc="Returns the collection of User Parameters in a design")

Design.__swig_getmethods__["allParameters"] = Design._get_allParameters
Design.allParameters = property(Design._get_allParameters, doc="Returns a read only list of all parameters in the design. This includes\nthe user parameters and model parameters from all components in this design. The parameters from Externally Referenced components\nare NOT included because they are in actuality, separate designs.")

Design.__swig_getmethods__["fusionUnitsManager"] = Design._get_fusionUnitsManager
Design.fusionUnitsManager = property(Design._get_fusionUnitsManager, doc="Returns a specialized UnitsManager that can set the default length units and work\nwith parameters.")

Design.__swig_getmethods__["exportManager"] = Design._get_exportManager
Design.exportManager = property(Design._get_exportManager, doc="Returns the ExportManager for this design. You use the ExportManager\nto export the current design in various formats.")

Design.__swig_getmethods__["isRootComponentActive"] = Design._get_isRootComponentActive
Design.isRootComponentActive = property(Design._get_isRootComponentActive, doc="Gets whether the root component is the active edit target in the user interface.\nThis is the same as checking the state of the radio button next to the root compoonent in the browser.\nTo activate the root component use the ActivateRootComponent method.")

Design.__swig_getmethods__["materials"] = Design._get_materials
Design.materials = property(Design._get_materials, doc="Returns the materials contained in this document.")

Design.__swig_getmethods__["appearances"] = Design._get_appearances
Design.appearances = property(Design._get_appearances, doc="Returns the appearances contained in this document.")

Design.__swig_getmethods__["activeOccurrence"] = Design._get_activeOccurrence
Design.activeOccurrence = property(Design._get_activeOccurrence, doc="Returns the occurrence that is currently activated, if any. This can return null in the case\nwhere no occurrence is activated and the root component is active.")

Design.__swig_getmethods__["contactSets"] = Design._get_contactSets
Design.contactSets = property(Design._get_contactSets, doc="Returns the contact sets associated with this design.")

Design.__swig_getmethods__["isContactAnalysisEnabled"] = Design._get_isContactAnalysisEnabled
Design.__swig_setmethods__["isContactAnalysisEnabled"] = Design._set_isContactAnalysisEnabled
Design.isContactAnalysisEnabled = property(Design._get_isContactAnalysisEnabled, Design._set_isContactAnalysisEnabled, doc="Gets and sets whether contact analysis is enabled for all components. This\nis the equivalent of the 'Disable Contact / Enable Contact' command. If this\nif True then any contact analysis defined (either all or contact sets) is enabled.\nif False, then no contact analysis is performed.")

Design.__swig_getmethods__["isContactSetAnalysis"] = Design._get_isContactSetAnalysis
Design.__swig_setmethods__["isContactSetAnalysis"] = Design._set_isContactSetAnalysis
Design.isContactSetAnalysis = property(Design._get_isContactSetAnalysis, Design._set_isContactSetAnalysis, doc="Gets and sets whether contact analysis is done using contact sets\nor between all bodies, independent of any contact sets. If True and\nthe isContactAnalysisEnabled property is True then contact analysis\nis performed using contact sets. If False and isContactAnalysisEnabled\nis True, then contact analysis is performed between all bodies. If\nisContactAnalysisEnabled is False then no contact analysis is performed.")

Design.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Design) else None
Design.cast = lambda arg: arg if isinstance(arg, Design) else None

class DraftFeatureInput(Base):
    """
    This class defines the methods and properties that pertain to the definition of a draft 
    feature.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DraftFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DraftFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::DraftFeatureInput *" : return _fusion.DraftFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.DraftFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.DraftFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.DraftFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.DraftFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_DraftFeatureInput
    __del__ = lambda self : None;
    def _get_inputFaces(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepFace > > >" :
        """
        Gets and sets the input faces.
        If IsTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.
        """
        return _fusion.DraftFeatureInput__get_inputFaces(self)

    def _set_inputFaces(self, *args) -> "bool" :
        """
        Gets and sets the input faces.
        If IsTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.
        """
        return _fusion.DraftFeatureInput__set_inputFaces(self, *args)

    def _get_plane(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets and sets the plane that defines the direction in which the draft is applied. This can be a planar BrepFace, or a ConstructionPlane."""
        return _fusion.DraftFeatureInput__get_plane(self)

    def _set_plane(self, *args) -> "bool" :
        """Gets and sets the plane that defines the direction in which the draft is applied. This can be a planar BrepFace, or a ConstructionPlane."""
        return _fusion.DraftFeatureInput__set_plane(self, *args)

    def _get_isTangentChain(self) -> "bool" :
        """
        Gets and sets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities. It defaults to true.
        """
        return _fusion.DraftFeatureInput__get_isTangentChain(self)

    def _set_isTangentChain(self, *args) -> "bool" :
        """
        Gets and sets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities. It defaults to true.
        """
        return _fusion.DraftFeatureInput__set_isTangentChain(self, *args)

    def _get_isDirectionFlipped(self) -> "bool" :
        """Gets and sets if the direction of the draft is flipped."""
        return _fusion.DraftFeatureInput__get_isDirectionFlipped(self)

    def _set_isDirectionFlipped(self, *args) -> "bool" :
        """Gets and sets if the direction of the draft is flipped."""
        return _fusion.DraftFeatureInput__set_isDirectionFlipped(self, *args)

    def setSingleAngle(self, *args) -> "bool" :
        """
        Defines the draft to be defined so that a single angle is used for all drafts.
        If the isSymmetric is true then the faces are split along the parting plane and drafted
        independently using the same angle. 
        isSymmetric : Set to 'true' if the faces are to be split along the plane and drafted symmetrically. This 
        will have the side effect of setting the isSymmetric property to the same value. 
        angle : The ValueInput object that defines the angle of the draft. This can be a positive or negative
        value which will affect the direction of the draft along with the isDirectionFlipped property. 
        Returns true if successful
        """
        return _fusion.DraftFeatureInput_setSingleAngle(self, *args)

    def setTwoAngles(self, *args) -> "bool" :
        """
        Defines both angles to use when the surfaces are split along the draft plane and
        the faces on each side of the plane are drafted independently from the other side. 
        angleOne : The ValueInput object that defines the angle for the faces on the first side of the draft plane. 
        angleTwo : The ValueInput object that defines the angle for the faces on the second side of the draft plane. 
        Returns true if successful
        """
        return _fusion.DraftFeatureInput_setTwoAngles(self, *args)

    def _get_angleOne(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets the first, or the only angle in the case of a single angle definition."""
        return _fusion.DraftFeatureInput__get_angleOne(self)

    def _get_angleTwo(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets the second angle. This can be null in the case where a single angle definition is used."""
        return _fusion.DraftFeatureInput__get_angleTwo(self)

    def _get_isSymmetric(self) -> "bool" :
        """
        Gets if the draft is symmetric from the draft plane. This only applies in the case where two
        angles have been specified and should be ignored otherwise.
        """
        return _fusion.DraftFeatureInput__get_isSymmetric(self)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.DraftFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.DraftFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.DraftFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.DraftFeatureInput__get_isValid(self)
DraftFeatureInput_swigregister = _fusion.DraftFeatureInput_swigregister
DraftFeatureInput_swigregister(DraftFeatureInput)

def DraftFeatureInput_classType() -> "char const *" :
  return _fusion.DraftFeatureInput_classType()
DraftFeatureInput_classType = _fusion.DraftFeatureInput_classType

DraftFeatureInput.__swig_getmethods__["inputFaces"] = DraftFeatureInput._get_inputFaces
DraftFeatureInput.__swig_setmethods__["inputFaces"] = DraftFeatureInput._set_inputFaces
DraftFeatureInput.inputFaces = property(DraftFeatureInput._get_inputFaces, DraftFeatureInput._set_inputFaces, doc="Gets and sets the input faces.\nIf IsTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.")

DraftFeatureInput.__swig_getmethods__["plane"] = DraftFeatureInput._get_plane
DraftFeatureInput.__swig_setmethods__["plane"] = DraftFeatureInput._set_plane
DraftFeatureInput.plane = property(DraftFeatureInput._get_plane, DraftFeatureInput._set_plane, doc="Gets and sets the plane that defines the direction in which the draft is applied. This can be a planar BrepFace, or a ConstructionPlane.")

DraftFeatureInput.__swig_getmethods__["isTangentChain"] = DraftFeatureInput._get_isTangentChain
DraftFeatureInput.__swig_setmethods__["isTangentChain"] = DraftFeatureInput._set_isTangentChain
DraftFeatureInput.isTangentChain = property(DraftFeatureInput._get_isTangentChain, DraftFeatureInput._set_isTangentChain, doc="Gets and sets if any faces that are tangentially connected to any of\nthe input faces will also be included in setting InputEntities. It defaults to true.")

DraftFeatureInput.__swig_getmethods__["isDirectionFlipped"] = DraftFeatureInput._get_isDirectionFlipped
DraftFeatureInput.__swig_setmethods__["isDirectionFlipped"] = DraftFeatureInput._set_isDirectionFlipped
DraftFeatureInput.isDirectionFlipped = property(DraftFeatureInput._get_isDirectionFlipped, DraftFeatureInput._set_isDirectionFlipped, doc="Gets and sets if the direction of the draft is flipped.")

DraftFeatureInput.__swig_getmethods__["angleOne"] = DraftFeatureInput._get_angleOne
DraftFeatureInput.angleOne = property(DraftFeatureInput._get_angleOne, doc="Gets the first, or the only angle in the case of a single angle definition.")

DraftFeatureInput.__swig_getmethods__["angleTwo"] = DraftFeatureInput._get_angleTwo
DraftFeatureInput.angleTwo = property(DraftFeatureInput._get_angleTwo, doc="Gets the second angle. This can be null in the case where a single angle definition is used.")

DraftFeatureInput.__swig_getmethods__["isSymmetric"] = DraftFeatureInput._get_isSymmetric
DraftFeatureInput.isSymmetric = property(DraftFeatureInput._get_isSymmetric, doc="Gets if the draft is symmetric from the draft plane. This only applies in the case where two\nangles have been specified and should be ignored otherwise.")

DraftFeatureInput.__swig_getmethods__["targetBaseFeature"] = DraftFeatureInput._get_targetBaseFeature
DraftFeatureInput.__swig_setmethods__["targetBaseFeature"] = DraftFeatureInput._set_targetBaseFeature
DraftFeatureInput.targetBaseFeature = property(DraftFeatureInput._get_targetBaseFeature, DraftFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

DraftFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DraftFeatureInput) else None
DraftFeatureInput.cast = lambda arg: arg if isinstance(arg, DraftFeatureInput) else None

class DraftFeatures(Base):
    """
    Collection that provides access to all of the existing draft features in a component
    and supports the ability to create new draft features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DraftFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DraftFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::DraftFeatures *" : return _fusion.DraftFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.DraftFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.DraftFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.DraftFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::DraftFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.DraftFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.DraftFeatures_classType
    if _newclass:classType = staticmethod(_fusion.DraftFeatures_classType)
    __swig_destroy__ = _fusion.delete_DraftFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::DraftFeature >" :
        """
        Function that returns the specified draft feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.DraftFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of draft features in the collection."""
        return _fusion.DraftFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::DraftFeatureInput >" :
        """
        Creates a DraftFeatureInput object. Use properties and methods on this object
        to define the draft you want to create and then use the Add method, passing in 
        the DraftFeatureInput object. 
        inputFaces : BRepFace array that contains the faces to which draft will be applied.
        The picked point on face is always the point returned from pointOnFace property of the first BRepFace in this collection. 
        plane : Input object that defines the direction in which the draft is applied. This can be a planar BrepFace, or a ConstructionPlane. 
        isTangentChain : A boolean value for setting whether or not faces that are tangentially connected to 
        any of the input faces (if any) will also be included. It defaults to true. 
        Returns the newly created DraftFeatureInput object or null if the creation failed.
        """
        return _fusion.DraftFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::DraftFeature >" :
        """
        Creates a new draft feature. 
        input : A DraftFeatureInput object that defines the desired draft. Use the createInput 
        method to create a new DraftFeatureInput object and then use methods on it 
        (the DraftFeatureInput object) to define the draft. 
        Returns the newly created DraftFeature object or null if the creation failed.
        """
        return _fusion.DraftFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::DraftFeature >" :
        """
        Function that returns the specified draft feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.DraftFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.DraftFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.DraftFeatures__get_isValid(self)
DraftFeatures_swigregister = _fusion.DraftFeatures_swigregister
DraftFeatures_swigregister(DraftFeatures)

def DraftFeatures_classType() -> "char const *" :
  return _fusion.DraftFeatures_classType()
DraftFeatures_classType = _fusion.DraftFeatures_classType

DraftFeatures.__swig_getmethods__["count"] = DraftFeatures._get_count
DraftFeatures.count = property(DraftFeatures._get_count, doc="The number of draft features in the collection.")

DraftFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DraftFeatures) else None
DraftFeatures.cast = lambda arg: arg if isinstance(arg, DraftFeatures) else None

class ExportManager(Base):
    """Provides support for exporting model data to various formats."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExportManager, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExportManager, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ExportManager *" : return _fusion.ExportManager___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ExportManager___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ExportManager___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ExportManager_classType
    if _newclass:classType = staticmethod(_fusion.ExportManager_classType)
    __swig_destroy__ = _fusion.delete_ExportManager
    __del__ = lambda self : None;
    def createIGESExportOptions(self, *args) -> "adsk::core::Ptr< adsk::fusion::IGESExportOptions >" :
        """
        Creates an IGESExportOptions object that's used to export a design in IGES format. Creation
        of the IGESExportOptions object does not perform the export. You must pass this object to the
        ExportManager.execute method to perform the export. The IGESExportOptions supports any available
        options when exporting to IGES format. 
        filename : The filename of the IGES file to be created. 
        geometry : The geometry to export. Valid geometry for this is currently a Component object. This argument is optional
        and if not specified, it results in the root component and it entire contents being exported. 
        The created IGESExportOptions object or null if the creation failed.
        """
        return _fusion.ExportManager_createIGESExportOptions(self, *args)

    def createSTEPExportOptions(self, *args) -> "adsk::core::Ptr< adsk::fusion::STEPExportOptions >" :
        """
        Creates an STEPExportOptions object that's used to export a design in STEP format. Creation
        of the STEPExportOptions object does not perform the export. You must pass this object to the
        ExportManager.execute method to perform the export. The STEPExportOptions supports any available
        options when exporting to STEP format. 
        filename : The filename of the STEP file to be created. 
        geometry : The geometry to export. Valid geometry for this is currently a Component object. This argument is optional
        and if not specified, it results in the root component and it entire contents being exported. 
        The created STEPExportOptions object or null if the creation failed.
        """
        return _fusion.ExportManager_createSTEPExportOptions(self, *args)

    def createSATExportOptions(self, *args) -> "adsk::core::Ptr< adsk::fusion::SATExportOptions >" :
        """
        Creates an SATExportOptions object that's used to export a design in SAT format. Creation
        of the SATExportOptions object does not perform the export. You must pass this object to the
        ExportManager.execute method to perform the export. The SATExportOptions supports any available
        options when exporting to SAT format. 
        filename : The filename of the SAT file to be created. 
        geometry : The geometry to export. Valid geometry for this is currently a Component object. This argument is optional
        and if not specified, it results in the root component and it entire contents being exported. 
        The created SATExportOptions object or null if the creation failed.
        """
        return _fusion.ExportManager_createSATExportOptions(self, *args)

    def createSMTExportOptions(self, *args) -> "adsk::core::Ptr< adsk::fusion::SMTExportOptions >" :
        """
        Creates an SMTExportOptions object that's used to export a design in SMT format. Creation
        of the SMTExportOptions object does not perform the export. You must pass this object to the
        ExportManager.execute method to perform the export. The SMTExportOptions supports any available
        options when exporting to SMT format. 
        filename : The filename of the SMT file to be created. 
        geometry : The geometry to export. Valid geometry for this is currently a Component object. This argument is optional
        and if not specified, it results in the root component and it entire contents being exported. 
        The created SMTExportOptions object or null if the creation failed.
        """
        return _fusion.ExportManager_createSMTExportOptions(self, *args)

    def createFusionArchiveExportOptions(self, *args) -> "adsk::core::Ptr< adsk::fusion::FusionArchiveExportOptions >" :
        """
        Creates an FusionArchiveExportOptions object that's used to export a design in Fusion 360 archive format. Creation
        of the FusionArchiveExportOptions object does not perform the export. You must pass this object to the
        ExportManager.execute method to perform the export. The FusionArchiveExportOptions supports any available
        options when exporting to Fusion 360 archive format. 
        filename : The filename of the Fusion 360 archive file to be created. 
        geometry : The geometry to export. Valid geometry for this is currently a Component object. This argument is optional
        and if not specified, it results in the root component and it entire contents being exported. 
        The created FusionArchiveExportOptions object or null if the creation failed.
        """
        return _fusion.ExportManager_createFusionArchiveExportOptions(self, *args)

    def createSTLExportOptions(self, *args) -> "adsk::core::Ptr< adsk::fusion::STLExportOptions >" :
        """
        Creates an STLExportOptions object that's used to export a design in STL format. Creation
        of the STLExportOptions object does not perform the export. You must pass this object to the
        ExportManager.execute method to perform the export. 
        geometry : The geometry to export. This can be a BRepBody, Occurrence, or the root Component object. 
        filename : The filename of the STL file to be created. This is optional and can be left out if the mesh will be opened in a mesh editor. 
        The created createSTLExportOptions object or null if the creation failed.
        """
        return _fusion.ExportManager_createSTLExportOptions(self, *args)

    def execute(self, *args) -> "bool" :
        """
        Executes the export operation to create the file in the format specified by the input ExportOptions object. 
        exportOptions : An ExportOptions object that is created using one of the create methods on the ExportManager object. This
        defines the type of file and any available options supported for that file type. 
        Returns true if the export was successful.
        """
        return _fusion.ExportManager_execute(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ExportManager__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ExportManager__get_isValid(self)
ExportManager_swigregister = _fusion.ExportManager_swigregister
ExportManager_swigregister(ExportManager)

def ExportManager_classType() -> "char const *" :
  return _fusion.ExportManager_classType()
ExportManager_classType = _fusion.ExportManager_classType

ExportManager.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ExportManager) else None
ExportManager.cast = lambda arg: arg if isinstance(arg, ExportManager) else None

class ExportOptions(Base):
    """
    The base class for the different export types. This class is never directly used
    in an export because you need the specific export type to specify the type of
    export to be performed.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExportOptions, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExportOptions, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ExportOptions *" : return _fusion.ExportOptions___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ExportOptions___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ExportOptions___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ExportOptions_classType
    if _newclass:classType = staticmethod(_fusion.ExportOptions_classType)
    __swig_destroy__ = _fusion.delete_ExportOptions
    __del__ = lambda self : None;
    def _get_filename(self) -> "std::string" :
        """
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.ExportOptions__get_filename(self)

    def _set_filename(self, *args) -> "bool" :
        """
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.ExportOptions__set_filename(self, *args)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Specifies the geometry to export. This can be Occurrence, or the root Component. For STLExport, we also support BRepBody."""
        return _fusion.ExportOptions__get_geometry(self)

    def _set_geometry(self, *args) -> "bool" :
        """Specifies the geometry to export. This can be Occurrence, or the root Component. For STLExport, we also support BRepBody."""
        return _fusion.ExportOptions__set_geometry(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ExportOptions__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ExportOptions__get_isValid(self)
ExportOptions_swigregister = _fusion.ExportOptions_swigregister
ExportOptions_swigregister(ExportOptions)

def ExportOptions_classType() -> "char const *" :
  return _fusion.ExportOptions_classType()
ExportOptions_classType = _fusion.ExportOptions_classType

ExportOptions.__swig_getmethods__["filename"] = ExportOptions._get_filename
ExportOptions.__swig_setmethods__["filename"] = ExportOptions._set_filename
ExportOptions.filename = property(ExportOptions._get_filename, ExportOptions._set_filename, doc="Gets and sets the filename that the exported file will be written to. This can\nbe empty in the case of STL export and sending the result to the mesh editor.")

ExportOptions.__swig_getmethods__["geometry"] = ExportOptions._get_geometry
ExportOptions.__swig_setmethods__["geometry"] = ExportOptions._set_geometry
ExportOptions.geometry = property(ExportOptions._get_geometry, ExportOptions._set_geometry, doc="Specifies the geometry to export. This can be Occurrence, or the root Component. For STLExport, we also support BRepBody.")

ExportOptions.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ExportOptions) else None
ExportOptions.cast = lambda arg: arg if isinstance(arg, ExportOptions) else None

class ExtendFeatureInput(Base):
    """This class defines the methods and properties that pertain to the definition of a extend feature."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExtendFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExtendFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ExtendFeatureInput *" : return _fusion.ExtendFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ExtendFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ExtendFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ExtendFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.ExtendFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_ExtendFeatureInput
    __del__ = lambda self : None;
    def _get_edges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """Gets and sets the edges to extend"""
        return _fusion.ExtendFeatureInput__get_edges(self)

    def _set_edges(self, *args) -> "bool" :
        """Gets and sets the edges to extend"""
        return _fusion.ExtendFeatureInput__set_edges(self, *args)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets and sets the ValueInput object that defines the extend distance"""
        return _fusion.ExtendFeatureInput__get_distance(self)

    def _set_distance(self, *args) -> "bool" :
        """Gets and sets the ValueInput object that defines the extend distance"""
        return _fusion.ExtendFeatureInput__set_distance(self, *args)

    def _get_extendType(self) -> "adsk::fusion::SurfaceExtendTypes" :
        """Gets and sets surface extend type to use"""
        return _fusion.ExtendFeatureInput__get_extendType(self)

    def _set_extendType(self, *args) -> "bool" :
        """Gets and sets surface extend type to use"""
        return _fusion.ExtendFeatureInput__set_extendType(self, *args)

    def _get_isChainingEnabled(self) -> "bool" :
        """
        Gets and sets if all edges that are tangent or curvature continuous, and end point connected, will be found 
        automatically and extended.
        """
        return _fusion.ExtendFeatureInput__get_isChainingEnabled(self)

    def _set_isChainingEnabled(self, *args) -> "bool" :
        """
        Gets and sets if all edges that are tangent or curvature continuous, and end point connected, will be found 
        automatically and extended.
        """
        return _fusion.ExtendFeatureInput__set_isChainingEnabled(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ExtendFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ExtendFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ExtendFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ExtendFeatureInput__get_isValid(self)
ExtendFeatureInput_swigregister = _fusion.ExtendFeatureInput_swigregister
ExtendFeatureInput_swigregister(ExtendFeatureInput)

def ExtendFeatureInput_classType() -> "char const *" :
  return _fusion.ExtendFeatureInput_classType()
ExtendFeatureInput_classType = _fusion.ExtendFeatureInput_classType

ExtendFeatureInput.__swig_getmethods__["edges"] = ExtendFeatureInput._get_edges
ExtendFeatureInput.__swig_setmethods__["edges"] = ExtendFeatureInput._set_edges
ExtendFeatureInput.edges = property(ExtendFeatureInput._get_edges, ExtendFeatureInput._set_edges, doc="Gets and sets the edges to extend")

ExtendFeatureInput.__swig_getmethods__["distance"] = ExtendFeatureInput._get_distance
ExtendFeatureInput.__swig_setmethods__["distance"] = ExtendFeatureInput._set_distance
ExtendFeatureInput.distance = property(ExtendFeatureInput._get_distance, ExtendFeatureInput._set_distance, doc="Gets and sets the ValueInput object that defines the extend distance")

ExtendFeatureInput.__swig_getmethods__["extendType"] = ExtendFeatureInput._get_extendType
ExtendFeatureInput.__swig_setmethods__["extendType"] = ExtendFeatureInput._set_extendType
ExtendFeatureInput.extendType = property(ExtendFeatureInput._get_extendType, ExtendFeatureInput._set_extendType, doc="Gets and sets surface extend type to use")

ExtendFeatureInput.__swig_getmethods__["isChainingEnabled"] = ExtendFeatureInput._get_isChainingEnabled
ExtendFeatureInput.__swig_setmethods__["isChainingEnabled"] = ExtendFeatureInput._set_isChainingEnabled
ExtendFeatureInput.isChainingEnabled = property(ExtendFeatureInput._get_isChainingEnabled, ExtendFeatureInput._set_isChainingEnabled, doc="Gets and sets if all edges that are tangent or curvature continuous, and end point connected, will be found\nautomatically and extended.")

ExtendFeatureInput.__swig_getmethods__["targetBaseFeature"] = ExtendFeatureInput._get_targetBaseFeature
ExtendFeatureInput.__swig_setmethods__["targetBaseFeature"] = ExtendFeatureInput._set_targetBaseFeature
ExtendFeatureInput.targetBaseFeature = property(ExtendFeatureInput._get_targetBaseFeature, ExtendFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

ExtendFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ExtendFeatureInput) else None
ExtendFeatureInput.cast = lambda arg: arg if isinstance(arg, ExtendFeatureInput) else None

class ExtendFeatures(Base):
    """
    Collection that provides access to all of the existing Extend features in a component
    and supports the ability to create new Extend features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExtendFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExtendFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ExtendFeatures *" : return _fusion.ExtendFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ExtendFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ExtendFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.ExtendFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::ExtendFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.ExtendFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ExtendFeatures_classType
    if _newclass:classType = staticmethod(_fusion.ExtendFeatures_classType)
    __swig_destroy__ = _fusion.delete_ExtendFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::ExtendFeature >" :
        """
        Function that returns the specified extend feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ExtendFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of Extend features in the collection."""
        return _fusion.ExtendFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::ExtendFeatureInput >" :
        """
        Creates a ExtendFeatureInput object. Use properties and methods on this object
        to define the extend feature you want to create and then use the Add method, passing in 
        the ExtendFeatureInput object. 
        edges : The surface edges to extend.
        Only the outer edges from an open body can be extended. The edges must all be from the same body.
        Depending on the extend type there can also be some limitations on the edges being input as described below
        for the extendType argument. 
        distance : ValueInput object that defines the distance to extend the face/s.
        Natural and Tangent Extend types require a positive distance value.
        Perpendicular Extend Type supports either a positive or negative value to
        control the direction of the extend. A positive number results in the
        perpendicular extension being in the same direction as the positive normal
        of the connected faces. 
        extendType : The extension type to use when extending the face(s).
        Input edges must be connected at endpoints when Tangent or Perpendicular Extend Types are used. 
        Input edges need not be connected when Natural Extend type is used. 
        isChainingEnabled : An optional boolean argument whose default is true. If this argument is true, all edges that are 
        tangent or curvature continuous, and end point connected, will be found automatically and include
        in the set of edges to extend. 
        Returns the newly created ExtendFeatureInput object or null if the creation failed.
        """
        return _fusion.ExtendFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::ExtendFeature >" :
        """
        Creates a new extend feature. 
        input : An ExtendFeatureInput object that defines the desired extend feature. Use the createInput 
        method to create a new ExtendFeatureInput object and then use methods on it 
        (the ExtendFeatureInput object) to define the desired options for the extent feature. 
        Returns the newly created ExtendFeature object or null if the creation failed.
        """
        return _fusion.ExtendFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::ExtendFeature >" :
        """
        Function that returns the specified extend feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.ExtendFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ExtendFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ExtendFeatures__get_isValid(self)
ExtendFeatures_swigregister = _fusion.ExtendFeatures_swigregister
ExtendFeatures_swigregister(ExtendFeatures)

def ExtendFeatures_classType() -> "char const *" :
  return _fusion.ExtendFeatures_classType()
ExtendFeatures_classType = _fusion.ExtendFeatures_classType

ExtendFeatures.__swig_getmethods__["count"] = ExtendFeatures._get_count
ExtendFeatures.count = property(ExtendFeatures._get_count, doc="The number of Extend features in the collection.")

ExtendFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ExtendFeatures) else None
ExtendFeatures.cast = lambda arg: arg if isinstance(arg, ExtendFeatures) else None

class ExtentDefinition(Base):
    """The base class for the various definition objects used to define the extent of a feature."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExtentDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExtentDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ExtentDefinition *" : return _fusion.ExtentDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ExtentDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ExtentDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ExtentDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ExtentDefinition_classType)
    __swig_destroy__ = _fusion.delete_ExtentDefinition
    __del__ = lambda self : None;
    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        """
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.ExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ExtentDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ExtentDefinition__get_isValid(self)
ExtentDefinition_swigregister = _fusion.ExtentDefinition_swigregister
ExtentDefinition_swigregister(ExtentDefinition)

def ExtentDefinition_classType() -> "char const *" :
  return _fusion.ExtentDefinition_classType()
ExtentDefinition_classType = _fusion.ExtentDefinition_classType

ExtentDefinition.__swig_getmethods__["parentFeature"] = ExtentDefinition._get_parentFeature
ExtentDefinition.parentFeature = property(ExtentDefinition._get_parentFeature, doc="Returns the parent feature that this definition is associated with. If this definition has been created\nstatically and is not associated with a feature this property will return null.")

ExtentDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ExtentDefinition) else None
ExtentDefinition.cast = lambda arg: arg if isinstance(arg, ExtentDefinition) else None

class ExtrudeFeatureInput(Base):
    """
    This class defines the methods and properties that pertain to the definition of an extrude 
    feature. This class also provides properties for setting/getting the Profile and Operation 
    of the extrude. The Profile and Operation are defined when the ExtrudeFeatures.createInput 
    method is called so they do not exist as properties on this class.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExtrudeFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExtrudeFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ExtrudeFeatureInput *" : return _fusion.ExtrudeFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ExtrudeFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ExtrudeFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ExtrudeFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.ExtrudeFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_ExtrudeFeatureInput
    __del__ = lambda self : None;
    def _get_profile(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the profiles or planar faces used to define the shape of the extrude.
        This property can return or be set with a single profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        To create a surface (non-solid) extrusion, you can use the createOpenProfile and createBRepEdgeProfile
        methods of the Component object to create an open profile. The isSolid property of the
        ExtrudeFeatureInput property must also be False.
        """
        return _fusion.ExtrudeFeatureInput__get_profile(self)

    def _set_profile(self, *args) -> "bool" :
        """
        Gets and sets the profiles or planar faces used to define the shape of the extrude.
        This property can return or be set with a single profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        To create a surface (non-solid) extrusion, you can use the createOpenProfile and createBRepEdgeProfile
        methods of the Component object to create an open profile. The isSolid property of the
        ExtrudeFeatureInput property must also be False.
        """
        return _fusion.ExtrudeFeatureInput__set_profile(self, *args)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """Gets and sets the type of operation performed by the extrusion."""
        return _fusion.ExtrudeFeatureInput__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """Gets and sets the type of operation performed by the extrusion."""
        return _fusion.ExtrudeFeatureInput__set_operation(self, *args)

    def _get_taperAngle(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Gets and sets the taper angle of the extrusion. This is used to define the
        taper angle for a single sided and symmetric and defines the angle for side one
        of a two sided extrusion. This property is initialized with a taper angle of zero.
        A negative angle will taper the extrusion inward while a positive value will taper
        the extrusion outward. This property is valid for both parametric and non-parametric extrusions.
        """
        return _fusion.ExtrudeFeatureInput__get_taperAngle(self)

    def _set_taperAngle(self, *args) -> "bool" :
        """
        Gets and sets the taper angle of the extrusion. This is used to define the
        taper angle for a single sided and symmetric and defines the angle for side one
        of a two sided extrusion. This property is initialized with a taper angle of zero.
        A negative angle will taper the extrusion inward while a positive value will taper
        the extrusion outward. This property is valid for both parametric and non-parametric extrusions.
        """
        return _fusion.ExtrudeFeatureInput__set_taperAngle(self, *args)

    def setDistanceExtent(self, *args) -> "bool" :
        """
        Sets the extrusion extents option to 'Distance'. 
        isSymmetric : Set to 'true' for an extrusion symmetrical about the profile plane 
        distance : ValueInput object that defines the extrude distance.
        If the isSymmetric argument is 'false', a positive or negative distance can be used to control the direction. 
        Returns true if successful
        """
        return _fusion.ExtrudeFeatureInput_setDistanceExtent(self, *args)

    def setTwoSidesDistanceExtent(self, *args) -> "bool" :
        """
        Sets the extrusion extents option to 'Two Side'.
        This method will fail in the case of a non-parametric extrusion. 
        distanceOne : ValueInput object that defines the extrude distance for the first side. 
        distanceTwo : ValueInput object that defines the extrude distance for the second side. 
        Returns true if successful
        """
        return _fusion.ExtrudeFeatureInput_setTwoSidesDistanceExtent(self, *args)

    def setAllExtent(self, *args) -> "bool" :
        """
        Sets the extrusion extents option to 'All' (i.e. the extrusion is through-all, in both directions.)
        This method will fail in the case of a non-parametric extrusion. 
        direction : The direction can be either positive, negative, or symmetric. 
        Returns true if successful
        """
        return _fusion.ExtrudeFeatureInput_setAllExtent(self, *args)

    def setOneSideToExtent(self, *args) -> "bool" :
        """
        Sets the extrusion Direction option to 'One Side' and the Extents option to 'To' (a specified face) 
        toEntity : The entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For an extrude it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        matchShape : If the matchShape argument is 'true', the toEntity is extended to fully intersect the extrusion. 
        directionHint : Specifies the direction of the extrusion. This is only used in the case where there are two possible solutions and the extrusion can
        hit the toEntity in either direction. An example is if the profile of the extrusion is within a hole.
        The extrusion will intersect the cylinder of the hole in either direction.
        Typically there is only a single solution and the direction is determined automatically. 
        Returns true if successful.
        """
        return _fusion.ExtrudeFeatureInput_setOneSideToExtent(self, *args)

    def setTwoSidesToExtent(self, *args) -> "bool" :
        """
        Set the extrusion Direction option to 'Two Side'
        This method will fail in the case of a non-parametric extrusion. 
        toEntityOne : The first entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For an extrude it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        toEntityTwo : The second entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For an extrude it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        matchShape : If the matchShape argument is 'true', the toEntity is extended to fully intersect the extrusion. 
        Returns true if successful.
        """
        return _fusion.ExtrudeFeatureInput_setTwoSidesToExtent(self, *args)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Extrusion is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the Extrusion) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ExtrudeFeatureInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, *args) -> "bool" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Extrusion is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the Extrusion) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ExtrudeFeatureInput__set_creationOccurrence(self, *args)

    def _get_isSolid(self) -> "bool" :
        """
        Specifies if the extrusion should be created as a solid or surface. If
        it's a surface then there aren't any end caps and it's open. When a ExtrudeFeature
        input is created, this is initialized to true so a solid will be created if it's not changed.
        """
        return _fusion.ExtrudeFeatureInput__get_isSolid(self)

    def _set_isSolid(self, *args) -> "bool" :
        """
        Specifies if the extrusion should be created as a solid or surface. If
        it's a surface then there aren't any end caps and it's open. When a ExtrudeFeature
        input is created, this is initialized to true so a solid will be created if it's not changed.
        """
        return _fusion.ExtrudeFeatureInput__set_isSolid(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ExtrudeFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ExtrudeFeatureInput__set_targetBaseFeature(self, *args)

    def _get_startExtent(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >" :
        """
        Gets and sets the extent used to define the start of the extrusion. When a new ExtrudeFeatureInput
        object is created the start extent is initialized to be the profile plane but you can change it
        to a profile plane with offset or from an object by setting this property with either a 
        ProfilePlaneWithOffsetStartDefinition or a EntityStartDefinition object. You can get either one
        of those objects by using the static create method on the class.
        """
        return _fusion.ExtrudeFeatureInput__get_startExtent(self)

    def _set_startExtent(self, *args) -> "bool" :
        """
        Gets and sets the extent used to define the start of the extrusion. When a new ExtrudeFeatureInput
        object is created the start extent is initialized to be the profile plane but you can change it
        to a profile plane with offset or from an object by setting this property with either a 
        ProfilePlaneWithOffsetStartDefinition or a EntityStartDefinition object. You can get either one
        of those objects by using the static create method on the class.
        """
        return _fusion.ExtrudeFeatureInput__set_startExtent(self, *args)

    def setOneSideExtent(self, *args) -> "bool" :
        """
        Defines the extrusion to go in one direction from the profile. The extent of the extrusion is 
        defined by the extent argument. 
        extent : An ExtentDefinition object that defines how the extent of the extrusion is defined. This can be
        a specified distance (DistanceExtentDefinition), to an entity (ToEntityExtent), or through-all (AllExtentDefinition).
        These objects can be obtained by using the static create method on the appropriate class. 
        direction : Specifies the direction of the extrusion. PositiveExtentDirection and NegativeExtentDirection
        are valid values. PositiveExtentDirection is in the same direction as the normal of the profile's
        parent sketch plane. 
        taperAngle : Optional argument that specifies the taper angle. If omitted a taper angle of 0 is used. 
        Returns true is setting the input to a one sided extent was successful.
        """
        return _fusion.ExtrudeFeatureInput_setOneSideExtent(self, *args)

    def setTwoSidesExtent(self, *args) -> "bool" :
        """
        Defines the extrusion to go in both directions from the profile. The extent is defined independently
        for each direction using the input arguments. 
        sideOneExtent : An ExtentDefinition object that defines how the extent of the extrusion towards side one is defined. This can be
        a specified distance (DistanceExtentDefinition), to an entity (ToEntityExtent), or through-all (AllExtentDefinition).
        These objects can be obtained by using the static create method on the appropriate class. 
        sideTwoExtent : An ExtentDefinition object that defines how the extent of the extrusion towards side two is defined. This can be
        a specified distance (DistanceExtentDefinition), to an entity (ToEntityExtent), or through-all (AllExtentDefinition).
        These objects can be obtained by using the static create method on the appropriate class. 
        sideOneTaperAngle : Optional argument that specifies the taper angle for side one. If omitted a taper angle of 0 is used. 
        sideTwoTaperAngle : Optional argument that specifies the taper angle for side two. If omitted a taper angle of 0 is used. 
        Returns true is setting the extent was successful.
        """
        return _fusion.ExtrudeFeatureInput_setTwoSidesExtent(self, *args)

    def setSymmetricExtent(self, *args) -> "bool" :
        """
        Defines the extrusion to go symmetrically in both directions from the profile. 
        distance : The distance of the extrusions. This is either the full length of half of the length of the final extrusion
        depending on the value of the isFullLength property. 
        isFullLength : Defines if the value defines the full length of the extrusion or half of the length. A value of true indicates
        it defines the full length. 
        taperAngle : Optional argument that specifies the taper angle. The same taper angle is used for both sides for a symmetric 
        extrusion. If omitted a taper angle of 0 is used. 
        Returns true is setting the extent was successful.
        """
        return _fusion.ExtrudeFeatureInput_setSymmetricExtent(self, *args)

    def _get_extentOne(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >" :
        """
        Gets the extent assinged for a single sided extrude or side one of a two-sided extrusion. To set the extent, use
        one of the set methods on the ExtrudeFeatureInput object.
        """
        return _fusion.ExtrudeFeatureInput__get_extentOne(self)

    def _get_extentTwo(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >" :
        """
        Gets the extent assinged for side two of the extrusion. If the extrude is single sided extrude this
        property will return null. The hasTwoExtents property can be used to determine if there
        are two sides or not. To set the extent, use one of the set methods on the ExtrudeFeatureInput object.
        """
        return _fusion.ExtrudeFeatureInput__get_extentTwo(self)

    def _get_taperAngleOne(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Gets the value that will be used as the taper angle for a single sided extrusion or side one of a two-sided
        extrusion. To set the taper angle, use one of the set methods on the ExtrudeFeatureInput object.
        """
        return _fusion.ExtrudeFeatureInput__get_taperAngleOne(self)

    def _get_taperAngleTwo(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Gets the value that will be used as the taper angle for side two of a two-sided extrusion. If the extrusion is 
        single-sided, this property will return null. The hasTwoExtents property can be used to determine if there
        are two sides or not. To set the taper angle, use one of the set methods on the ExtrudeFeatureInput object.
        """
        return _fusion.ExtrudeFeatureInput__get_taperAngleTwo(self)

    def _get_hasTwoExtents(self) -> "bool" :
        """
        Property that indicates if the extrusion is a single or two-sided extrusion. If false, the extentTwo
        and taperAngleTwo properties should not be used.
        """
        return _fusion.ExtrudeFeatureInput__get_hasTwoExtents(self)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >" :
        """
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        feature will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.ExtrudeFeatureInput__get_participantBodies(self)

    def _set_participantBodies(self, *args) -> "bool" :
        """
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        feature will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.ExtrudeFeatureInput__set_participantBodies(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ExtrudeFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ExtrudeFeatureInput__get_isValid(self)
ExtrudeFeatureInput_swigregister = _fusion.ExtrudeFeatureInput_swigregister
ExtrudeFeatureInput_swigregister(ExtrudeFeatureInput)

def ExtrudeFeatureInput_classType() -> "char const *" :
  return _fusion.ExtrudeFeatureInput_classType()
ExtrudeFeatureInput_classType = _fusion.ExtrudeFeatureInput_classType

ExtrudeFeatureInput.__swig_getmethods__["profile"] = ExtrudeFeatureInput._get_profile
ExtrudeFeatureInput.__swig_setmethods__["profile"] = ExtrudeFeatureInput._set_profile
ExtrudeFeatureInput.profile = property(ExtrudeFeatureInput._get_profile, ExtrudeFeatureInput._set_profile, doc="Gets and sets the profiles or planar faces used to define the shape of the extrude.\nThis property can return or be set with a single profile, a single planar face, or\nan ObjectCollection consisting of multiple profiles and planar faces. When an\nObjectCollection is used all of the profiles and faces must be co-planar.\nTo create a surface (non-solid) extrusion, you can use the createOpenProfile and createBRepEdgeProfile\nmethods of the Component object to create an open profile. The isSolid property of the\nExtrudeFeatureInput property must also be False.")

ExtrudeFeatureInput.__swig_getmethods__["operation"] = ExtrudeFeatureInput._get_operation
ExtrudeFeatureInput.__swig_setmethods__["operation"] = ExtrudeFeatureInput._set_operation
ExtrudeFeatureInput.operation = property(ExtrudeFeatureInput._get_operation, ExtrudeFeatureInput._set_operation, doc="Gets and sets the type of operation performed by the extrusion.")

ExtrudeFeatureInput.__swig_getmethods__["taperAngle"] = ExtrudeFeatureInput._get_taperAngle
ExtrudeFeatureInput.__swig_setmethods__["taperAngle"] = ExtrudeFeatureInput._set_taperAngle
ExtrudeFeatureInput.taperAngle = property(ExtrudeFeatureInput._get_taperAngle, ExtrudeFeatureInput._set_taperAngle, doc="Gets and sets the taper angle of the extrusion. This is used to define the\ntaper angle for a single sided and symmetric and defines the angle for side one\nof a two sided extrusion. This property is initialized with a taper angle of zero.\nA negative angle will taper the extrusion inward while a positive value will taper\nthe extrusion outward. This property is valid for both parametric and non-parametric extrusions.")

ExtrudeFeatureInput.__swig_getmethods__["creationOccurrence"] = ExtrudeFeatureInput._get_creationOccurrence
ExtrudeFeatureInput.__swig_setmethods__["creationOccurrence"] = ExtrudeFeatureInput._set_creationOccurrence
ExtrudeFeatureInput.creationOccurrence = property(ExtrudeFeatureInput._get_creationOccurrence, ExtrudeFeatureInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the Extrusion is created based on geometry (e.g. a profile and/or face(s))\nin another component AND (the Extrusion) is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI")

ExtrudeFeatureInput.__swig_getmethods__["isSolid"] = ExtrudeFeatureInput._get_isSolid
ExtrudeFeatureInput.__swig_setmethods__["isSolid"] = ExtrudeFeatureInput._set_isSolid
ExtrudeFeatureInput.isSolid = property(ExtrudeFeatureInput._get_isSolid, ExtrudeFeatureInput._set_isSolid, doc="Specifies if the extrusion should be created as a solid or surface. If\nit's a surface then there aren't any end caps and it's open. When a ExtrudeFeature\ninput is created, this is initialized to true so a solid will be created if it's not changed.")

ExtrudeFeatureInput.__swig_getmethods__["targetBaseFeature"] = ExtrudeFeatureInput._get_targetBaseFeature
ExtrudeFeatureInput.__swig_setmethods__["targetBaseFeature"] = ExtrudeFeatureInput._set_targetBaseFeature
ExtrudeFeatureInput.targetBaseFeature = property(ExtrudeFeatureInput._get_targetBaseFeature, ExtrudeFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

ExtrudeFeatureInput.__swig_getmethods__["startExtent"] = ExtrudeFeatureInput._get_startExtent
ExtrudeFeatureInput.__swig_setmethods__["startExtent"] = ExtrudeFeatureInput._set_startExtent
ExtrudeFeatureInput.startExtent = property(ExtrudeFeatureInput._get_startExtent, ExtrudeFeatureInput._set_startExtent, doc="Gets and sets the extent used to define the start of the extrusion. When a new ExtrudeFeatureInput\nobject is created the start extent is initialized to be the profile plane but you can change it\nto a profile plane with offset or from an object by setting this property with either a\nProfilePlaneWithOffsetStartDefinition or a EntityStartDefinition object. You can get either one\nof those objects by using the static create method on the class.")

ExtrudeFeatureInput.__swig_getmethods__["extentOne"] = ExtrudeFeatureInput._get_extentOne
ExtrudeFeatureInput.extentOne = property(ExtrudeFeatureInput._get_extentOne, doc="Gets the extent assinged for a single sided extrude or side one of a two-sided extrusion. To set the extent, use\none of the set methods on the ExtrudeFeatureInput object.")

ExtrudeFeatureInput.__swig_getmethods__["extentTwo"] = ExtrudeFeatureInput._get_extentTwo
ExtrudeFeatureInput.extentTwo = property(ExtrudeFeatureInput._get_extentTwo, doc="Gets the extent assinged for side two of the extrusion. If the extrude is single sided extrude this\nproperty will return null. The hasTwoExtents property can be used to determine if there\nare two sides or not. To set the extent, use one of the set methods on the ExtrudeFeatureInput object.")

ExtrudeFeatureInput.__swig_getmethods__["taperAngleOne"] = ExtrudeFeatureInput._get_taperAngleOne
ExtrudeFeatureInput.taperAngleOne = property(ExtrudeFeatureInput._get_taperAngleOne, doc="Gets the value that will be used as the taper angle for a single sided extrusion or side one of a two-sided\nextrusion. To set the taper angle, use one of the set methods on the ExtrudeFeatureInput object.")

ExtrudeFeatureInput.__swig_getmethods__["taperAngleTwo"] = ExtrudeFeatureInput._get_taperAngleTwo
ExtrudeFeatureInput.taperAngleTwo = property(ExtrudeFeatureInput._get_taperAngleTwo, doc="Gets the value that will be used as the taper angle for side two of a two-sided extrusion. If the extrusion is\nsingle-sided, this property will return null. The hasTwoExtents property can be used to determine if there\nare two sides or not. To set the taper angle, use one of the set methods on the ExtrudeFeatureInput object.")

ExtrudeFeatureInput.__swig_getmethods__["hasTwoExtents"] = ExtrudeFeatureInput._get_hasTwoExtents
ExtrudeFeatureInput.hasTwoExtents = property(ExtrudeFeatureInput._get_hasTwoExtents, doc="Property that indicates if the extrusion is a single or two-sided extrusion. If false, the extentTwo\nand taperAngleTwo properties should not be used.")

ExtrudeFeatureInput.__swig_getmethods__["participantBodies"] = ExtrudeFeatureInput._get_participantBodies
ExtrudeFeatureInput.__swig_setmethods__["participantBodies"] = ExtrudeFeatureInput._set_participantBodies
ExtrudeFeatureInput.participantBodies = property(ExtrudeFeatureInput._get_participantBodies, ExtrudeFeatureInput._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.\nIf this property has not been set, the default behavior is that all bodies that are intersected by the\nfeature will participate.\nThis property can return null in the case where the feature has not been fully defined so that\npossible intersecting bodies can be computed.")

ExtrudeFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ExtrudeFeatureInput) else None
ExtrudeFeatureInput.cast = lambda arg: arg if isinstance(arg, ExtrudeFeatureInput) else None

class ExtrudeFeatures(Base):
    """
    Collection that provides access to all of the existing extrude features in a design
    and supports the ability to create new extrude features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExtrudeFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExtrudeFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ExtrudeFeatures *" : return _fusion.ExtrudeFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ExtrudeFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ExtrudeFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.ExtrudeFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::ExtrudeFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.ExtrudeFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ExtrudeFeatures_classType
    if _newclass:classType = staticmethod(_fusion.ExtrudeFeatures_classType)
    __swig_destroy__ = _fusion.delete_ExtrudeFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::ExtrudeFeature >" :
        """
        Function that returns the specified extrude feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ExtrudeFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of extrude features in the collection."""
        return _fusion.ExtrudeFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::ExtrudeFeatureInput >" :
        """
        Creates a new ExtrudeFeatureInput object that is used to specify the input needed
        to create a new extrude feature. 
        profile : The profile argument can be a single Profile, a single planar face, a single SketchText object,
        or an ObjectCollection consisting of multiple profiles, planar faces, and sketch texts.
        When an ObjectCollection is used all of the profiles, faces, and sketch texts must be co-planar.
        To create a surface (non-solid) extrusion, you can use the createOpenProfile and createBRepEdgeProfile
        methods of the Component object to create an open profile. You also need to set the isSolid property
        of the returned ExtrudeFeatureInput property to False. 
        operation : The feature operation to perform. 
        Returns the newly created ExtrudeFeatureInput object or null if the creation failed.
        """
        return _fusion.ExtrudeFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::ExtrudeFeature >" :
        """
        Creates a new extrude feature based on the information defined by the provided ExtrudeFeatureInput object.
        To create a new extrusion use the createInput function to create a new input object and use the methods and 
        properties on that object to define the required input for an extrusion. Once the information is defined on the
        input object you can pass it to the Add method to create the extrusion. 
        input : The ExtrudeFeatureInput object that specifies the input needed to create a new extrude 
        feature. 
        Returns the newly created ExtrudeFeature or null if the creation failed.
        """
        return _fusion.ExtrudeFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::ExtrudeFeature >" :
        """
        Function that returns the specified extrude feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.ExtrudeFeatures_itemByName(self, *args)

    def addSimple(self, *args) -> "adsk::core::Ptr< adsk::fusion::ExtrudeFeature >" :
        """
        Creates a basic extrusion that goes from the profile plane the specified distance. 
        profile : The profile argument can be a single Profile, a single planar face, a single SketchText object,
        or an ObjectCollection consisting of multiple profiles, planar faces, and sketch texts.
        When an ObjectCollection is used all of the profiles, faces, and sketch texts must be co-planar.
        To create a surface (non-solid) extrusion, you can use the createOpenProfile and createBRepEdgeProfile
        methods of the Component object to create an open profile. You also need to set the isSolid property
        of the returned ExtrudeFeatureInput property to False. 
        distance : ValueInput object that defines the extrude distance. A positive value extrudes in the positive direction
        of the sketch plane and negative value is in the opposite direction. 
        operation : The feature operation to perform. 
        Returns the newly created ExtrudeFeature or null if the creation failed.
        """
        return _fusion.ExtrudeFeatures_addSimple(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ExtrudeFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ExtrudeFeatures__get_isValid(self)
ExtrudeFeatures_swigregister = _fusion.ExtrudeFeatures_swigregister
ExtrudeFeatures_swigregister(ExtrudeFeatures)

def ExtrudeFeatures_classType() -> "char const *" :
  return _fusion.ExtrudeFeatures_classType()
ExtrudeFeatures_classType = _fusion.ExtrudeFeatures_classType

ExtrudeFeatures.__swig_getmethods__["count"] = ExtrudeFeatures._get_count
ExtrudeFeatures.count = property(ExtrudeFeatures._get_count, doc="The number of extrude features in the collection.")

ExtrudeFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ExtrudeFeatures) else None
ExtrudeFeatures.cast = lambda arg: arg if isinstance(arg, ExtrudeFeatures) else None

class Feature(Base):
    """Base class object representing all features."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Feature, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Feature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::Feature *" : return _fusion.Feature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Feature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Feature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Feature_classType
    if _newclass:classType = staticmethod(_fusion.Feature_classType)
    __swig_destroy__ = _fusion.delete_Feature
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.Feature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.Feature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.Feature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.Feature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.Feature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.Feature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.Feature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.Feature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.Feature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.Feature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.Feature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.Feature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.Feature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.Feature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.Feature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.Feature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.Feature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.Feature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Feature__get_isValid(self)
Feature_swigregister = _fusion.Feature_swigregister
Feature_swigregister(Feature)

def Feature_classType() -> "char const *" :
  return _fusion.Feature_classType()
Feature_classType = _fusion.Feature_classType

Feature.__swig_getmethods__["name"] = Feature._get_name
Feature.__swig_setmethods__["name"] = Feature._set_name
Feature.name = property(Feature._get_name, Feature._set_name, doc="Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric).")

Feature.__swig_getmethods__["isSuppressed"] = Feature._get_isSuppressed
Feature.__swig_setmethods__["isSuppressed"] = Feature._set_isSuppressed
Feature.isSuppressed = property(Feature._get_isSuppressed, Feature._set_isSuppressed, doc="Gets and sets if this feature is suppressed. This is only valid\nfor parametric features.")

Feature.__swig_getmethods__["isParametric"] = Feature._get_isParametric
Feature.isParametric = property(Feature._get_isParametric, doc="Indicates if this feature is parametric or not.")

Feature.__swig_getmethods__["faces"] = Feature._get_faces
Feature.faces = property(Feature._get_faces, doc="Returns the faces that were created by this feature.\nThis works for both parametric and non-parametric features.")

Feature.__swig_getmethods__["parentComponent"] = Feature._get_parentComponent
Feature.parentComponent = property(Feature._get_parentComponent, doc="Returns the parent component that owns this feature.")

Feature.__swig_getmethods__["linkedFeatures"] = Feature._get_linkedFeatures
Feature.linkedFeatures = property(Feature._get_linkedFeatures, doc="Returns the set of features that are linked to this feature. The set of linked features\nare all of the features that were created in various components as the result of a\nsingle feature being created in the user interface.")

Feature.__swig_getmethods__["assemblyContext"] = Feature._get_assemblyContext
Feature.assemblyContext = property(Feature._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")

Feature.__swig_getmethods__["timelineObject"] = Feature._get_timelineObject
Feature.timelineObject = property(Feature._get_timelineObject, doc="Returns the timeline object associated with this feature.")

Feature.__swig_getmethods__["bodies"] = Feature._get_bodies
Feature.bodies = property(Feature._get_bodies, doc="Returns the bodies that were modified or created by this feature.\nThis works for both parametric and non-parametric features. For a BaseFeature\nthis returns the bodies that are owned by the base feature.")

Feature.__swig_getmethods__["attributes"] = Feature._get_attributes
Feature.attributes = property(Feature._get_attributes, doc="Returns the collection of attributes associated with this face.")

Feature.__swig_getmethods__["baseFeature"] = Feature._get_baseFeature
Feature.baseFeature = property(Feature._get_baseFeature, doc="If this feature is associated with a base feature, this property will return that base feature.\nIf it's not associated with a base feature, this property will return null.")

Feature.__swig_getmethods__["healthState"] = Feature._get_healthState
Feature.healthState = property(Feature._get_healthState, doc="Returns the current health state of the feature.")

Feature.__swig_getmethods__["errorOrWarningMessage"] = Feature._get_errorOrWarningMessage
Feature.errorOrWarningMessage = property(Feature._get_errorOrWarningMessage, doc="Returns the error or warning message in the case where the healthState property returns either\nWarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.")

Feature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Feature) else None
Feature.cast = lambda arg: arg if isinstance(arg, Feature) else None

class FeatureList(Base):
    """
    Provides access to a list of features. This is used in the API to return
    a list of features from an API call.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FeatureList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FeatureList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::FeatureList *" : return _fusion.FeatureList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.FeatureList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.FeatureList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.FeatureList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.FeatureList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.FeatureList_classType
    if _newclass:classType = staticmethod(_fusion.FeatureList_classType)
    __swig_destroy__ = _fusion.delete_FeatureList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        """
        Returns the specified folder. 
        index : The index of the feature to return. The first feature in the list has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.FeatureList_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of features in this collection."""
        return _fusion.FeatureList__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.FeatureList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.FeatureList__get_isValid(self)
FeatureList_swigregister = _fusion.FeatureList_swigregister
FeatureList_swigregister(FeatureList)

def FeatureList_classType() -> "char const *" :
  return _fusion.FeatureList_classType()
FeatureList_classType = _fusion.FeatureList_classType

FeatureList.__swig_getmethods__["count"] = FeatureList._get_count
FeatureList.count = property(FeatureList._get_count, doc="The number of features in this collection.")

FeatureList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FeatureList) else None
FeatureList.cast = lambda arg: arg if isinstance(arg, FeatureList) else None

class Features(Base):
    """
    The features collection which provides access to all existing features. This collection
    provides direct access to all features regardless of type. It also provides access
    to type specific collections where you can get features of a specific type and also create
    new features of that type.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Features, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Features, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::Features *" : return _fusion.Features___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Features___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Features___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.Features___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.Features___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Features_classType
    if _newclass:classType = staticmethod(_fusion.Features_classType)
    __swig_destroy__ = _fusion.delete_Features
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        """
        Function that returns the specified feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.Features_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of bodies in the collection."""
        return _fusion.Features__get_count(self)

    def _get_extrudeFeatures(self) -> "adsk::core::Ptr< adsk::fusion::ExtrudeFeatures >" :
        """
        Returns the collection that provides access to the extrude features within the component 
        and supports the creation of new extrude features.
        """
        return _fusion.Features__get_extrudeFeatures(self)

    def _get_revolveFeatures(self) -> "adsk::core::Ptr< adsk::fusion::RevolveFeatures >" :
        """
        Returns the collection that provides access to the revolve features within the component 
        and supports the creation of new revolved features.
        """
        return _fusion.Features__get_revolveFeatures(self)

    def _get_holeFeatures(self) -> "adsk::core::Ptr< adsk::fusion::HoleFeatures >" :
        """
        Returns the collection that provides access to the hole features within the component
        and supports the creation of new hole features.
        """
        return _fusion.Features__get_holeFeatures(self)

    def _get_filletFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FilletFeatures >" :
        """
        Returns the collection that provides access to the fillet features within the component
        and supports the creation of new fillet features.
        """
        return _fusion.Features__get_filletFeatures(self)

    def _get_sweepFeatures(self) -> "adsk::core::Ptr< adsk::fusion::SweepFeatures >" :
        """
        Returns the collection that provides access to the sweep features within the component
        and supports the creation of new sweep features.
        """
        return _fusion.Features__get_sweepFeatures(self)

    def _get_chamferFeatures(self) -> "adsk::core::Ptr< adsk::fusion::ChamferFeatures >" :
        """
        Returns the collection that provides access to the chamfer features within the component
        and supports the creation of new chamfer features.
        """
        return _fusion.Features__get_chamferFeatures(self)

    def _get_shellFeatures(self) -> "adsk::core::Ptr< adsk::fusion::ShellFeatures >" :
        """
        Returns the collection that provides access to the shell features within the component
        and supports the creation of new shell features.
        """
        return _fusion.Features__get_shellFeatures(self)

    def _get_mirrorFeatures(self) -> "adsk::core::Ptr< adsk::fusion::MirrorFeatures >" :
        """
        Returns the collection that provides access to the mirror features within the component
        and supports the creation of new mirror features.
        """
        return _fusion.Features__get_mirrorFeatures(self)

    def _get_circularPatternFeatures(self) -> "adsk::core::Ptr< adsk::fusion::CircularPatternFeatures >" :
        """
        Returns the collection that provides access to the circular pattern features within the component
        and supports the creation of new circular pattern features.
        """
        return _fusion.Features__get_circularPatternFeatures(self)

    def _get_rectangularPatternFeatures(self) -> "adsk::core::Ptr< adsk::fusion::RectangularPatternFeatures >" :
        """
        Returns the collection that provides access to the rectangular pattern features within the component
        and supports the creation of new rectangular pattern features.
        """
        return _fusion.Features__get_rectangularPatternFeatures(self)

    def _get_pathPatternFeatures(self) -> "adsk::core::Ptr< adsk::fusion::PathPatternFeatures >" :
        """
        Returns the collection that provides access to the path pattern features within the component
        and supports the creation of new path pattern features.
        """
        return _fusion.Features__get_pathPatternFeatures(self)

    def _get_combineFeatures(self) -> "adsk::core::Ptr< adsk::fusion::CombineFeatures >" :
        """
        Returns the collection that provides access to the combine features within the component
        and supports the creation of new combine features.
        """
        return _fusion.Features__get_combineFeatures(self)

    def _get_threadFeatures(self) -> "adsk::core::Ptr< adsk::fusion::ThreadFeatures >" :
        """
        Returns the collection that provides access to the thread features within the component
        and supports the creation of new thread features.
        """
        return _fusion.Features__get_threadFeatures(self)

    def _get_draftFeatures(self) -> "adsk::core::Ptr< adsk::fusion::DraftFeatures >" :
        """
        Returns the collection that provides access to the draft features within the component
        and supports the creation of new draft features.
        """
        return _fusion.Features__get_draftFeatures(self)

    def _get_scaleFeatures(self) -> "adsk::core::Ptr< adsk::fusion::ScaleFeatures >" :
        """
        Returns the collection that provides access to the scale features within the component
        and supports the creation of new scale features.
        """
        return _fusion.Features__get_scaleFeatures(self)

    def createPath(self, *args) -> "adsk::core::Ptr< adsk::fusion::Path >" :
        """
        Method that creates a Path used to define the shape of a Sweep feature. A Path is a contiguous
        set of curves that can be a combination of sketch curves and model edges. 
        curve : A SketchCurve or an ObjectCollection containing multiple sketch entities and/or BRepEdge objects. If a single sketch curve
        or edge is input the isChain argument is checked to determine if connected curves (they do not need to be tangent)
        should be automatically found. If multiple curves are provided the isChain argument is always
        treated as false so you must provide all of the curves in the object collection that you want included in the path.
        The provided curves must all connect together in a single path.
        The input curves can be from multiple sketches and bodies and they need to geometrically connect for
        a valid path to be created. 
        isChain : Optional argument, that defaults to true. If this argument is set to true, all curves and edges that are end point 
        connected to the single input curve will be found and used to create the path.
        This argument is only used when the first argument is a single SketchCurve/BRepEdge object. 
        Returns the newly created Path.
        """
        return _fusion.Features_createPath(self, *args)

    def _get_replaceFaceFeatures(self) -> "adsk::core::Ptr< adsk::fusion::ReplaceFaceFeatures >" :
        """
        Returns the collection that provides access to the replaceFace features within the component
        and supports the creation of new replaceFace features.
        """
        return _fusion.Features__get_replaceFaceFeatures(self)

    def _get_moveFeatures(self) -> "adsk::core::Ptr< adsk::fusion::MoveFeatures >" :
        """
        Returns the collection that provides access to the Move features within the component
        and supports the creation of new Move features.
        """
        return _fusion.Features__get_moveFeatures(self)

    def _get_splitFaceFeatures(self) -> "adsk::core::Ptr< adsk::fusion::SplitFaceFeatures >" :
        """
        Returns the collection that provides access to the SplitFace features within the component and supports the creation
        of new SplitFace features
        """
        return _fusion.Features__get_splitFaceFeatures(self)

    def _get_splitBodyFeatures(self) -> "adsk::core::Ptr< adsk::fusion::SplitBodyFeatures >" :
        """
        Returns the collection that provides access to the SplitBody features within the component and supports the creation
        of new SplitBody features
        """
        return _fusion.Features__get_splitBodyFeatures(self)

    def _get_silhouetteSplitFeatures(self) -> "adsk::core::Ptr< adsk::fusion::SilhouetteSplitFeatures >" :
        """
        Returns the collection that provides access to the Parting Line Split features within the component and supports 
        the creation of new Parting Line Split features
        """
        return _fusion.Features__get_silhouetteSplitFeatures(self)

    def _get_offsetFeatures(self) -> "adsk::core::Ptr< adsk::fusion::OffsetFeatures >" :
        """
        Returns the collection that provides access to the Offset features within the component
        and supports the creation of new Offset features.
        """
        return _fusion.Features__get_offsetFeatures(self)

    def _get_extendFeatures(self) -> "adsk::core::Ptr< adsk::fusion::ExtendFeatures >" :
        """
        Returns the collection that provides access to the Extend features within the component
        and supports the creation of new Extend features.
        """
        return _fusion.Features__get_extendFeatures(self)

    def _get_stitchFeatures(self) -> "adsk::core::Ptr< adsk::fusion::StitchFeatures >" :
        """
        Returns the collection that provides access to the Stitch features within the component
        and supports the creation of new Stitch features.
        """
        return _fusion.Features__get_stitchFeatures(self)

    def _get_boundaryFillFeatures(self) -> "adsk::core::Ptr< adsk::fusion::BoundaryFillFeatures >" :
        """
        Returns the collection that provides access to the Boundary Fill features within the component
        and supports the creation of new Boundary Fill features.
        """
        return _fusion.Features__get_boundaryFillFeatures(self)

    def _get_trimFeatures(self) -> "adsk::core::Ptr< adsk::fusion::TrimFeatures >" :
        """
        Returns the collection that provides access to the Trim features within the component
        and supports the creation of new Trim features.
        """
        return _fusion.Features__get_trimFeatures(self)

    def _get_thickenFeatures(self) -> "adsk::core::Ptr< adsk::fusion::ThickenFeatures >" :
        """
        Returns the collection that provides access to the Thicken features within the component
        and supports the creation of new Thicken features.
        """
        return _fusion.Features__get_thickenFeatures(self)

    def _get_unstitchFeatures(self) -> "adsk::core::Ptr< adsk::fusion::UnstitchFeatures >" :
        """
        Returns the collection that provides access to the Unstitch features within the component
        and supports the creation of new Unstitch features.
        """
        return _fusion.Features__get_unstitchFeatures(self)

    def _get_removeFeatures(self) -> "adsk::core::Ptr< adsk::fusion::RemoveFeatures >" :
        """
        Returns the collection that provides access to the Remove features within the component
        and supports the creation of new Remove features.
        """
        return _fusion.Features__get_removeFeatures(self)

    def _get_baseFeatures(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeatures >" :
        """
        Returns the collection that provides access to the existing base features 
        and supports the creation of new base features. A base feature represents
        a body that is non-parametric.
        """
        return _fusion.Features__get_baseFeatures(self)

    def _get_coilFeatures(self) -> "adsk::core::Ptr< adsk::fusion::CoilFeatures >" :
        """Returns the collection that provides access to the Coil Primitive features within the component."""
        return _fusion.Features__get_coilFeatures(self)

    def _get_boxFeatures(self) -> "adsk::core::Ptr< adsk::fusion::BoxFeatures >" :
        """Returns the collection that provides access to the existing box features."""
        return _fusion.Features__get_boxFeatures(self)

    def _get_cylinderFeatures(self) -> "adsk::core::Ptr< adsk::fusion::CylinderFeatures >" :
        """Returns the collection that provides access to the existing cylinder features."""
        return _fusion.Features__get_cylinderFeatures(self)

    def _get_sphereFeatures(self) -> "adsk::core::Ptr< adsk::fusion::SphereFeatures >" :
        """Returns the collection that provides access to the existing sphere features."""
        return _fusion.Features__get_sphereFeatures(self)

    def _get_torusFeatures(self) -> "adsk::core::Ptr< adsk::fusion::TorusFeatures >" :
        """Returns the collection that provides access to the existing torus features."""
        return _fusion.Features__get_torusFeatures(self)

    def _get_pipeFeatues(self) -> "adsk::core::Ptr< adsk::fusion::PipeFeatures >" :
        """Returns the collection that provides access to the existing pipe features."""
        return _fusion.Features__get_pipeFeatues(self)

    def _get_ribFeatures(self) -> "adsk::core::Ptr< adsk::fusion::RibFeatures >" :
        """Returns the collection that provides access to the existing rib features."""
        return _fusion.Features__get_ribFeatures(self)

    def _get_webFeatures(self) -> "adsk::core::Ptr< adsk::fusion::WebFeatures >" :
        """Returns the collection that provides access to the existing web features."""
        return _fusion.Features__get_webFeatures(self)

    def _get_formFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FormFeatures >" :
        """Returns the collection that provides access to the existing form features."""
        return _fusion.Features__get_formFeatures(self)

    def _get_reverseNormalFeatures(self) -> "adsk::core::Ptr< adsk::fusion::ReverseNormalFeatures >" :
        """
        Returns the collection that provides access to the Reverse Normal features within the component
        and supports the creation of new Reverse Normal features.
        """
        return _fusion.Features__get_reverseNormalFeatures(self)

    def _get_patchFeatures(self) -> "adsk::core::Ptr< adsk::fusion::PatchFeatures >" :
        """
        Returns the collection that provides access to the Patch features within the component
        and supports the creation of new Patch features.
        """
        return _fusion.Features__get_patchFeatures(self)

    def _get_loftFeatures(self) -> "adsk::core::Ptr< adsk::fusion::LoftFeatures >" :
        """
        Returns the collection that provides access to the existing loft features and
        supports the creation of new loft features.
        """
        return _fusion.Features__get_loftFeatures(self)

    def _get_ruleFilletFeatures(self) -> "adsk::core::Ptr< adsk::fusion::RuleFilletFeatures >" :
        """Returns the collection that provides access to the existing form features."""
        return _fusion.Features__get_ruleFilletFeatures(self)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        """
        Function that returns the specified feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the same name seen in the timeline. 
        Returns the specified item or null if a feature matching the name was not found.
        """
        return _fusion.Features_itemByName(self, *args)

    def _get_surfaceDeleteFaceFeatures(self) -> "adsk::core::Ptr< adsk::fusion::SurfaceDeleteFaceFeatures >" :
        """Returns the collection that provides access to the existing Surface Delete Face features."""
        return _fusion.Features__get_surfaceDeleteFaceFeatures(self)

    def _get_deleteFaceFeatures(self) -> "adsk::core::Ptr< adsk::fusion::DeleteFaceFeatures >" :
        """Returns the collection that provides access to the existing Delete Face features."""
        return _fusion.Features__get_deleteFaceFeatures(self)

    def _get_offsetFacesFeatures(self) -> "adsk::core::Ptr< adsk::fusion::OffsetFacesFeatures >" :
        """Returns the collection that provides access to the existing Offset Face features."""
        return _fusion.Features__get_offsetFacesFeatures(self)

    def _get_copyPasteBodies(self) -> "adsk::core::Ptr< adsk::fusion::CopyPasteBodies >" :
        """
        Returns the collection that provides access to the existing copy-paste features
        and supports the creation of new copy-paste features.
        """
        return _fusion.Features__get_copyPasteBodies(self)

    def _get_cutPasteBodies(self) -> "adsk::core::Ptr< adsk::fusion::CutPasteBodies >" :
        """
        Returns the collection that provides access to the existing cut-paste features
        and supports the creation of new cut-paste features.
        """
        return _fusion.Features__get_cutPasteBodies(self)

    def _get_objectType(self) -> "char const *" : return _fusion.Features__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Features__get_isValid(self)
Features_swigregister = _fusion.Features_swigregister
Features_swigregister(Features)

def Features_classType() -> "char const *" :
  return _fusion.Features_classType()
Features_classType = _fusion.Features_classType

Features.__swig_getmethods__["count"] = Features._get_count
Features.count = property(Features._get_count, doc="Returns the number of bodies in the collection.")

Features.__swig_getmethods__["extrudeFeatures"] = Features._get_extrudeFeatures
Features.extrudeFeatures = property(Features._get_extrudeFeatures, doc="Returns the collection that provides access to the extrude features within the component\nand supports the creation of new extrude features.")

Features.__swig_getmethods__["revolveFeatures"] = Features._get_revolveFeatures
Features.revolveFeatures = property(Features._get_revolveFeatures, doc="Returns the collection that provides access to the revolve features within the component\nand supports the creation of new revolved features.")

Features.__swig_getmethods__["holeFeatures"] = Features._get_holeFeatures
Features.holeFeatures = property(Features._get_holeFeatures, doc="Returns the collection that provides access to the hole features within the component\nand supports the creation of new hole features.")

Features.__swig_getmethods__["filletFeatures"] = Features._get_filletFeatures
Features.filletFeatures = property(Features._get_filletFeatures, doc="Returns the collection that provides access to the fillet features within the component\nand supports the creation of new fillet features.")

Features.__swig_getmethods__["sweepFeatures"] = Features._get_sweepFeatures
Features.sweepFeatures = property(Features._get_sweepFeatures, doc="Returns the collection that provides access to the sweep features within the component\nand supports the creation of new sweep features.")

Features.__swig_getmethods__["chamferFeatures"] = Features._get_chamferFeatures
Features.chamferFeatures = property(Features._get_chamferFeatures, doc="Returns the collection that provides access to the chamfer features within the component\nand supports the creation of new chamfer features.")

Features.__swig_getmethods__["shellFeatures"] = Features._get_shellFeatures
Features.shellFeatures = property(Features._get_shellFeatures, doc="Returns the collection that provides access to the shell features within the component\nand supports the creation of new shell features.")

Features.__swig_getmethods__["mirrorFeatures"] = Features._get_mirrorFeatures
Features.mirrorFeatures = property(Features._get_mirrorFeatures, doc="Returns the collection that provides access to the mirror features within the component\nand supports the creation of new mirror features.")

Features.__swig_getmethods__["circularPatternFeatures"] = Features._get_circularPatternFeatures
Features.circularPatternFeatures = property(Features._get_circularPatternFeatures, doc="Returns the collection that provides access to the circular pattern features within the component\nand supports the creation of new circular pattern features.")

Features.__swig_getmethods__["rectangularPatternFeatures"] = Features._get_rectangularPatternFeatures
Features.rectangularPatternFeatures = property(Features._get_rectangularPatternFeatures, doc="Returns the collection that provides access to the rectangular pattern features within the component\nand supports the creation of new rectangular pattern features.")

Features.__swig_getmethods__["pathPatternFeatures"] = Features._get_pathPatternFeatures
Features.pathPatternFeatures = property(Features._get_pathPatternFeatures, doc="Returns the collection that provides access to the path pattern features within the component\nand supports the creation of new path pattern features.")

Features.__swig_getmethods__["combineFeatures"] = Features._get_combineFeatures
Features.combineFeatures = property(Features._get_combineFeatures, doc="Returns the collection that provides access to the combine features within the component\nand supports the creation of new combine features.")

Features.__swig_getmethods__["threadFeatures"] = Features._get_threadFeatures
Features.threadFeatures = property(Features._get_threadFeatures, doc="Returns the collection that provides access to the thread features within the component\nand supports the creation of new thread features.")

Features.__swig_getmethods__["draftFeatures"] = Features._get_draftFeatures
Features.draftFeatures = property(Features._get_draftFeatures, doc="Returns the collection that provides access to the draft features within the component\nand supports the creation of new draft features.")

Features.__swig_getmethods__["scaleFeatures"] = Features._get_scaleFeatures
Features.scaleFeatures = property(Features._get_scaleFeatures, doc="Returns the collection that provides access to the scale features within the component\nand supports the creation of new scale features.")

Features.__swig_getmethods__["replaceFaceFeatures"] = Features._get_replaceFaceFeatures
Features.replaceFaceFeatures = property(Features._get_replaceFaceFeatures, doc="Returns the collection that provides access to the replaceFace features within the component\nand supports the creation of new replaceFace features.")

Features.__swig_getmethods__["moveFeatures"] = Features._get_moveFeatures
Features.moveFeatures = property(Features._get_moveFeatures, doc="Returns the collection that provides access to the Move features within the component\nand supports the creation of new Move features.")

Features.__swig_getmethods__["splitFaceFeatures"] = Features._get_splitFaceFeatures
Features.splitFaceFeatures = property(Features._get_splitFaceFeatures, doc="Returns the collection that provides access to the SplitFace features within the component and supports the creation\nof new SplitFace features")

Features.__swig_getmethods__["splitBodyFeatures"] = Features._get_splitBodyFeatures
Features.splitBodyFeatures = property(Features._get_splitBodyFeatures, doc="Returns the collection that provides access to the SplitBody features within the component and supports the creation\nof new SplitBody features")

Features.__swig_getmethods__["silhouetteSplitFeatures"] = Features._get_silhouetteSplitFeatures
Features.silhouetteSplitFeatures = property(Features._get_silhouetteSplitFeatures, doc="Returns the collection that provides access to the Parting Line Split features within the component and supports\nthe creation of new Parting Line Split features")

Features.__swig_getmethods__["offsetFeatures"] = Features._get_offsetFeatures
Features.offsetFeatures = property(Features._get_offsetFeatures, doc="Returns the collection that provides access to the Offset features within the component\nand supports the creation of new Offset features.")

Features.__swig_getmethods__["extendFeatures"] = Features._get_extendFeatures
Features.extendFeatures = property(Features._get_extendFeatures, doc="Returns the collection that provides access to the Extend features within the component\nand supports the creation of new Extend features.")

Features.__swig_getmethods__["stitchFeatures"] = Features._get_stitchFeatures
Features.stitchFeatures = property(Features._get_stitchFeatures, doc="Returns the collection that provides access to the Stitch features within the component\nand supports the creation of new Stitch features.")

Features.__swig_getmethods__["boundaryFillFeatures"] = Features._get_boundaryFillFeatures
Features.boundaryFillFeatures = property(Features._get_boundaryFillFeatures, doc="Returns the collection that provides access to the Boundary Fill features within the component\nand supports the creation of new Boundary Fill features.")

Features.__swig_getmethods__["trimFeatures"] = Features._get_trimFeatures
Features.trimFeatures = property(Features._get_trimFeatures, doc="Returns the collection that provides access to the Trim features within the component\nand supports the creation of new Trim features.")

Features.__swig_getmethods__["thickenFeatures"] = Features._get_thickenFeatures
Features.thickenFeatures = property(Features._get_thickenFeatures, doc="Returns the collection that provides access to the Thicken features within the component\nand supports the creation of new Thicken features.")

Features.__swig_getmethods__["unstitchFeatures"] = Features._get_unstitchFeatures
Features.unstitchFeatures = property(Features._get_unstitchFeatures, doc="Returns the collection that provides access to the Unstitch features within the component\nand supports the creation of new Unstitch features.")

Features.__swig_getmethods__["removeFeatures"] = Features._get_removeFeatures
Features.removeFeatures = property(Features._get_removeFeatures, doc="Returns the collection that provides access to the Remove features within the component\nand supports the creation of new Remove features.")

Features.__swig_getmethods__["baseFeatures"] = Features._get_baseFeatures
Features.baseFeatures = property(Features._get_baseFeatures, doc="Returns the collection that provides access to the existing base features\nand supports the creation of new base features. A base feature represents\na body that is non-parametric.")

Features.__swig_getmethods__["coilFeatures"] = Features._get_coilFeatures
Features.coilFeatures = property(Features._get_coilFeatures, doc="Returns the collection that provides access to the Coil Primitive features within the component.")

Features.__swig_getmethods__["boxFeatures"] = Features._get_boxFeatures
Features.boxFeatures = property(Features._get_boxFeatures, doc="Returns the collection that provides access to the existing box features.")

Features.__swig_getmethods__["cylinderFeatures"] = Features._get_cylinderFeatures
Features.cylinderFeatures = property(Features._get_cylinderFeatures, doc="Returns the collection that provides access to the existing cylinder features.")

Features.__swig_getmethods__["sphereFeatures"] = Features._get_sphereFeatures
Features.sphereFeatures = property(Features._get_sphereFeatures, doc="Returns the collection that provides access to the existing sphere features.")

Features.__swig_getmethods__["torusFeatures"] = Features._get_torusFeatures
Features.torusFeatures = property(Features._get_torusFeatures, doc="Returns the collection that provides access to the existing torus features.")

Features.__swig_getmethods__["pipeFeatues"] = Features._get_pipeFeatues
Features.pipeFeatues = property(Features._get_pipeFeatues, doc="Returns the collection that provides access to the existing pipe features.")

Features.__swig_getmethods__["ribFeatures"] = Features._get_ribFeatures
Features.ribFeatures = property(Features._get_ribFeatures, doc="Returns the collection that provides access to the existing rib features.")

Features.__swig_getmethods__["webFeatures"] = Features._get_webFeatures
Features.webFeatures = property(Features._get_webFeatures, doc="Returns the collection that provides access to the existing web features.")

Features.__swig_getmethods__["formFeatures"] = Features._get_formFeatures
Features.formFeatures = property(Features._get_formFeatures, doc="Returns the collection that provides access to the existing form features.")

Features.__swig_getmethods__["reverseNormalFeatures"] = Features._get_reverseNormalFeatures
Features.reverseNormalFeatures = property(Features._get_reverseNormalFeatures, doc="Returns the collection that provides access to the Reverse Normal features within the component\nand supports the creation of new Reverse Normal features.")

Features.__swig_getmethods__["patchFeatures"] = Features._get_patchFeatures
Features.patchFeatures = property(Features._get_patchFeatures, doc="Returns the collection that provides access to the Patch features within the component\nand supports the creation of new Patch features.")

Features.__swig_getmethods__["loftFeatures"] = Features._get_loftFeatures
Features.loftFeatures = property(Features._get_loftFeatures, doc="Returns the collection that provides access to the existing loft features and\nsupports the creation of new loft features.")

Features.__swig_getmethods__["ruleFilletFeatures"] = Features._get_ruleFilletFeatures
Features.ruleFilletFeatures = property(Features._get_ruleFilletFeatures, doc="Returns the collection that provides access to the existing form features.")

Features.__swig_getmethods__["surfaceDeleteFaceFeatures"] = Features._get_surfaceDeleteFaceFeatures
Features.surfaceDeleteFaceFeatures = property(Features._get_surfaceDeleteFaceFeatures, doc="Returns the collection that provides access to the existing Surface Delete Face features.")

Features.__swig_getmethods__["deleteFaceFeatures"] = Features._get_deleteFaceFeatures
Features.deleteFaceFeatures = property(Features._get_deleteFaceFeatures, doc="Returns the collection that provides access to the existing Delete Face features.")

Features.__swig_getmethods__["offsetFacesFeatures"] = Features._get_offsetFacesFeatures
Features.offsetFacesFeatures = property(Features._get_offsetFacesFeatures, doc="Returns the collection that provides access to the existing Offset Face features.")

Features.__swig_getmethods__["copyPasteBodies"] = Features._get_copyPasteBodies
Features.copyPasteBodies = property(Features._get_copyPasteBodies, doc="Returns the collection that provides access to the existing copy-paste features\nand supports the creation of new copy-paste features.")

Features.__swig_getmethods__["cutPasteBodies"] = Features._get_cutPasteBodies
Features.cutPasteBodies = property(Features._get_cutPasteBodies, doc="Returns the collection that provides access to the existing cut-paste features\nand supports the creation of new cut-paste features.")

Features.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Features) else None
Features.cast = lambda arg: arg if isinstance(arg, Features) else None

class FilletEdgeSet(Base):
    """The base class for the classes that define the different types of fillet edge sets."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FilletEdgeSet, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FilletEdgeSet, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::FilletEdgeSet *" : return _fusion.FilletEdgeSet___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.FilletEdgeSet___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.FilletEdgeSet___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.FilletEdgeSet_classType
    if _newclass:classType = staticmethod(_fusion.FilletEdgeSet_classType)
    __swig_destroy__ = _fusion.delete_FilletEdgeSet
    __del__ = lambda self : None;
    def _get_objectType(self) -> "char const *" : return _fusion.FilletEdgeSet__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.FilletEdgeSet__get_isValid(self)
FilletEdgeSet_swigregister = _fusion.FilletEdgeSet_swigregister
FilletEdgeSet_swigregister(FilletEdgeSet)

def FilletEdgeSet_classType() -> "char const *" :
  return _fusion.FilletEdgeSet_classType()
FilletEdgeSet_classType = _fusion.FilletEdgeSet_classType

FilletEdgeSet.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FilletEdgeSet) else None
FilletEdgeSet.cast = lambda arg: arg if isinstance(arg, FilletEdgeSet) else None

class FilletEdgeSets(Base):
    """Collection that provides access to all of the existing fillet edge sets in a component"""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FilletEdgeSets, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FilletEdgeSets, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::FilletEdgeSets *" : return _fusion.FilletEdgeSets___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.FilletEdgeSets___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.FilletEdgeSets___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.FilletEdgeSets___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::FilletEdgeSet >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.FilletEdgeSets___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.FilletEdgeSets_classType
    if _newclass:classType = staticmethod(_fusion.FilletEdgeSets_classType)
    __swig_destroy__ = _fusion.delete_FilletEdgeSets
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::FilletEdgeSet >" :
        """
        Function that returns the specified fillet edge set using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.FilletEdgeSets_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of fillet edge sets in the collection."""
        return _fusion.FilletEdgeSets__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.FilletEdgeSets__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.FilletEdgeSets__get_isValid(self)
FilletEdgeSets_swigregister = _fusion.FilletEdgeSets_swigregister
FilletEdgeSets_swigregister(FilletEdgeSets)

def FilletEdgeSets_classType() -> "char const *" :
  return _fusion.FilletEdgeSets_classType()
FilletEdgeSets_classType = _fusion.FilletEdgeSets_classType

FilletEdgeSets.__swig_getmethods__["count"] = FilletEdgeSets._get_count
FilletEdgeSets.count = property(FilletEdgeSets._get_count, doc="The number of fillet edge sets in the collection.")

FilletEdgeSets.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FilletEdgeSets) else None
FilletEdgeSets.cast = lambda arg: arg if isinstance(arg, FilletEdgeSets) else None

class FilletFeatureInput(Base):
    """
    This class defines the methods and properties that pertain to the definition of a fillet 
    feature.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FilletFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FilletFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::FilletFeatureInput *" : return _fusion.FilletFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.FilletFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.FilletFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.FilletFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.FilletFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_FilletFeatureInput
    __del__ = lambda self : None;
    def addConstantRadiusEdgeSet(self, *args) -> "bool" :
        """
        Adds a set of edges with a constant radius to this input. 
        edges : An ObjectCollection containing the edges to be filleted. If the isTangentChain argument is true
        additional edges may also get filleted if they are tangentially connected to any of the 
        input edges. 
        radius : A ValueInput object that defines the radius of the fillet. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '2 in'). If no units are specified
        it is interpreted using the current default units for length. 
        isTangentChain : A boolean value for setting whether or not edges that are tangentially connected to 
        the input edges (if any) will also be filleted. 
        Returns true if the set of edges was successfully added to the FilletFeatureInput.
        """
        return _fusion.FilletFeatureInput_addConstantRadiusEdgeSet(self, *args)

    def addVariableRadiusEdgeSet(self, *args) -> "bool" :
        """
        Adds a single edge or set of tangent edges along with variable radius information to this input. 
        tangentEdges : An object collection containing a single edge or multiple edges. Multiple edges 
        must be tangentially connected and added to the collection in order. 
        startRadius : A ValueInput object that defines the starting radius of the fillet. If a single edge is
        being filleted, the start radius is at the start end of the edge. If multiple tangent
        edges are being filleted the start radius is the open end of the first edge in the
        collection.
        If the ValueInput uses a real then it is interpreted as centimeters. If it is a string then 
        the units can be defined as part of the string (i.e. '2 in'). If no units are specified
        it is interpreted using the current default units for length. 
        endRadius : A ValueInput object that defines the ending radius of the fillet. If a single edge is
        being filleted, the end radius is at the end of the edge. If multiple tangent
        edges are being filleted the end radius is the open end of the last edge in the
        collection.
        If the ValueInput uses a real then it is interpreted as centimeters. If it is a string then 
        the units can be defined as part of the string (i.e. '2 in'). If no units are specified
        it is interpreted using the current default units for length. 
        positions : An array of ValueInput objects that defines the positions of any additonal radii
        along the edge(s). The value must be between 0 and 1 and defines the percentage along the 
        curve where a radius is defined. The value is unitless. This array must have the same 
        number of values as the array passed in for the radii argument. 
        radii : An array of ValueInput objects that define the radii at positions along the edge(s).
        This array must have the same number of values as the array passed in for
        the positions argument. If the ValueInput uses a real then it is interpreted as centimeters.
        If it is a string then the units can be defined as part of the string (i.e. '2 in'). 
        If no units are specified it will be interpreted using the current default units for length. 
        Returns true if the edge set was successfully added to the FilletFeatureInput.
        """
        return _fusion.FilletFeatureInput_addVariableRadiusEdgeSet(self, *args)

    def _get_isG2(self) -> "bool" :
        """Gets and sets if the fillet uses the G2 (curvature-continuity) surface quality option ."""
        return _fusion.FilletFeatureInput__get_isG2(self)

    def _set_isG2(self, *args) -> "bool" :
        """Gets and sets if the fillet uses the G2 (curvature-continuity) surface quality option ."""
        return _fusion.FilletFeatureInput__set_isG2(self, *args)

    def _get_isRollingBallCorner(self) -> "bool" :
        """Gets and sets if a rolling ball solution is to be used in any corners."""
        return _fusion.FilletFeatureInput__get_isRollingBallCorner(self)

    def _set_isRollingBallCorner(self, *args) -> "bool" :
        """Gets and sets if a rolling ball solution is to be used in any corners."""
        return _fusion.FilletFeatureInput__set_isRollingBallCorner(self, *args)

    def _get_isTangentChain(self) -> "bool" :
        """
        Gets and sets if any edges that are tangentially connected to any of filleted
        edges will also be included in the fillet.
        """
        return _fusion.FilletFeatureInput__get_isTangentChain(self)

    def _set_isTangentChain(self, *args) -> "bool" :
        """
        Gets and sets if any edges that are tangentially connected to any of filleted
        edges will also be included in the fillet.
        """
        return _fusion.FilletFeatureInput__set_isTangentChain(self, *args)

    def addChordLengthEdgeSet(self, *args) -> "bool" :
        """
        Adds a set of edges with a chord length to this input. 
        edges : An ObjectCollection containing the edges to be filleted. If the isTangentChain argument is true
        additional edges may also get filleted if they are tangentially connected to any of the 
        input edges. 
        chordLength : A ValueInput object that defines the chord length of the fillet. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '2 in'). If no units are specified
        it is interpreted using the current default units for length. 
        isTangentChain : A boolean value for setting whether or not edges that are tangentially connected to 
        the input edges (if any) will also be filleted. 
        Returns true if the set of edges was successfully added to the FilletFeatureInput.
        """
        return _fusion.FilletFeatureInput_addChordLengthEdgeSet(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.FilletFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.FilletFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.FilletFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.FilletFeatureInput__get_isValid(self)
FilletFeatureInput_swigregister = _fusion.FilletFeatureInput_swigregister
FilletFeatureInput_swigregister(FilletFeatureInput)

def FilletFeatureInput_classType() -> "char const *" :
  return _fusion.FilletFeatureInput_classType()
FilletFeatureInput_classType = _fusion.FilletFeatureInput_classType

FilletFeatureInput.__swig_getmethods__["isG2"] = FilletFeatureInput._get_isG2
FilletFeatureInput.__swig_setmethods__["isG2"] = FilletFeatureInput._set_isG2
FilletFeatureInput.isG2 = property(FilletFeatureInput._get_isG2, FilletFeatureInput._set_isG2, doc="Gets and sets if the fillet uses the G2 (curvature-continuity) surface quality option .")

FilletFeatureInput.__swig_getmethods__["isRollingBallCorner"] = FilletFeatureInput._get_isRollingBallCorner
FilletFeatureInput.__swig_setmethods__["isRollingBallCorner"] = FilletFeatureInput._set_isRollingBallCorner
FilletFeatureInput.isRollingBallCorner = property(FilletFeatureInput._get_isRollingBallCorner, FilletFeatureInput._set_isRollingBallCorner, doc="Gets and sets if a rolling ball solution is to be used in any corners.")

FilletFeatureInput.__swig_getmethods__["isTangentChain"] = FilletFeatureInput._get_isTangentChain
FilletFeatureInput.__swig_setmethods__["isTangentChain"] = FilletFeatureInput._set_isTangentChain
FilletFeatureInput.isTangentChain = property(FilletFeatureInput._get_isTangentChain, FilletFeatureInput._set_isTangentChain, doc="Gets and sets if any edges that are tangentially connected to any of filleted\nedges will also be included in the fillet.")

FilletFeatureInput.__swig_getmethods__["targetBaseFeature"] = FilletFeatureInput._get_targetBaseFeature
FilletFeatureInput.__swig_setmethods__["targetBaseFeature"] = FilletFeatureInput._set_targetBaseFeature
FilletFeatureInput.targetBaseFeature = property(FilletFeatureInput._get_targetBaseFeature, FilletFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

FilletFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FilletFeatureInput) else None
FilletFeatureInput.cast = lambda arg: arg if isinstance(arg, FilletFeatureInput) else None

class FilletFeatures(Base):
    """
    Collection that provides access to all of the existing fillet features in a component
    and supports the ability to create new fillet features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FilletFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FilletFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::FilletFeatures *" : return _fusion.FilletFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.FilletFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.FilletFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.FilletFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::FilletFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.FilletFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.FilletFeatures_classType
    if _newclass:classType = staticmethod(_fusion.FilletFeatures_classType)
    __swig_destroy__ = _fusion.delete_FilletFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::FilletFeature >" :
        """
        Function that returns the specified fillet feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.FilletFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of fillet features in the collection."""
        return _fusion.FilletFeatures__get_count(self)

    def createInput(self) -> "adsk::core::Ptr< adsk::fusion::FilletFeatureInput >" :
        """
        Creates a FilletFeatureInput object. Use properties and methods on this object
        to define the fillet you want to create and then use the Add method, passing in 
        the FilletFeatureInput object. 
        Returns the newly created FilletFeatureInput object or null if the creation failed.
        """
        return _fusion.FilletFeatures_createInput(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::FilletFeature >" :
        """
        Creates a new fillet feature. 
        input : A FilletFeatureInput object that defines the desired fillet. Use the createInput 
        method to create a new FilletFeatureInput object and then use methods on it 
        (the FilletFeatureInput object) to define the fillet. 
        Returns the newly created FilletFeature object or null if the creation failed.
        """
        return _fusion.FilletFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::FilletFeature >" :
        """
        Function that returns the specified fillet feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.FilletFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.FilletFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.FilletFeatures__get_isValid(self)
FilletFeatures_swigregister = _fusion.FilletFeatures_swigregister
FilletFeatures_swigregister(FilletFeatures)

def FilletFeatures_classType() -> "char const *" :
  return _fusion.FilletFeatures_classType()
FilletFeatures_classType = _fusion.FilletFeatures_classType

FilletFeatures.__swig_getmethods__["count"] = FilletFeatures._get_count
FilletFeatures.count = property(FilletFeatures._get_count, doc="The number of fillet features in the collection.")

FilletFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FilletFeatures) else None
FilletFeatures.cast = lambda arg: arg if isinstance(arg, FilletFeatures) else None

class FormFeatures(Base):
    """Collection that provides access to all of the existing Form features in a component."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::FormFeatures *" : return _fusion.FormFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.FormFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.FormFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.FormFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::FormFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.FormFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.FormFeatures_classType
    if _newclass:classType = staticmethod(_fusion.FormFeatures_classType)
    __swig_destroy__ = _fusion.delete_FormFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::FormFeature >" :
        """
        Function that returns the specified Form feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.FormFeatures_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::FormFeature >" :
        """
        Function that returns the specified form feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.FormFeatures_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of Form features in the collection."""
        return _fusion.FormFeatures__get_count(self)

    def add(self) -> "adsk::core::Ptr< adsk::fusion::FormFeature >" :
        """
        Creates a new empty form feature in the parent component. 
        Returns the new FormFeature or null in the case of an error.
        """
        return _fusion.FormFeatures_add(self)

    def _get_objectType(self) -> "char const *" : return _fusion.FormFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.FormFeatures__get_isValid(self)
FormFeatures_swigregister = _fusion.FormFeatures_swigregister
FormFeatures_swigregister(FormFeatures)

def FormFeatures_classType() -> "char const *" :
  return _fusion.FormFeatures_classType()
FormFeatures_classType = _fusion.FormFeatures_classType

FormFeatures.__swig_getmethods__["count"] = FormFeatures._get_count
FormFeatures.count = property(FormFeatures._get_count, doc="The number of Form features in the collection.")

FormFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FormFeatures) else None
FormFeatures.cast = lambda arg: arg if isinstance(arg, FormFeatures) else None

class FusionDefaultUnitsPreferences(adsk.core.DefaultUnitsPreferences):
    """Fusion 360 Default Units for Design Preferences"""
    __swig_setmethods__ = {}
    for _s in [adsk.core.DefaultUnitsPreferences]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FusionDefaultUnitsPreferences, name, value)
    __swig_getmethods__ = {}
    for _s in [adsk.core.DefaultUnitsPreferences]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FusionDefaultUnitsPreferences, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::FusionDefaultUnitsPreferences *" : return _fusion.FusionDefaultUnitsPreferences___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.FusionDefaultUnitsPreferences___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.FusionDefaultUnitsPreferences___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.FusionDefaultUnitsPreferences_classType
    if _newclass:classType = staticmethod(_fusion.FusionDefaultUnitsPreferences_classType)
    __swig_destroy__ = _fusion.delete_FusionDefaultUnitsPreferences
    __del__ = lambda self : None;
    def _get_distanceDisplayUnits(self) -> "adsk::fusion::DistanceUnits" :
        """Gets and sets the default units for length when creating a new Fusion 360 file."""
        return _fusion.FusionDefaultUnitsPreferences__get_distanceDisplayUnits(self)

    def _set_distanceDisplayUnits(self, *args) -> "bool" :
        """Gets and sets the default units for length when creating a new Fusion 360 file."""
        return _fusion.FusionDefaultUnitsPreferences__set_distanceDisplayUnits(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of this DefaultUnitPreferences object."""
        return _fusion.FusionDefaultUnitsPreferences__get_name(self)

    def _get_objectType(self) -> "char const *" : return _fusion.FusionDefaultUnitsPreferences__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.FusionDefaultUnitsPreferences__get_isValid(self)
FusionDefaultUnitsPreferences_swigregister = _fusion.FusionDefaultUnitsPreferences_swigregister
FusionDefaultUnitsPreferences_swigregister(FusionDefaultUnitsPreferences)

def FusionDefaultUnitsPreferences_classType() -> "char const *" :
  return _fusion.FusionDefaultUnitsPreferences_classType()
FusionDefaultUnitsPreferences_classType = _fusion.FusionDefaultUnitsPreferences_classType

FusionDefaultUnitsPreferences.__swig_getmethods__["distanceDisplayUnits"] = FusionDefaultUnitsPreferences._get_distanceDisplayUnits
FusionDefaultUnitsPreferences.__swig_setmethods__["distanceDisplayUnits"] = FusionDefaultUnitsPreferences._set_distanceDisplayUnits
FusionDefaultUnitsPreferences.distanceDisplayUnits = property(FusionDefaultUnitsPreferences._get_distanceDisplayUnits, FusionDefaultUnitsPreferences._set_distanceDisplayUnits, doc="Gets and sets the default units for length when creating a new Fusion 360 file.")

FusionDefaultUnitsPreferences.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FusionDefaultUnitsPreferences) else None
FusionDefaultUnitsPreferences.cast = lambda arg: arg if isinstance(arg, FusionDefaultUnitsPreferences) else None

class FusionDocument(adsk.core.Document):
    """Object that represents a Fusion 360 specific document."""
    __swig_setmethods__ = {}
    for _s in [adsk.core.Document]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FusionDocument, name, value)
    __swig_getmethods__ = {}
    for _s in [adsk.core.Document]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FusionDocument, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::FusionDocument *" : return _fusion.FusionDocument___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.FusionDocument___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.FusionDocument___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.FusionDocument_classType
    if _newclass:classType = staticmethod(_fusion.FusionDocument_classType)
    __swig_destroy__ = _fusion.delete_FusionDocument
    __del__ = lambda self : None;
    def _get_design(self) -> "adsk::core::Ptr< adsk::fusion::Design >" :
        """Returns the design associated with this Fusion 360 document."""
        return _fusion.FusionDocument__get_design(self)

    def activate(self) -> "bool" :
        """
        Causes this document to become the active document in the user interface. 
        Returns true if the activation was successful.
        """
        return _fusion.FusionDocument_activate(self)

    def _get_name(self) -> "std::string" :
        """Gets and sets the name of the document."""
        return _fusion.FusionDocument__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Gets and sets the name of the document."""
        return _fusion.FusionDocument__set_name(self, *args)

    def close(self, *args) -> "bool" :
        """
        Closes this document. 
        saveChanges : This argument defines what the behavior of the close is when the document
        has been modified. If the document hasn't been modified then this argument
        is ignored and the document is closed. If the document has been modified
        and this argument is false then Fusion 360 will close the document and lose
        any changes. If the document has been modified and this argument is true then
        it will prompt the user if they want to save the changes or not, just the same
        as if the user was to interactively close the document. 
        Returns true if closing the document was successful.
        """
        return _fusion.FusionDocument_close(self, *args)

    def _get_isModified(self) -> "bool" :
        """Property that indicates if the document has been modified since it was last saved."""
        return _fusion.FusionDocument__get_isModified(self)

    def _get_isSaved(self) -> "bool" :
        """
        Property that indicates if this document has been saved or not. The initial save of
        a document requires that the name and location be specified and requires the saveAs method
        to be used. If the document has been saved then the save method can be used to save changes made.
        """
        return _fusion.FusionDocument__get_isSaved(self)

    def save(self, *args) -> "bool" :
        """
        Saves a version of the current document. You must use the SaveAs method the first
        time a document is saved. You can determine if a document has been saved by checking
        the value of the isSaved property. 
        description : The version description for this document 
        Returns true if saving the document was successful.
        """
        return _fusion.FusionDocument_save(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Application >" :
        """Returns the parent Application object."""
        return _fusion.FusionDocument__get_parent(self)

    def saveAs(self, *args) -> "bool" :
        """
        Performs a Save As on this document. This saves the currently open document to the specified
        location and this document becomes the saved document. If this is a new document that has 
        never been saved you must use the SaveAs method in order to specify the location and name. You
        can determine if the document has been saved by checking the value of the isSaved property. 
        name : The name to use for this document. If this is an empty string, Fusion 360 will use the default name
        assigned when the document was created. 
        dataFolder : The data folder to save this document to. 
        description : The description string of the document. This can be an empty string. 
        tag : The tag string of the document. This can be an empty string. 
        Returns true if the save as was successful.
        """
        return _fusion.FusionDocument_saveAs(self, *args)

    def _get_products(self) -> "adsk::core::Ptr< adsk::core::Products >" :
        """Returns the products associated with this document."""
        return _fusion.FusionDocument__get_products(self)

    def _get_isActive(self) -> "bool" :
        """Gets if this document is the active document in the user interface."""
        return _fusion.FusionDocument__get_isActive(self)

    def _get_isVisible(self) -> "bool" :
        """Gets if a currently open document is open as visible."""
        return _fusion.FusionDocument__get_isVisible(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this document."""
        return _fusion.FusionDocument__get_attributes(self)

    def _get_dataFile(self) -> "adsk::core::Ptr< adsk::core::DataFile >" :
        """Gets the DataFile that represents this document in A360."""
        return _fusion.FusionDocument__get_dataFile(self)

    def _get_version(self) -> "std::string" :
        """Returns the Fusion 360 version this document was last saved with."""
        return _fusion.FusionDocument__get_version(self)

    def _get_documentReferences(self) -> "adsk::core::Ptr< adsk::core::DocumentReferences >" :
        """
        Returns a collection containing the documents directly referenced
        by this document.
        """
        return _fusion.FusionDocument__get_documentReferences(self)

    def _get_isUpToDate(self) -> "bool" :
        """
        Indicates if any references in the assembly are out of date. This is the API 
        equivalent to the 'Out of Date' notification displayed in the Quick Access Toolbar.
        """
        return _fusion.FusionDocument__get_isUpToDate(self)

    def _get_allDocumentReferences(self) -> "adsk::core::Ptr< adsk::core::DocumentReferences >" :
        """
        Returns a collection containing all of the documents referenced directly
        by this document and those referenced by all sub-assemblies.
        """
        return _fusion.FusionDocument__get_allDocumentReferences(self)

    def _get_objectType(self) -> "char const *" : return _fusion.FusionDocument__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.FusionDocument__get_isValid(self)
FusionDocument_swigregister = _fusion.FusionDocument_swigregister
FusionDocument_swigregister(FusionDocument)

def FusionDocument_classType() -> "char const *" :
  return _fusion.FusionDocument_classType()
FusionDocument_classType = _fusion.FusionDocument_classType

FusionDocument.__swig_getmethods__["design"] = FusionDocument._get_design
FusionDocument.design = property(FusionDocument._get_design, doc="Returns the design associated with this Fusion 360 document.")

FusionDocument.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FusionDocument) else None
FusionDocument.cast = lambda arg: arg if isinstance(arg, FusionDocument) else None

class FusionProductPreferences(adsk.core.ProductPreferences):
    """Fusion 360 General Design Preferences"""
    __swig_setmethods__ = {}
    for _s in [adsk.core.ProductPreferences]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FusionProductPreferences, name, value)
    __swig_getmethods__ = {}
    for _s in [adsk.core.ProductPreferences]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FusionProductPreferences, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::FusionProductPreferences *" : return _fusion.FusionProductPreferences___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.FusionProductPreferences___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.FusionProductPreferences___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.FusionProductPreferences_classType
    if _newclass:classType = staticmethod(_fusion.FusionProductPreferences_classType)
    __swig_destroy__ = _fusion.delete_FusionProductPreferences
    __del__ = lambda self : None;
    def _get_isActiveComponentVisibilityUsed(self) -> "bool" :
        """Gets and sets the Active Component Visibility option"""
        return _fusion.FusionProductPreferences__get_isActiveComponentVisibilityUsed(self)

    def _set_isActiveComponentVisibilityUsed(self, *args) -> "bool" :
        """Gets and sets the Active Component Visibility option"""
        return _fusion.FusionProductPreferences__set_isActiveComponentVisibilityUsed(self, *args)

    def _get_defaultDesignType(self) -> "adsk::fusion::DefaultDesignTypeOptions" :
        """Gets and sets the Design History (default design type) setting"""
        return _fusion.FusionProductPreferences__get_defaultDesignType(self)

    def _set_defaultDesignType(self, *args) -> "bool" :
        """Gets and sets the Design History (default design type) setting"""
        return _fusion.FusionProductPreferences__set_defaultDesignType(self, *args)

    def _get_defaultWorkspace(self) -> "adsk::fusion::DefaultWorkspaces" :
        """Gets and sets the Default workspace setting. (Model, Sculpt or Patch)"""
        return _fusion.FusionProductPreferences__get_defaultWorkspace(self)

    def _set_defaultWorkspace(self, *args) -> "bool" :
        """Gets and sets the Default workspace setting. (Model, Sculpt or Patch)"""
        return _fusion.FusionProductPreferences__set_defaultWorkspace(self, *args)

    def _get_isJointPreviewAnimated(self) -> "bool" :
        """Gets and sets the Animate joint preview option"""
        return _fusion.FusionProductPreferences__get_isJointPreviewAnimated(self)

    def _set_isJointPreviewAnimated(self, *args) -> "bool" :
        """Gets and sets the Animate joint preview option"""
        return _fusion.FusionProductPreferences__set_isJointPreviewAnimated(self, *args)

    def _get_is3DSketchingAllowed(self) -> "bool" :
        """
        Gets and sets the Allow 3D sketching of lines and splines option
        which controls if 3D sketching is allowed or if sketching is forced to
        be on the x-y plane of the sketch.
        """
        return _fusion.FusionProductPreferences__get_is3DSketchingAllowed(self)

    def _set_is3DSketchingAllowed(self, *args) -> "bool" :
        """
        Gets and sets the Allow 3D sketching of lines and splines option
        which controls if 3D sketching is allowed or if sketching is forced to
        be on the x-y plane of the sketch.
        """
        return _fusion.FusionProductPreferences__set_is3DSketchingAllowed(self, *args)

    def _get_isGhostedResultBodyShown(self) -> "bool" :
        """Gets and sets the Show ghosted result body option"""
        return _fusion.FusionProductPreferences__get_isGhostedResultBodyShown(self)

    def _set_isGhostedResultBodyShown(self, *args) -> "bool" :
        """Gets and sets the Show ghosted result body option"""
        return _fusion.FusionProductPreferences__set_isGhostedResultBodyShown(self, *args)

    def _get_isDimensionEditedWhenCreated(self) -> "bool" :
        """Gets and sets if dimension value is edited when the dimension is created."""
        return _fusion.FusionProductPreferences__get_isDimensionEditedWhenCreated(self)

    def _set_isDimensionEditedWhenCreated(self, *args) -> "bool" :
        """Gets and sets if dimension value is edited when the dimension is created."""
        return _fusion.FusionProductPreferences__set_isDimensionEditedWhenCreated(self, *args)

    def _get_isAutoLookAtSketch(self) -> "bool" :
        """Gets and sets if the view is re-oriented to view the newly created sketch."""
        return _fusion.FusionProductPreferences__get_isAutoLookAtSketch(self)

    def _set_isAutoLookAtSketch(self, *args) -> "bool" :
        """Gets and sets if the view is re-oriented to view the newly created sketch."""
        return _fusion.FusionProductPreferences__set_isAutoLookAtSketch(self, *args)

    def _get_isAutoProjectGeometry(self) -> "bool" :
        """Gets and Sets if geometry, not in the active sketch plane, is to be automatically projected."""
        return _fusion.FusionProductPreferences__get_isAutoProjectGeometry(self)

    def _set_isAutoProjectGeometry(self, *args) -> "bool" :
        """Gets and Sets if geometry, not in the active sketch plane, is to be automatically projected."""
        return _fusion.FusionProductPreferences__set_isAutoProjectGeometry(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of this ProductPreferences object."""
        return _fusion.FusionProductPreferences__get_name(self)

    def _get_objectType(self) -> "char const *" : return _fusion.FusionProductPreferences__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.FusionProductPreferences__get_isValid(self)
FusionProductPreferences_swigregister = _fusion.FusionProductPreferences_swigregister
FusionProductPreferences_swigregister(FusionProductPreferences)

def FusionProductPreferences_classType() -> "char const *" :
  return _fusion.FusionProductPreferences_classType()
FusionProductPreferences_classType = _fusion.FusionProductPreferences_classType

FusionProductPreferences.__swig_getmethods__["isActiveComponentVisibilityUsed"] = FusionProductPreferences._get_isActiveComponentVisibilityUsed
FusionProductPreferences.__swig_setmethods__["isActiveComponentVisibilityUsed"] = FusionProductPreferences._set_isActiveComponentVisibilityUsed
FusionProductPreferences.isActiveComponentVisibilityUsed = property(FusionProductPreferences._get_isActiveComponentVisibilityUsed, FusionProductPreferences._set_isActiveComponentVisibilityUsed, doc="Gets and sets the Active Component Visibility option")

FusionProductPreferences.__swig_getmethods__["defaultDesignType"] = FusionProductPreferences._get_defaultDesignType
FusionProductPreferences.__swig_setmethods__["defaultDesignType"] = FusionProductPreferences._set_defaultDesignType
FusionProductPreferences.defaultDesignType = property(FusionProductPreferences._get_defaultDesignType, FusionProductPreferences._set_defaultDesignType, doc="Gets and sets the Design History (default design type) setting")

FusionProductPreferences.__swig_getmethods__["defaultWorkspace"] = FusionProductPreferences._get_defaultWorkspace
FusionProductPreferences.__swig_setmethods__["defaultWorkspace"] = FusionProductPreferences._set_defaultWorkspace
FusionProductPreferences.defaultWorkspace = property(FusionProductPreferences._get_defaultWorkspace, FusionProductPreferences._set_defaultWorkspace, doc="Gets and sets the Default workspace setting. (Model, Sculpt or Patch)")

FusionProductPreferences.__swig_getmethods__["isJointPreviewAnimated"] = FusionProductPreferences._get_isJointPreviewAnimated
FusionProductPreferences.__swig_setmethods__["isJointPreviewAnimated"] = FusionProductPreferences._set_isJointPreviewAnimated
FusionProductPreferences.isJointPreviewAnimated = property(FusionProductPreferences._get_isJointPreviewAnimated, FusionProductPreferences._set_isJointPreviewAnimated, doc="Gets and sets the Animate joint preview option")

FusionProductPreferences.__swig_getmethods__["is3DSketchingAllowed"] = FusionProductPreferences._get_is3DSketchingAllowed
FusionProductPreferences.__swig_setmethods__["is3DSketchingAllowed"] = FusionProductPreferences._set_is3DSketchingAllowed
FusionProductPreferences.is3DSketchingAllowed = property(FusionProductPreferences._get_is3DSketchingAllowed, FusionProductPreferences._set_is3DSketchingAllowed, doc="Gets and sets the Allow 3D sketching of lines and splines option\nwhich controls if 3D sketching is allowed or if sketching is forced to\nbe on the x-y plane of the sketch.")

FusionProductPreferences.__swig_getmethods__["isGhostedResultBodyShown"] = FusionProductPreferences._get_isGhostedResultBodyShown
FusionProductPreferences.__swig_setmethods__["isGhostedResultBodyShown"] = FusionProductPreferences._set_isGhostedResultBodyShown
FusionProductPreferences.isGhostedResultBodyShown = property(FusionProductPreferences._get_isGhostedResultBodyShown, FusionProductPreferences._set_isGhostedResultBodyShown, doc="Gets and sets the Show ghosted result body option")

FusionProductPreferences.__swig_getmethods__["isDimensionEditedWhenCreated"] = FusionProductPreferences._get_isDimensionEditedWhenCreated
FusionProductPreferences.__swig_setmethods__["isDimensionEditedWhenCreated"] = FusionProductPreferences._set_isDimensionEditedWhenCreated
FusionProductPreferences.isDimensionEditedWhenCreated = property(FusionProductPreferences._get_isDimensionEditedWhenCreated, FusionProductPreferences._set_isDimensionEditedWhenCreated, doc="Gets and sets if dimension value is edited when the dimension is created.")

FusionProductPreferences.__swig_getmethods__["isAutoLookAtSketch"] = FusionProductPreferences._get_isAutoLookAtSketch
FusionProductPreferences.__swig_setmethods__["isAutoLookAtSketch"] = FusionProductPreferences._set_isAutoLookAtSketch
FusionProductPreferences.isAutoLookAtSketch = property(FusionProductPreferences._get_isAutoLookAtSketch, FusionProductPreferences._set_isAutoLookAtSketch, doc="Gets and sets if the view is re-oriented to view the newly created sketch.")

FusionProductPreferences.__swig_getmethods__["isAutoProjectGeometry"] = FusionProductPreferences._get_isAutoProjectGeometry
FusionProductPreferences.__swig_setmethods__["isAutoProjectGeometry"] = FusionProductPreferences._set_isAutoProjectGeometry
FusionProductPreferences.isAutoProjectGeometry = property(FusionProductPreferences._get_isAutoProjectGeometry, FusionProductPreferences._set_isAutoProjectGeometry, doc="Gets and Sets if geometry, not in the active sketch plane, is to be automatically projected.")

FusionProductPreferences.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FusionProductPreferences) else None
FusionProductPreferences.cast = lambda arg: arg if isinstance(arg, FusionProductPreferences) else None

class FusionUnitsManager(adsk.core.UnitsManager):
    """
    Utility class used to work with Values and control default units. 
    Internal values are held in SI units (e.g. seconds, radians, kg for time, angle, mass) 
    with the exception that all lengths are in cm rather than meter and this affects derived 
    units (e.g. velocity is cm/s, volume is cm^3). Units are specified flexibly via strings 
    (e.g. 'cm', 'in', 'inch', 'cm^3', 'cm*cm*cm', 'mph', 'mps' 'm/s').
    """
    __swig_setmethods__ = {}
    for _s in [adsk.core.UnitsManager]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FusionUnitsManager, name, value)
    __swig_getmethods__ = {}
    for _s in [adsk.core.UnitsManager]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FusionUnitsManager, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::FusionUnitsManager *" : return _fusion.FusionUnitsManager___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.FusionUnitsManager___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.FusionUnitsManager___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.FusionUnitsManager_classType
    if _newclass:classType = staticmethod(_fusion.FusionUnitsManager_classType)
    __swig_destroy__ = _fusion.delete_FusionUnitsManager
    __del__ = lambda self : None;
    def _get_design(self) -> "adsk::core::Ptr< adsk::fusion::Design >" :
        """Returns the the parent design"""
        return _fusion.FusionUnitsManager__get_design(self)

    def _get_distanceDisplayUnits(self) -> "adsk::fusion::DistanceUnits" :
        """Gets and sets the default distance units for this design."""
        return _fusion.FusionUnitsManager__get_distanceDisplayUnits(self)

    def _set_distanceDisplayUnits(self, *args) -> "bool" :
        """Gets and sets the default distance units for this design."""
        return _fusion.FusionUnitsManager__set_distanceDisplayUnits(self, *args)

    def _get_product(self) -> "adsk::core::Ptr< adsk::core::Product >" :
        """Returns the parent Product."""
        return _fusion.FusionUnitsManager__get_product(self)

    def isValidExpression(self, *args) -> "bool" :
        """
        Checks to see if the given expression is valid. 
        expression : 
        units : The units to use when validating the expression. 
        Returns True if it is a valid expression.
        """
        return _fusion.FusionUnitsManager_isValidExpression(self, *args)

    def evaluateExpression(self, *args) -> "double" :
        """
        Gets the value (in internal units) of the expression. 
        expression : EvaluateExpression('1cm + 1in') -> 3.54
        EvaluateExpression('1') -> -> depends on the DistanceUnits, with 'mm' it gives 0.1 
        units : If not supplied the units will default to the default length specified in the preferences. 
        Returns -1 AND GetLastError will return ExpressionError in the event of an error.
        """
        return _fusion.FusionUnitsManager_evaluateExpression(self, *args)

    def convert(self, *args) -> "double" :
        """
        Converts a value from one unit to another. The input and output unit specifiers must be compatible.
        For example, 'in' (inches) and 'cm' (centimeters) will work because they both define length. 
        So Convert(1.5, 'in', 'ft') -> 0.125
        Convert(1.5, unitsManager.defaultLengthUnits, 'cm') -> depends on the current default distance units, with 'mm' it gives 0.15
        So Convert(1.5, 'in', 'kg') -> -1 and GetLastError returns ExpressionError (to denote error)
        So Convert(1, 'in', 'internalUnits') -> 2.54
        So Convert(1, 'internalUnits', 'in') -> 0.3937... 
        valueInInputUnits : The value to convert 
        inputUnits : The units of the value to convert 
        outputUnits : The units to convert the value to 
        Returns -1 AND GetLastError returns ExpressionError in the event of an error.
        """
        return _fusion.FusionUnitsManager_convert(self, *args)

    def formatInternalValue(self, *args) -> "std::string" :
        """
        Formats the internal value as a string. The output string is formatted using the current 
        unit settings in preferences. The preferences control the number of decimal places, whether 
        units are abbreviated and several other things.
        FormatInternalValue(1.5, 'in') -> '0.591 in'
        FormatInternalValue(1.5, 'in', false) -> '0.591'
        FormatInternalValue(1.5, 'mm', true) -> '15.00 mm'
        FormatInternalValue(1.5) -> depends on DistanceUnits, might be '15.0 mm' 
        internalValue : The internal value to format. 
        displayUnits : The units to display the value in. If not supplied the units will default to the default length specified in the preferences. 
        showUnits : Specify false to exclude units from the format. The default is true. 
        Returns an empty string if the units are incorrectly specified.
        """
        return _fusion.FusionUnitsManager_formatInternalValue(self, *args)

    def formatUnits(self, *args) -> "std::string" :
        """
        Formats the unit according to the user preferences
        'centimeter' -> 'cm'
        'inch' -> 'in'
        'cm* cm *cm / s' -> , 'cm^3 / s' 
        units : The unit to use when converting the value into a string. 
        Returns an empty string and GetLastError returns ExpressionError in the event of an error.
        """
        return _fusion.FusionUnitsManager_formatUnits(self, *args)

    def standardizeExpression(self, *args) -> "std::string" :
        """
        Standardizes the expression in terms of spacing and user preferences. 
        StandardizeExpression('1.5') -> depends on distance units, but with mmight be '1.5 mm'
        StandardizeExpression('1.5', 'in') -> '1.5 in'
        StandardizeExpression('1.5 cm + 1.50001 centimeter') -> '1.5 cm + 1.50001 cm'
        StandardizeExpression('1.5', 'm * m * m / s') -> '1.5 m^3 /s' 
        expression : The expression to standardize 
        units : The units to apply to the standardized expression. If not supplied the units will default to the default length specified in the preferences. 
        Returns an empty string AND GetLastError returns ExpressionError in the event of an error.
        """
        return _fusion.FusionUnitsManager_standardizeExpression(self, *args)

    def _get_internalUnits(self) -> "std::string" :
        """
        Returns a string that represents internal units - i.e. 'internalUnits'. 
        This can be used when performing conversions via Convert.
        """
        return _fusion.FusionUnitsManager__get_internalUnits(self)

    def _get_defaultLengthUnits(self) -> "std::string" :
        """
        Returns the unit strings for the current default length unit as specified in preferences. - e.g. 'cm' or 'in'
        This is the string that is being used by Fusion 360 to represent the current length unit and is affected
        by the preference settings that let the user choose whether abbrevations and symbols can be used. This means
        that inch length units can be returned as inch, in, or '. If you need a consistent way of determing the current
        length unit, the distanceDisplayUnits of the FusionUnitsManager object returns an enum value.
        """
        return _fusion.FusionUnitsManager__get_defaultLengthUnits(self)

    def _get_objectType(self) -> "char const *" : return _fusion.FusionUnitsManager__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.FusionUnitsManager__get_isValid(self)
FusionUnitsManager_swigregister = _fusion.FusionUnitsManager_swigregister
FusionUnitsManager_swigregister(FusionUnitsManager)

def FusionUnitsManager_classType() -> "char const *" :
  return _fusion.FusionUnitsManager_classType()
FusionUnitsManager_classType = _fusion.FusionUnitsManager_classType

FusionUnitsManager.__swig_getmethods__["design"] = FusionUnitsManager._get_design
FusionUnitsManager.design = property(FusionUnitsManager._get_design, doc="Returns the the parent design")

FusionUnitsManager.__swig_getmethods__["distanceDisplayUnits"] = FusionUnitsManager._get_distanceDisplayUnits
FusionUnitsManager.__swig_setmethods__["distanceDisplayUnits"] = FusionUnitsManager._set_distanceDisplayUnits
FusionUnitsManager.distanceDisplayUnits = property(FusionUnitsManager._get_distanceDisplayUnits, FusionUnitsManager._set_distanceDisplayUnits, doc="Gets and sets the default distance units for this design.")

FusionUnitsManager.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FusionUnitsManager) else None
FusionUnitsManager.cast = lambda arg: arg if isinstance(arg, FusionUnitsManager) else None

class GeometricConstraint(Base):
    """The base class for all geometric constraints."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GeometricConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GeometricConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::GeometricConstraint *" : return _fusion.GeometricConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.GeometricConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.GeometricConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.GeometricConstraint_classType
    if _newclass:classType = staticmethod(_fusion.GeometricConstraint_classType)
    __swig_destroy__ = _fusion.delete_GeometricConstraint
    __del__ = lambda self : None;
    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.GeometricConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.GeometricConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.GeometricConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.GeometricConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.GeometricConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.GeometricConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.GeometricConstraint__get_isValid(self)
GeometricConstraint_swigregister = _fusion.GeometricConstraint_swigregister
GeometricConstraint_swigregister(GeometricConstraint)

def GeometricConstraint_classType() -> "char const *" :
  return _fusion.GeometricConstraint_classType()
GeometricConstraint_classType = _fusion.GeometricConstraint_classType

GeometricConstraint.__swig_getmethods__["isDeletable"] = GeometricConstraint._get_isDeletable
GeometricConstraint.isDeletable = property(GeometricConstraint._get_isDeletable, doc="Indicates if this constraint is deletable.")

GeometricConstraint.__swig_getmethods__["parentSketch"] = GeometricConstraint._get_parentSketch
GeometricConstraint.parentSketch = property(GeometricConstraint._get_parentSketch, doc="Returns the parent sketch object.")

GeometricConstraint.__swig_getmethods__["assemblyContext"] = GeometricConstraint._get_assemblyContext
GeometricConstraint.assemblyContext = property(GeometricConstraint._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")

GeometricConstraint.__swig_getmethods__["attributes"] = GeometricConstraint._get_attributes
GeometricConstraint.attributes = property(GeometricConstraint._get_attributes, doc="Returns the collection of attributes associated with this geometric constraint.")

GeometricConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, GeometricConstraint) else None
GeometricConstraint.cast = lambda arg: arg if isinstance(arg, GeometricConstraint) else None

class GeometricConstraintList(Base):
    """A list of geometric constraints."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GeometricConstraintList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GeometricConstraintList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::GeometricConstraintList *" : return _fusion.GeometricConstraintList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.GeometricConstraintList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.GeometricConstraintList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.GeometricConstraintList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraint >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.GeometricConstraintList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.GeometricConstraintList_classType
    if _newclass:classType = staticmethod(_fusion.GeometricConstraintList_classType)
    __swig_destroy__ = _fusion.delete_GeometricConstraintList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraint >" :
        """
        Function that returns the specified geometry constraint using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.GeometricConstraintList_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of constraints in the sketch."""
        return _fusion.GeometricConstraintList__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.GeometricConstraintList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.GeometricConstraintList__get_isValid(self)
GeometricConstraintList_swigregister = _fusion.GeometricConstraintList_swigregister
GeometricConstraintList_swigregister(GeometricConstraintList)

def GeometricConstraintList_classType() -> "char const *" :
  return _fusion.GeometricConstraintList_classType()
GeometricConstraintList_classType = _fusion.GeometricConstraintList_classType

GeometricConstraintList.__swig_getmethods__["count"] = GeometricConstraintList._get_count
GeometricConstraintList.count = property(GeometricConstraintList._get_count, doc="Returns the number of constraints in the sketch.")

GeometricConstraintList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, GeometricConstraintList) else None
GeometricConstraintList.cast = lambda arg: arg if isinstance(arg, GeometricConstraintList) else None

class GeometricConstraints(Base):
    """
    A collection of all of the geometric constraints in a sketch. This object
    also supports the methods to create new geometric constraints.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GeometricConstraints, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GeometricConstraints, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::GeometricConstraints *" : return _fusion.GeometricConstraints___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.GeometricConstraints___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.GeometricConstraints___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.GeometricConstraints___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraint >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.GeometricConstraints___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.GeometricConstraints_classType
    if _newclass:classType = staticmethod(_fusion.GeometricConstraints_classType)
    __swig_destroy__ = _fusion.delete_GeometricConstraints
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraint >" :
        """
        Function that returns the specified sketch constraint using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.GeometricConstraints_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of constraints in the sketch."""
        return _fusion.GeometricConstraints__get_count(self)

    def addCoincident(self, *args) -> "adsk::core::Ptr< adsk::fusion::CoincidentConstraint >" :
        """
        Creates a new coincident constraint between two entities. The first argument
        is a sketch point. The second argument is a sketch curve or point. 
        point : The SketchPoint that will be made coincident. 
        entity : The SketchPoint or sketch curve that the point will be made coincident to. 
        Returns the newly created CoincidentConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addCoincident(self, *args)

    def addCollinear(self, *args) -> "adsk::core::Ptr< adsk::fusion::CollinearConstraint >" :
        """
        Creates a new collinear constraint between two lines. 
        lineOne : The first line to create the constraint on. 
        lineTwo : The second line to create the constraint on. 
        Returns the newly created CollinearConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addCollinear(self, *args)

    def addConcentric(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConcentricConstraint >" :
        """
        Creates a new concentric constraint between two circles, arcs, ellipses, or elliptical arcs. 
        entityOne : The first circle, arc, ellipse or elliptical arc. 
        entityTwo : The second circle, arc, ellipse or elliptical arc. 
        Returns the newly created ConcentricConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addConcentric(self, *args)

    def addMidPoint(self, *args) -> "adsk::core::Ptr< adsk::fusion::MidPointConstraint >" :
        """
        Creates a new midpoint constraint between a point and a curve. 
        point : The point to constrain to the midpoint of a curve. 
        midPointCurve : The curve that defines the midpoint to constraint to. 
        Returns the newly created MidPointConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addMidPoint(self, *args)

    def addParallel(self, *args) -> "adsk::core::Ptr< adsk::fusion::ParallelConstraint >" :
        """
        Creates a new parallel constraint between two lines. 
        lineOne : The first SketchLine. 
        lineTwo : The second SketchLine. 
        Returns the newly created ParallelConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addParallel(self, *args)

    def addPerpendicular(self, *args) -> "adsk::core::Ptr< adsk::fusion::PerpendicularConstraint >" :
        """
        Creates a new perpendicular constraint between two lines. 
        lineOne : The first SketchLine. 
        lineTwo : The second SketchLine. 
        Returns the newly created PerpendicularConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addPerpendicular(self, *args)

    def addHorizontal(self, *args) -> "adsk::core::Ptr< adsk::fusion::HorizontalConstraint >" :
        """
        Creates a new horizontal constraint on a line. 
        line : The line to constrain horizontally. 
        Returns the newly created HorizontalConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addHorizontal(self, *args)

    def addHorizontalPoints(self, *args) -> "adsk::core::Ptr< adsk::fusion::HorizontalPointsConstraint >" :
        """
        Creates a new horizontal constraint between two points. 
        pointOne : The first SketchPoint to constrain horizontally. 
        pointTwo : The second SketchPoint to constrain horizontally. 
        Returns the newly created HorizontalPointsConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addHorizontalPoints(self, *args)

    def addVertical(self, *args) -> "adsk::core::Ptr< adsk::fusion::VerticalConstraint >" :
        """
        Creates a new vertical constraint on a line. 
        line : The line to constrain vertically. 
        Returns the newly created VerticalConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addVertical(self, *args)

    def addVerticalPoints(self, *args) -> "adsk::core::Ptr< adsk::fusion::VerticalPointsConstraint >" :
        """
        Creates a new vertical constraint between two points. 
        pointOne : The first SketchPoint to constrain vertically. 
        pointTwo : The second SketchPoint to constrain vertically. 
        Returns the newly created VerticalPointsConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addVerticalPoints(self, *args)

    def addTangent(self, *args) -> "adsk::core::Ptr< adsk::fusion::TangentConstraint >" :
        """
        Creates a new tangent constraint between two curves. 
        curveOne : The first curve to be tangent. 
        curveTwo : The second curve to be tangent. 
        Returns the newly created TangentConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addTangent(self, *args)

    def addSmooth(self, *args) -> "adsk::core::Ptr< adsk::fusion::SmoothConstraint >" :
        """
        Creates a new smooth constraint between two curves. One of the curves
        must be a spline. The other curve can be a spline or an arc. 
        curveOne : The first curve to be smooth. 
        curveTwo : The first curve to be smooth. 
        Returns the newly created SmoothConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addSmooth(self, *args)

    def addEqual(self, *args) -> "adsk::core::Ptr< adsk::fusion::EqualConstraint >" :
        """
        Creates a new equal constraint between two lines, or between arcs and circles. 
        curveOne : The first line, arc, or circle. 
        curveTwo : The second line, arc, or circle. 
        Returns the newly created EqualConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addEqual(self, *args)

    def addSymmetry(self, *args) -> "adsk::core::Ptr< adsk::fusion::SymmetryConstraint >" :
        """
        Creates a new symmetry constraint. 
        entityOne : The first sketch entity to be symmetric. 
        entityTwo : The second sketch entity to be symmetric. It must be the same type as the first entity. 
        symmetryLine : The SketchLine that defines the axis of symmetry. 
        Returns the newly created SymmetryConstraint object or null if the creation failed.
        """
        return _fusion.GeometricConstraints_addSymmetry(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.GeometricConstraints__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.GeometricConstraints__get_isValid(self)
GeometricConstraints_swigregister = _fusion.GeometricConstraints_swigregister
GeometricConstraints_swigregister(GeometricConstraints)

def GeometricConstraints_classType() -> "char const *" :
  return _fusion.GeometricConstraints_classType()
GeometricConstraints_classType = _fusion.GeometricConstraints_classType

GeometricConstraints.__swig_getmethods__["count"] = GeometricConstraints._get_count
GeometricConstraints.count = property(GeometricConstraints._get_count, doc="Returns the number of constraints in the sketch.")

GeometricConstraints.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, GeometricConstraints) else None
GeometricConstraints.cast = lambda arg: arg if isinstance(arg, GeometricConstraints) else None

class HoleFeatureInput(Base):
    """
    This class defines the methods and properties that pertain to the definition of a hole 
    feature.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HoleFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HoleFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::HoleFeatureInput *" : return _fusion.HoleFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.HoleFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.HoleFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.HoleFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.HoleFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_HoleFeatureInput
    __del__ = lambda self : None;
    def setPositionByPoint(self, *args) -> "bool" :
        """
        Defines the position of a the hole using a point. The point can be a vertex on the face
        or it can be a Point3D object to define any location on the face. If a Point3D object is 
        provided it will be projected onto the plane along the planes normal. The orientation of the
        hole is defined by the planar face or construction plane. If a vertex is used, the position of 
        the hole is associative to that vertex. If a Point3D object is used the position of the hole 
        is not associative. 
        planarEntity : The planar BRepFace or ConstructionPlane object that defines the orientation of the hole.
        The natural direction of the hole will be opposite the normal of the face or construction plane. 
        point : A Point3D object or vertex that defines the position of the hole. The point will be projected 
        onto the plane along the normal of the plane. 
        Returns true if successful.
        """
        return _fusion.HoleFeatureInput_setPositionByPoint(self, *args)

    def setPositionAtCenter(self, *args) -> "bool" :
        """
        Defines the position of the hole at the center of a circular or elliptical edge of the face. 
        planarEntity : The planar BRepFace or ConstructionPlane object that defines the orientation of the hole.
        The natural direction of the hole will be opposite the normal of the face or construction plane. 
        centerEdge : A circular or elliptical edge whose center point will be the position of the hole. 
        Returns true if successful.
        """
        return _fusion.HoleFeatureInput_setPositionAtCenter(self, *args)

    def setPositionBySketchPoint(self, *args) -> "bool" :
        """
        Defines the position and orientation of the hole using a sketch point. 
        sketchPoint : The sketch point that defines the position of the hole. The orientation is
        inferred from the normal of the point's parent sketch. The natural direction will be 
        opposite the normal of the sketch. 
        Returns true if successful.
        """
        return _fusion.HoleFeatureInput_setPositionBySketchPoint(self, *args)

    def setPositionByPlaneAndOffsets(self, *args) -> "bool" :
        """
        Defines the orientation of the hole using a planar face or construction plane. 
        The position of the hole is defined by the distance from one or two edges. 
        planarEntity : The planar BRepFace or ConstructionPlane object that defines the orientation of the hole.
        The natural direction of the hole will be opposite the normal of the face or construction plane. 
        point : A Point3D object that defines the approximate initial position of the hole. The point will be 
        projected onto the plane. This point should be close to the final position of the hole and 
        is used to determine which solution out of several possible solutions should be chosen 
        for the hole location. 
        edgeOne : A linear BRepEdge object that the position of the hole will be measured from. The position 
        of the hole will be measured along a perpendicular from this edge. 
        offsetOne : A ValueInput object that defines the offset distance from edgeOne. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '3 in'). If no units are specified
        it is interpreted using the current default units for length. 
        edgeTwo : You can optionally define a second edge and offset to specify the position of the hole. If you use a
        second edge it has the same requirements as the edgeOne argument. If you provide a second edge you 
        must also provide the offsetTwo argument. 
        offsetTwo : If edgeTwo is defined, you must provide this argument which is a ValueInput object that 
        defines the offset from the edgeTwo. If the ValueInput uses a real then it is interpreted 
        as centimeters. If it is a string then the units can be defined as part of the string 
        (i.e. '3 in'). If no units are specified it is interpreted using the current default units 
        for length. 
        Returns true if successful.
        """
        return _fusion.HoleFeatureInput_setPositionByPlaneAndOffsets(self, *args)

    def setPositionOnEdge(self, *args) -> "bool" :
        """
        Defines the position and orientation of the hole to be on the start, end or center of an edge. 
        planarEntity : The planar BRepFace or ConstructionPlane object that defines the orientation of the hole
        and start of the hole. The natural direction of the hole will be opposite the normal of 
        the face or construction plane. 
        edge : The edge to position the hole on. 
        position : The position along the edge to place the hole. 
        Returns true if successful.
        """
        return _fusion.HoleFeatureInput_setPositionOnEdge(self, *args)

    def _get_tipAngle(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Gets the ValueInput object that defines the angle of the tip of the hole. The default 
        is '118.0 deg' but can be modified by setting it using another Value object.
        """
        return _fusion.HoleFeatureInput__get_tipAngle(self)

    def _set_tipAngle(self, *args) -> "bool" :
        """
        Gets the ValueInput object that defines the angle of the tip of the hole. The default 
        is '118.0 deg' but can be modified by setting it using another Value object.
        """
        return _fusion.HoleFeatureInput__set_tipAngle(self, *args)

    def _get_isDefaultDirection(self) -> "bool" :
        """Gets or sets if the hole goes in the default direction or is reversed."""
        return _fusion.HoleFeatureInput__get_isDefaultDirection(self)

    def _set_isDefaultDirection(self, *args) -> "bool" :
        """Gets or sets if the hole goes in the default direction or is reversed."""
        return _fusion.HoleFeatureInput__set_isDefaultDirection(self, *args)

    def setDistanceExtent(self, *args) -> "bool" :
        """
        Defines the depth of the hole using a specified distance. 
        distance : The depth of the hole. If a real is specified the value is in centimeters. 
        If a string is specified the units are derived from the string. If no units are specified, 
        the default units of the document are used. 
        Returns true if setting the extent was successful.
        """
        return _fusion.HoleFeatureInput_setDistanceExtent(self, *args)

    def setAllExtent(self, *args) -> "bool" :
        """
        Defines the extent of the hole to be through-all. The direction can be
        either positive, negative. 
        direction : The direction of the hole relative to the normal of the sketch plane. 
        Returns true if successful.
        """
        return _fusion.HoleFeatureInput_setAllExtent(self, *args)

    def setOneSideToExtent(self, *args) -> "bool" :
        """
        Sets the extent of the hole to be from the sketch plane to the specified 'to' face. 
        toEntity : The entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For a hole it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        matchShape : Indicates if the hole is not contained on the face that the hole should match
        the shape of the entity as if it extended beyond it's current boundaries. 
        directionHint : Specifies the direction of the hole. This is only used in the case where there are two possible solutions and the hole can
        hit the toEntity in either direction.
        Typically there is only a single solution and the direction is determined automatically. 
        Returns true if successful.
        """
        return _fusion.HoleFeatureInput_setOneSideToExtent(self, *args)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Hole is created based on geometry (e.g. a face or point)
        in another component AND (the Hole) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        A value of null indicates that everything is in the context of a single component.
        """
        return _fusion.HoleFeatureInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, *args) -> "bool" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Hole is created based on geometry (e.g. a face or point)
        in another component AND (the Hole) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        A value of null indicates that everything is in the context of a single component.
        """
        return _fusion.HoleFeatureInput__set_creationOccurrence(self, *args)

    def setPositionBySketchPoints(self, *args) -> "bool" :
        """
        Defines the position and orientation of the hole using a set of sketch points. 
        sketchPoints : A collection of sketch points that defines the positions of the holes. The orientation is
        inferred from the normal of the point's parent sketch. The natural direction will be 
        opposite the normal of the sketch. The points can be from multiple sketches but they
        must all be co-planar. 
        Returns true if successful.
        """
        return _fusion.HoleFeatureInput_setPositionBySketchPoints(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.HoleFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.HoleFeatureInput__set_targetBaseFeature(self, *args)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >" :
        """
        Gets and sets the list of bodies that will participate in the hole.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        hole will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.HoleFeatureInput__get_participantBodies(self)

    def _set_participantBodies(self, *args) -> "bool" :
        """
        Gets and sets the list of bodies that will participate in the hole.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        hole will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.HoleFeatureInput__set_participantBodies(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.HoleFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.HoleFeatureInput__get_isValid(self)
HoleFeatureInput_swigregister = _fusion.HoleFeatureInput_swigregister
HoleFeatureInput_swigregister(HoleFeatureInput)

def HoleFeatureInput_classType() -> "char const *" :
  return _fusion.HoleFeatureInput_classType()
HoleFeatureInput_classType = _fusion.HoleFeatureInput_classType

HoleFeatureInput.__swig_getmethods__["tipAngle"] = HoleFeatureInput._get_tipAngle
HoleFeatureInput.__swig_setmethods__["tipAngle"] = HoleFeatureInput._set_tipAngle
HoleFeatureInput.tipAngle = property(HoleFeatureInput._get_tipAngle, HoleFeatureInput._set_tipAngle, doc="Gets the ValueInput object that defines the angle of the tip of the hole. The default\nis '118.0 deg' but can be modified by setting it using another Value object.")

HoleFeatureInput.__swig_getmethods__["isDefaultDirection"] = HoleFeatureInput._get_isDefaultDirection
HoleFeatureInput.__swig_setmethods__["isDefaultDirection"] = HoleFeatureInput._set_isDefaultDirection
HoleFeatureInput.isDefaultDirection = property(HoleFeatureInput._get_isDefaultDirection, HoleFeatureInput._set_isDefaultDirection, doc="Gets or sets if the hole goes in the default direction or is reversed.")

HoleFeatureInput.__swig_getmethods__["creationOccurrence"] = HoleFeatureInput._get_creationOccurrence
HoleFeatureInput.__swig_setmethods__["creationOccurrence"] = HoleFeatureInput._set_creationOccurrence
HoleFeatureInput.creationOccurrence = property(HoleFeatureInput._get_creationOccurrence, HoleFeatureInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the Hole is created based on geometry (e.g. a face or point)\nin another component AND (the Hole) is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI\nA value of null indicates that everything is in the context of a single component.")

HoleFeatureInput.__swig_getmethods__["targetBaseFeature"] = HoleFeatureInput._get_targetBaseFeature
HoleFeatureInput.__swig_setmethods__["targetBaseFeature"] = HoleFeatureInput._set_targetBaseFeature
HoleFeatureInput.targetBaseFeature = property(HoleFeatureInput._get_targetBaseFeature, HoleFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

HoleFeatureInput.__swig_getmethods__["participantBodies"] = HoleFeatureInput._get_participantBodies
HoleFeatureInput.__swig_setmethods__["participantBodies"] = HoleFeatureInput._set_participantBodies
HoleFeatureInput.participantBodies = property(HoleFeatureInput._get_participantBodies, HoleFeatureInput._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the hole.\nIf this property has not been set, the default behavior is that all bodies that are intersected by the\nhole will participate.\nThis property can return null in the case where the feature has not been fully defined so that\npossible intersecting bodies can be computed.")

HoleFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, HoleFeatureInput) else None
HoleFeatureInput.cast = lambda arg: arg if isinstance(arg, HoleFeatureInput) else None

class HoleFeatures(Base):
    """
    Collection that provides access to all of the existing hole features in a component
    and supports the ability to create new hole features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HoleFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HoleFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::HoleFeatures *" : return _fusion.HoleFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.HoleFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.HoleFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.HoleFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::HoleFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.HoleFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.HoleFeatures_classType
    if _newclass:classType = staticmethod(_fusion.HoleFeatures_classType)
    __swig_destroy__ = _fusion.delete_HoleFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::HoleFeature >" :
        """
        Function that returns the specified hole feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.HoleFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of hole features in the collection."""
        return _fusion.HoleFeatures__get_count(self)

    def createSimpleInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::HoleFeatureInput >" :
        """
        Creates a HoleFeatureInput object that defines a simple hole (a single diameter). 
        This is not a hole feature, but an object used to create a hole feature. Functionality
        on the returned HoleFeatureInput object is used to define the position and extent 
        of the hole. 
        holeDiameter : A ValueInput object that defines the diameter of the hole. If the ValueInput uses
        a real, it is interpreted as centimeters. If it is a string, the units
        can be defined as part of the string (i.e. '3 in') If no units are specified,
        it is interpreted using the current default units for length. 
        Returns the newly created HoleFeatureInput object or null if the creation failed.
        """
        return _fusion.HoleFeatures_createSimpleInput(self, *args)

    def createCounterboreInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::HoleFeatureInput >" :
        """
        Creates a HoleFeatureInput object that defines a counterbore hole. This is not
        a hole feature but an object used to create a hole feature. Functionality
        on the returned HoleFeatureInput object is used to define the position and extent 
        of the hole. 
        holeDiameter : A ValueInput object that defines the diameter of the hole. If the ValueInput uses
        a real, it is interpreted as centimeters. If it is a string, the units
        can be defined as part of the string (i.e. '3 in') If no units are specified,
        it is interpreted using the current default units for length. 
        counterboreDiameter : A ValueInput object that defines the counterbore diameter of the hole. If the ValueInput uses
        a real, it is interpreted as centimeters. If it is a string, the units
        can be defined as part of the string (i.e. '3 in') If no units are specified,
        it is interpreted using the current default units for length. 
        counterboreDepth : A ValueInput object that defines the counterbore depth of the hole. If the ValueInput uses
        a real, it is interpreted as centimeters. If it is a string, the units
        can be defined as part of the string (i.e. '3 in') If no units are specified,
        it is interpreted using the current default units for length. 
        Returns the newly created HoleFeatureInput object or null if the creation failed.
        """
        return _fusion.HoleFeatures_createCounterboreInput(self, *args)

    def createCountersinkInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::HoleFeatureInput >" :
        """
        Creates a HoleFeatureInput object that defines a countersink hole. This is not
        a hole feature but an object used to create a hole feature. Functionality
        on the returned HoleFeatureInput object is used to define the position and extent of the hole. 
        holeDiameter : A ValueInput object that defines the diameter of the hole. If the ValueInput uses
        a real, it is interpreted as centimeters. If it is a string, the units
        can be defined as part of the string (i.e. '3 in') If no units are specified,
        it is interpreted using the current default units for length. 
        countersinkDiameter : A ValueInput object that defines the diameter of the countersink. If the ValueInput uses
        a real, it is interpreted as centimeters. If it is a string, the units
        can be defined as part of the string (i.e. '3 in') If no units are specified,
        it is interpreted using the current default units for length. 
        countersinkAngle : A ValueInput object that defines the angle of the countersink. If the ValueInput uses
        a real then it is interpreted as radians. If it is a string then the units
        can be defined as part of the string (i.e. '120 deg'). If no units are specified
        it is interpreted using the current default units for angles. 
        Returns the newly created HoleFeatureInput object or null if the creation failed.
        """
        return _fusion.HoleFeatures_createCountersinkInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::HoleFeature >" :
        """
        Creates a new hole feature based on the information provided by a HoleFeatureInput object.
        To create a new hole, use one of the createInput functions to define a new input object for 
        the type of hole you want to create. Use the methods and properties on the input object 
        to define any additional input. Once the information is defined on the input object, you 
        can pass it to the Add method to create the hole. 
        input : The HoleFeatureInput object that defines the hole you want to create. 
        Returns the newly created HoleFeature or null if the creation failed.
        """
        return _fusion.HoleFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::HoleFeature >" :
        """
        Function that returns the specified hole feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.HoleFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.HoleFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.HoleFeatures__get_isValid(self)
HoleFeatures_swigregister = _fusion.HoleFeatures_swigregister
HoleFeatures_swigregister(HoleFeatures)

def HoleFeatures_classType() -> "char const *" :
  return _fusion.HoleFeatures_classType()
HoleFeatures_classType = _fusion.HoleFeatures_classType

HoleFeatures.__swig_getmethods__["count"] = HoleFeatures._get_count
HoleFeatures.count = property(HoleFeatures._get_count, doc="The number of hole features in the collection.")

HoleFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, HoleFeatures) else None
HoleFeatures.cast = lambda arg: arg if isinstance(arg, HoleFeatures) else None

class HolePositionDefinition(Base):
    """The base class for the classes that define how a hole can be positioned."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HolePositionDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HolePositionDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::HolePositionDefinition *" : return _fusion.HolePositionDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.HolePositionDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.HolePositionDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.HolePositionDefinition_classType
    if _newclass:classType = staticmethod(_fusion.HolePositionDefinition_classType)
    __swig_destroy__ = _fusion.delete_HolePositionDefinition
    __del__ = lambda self : None;
    def _get_objectType(self) -> "char const *" : return _fusion.HolePositionDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.HolePositionDefinition__get_isValid(self)
HolePositionDefinition_swigregister = _fusion.HolePositionDefinition_swigregister
HolePositionDefinition_swigregister(HolePositionDefinition)

def HolePositionDefinition_classType() -> "char const *" :
  return _fusion.HolePositionDefinition_classType()
HolePositionDefinition_classType = _fusion.HolePositionDefinition_classType

HolePositionDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, HolePositionDefinition) else None
HolePositionDefinition.cast = lambda arg: arg if isinstance(arg, HolePositionDefinition) else None

class InterferenceInput(Base):
    """
    Used to gather and define the various inputs and settings needed to calculate interference. This
    object is created using the Design.createInterferenceInput method.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InterferenceInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InterferenceInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::InterferenceInput *" : return _fusion.InterferenceInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.InterferenceInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.InterferenceInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.InterferenceInput_classType
    if _newclass:classType = staticmethod(_fusion.InterferenceInput_classType)
    __swig_destroy__ = _fusion.delete_InterferenceInput
    __del__ = lambda self : None;
    def _get_entities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and set an ObjectCollection containing BRepBody and/or Occurrence entities that
        will be used when checking for interference. All entities must be in the context of 
        the root component of the top-level design.
        """
        return _fusion.InterferenceInput__get_entities(self)

    def _set_entities(self, *args) -> "bool" :
        """
        Gets and set an ObjectCollection containing BRepBody and/or Occurrence entities that
        will be used when checking for interference. All entities must be in the context of 
        the root component of the top-level design.
        """
        return _fusion.InterferenceInput__set_entities(self, *args)

    def _get_areCoincidentFacesIncluded(self) -> "bool" :
        """
        Gets and sets whether any coincident faces in the input bodies are considered as interference
        or not. This property defaults to False for a newly created InterferenceInput object.
        """
        return _fusion.InterferenceInput__get_areCoincidentFacesIncluded(self)

    def _set_areCoincidentFacesIncluded(self, *args) -> "bool" :
        """
        Gets and sets whether any coincident faces in the input bodies are considered as interference
        or not. This property defaults to False for a newly created InterferenceInput object.
        """
        return _fusion.InterferenceInput__set_areCoincidentFacesIncluded(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.InterferenceInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.InterferenceInput__get_isValid(self)
InterferenceInput_swigregister = _fusion.InterferenceInput_swigregister
InterferenceInput_swigregister(InterferenceInput)

def InterferenceInput_classType() -> "char const *" :
  return _fusion.InterferenceInput_classType()
InterferenceInput_classType = _fusion.InterferenceInput_classType

InterferenceInput.__swig_getmethods__["entities"] = InterferenceInput._get_entities
InterferenceInput.__swig_setmethods__["entities"] = InterferenceInput._set_entities
InterferenceInput.entities = property(InterferenceInput._get_entities, InterferenceInput._set_entities, doc="Gets and set an ObjectCollection containing BRepBody and/or Occurrence entities that\nwill be used when checking for interference. All entities must be in the context of\nthe root component of the top-level design.")

InterferenceInput.__swig_getmethods__["areCoincidentFacesIncluded"] = InterferenceInput._get_areCoincidentFacesIncluded
InterferenceInput.__swig_setmethods__["areCoincidentFacesIncluded"] = InterferenceInput._set_areCoincidentFacesIncluded
InterferenceInput.areCoincidentFacesIncluded = property(InterferenceInput._get_areCoincidentFacesIncluded, InterferenceInput._set_areCoincidentFacesIncluded, doc="Gets and sets whether any coincident faces in the input bodies are considered as interference\nor not. This property defaults to False for a newly created InterferenceInput object.")

InterferenceInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, InterferenceInput) else None
InterferenceInput.cast = lambda arg: arg if isinstance(arg, InterferenceInput) else None

class InterferenceResult(Base):
    """Represents the interference between bodies and/or occurrences in an interference analysis."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InterferenceResult, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InterferenceResult, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::InterferenceResult *" : return _fusion.InterferenceResult___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.InterferenceResult___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.InterferenceResult___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.InterferenceResult_classType
    if _newclass:classType = staticmethod(_fusion.InterferenceResult_classType)
    __swig_destroy__ = _fusion.delete_InterferenceResult
    __del__ = lambda self : None;
    def _get_entityOne(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the first entity involved in the interference"""
        return _fusion.InterferenceResult__get_entityOne(self)

    def _get_entityTwo(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the second entity involved in the interference"""
        return _fusion.InterferenceResult__get_entityTwo(self)

    def _get_interferenceBody(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """Returns a transient BRepBody that represents the volume of interference."""
        return _fusion.InterferenceResult__get_interferenceBody(self)

    def _get_isCreateBody(self) -> "bool" :
        """
        Gets and sets if this interference volume should be created as a model body. Setting
        this to true doesn't create the body just indicates that a body is desired. Calling
        the createBodies method on the interferenceResults object will result in the creation
        of the model body if this property is true.
        """
        return _fusion.InterferenceResult__get_isCreateBody(self)

    def _set_isCreateBody(self, *args) -> "bool" :
        """
        Gets and sets if this interference volume should be created as a model body. Setting
        this to true doesn't create the body just indicates that a body is desired. Calling
        the createBodies method on the interferenceResults object will result in the creation
        of the model body if this property is true.
        """
        return _fusion.InterferenceResult__set_isCreateBody(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.InterferenceResult__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.InterferenceResult__get_isValid(self)
InterferenceResult_swigregister = _fusion.InterferenceResult_swigregister
InterferenceResult_swigregister(InterferenceResult)

def InterferenceResult_classType() -> "char const *" :
  return _fusion.InterferenceResult_classType()
InterferenceResult_classType = _fusion.InterferenceResult_classType

InterferenceResult.__swig_getmethods__["entityOne"] = InterferenceResult._get_entityOne
InterferenceResult.entityOne = property(InterferenceResult._get_entityOne, doc="Returns the first entity involved in the interference")

InterferenceResult.__swig_getmethods__["entityTwo"] = InterferenceResult._get_entityTwo
InterferenceResult.entityTwo = property(InterferenceResult._get_entityTwo, doc="Returns the second entity involved in the interference")

InterferenceResult.__swig_getmethods__["interferenceBody"] = InterferenceResult._get_interferenceBody
InterferenceResult.interferenceBody = property(InterferenceResult._get_interferenceBody, doc="Returns a transient BRepBody that represents the volume of interference.")

InterferenceResult.__swig_getmethods__["isCreateBody"] = InterferenceResult._get_isCreateBody
InterferenceResult.__swig_setmethods__["isCreateBody"] = InterferenceResult._set_isCreateBody
InterferenceResult.isCreateBody = property(InterferenceResult._get_isCreateBody, InterferenceResult._set_isCreateBody, doc="Gets and sets if this interference volume should be created as a model body. Setting\nthis to true doesn't create the body just indicates that a body is desired. Calling\nthe createBodies method on the interferenceResults object will result in the creation\nof the model body if this property is true.")

InterferenceResult.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, InterferenceResult) else None
InterferenceResult.cast = lambda arg: arg if isinstance(arg, InterferenceResult) else None

class InterferenceResults(Base):
    """Transient object used to return the result of an interference analysis."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InterferenceResults, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InterferenceResults, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::InterferenceResults *" : return _fusion.InterferenceResults___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.InterferenceResults___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.InterferenceResults___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.InterferenceResults___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::InterferenceResult >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.InterferenceResults___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.InterferenceResults_classType
    if _newclass:classType = staticmethod(_fusion.InterferenceResults_classType)
    __swig_destroy__ = _fusion.delete_InterferenceResults
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::InterferenceResult >" :
        """
        Function that returns the specified interference result using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.InterferenceResults_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of interference results in the collection."""
        return _fusion.InterferenceResults__get_count(self)

    def createBodies(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Creates bodies in the model that represent the interference volumes.
        This is not supported in parametric modelling. 
        allInterferenceBodies : Sets if all bodies or only individual bodies will be created as bodies in the model.
        If False, then only interferenceResult objects whose isCreateBody property is true
        will be created as a model body. If true, all interface volumes will be created as
        a body regardless of the value of the isCreateBody property.
        """
        return _fusion.InterferenceResults_createBodies(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.InterferenceResults__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.InterferenceResults__get_isValid(self)
InterferenceResults_swigregister = _fusion.InterferenceResults_swigregister
InterferenceResults_swigregister(InterferenceResults)

def InterferenceResults_classType() -> "char const *" :
  return _fusion.InterferenceResults_classType()
InterferenceResults_classType = _fusion.InterferenceResults_classType

InterferenceResults.__swig_getmethods__["count"] = InterferenceResults._get_count
InterferenceResults.count = property(InterferenceResults._get_count, doc="Returns the number of interference results in the collection.")

InterferenceResults.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, InterferenceResults) else None
InterferenceResults.cast = lambda arg: arg if isinstance(arg, InterferenceResults) else None

class Joint(Base):
    """A joint in a design."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Joint, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Joint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::Joint *" : return _fusion.Joint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Joint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Joint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Joint_classType
    if _newclass:classType = staticmethod(_fusion.Joint_classType)
    __swig_destroy__ = _fusion.delete_Joint
    __del__ = lambda self : None;
    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this joint."""
        return _fusion.Joint__get_parentComponent(self)

    def _get_name(self) -> "std::string" :
        """Gets and sets the name of the joint."""
        return _fusion.Joint__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Gets and sets the name of the joint."""
        return _fusion.Joint__set_name(self, *args)

    def _get_geometryOrOriginOne(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets and sets the first JointGeometry or JointOrigin for this joint."""
        return _fusion.Joint__get_geometryOrOriginOne(self)

    def _set_geometryOrOriginOne(self, *args) -> "bool" :
        """Gets and sets the first JointGeometry or JointOrigin for this joint."""
        return _fusion.Joint__set_geometryOrOriginOne(self, *args)

    def _get_geometryOrOriginTwo(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets and sets the second JointGeometry or JointOrigin for this joint."""
        return _fusion.Joint__get_geometryOrOriginTwo(self)

    def _set_geometryOrOriginTwo(self, *args) -> "bool" :
        """Gets and sets the second JointGeometry or JointOrigin for this joint."""
        return _fusion.Joint__set_geometryOrOriginTwo(self, *args)

    def _get_angle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter controlling the angle between the two input geometries. This is effectively the
        angle between the two primary axes of the two joint geometries.
        """
        return _fusion.Joint__get_angle(self)

    def _get_offset(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter controlling the offset between the two input geometries. This is effectively the
        offset distance between the two planes defined by the primary and secondary axes
        of the input geometries or the offset along the tertiary axis (z axis) of the joint.
        """
        return _fusion.Joint__get_offset(self)

    def _get_isFlipped(self) -> "bool" :
        """
        Gets and sets if the joint direction is flipped or not. This is effectively
        specifying if the third axis of the two input geometries is facing (false) or
        opposed (true).
        """
        return _fusion.Joint__get_isFlipped(self)

    def _set_isFlipped(self, *args) -> "bool" :
        """
        Gets and sets if the joint direction is flipped or not. This is effectively
        specifying if the third axis of the two input geometries is facing (false) or
        opposed (true).
        """
        return _fusion.Joint__set_isFlipped(self, *args)

    def _get_jointMotion(self) -> "adsk::core::Ptr< adsk::fusion::JointMotion >" :
        """Returns a JointMotion object that defines the motion relationship between the two geometries."""
        return _fusion.Joint__get_jointMotion(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes this joint. 
        Returns true if the delete is successful.
        """
        return _fusion.Joint_deleteMe(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this joint."""
        return _fusion.Joint__get_timelineObject(self)

    def setAsRigidJointMotion(self) -> "bool" :
        """
        Redefines the relationship between the two joint geometries as a rigid joint. 
        Returns true if successful.
        """
        return _fusion.Joint_setAsRigidJointMotion(self)

    def setAsRevoluteJointMotion(self, *args) -> "bool" :
        """
        Redefines the relationship between the two joint geometries as a revolute joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived
        from. 
        Returns true if the operation was successful.
        """
        return _fusion.Joint_setAsRevoluteJointMotion(self, *args)

    def setAsSliderJointMotion(self, *args) -> "bool" :
        """
        Redefines the relationship between the two joint geometries as a slider joint. 
        sliderDirection : Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the 
        customSliderDirectionEntity argument must also be provided. 
        customSliderDirectionEntity : If the sliderDirection is CustomJointDirection this argument is used to specify the entity that defines
        the custom slider direction. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.Joint_setAsSliderJointMotion(self, *args)

    def setAsCylindricalJointMotion(self, *args) -> "bool" :
        """
        Redefines the relationship between the two joint geometries as a cylindrical joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived
        from. 
        Returns true if the operation was successful.
        """
        return _fusion.Joint_setAsCylindricalJointMotion(self, *args)

    def setAsPinSlotJointMotion(self, *args) -> "bool" :
        """
        Redefines the relationship between the two joint geometries as a pin-slot joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        slideDirection : Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the 
        customSlideDirectionEntity argument must also be provided. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived 
        customSlideDirectionEntity : If the slideDirection is CustomJointDirection this argument is used to specify the entity that defines
        the custom slide direction. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.Joint_setAsPinSlotJointMotion(self, *args)

    def setAsPlanarJointMotion(self, *args) -> "bool" :
        """
        Redefines the relationship between the two joint geometries as a planar joint. 
        normalDirection : Defines the direction of the normal of the single degree of rotation.
        This can be set to XAxisJointDirection, YAxisJointDirection, ZAxisJointDirection, 
        or CustomJointDirection. If set to CustomJointDirection then the customNormalDirectionEntity
        argument must also be provided. 
        customNormalDirectionEntity : If the normalDirection is CustomJointDirection this argument is used to specify the entity that defines
        the direction of the normal. This can be several types of entities that can define a direction. 
        customPrimarySlideDirection : This arguments defines the direction of the primary slide direction. A default primary slide direction 
        is automatically chosen and will be used if this argument is not provided or is null. The secondar slide
        direction is automatically inferred from the normal and primary slide directions. 
        Returns true if the operation was successful.
        """
        return _fusion.Joint_setAsPlanarJointMotion(self, *args)

    def setAsBallJointMotion(self, *args) -> "bool" :
        """
        Redefines the relationship between the two joint geometries as a ball joint. 
        pitchDirection : Defines the direction the pitch angle is measured from. This can be ZAxisJointDirection or CustomJointDirection. If
        CustomJointDirection is specified then you must also provide a value for the customPitchDirection argument. 
        yawDirection : Defines the direction the yaw is measured from. This can be XAxisJointDirection or CustomJointDirection. If
        CustomJointDirection is specified then you must also provide a value for the customYawDirection argument. 
        customPitchDirection : If the pitchDirection argument is customPitchDirection this argument is used to define the direction the pitch
        angel is measured from. This can be several types of entities that can define a direction. 
        customYawDirection : If the yawDirection argument is customPitchDirection this argument is used to define the direction the yaw
        angel is measured from. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.Joint_setAsBallJointMotion(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::Joint >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.Joint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::Joint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.Joint_createForAssemblyContext(self, *args)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.Joint__get_assemblyContext(self)

    def _get_isSuppressed(self) -> "bool" :
        """Gets and sets if this joint is suppressed."""
        return _fusion.Joint__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """Gets and sets if this joint is suppressed."""
        return _fusion.Joint__set_isSuppressed(self, *args)

    def _get_isLightBulbOn(self) -> "bool" :
        """
        Gets and sets if the light bulb of this joint as displayed in the browser is on or off.
        A joint will only be visible if the light bulb is switched on. However,
        the light bulb can be on and the joint still invisible if a higher level occurrence 
        in the assembly context is not visible because its light bulb is off or the joints folder
        is light bulb is off.
        """
        return _fusion.Joint__get_isLightBulbOn(self)

    def _set_isLightBulbOn(self, *args) -> "bool" :
        """
        Gets and sets if the light bulb of this joint as displayed in the browser is on or off.
        A joint will only be visible if the light bulb is switched on. However,
        the light bulb can be on and the joint still invisible if a higher level occurrence 
        in the assembly context is not visible because its light bulb is off or the joints folder
        is light bulb is off.
        """
        return _fusion.Joint__set_isLightBulbOn(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        Gets whether the joint is visible. To change the visibility see the isLightBulbOn property.
        This property is affected by the assembly context.
        """
        return _fusion.Joint__get_isVisible(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this joint."""
        return _fusion.Joint__get_attributes(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the joint."""
        return _fusion.Joint__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.Joint__get_errorOrWarningMessage(self)

    def _get_occurrenceOne(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the first of two occurrences that this joint defines a relationship between. This is the occurrence
        that can also be found through the geometryOrOriginOne property.
        """
        return _fusion.Joint__get_occurrenceOne(self)

    def _get_occurrenceTwo(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the first of two occurrences that this joint defines a relationship between. This is the occurrence
        that can also be found through the geometryOrOriginTwo property.
        """
        return _fusion.Joint__get_occurrenceTwo(self)

    def _get_isLocked(self) -> "bool" :
        """Gets and sets if the joint is locked."""
        return _fusion.Joint__get_isLocked(self)

    def _set_isLocked(self, *args) -> "bool" :
        """Gets and sets if the joint is locked."""
        return _fusion.Joint__set_isLocked(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.Joint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Joint__get_isValid(self)
Joint_swigregister = _fusion.Joint_swigregister
Joint_swigregister(Joint)

def Joint_classType() -> "char const *" :
  return _fusion.Joint_classType()
Joint_classType = _fusion.Joint_classType

Joint.__swig_getmethods__["parentComponent"] = Joint._get_parentComponent
Joint.parentComponent = property(Joint._get_parentComponent, doc="Returns the parent component that owns this joint.")

Joint.__swig_getmethods__["name"] = Joint._get_name
Joint.__swig_setmethods__["name"] = Joint._set_name
Joint.name = property(Joint._get_name, Joint._set_name, doc="Gets and sets the name of the joint.")

Joint.__swig_getmethods__["geometryOrOriginOne"] = Joint._get_geometryOrOriginOne
Joint.__swig_setmethods__["geometryOrOriginOne"] = Joint._set_geometryOrOriginOne
Joint.geometryOrOriginOne = property(Joint._get_geometryOrOriginOne, Joint._set_geometryOrOriginOne, doc="Gets and sets the first JointGeometry or JointOrigin for this joint.")

Joint.__swig_getmethods__["geometryOrOriginTwo"] = Joint._get_geometryOrOriginTwo
Joint.__swig_setmethods__["geometryOrOriginTwo"] = Joint._set_geometryOrOriginTwo
Joint.geometryOrOriginTwo = property(Joint._get_geometryOrOriginTwo, Joint._set_geometryOrOriginTwo, doc="Gets and sets the second JointGeometry or JointOrigin for this joint.")

Joint.__swig_getmethods__["angle"] = Joint._get_angle
Joint.angle = property(Joint._get_angle, doc="Returns the parameter controlling the angle between the two input geometries. This is effectively the\nangle between the two primary axes of the two joint geometries.")

Joint.__swig_getmethods__["offset"] = Joint._get_offset
Joint.offset = property(Joint._get_offset, doc="Returns the parameter controlling the offset between the two input geometries. This is effectively the\noffset distance between the two planes defined by the primary and secondary axes\nof the input geometries or the offset along the tertiary axis (z axis) of the joint.")

Joint.__swig_getmethods__["isFlipped"] = Joint._get_isFlipped
Joint.__swig_setmethods__["isFlipped"] = Joint._set_isFlipped
Joint.isFlipped = property(Joint._get_isFlipped, Joint._set_isFlipped, doc="Gets and sets if the joint direction is flipped or not. This is effectively\nspecifying if the third axis of the two input geometries is facing (false) or\nopposed (true).")

Joint.__swig_getmethods__["jointMotion"] = Joint._get_jointMotion
Joint.jointMotion = property(Joint._get_jointMotion, doc="Returns a JointMotion object that defines the motion relationship between the two geometries.")

Joint.__swig_getmethods__["timelineObject"] = Joint._get_timelineObject
Joint.timelineObject = property(Joint._get_timelineObject, doc="Returns the timeline object associated with this joint.")

Joint.__swig_getmethods__["nativeObject"] = Joint._get_nativeObject
Joint.nativeObject = property(Joint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

Joint.__swig_getmethods__["assemblyContext"] = Joint._get_assemblyContext
Joint.assemblyContext = property(Joint._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")

Joint.__swig_getmethods__["isSuppressed"] = Joint._get_isSuppressed
Joint.__swig_setmethods__["isSuppressed"] = Joint._set_isSuppressed
Joint.isSuppressed = property(Joint._get_isSuppressed, Joint._set_isSuppressed, doc="Gets and sets if this joint is suppressed.")

Joint.__swig_getmethods__["isLightBulbOn"] = Joint._get_isLightBulbOn
Joint.__swig_setmethods__["isLightBulbOn"] = Joint._set_isLightBulbOn
Joint.isLightBulbOn = property(Joint._get_isLightBulbOn, Joint._set_isLightBulbOn, doc="Gets and sets if the light bulb of this joint as displayed in the browser is on or off.\nA joint will only be visible if the light bulb is switched on. However,\nthe light bulb can be on and the joint still invisible if a higher level occurrence\nin the assembly context is not visible because its light bulb is off or the joints folder\nis light bulb is off.")

Joint.__swig_getmethods__["isVisible"] = Joint._get_isVisible
Joint.isVisible = property(Joint._get_isVisible, doc="Gets whether the joint is visible. To change the visibility see the isLightBulbOn property.\nThis property is affected by the assembly context.")

Joint.__swig_getmethods__["attributes"] = Joint._get_attributes
Joint.attributes = property(Joint._get_attributes, doc="Returns the collection of attributes associated with this joint.")

Joint.__swig_getmethods__["healthState"] = Joint._get_healthState
Joint.healthState = property(Joint._get_healthState, doc="Returns the current health state of the joint.")

Joint.__swig_getmethods__["errorOrWarningMessage"] = Joint._get_errorOrWarningMessage
Joint.errorOrWarningMessage = property(Joint._get_errorOrWarningMessage, doc="Returns the error or warning message in the case where the healthState property returns either\nWarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.")

Joint.__swig_getmethods__["occurrenceOne"] = Joint._get_occurrenceOne
Joint.occurrenceOne = property(Joint._get_occurrenceOne, doc="Returns the first of two occurrences that this joint defines a relationship between. This is the occurrence\nthat can also be found through the geometryOrOriginOne property.")

Joint.__swig_getmethods__["occurrenceTwo"] = Joint._get_occurrenceTwo
Joint.occurrenceTwo = property(Joint._get_occurrenceTwo, doc="Returns the first of two occurrences that this joint defines a relationship between. This is the occurrence\nthat can also be found through the geometryOrOriginTwo property.")

Joint.__swig_getmethods__["isLocked"] = Joint._get_isLocked
Joint.__swig_setmethods__["isLocked"] = Joint._set_isLocked
Joint.isLocked = property(Joint._get_isLocked, Joint._set_isLocked, doc="Gets and sets if the joint is locked.")

Joint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Joint) else None
Joint.cast = lambda arg: arg if isinstance(arg, Joint) else None

class JointGeometry(Base):
    """
    A transient object used to define and query the geometric input of a joint and the resulting coordinate
    system it defines. New JointGeometry objects are created using its various static create methods and 
    are then used as input to the Joints.createInput method.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JointGeometry, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, JointGeometry, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::JointGeometry *" : return _fusion.JointGeometry___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.JointGeometry___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.JointGeometry___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.JointGeometry_classType
    if _newclass:classType = staticmethod(_fusion.JointGeometry_classType)
    __swig_getmethods__["createByPlanarFace"] = lambda x: _fusion.JointGeometry_createByPlanarFace
    if _newclass:createByPlanarFace = staticmethod(_fusion.JointGeometry_createByPlanarFace)
    __swig_getmethods__["createByNonPlanarFace"] = lambda x: _fusion.JointGeometry_createByNonPlanarFace
    if _newclass:createByNonPlanarFace = staticmethod(_fusion.JointGeometry_createByNonPlanarFace)
    __swig_getmethods__["createByProfile"] = lambda x: _fusion.JointGeometry_createByProfile
    if _newclass:createByProfile = staticmethod(_fusion.JointGeometry_createByProfile)
    __swig_getmethods__["createByCurve"] = lambda x: _fusion.JointGeometry_createByCurve
    if _newclass:createByCurve = staticmethod(_fusion.JointGeometry_createByCurve)
    __swig_getmethods__["createByPoint"] = lambda x: _fusion.JointGeometry_createByPoint
    if _newclass:createByPoint = staticmethod(_fusion.JointGeometry_createByPoint)
    __swig_getmethods__["createByBetweenTwoPlanes"] = lambda x: _fusion.JointGeometry_createByBetweenTwoPlanes
    if _newclass:createByBetweenTwoPlanes = staticmethod(_fusion.JointGeometry_createByBetweenTwoPlanes)
    __swig_destroy__ = _fusion.delete_JointGeometry
    __del__ = lambda self : None;
    def _get_geometryType(self) -> "adsk::fusion::JointGeometryTypes" :
        """Returns the type of geometry this JointGeometry object represents."""
        return _fusion.JointGeometry__get_geometryType(self)

    def _get_keyPointType(self) -> "adsk::fusion::JointKeyPointTypes" :
        """Returns the keypoint type this JointGeometry is using."""
        return _fusion.JointGeometry__get_keyPointType(self)

    def _get_entityOne(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        The first entity that's defining this joint geometry. This can be various types of geometry depending
        on how this joint geometry is defined. The geometryType property indicates how this joint geometry is
        defined a provides a clue about the type of geometry to expect back from this property.
        """
        return _fusion.JointGeometry__get_entityOne(self)

    def _get_entityTwo(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        This is the second entity that defines this joint geometry. This isn't used for all joint geometry types
        and will return null in the cases where it's not used. A second geometry is used in the case where the geometryType
        property returns JointProfileGeometry, JointPlanarBRepFaceGeometry, or JointBetweenTowFacesGeometry.
        """
        return _fusion.JointGeometry__get_entityTwo(self)

    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Returns the origin point that's been calculated for this joint geometry."""
        return _fusion.JointGeometry__get_origin(self)

    def _get_primaryAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Returns the direction of the primary axis that's been calculated for this joint geometry.
        Conceptually, this is the X-axis of the computed coordinate system.
        """
        return _fusion.JointGeometry__get_primaryAxisVector(self)

    def _get_secondaryAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Returns the direction of the secondary axis that's been calculated for this joint geometry.
        Conceptually, this is the Y-axis of the computed coordinate system.
        """
        return _fusion.JointGeometry__get_secondaryAxisVector(self)

    def _get_thirdAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Returns the direction of the third axis that's been calculated for this joint geometry.
        Conceptually, this is the Z-axis of the computed coordinate system.
        """
        return _fusion.JointGeometry__get_thirdAxisVector(self)

    def _get_planeOne(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the first plane for joint geometry that is defined between two planes. Returns null in all other cases."""
        return _fusion.JointGeometry__get_planeOne(self)

    def _get_planeTwo(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the second plane for joint geometry that is defined between two planes. Returns null in all other cases."""
        return _fusion.JointGeometry__get_planeTwo(self)

    def _get_objectType(self) -> "char const *" : return _fusion.JointGeometry__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.JointGeometry__get_isValid(self)
JointGeometry_swigregister = _fusion.JointGeometry_swigregister
JointGeometry_swigregister(JointGeometry)

def JointGeometry_classType() -> "char const *" :
  return _fusion.JointGeometry_classType()
JointGeometry_classType = _fusion.JointGeometry_classType

def JointGeometry_createByPlanarFace(*args) -> "adsk::core::Ptr< adsk::fusion::BRepFace > const &, adsk::core::Ptr< adsk::fusion::BRepEdge > const &" :
  return _fusion.JointGeometry_createByPlanarFace(*args)
JointGeometry_createByPlanarFace = _fusion.JointGeometry_createByPlanarFace

def JointGeometry_createByNonPlanarFace(*args) -> "adsk::core::Ptr< adsk::fusion::BRepFace > const &" :
  return _fusion.JointGeometry_createByNonPlanarFace(*args)
JointGeometry_createByNonPlanarFace = _fusion.JointGeometry_createByNonPlanarFace

def JointGeometry_createByProfile(*args) -> "adsk::core::Ptr< adsk::fusion::Profile > const &, adsk::core::Ptr< adsk::fusion::SketchCurve > const &" :
  return _fusion.JointGeometry_createByProfile(*args)
JointGeometry_createByProfile = _fusion.JointGeometry_createByProfile

def JointGeometry_createByCurve(*args) -> "adsk::core::Ptr< adsk::fusion::JointGeometry >" :
  return _fusion.JointGeometry_createByCurve(*args)
JointGeometry_createByCurve = _fusion.JointGeometry_createByCurve

def JointGeometry_createByPoint(*args) -> "adsk::core::Ptr< adsk::fusion::JointGeometry >" :
  return _fusion.JointGeometry_createByPoint(*args)
JointGeometry_createByPoint = _fusion.JointGeometry_createByPoint

def JointGeometry_createByBetweenTwoPlanes(*args) -> "adsk::core::Ptr< adsk::fusion::JointGeometry >" :
  return _fusion.JointGeometry_createByBetweenTwoPlanes(*args)
JointGeometry_createByBetweenTwoPlanes = _fusion.JointGeometry_createByBetweenTwoPlanes

JointGeometry.__swig_getmethods__["geometryType"] = JointGeometry._get_geometryType
JointGeometry.geometryType = property(JointGeometry._get_geometryType, doc="Returns the type of geometry this JointGeometry object represents.")

JointGeometry.__swig_getmethods__["keyPointType"] = JointGeometry._get_keyPointType
JointGeometry.keyPointType = property(JointGeometry._get_keyPointType, doc="Returns the keypoint type this JointGeometry is using.")

JointGeometry.__swig_getmethods__["entityOne"] = JointGeometry._get_entityOne
JointGeometry.entityOne = property(JointGeometry._get_entityOne, doc="The first entity that's defining this joint geometry. This can be various types of geometry depending\non how this joint geometry is defined. The geometryType property indicates how this joint geometry is\ndefined a provides a clue about the type of geometry to expect back from this property.")

JointGeometry.__swig_getmethods__["entityTwo"] = JointGeometry._get_entityTwo
JointGeometry.entityTwo = property(JointGeometry._get_entityTwo, doc="This is the second entity that defines this joint geometry. This isn't used for all joint geometry types\nand will return null in the cases where it's not used. A second geometry is used in the case where the geometryType\nproperty returns JointProfileGeometry, JointPlanarBRepFaceGeometry, or JointBetweenTowFacesGeometry.")

JointGeometry.__swig_getmethods__["origin"] = JointGeometry._get_origin
JointGeometry.origin = property(JointGeometry._get_origin, doc="Returns the origin point that's been calculated for this joint geometry.")

JointGeometry.__swig_getmethods__["primaryAxisVector"] = JointGeometry._get_primaryAxisVector
JointGeometry.primaryAxisVector = property(JointGeometry._get_primaryAxisVector, doc="Returns the direction of the primary axis that's been calculated for this joint geometry.\nConceptually, this is the X-axis of the computed coordinate system.")

JointGeometry.__swig_getmethods__["secondaryAxisVector"] = JointGeometry._get_secondaryAxisVector
JointGeometry.secondaryAxisVector = property(JointGeometry._get_secondaryAxisVector, doc="Returns the direction of the secondary axis that's been calculated for this joint geometry.\nConceptually, this is the Y-axis of the computed coordinate system.")

JointGeometry.__swig_getmethods__["thirdAxisVector"] = JointGeometry._get_thirdAxisVector
JointGeometry.thirdAxisVector = property(JointGeometry._get_thirdAxisVector, doc="Returns the direction of the third axis that's been calculated for this joint geometry.\nConceptually, this is the Z-axis of the computed coordinate system.")

JointGeometry.__swig_getmethods__["planeOne"] = JointGeometry._get_planeOne
JointGeometry.planeOne = property(JointGeometry._get_planeOne, doc="Returns the first plane for joint geometry that is defined between two planes. Returns null in all other cases.")

JointGeometry.__swig_getmethods__["planeTwo"] = JointGeometry._get_planeTwo
JointGeometry.planeTwo = property(JointGeometry._get_planeTwo, doc="Returns the second plane for joint geometry that is defined between two planes. Returns null in all other cases.")

JointGeometry.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, JointGeometry) else None
JointGeometry.cast = lambda arg: arg if isinstance(arg, JointGeometry) else None

class JointInput(Base):
    """
    Defines all of the information required to create a new joint. This object provides
    equivalent functionality to the Joint command dialog in that it gathers the required
    information to create a joint.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JointInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, JointInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::JointInput *" : return _fusion.JointInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.JointInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.JointInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.JointInput_classType
    if _newclass:classType = staticmethod(_fusion.JointInput_classType)
    __swig_destroy__ = _fusion.delete_JointInput
    __del__ = lambda self : None;
    def _get_geometryOrOriginOne(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets and sets the first JointGeometry or JointOrigin for this joint."""
        return _fusion.JointInput__get_geometryOrOriginOne(self)

    def _set_geometryOrOriginOne(self, *args) -> "bool" :
        """Gets and sets the first JointGeometry or JointOrigin for this joint."""
        return _fusion.JointInput__set_geometryOrOriginOne(self, *args)

    def _get_geometryOrOriginTwo(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets and sets the second JointGeometry or JointOrigin for this joint."""
        return _fusion.JointInput__get_geometryOrOriginTwo(self)

    def _set_geometryOrOriginTwo(self, *args) -> "bool" :
        """Gets and sets the second JointGeometry or JointOrigin for this joint."""
        return _fusion.JointInput__set_geometryOrOriginTwo(self, *args)

    def _get_angle(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Specifies the angle between two input geometries. This is effectively the
        angle between the two primary axes of the input geometries. When a new
        JointInput object is created, this value defaults to zero. When the joint
        is created this will become the value of the parameter that controls the joint angle.
        When using a real value to define the angle, the value is in radians. When
        using a string the expression is evaluated using the document default units for angles.
        """
        return _fusion.JointInput__get_angle(self)

    def _set_angle(self, *args) -> "bool" :
        """
        Specifies the angle between two input geometries. This is effectively the
        angle between the two primary axes of the input geometries. When a new
        JointInput object is created, this value defaults to zero. When the joint
        is created this will become the value of the parameter that controls the joint angle.
        When using a real value to define the angle, the value is in radians. When
        using a string the expression is evaluated using the document default units for angles.
        """
        return _fusion.JointInput__set_angle(self, *args)

    def _get_offset(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Specifies the offset between two input geometries. This is effectively the
        offset distance between the two planes defined by the primary and secondary axes
        of the input geometries. When a new JointInput object is created, this value defaults to zero. 
        When the joint is created this will become the value of the parameter that controls the joint offset.
        When using a real value to define the offset, the value is in centimeters. When
        using a string the expression is evaluated using the document default units for distance.
        """
        return _fusion.JointInput__get_offset(self)

    def _set_offset(self, *args) -> "bool" :
        """
        Specifies the offset between two input geometries. This is effectively the
        offset distance between the two planes defined by the primary and secondary axes
        of the input geometries. When a new JointInput object is created, this value defaults to zero. 
        When the joint is created this will become the value of the parameter that controls the joint offset.
        When using a real value to define the offset, the value is in centimeters. When
        using a string the expression is evaluated using the document default units for distance.
        """
        return _fusion.JointInput__set_offset(self, *args)

    def _get_isFlipped(self) -> "bool" :
        """
        Gets and sets if the joint direction is flipped or not. This is effectively
        specifying if the third axis of the two input geometries is facing (false) or
        opposed (true).
        """
        return _fusion.JointInput__get_isFlipped(self)

    def _set_isFlipped(self, *args) -> "bool" :
        """
        Gets and sets if the joint direction is flipped or not. This is effectively
        specifying if the third axis of the two input geometries is facing (false) or
        opposed (true).
        """
        return _fusion.JointInput__set_isFlipped(self, *args)

    def setAsRigidJointMotion(self) -> "bool" :
        """
        Defines the relationship between the two joint geometries as a rigid joint. 
        Returns true if successful.
        """
        return _fusion.JointInput_setAsRigidJointMotion(self)

    def setAsRevoluteJointMotion(self, *args) -> "bool" :
        """
        Defines the relationship between the two joint geometries as a revolute joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived
        from. 
        Returns true if the operation was successful.
        """
        return _fusion.JointInput_setAsRevoluteJointMotion(self, *args)

    def setAsSliderJointMotion(self, *args) -> "bool" :
        """
        Defines the relationship between the two joint geometries as a slider joint. 
        sliderDirection : Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the 
        customSliderDirectionEntity argument must also be provided. 
        customSliderDirectionEntity : If the sliderDirection is CustomJointDirection this argument is used to specify the entity that defines
        the custom slider direction. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.JointInput_setAsSliderJointMotion(self, *args)

    def setAsCylindricalJointMotion(self, *args) -> "bool" :
        """
        Defines the relationship between the two joint geometries as a cylindrical joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived
        from. 
        Returns true if the operation was successful.
        """
        return _fusion.JointInput_setAsCylindricalJointMotion(self, *args)

    def setAsPinSlotJointMotion(self, *args) -> "bool" :
        """
        Defines the relationship between the two joint geometries as a pin-slot joint. 
        rotationAxis : Specifies which axis the rotation is around. If this is set to CustomJointDirection then the 
        customRotationAxisEntity argument must also be provided. 
        slideDirection : Specifies which axis the slide direction is along. If this is set to CustomJointDirection then the 
        customSlideDirectionEntity argument must also be provided. 
        customRotationAxisEntity : If the rotationAxis is customAxisEntity this argument is used to specify the entity that defines
        the custom axis of rotation. This can be several types of entities that an axis can be derived 
        customSlideDirectionEntity : If the slideDirection is CustomJointDirection this argument is used to specify the entity that defines
        the custom slide direction. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.JointInput_setAsPinSlotJointMotion(self, *args)

    def setAsPlanarJointMotion(self, *args) -> "bool" :
        """
        Defines the relationship between the two joint geometries as a planar joint. 
        normalDirection : Defines the direction of the normal of the single degree of rotation.
        This can be set to XAxisJointDirection, YAxisJointDirection, ZAxisJointDirection, 
        or CustomJointDirection. If set to CustomJointDirection then the customNormalDirectionEntity
        argument must also be provided. 
        customNormalDirectionEntity : If the normalDirection is CustomJointDirection this argument is used to specify the entity that defines
        the direction of the normal. This can be several types of entities that can define a direction. 
        customPrimarySlideDirection : This arguments defines the direction of the primary slide direction. A default primary slide direction 
        is automatically chosen and will be used if this argument is not provided or is null. The secondary slide
        direction is automatically inferred from the normal and primary slide directions. 
        Returns true if the operation was successful.
        """
        return _fusion.JointInput_setAsPlanarJointMotion(self, *args)

    def setAsBallJointMotion(self, *args) -> "bool" :
        """
        Defines the relationship between the two joint geometries as a ball joint. 
        pitchDirection : Defines the direction the pitch angle is measured from. This can be ZAxisJointDirection or CustomJointDirection. If
        CustomJointDirection is specified then you must also provide a value for the customPitchDirection argument. 
        yawDirection : Defines the direction the yaw is measured from. This can be XAxisJointDirection or CustomJointDirection. If
        CustomJointDirection is specified then you must also provide a value for the customYawDirection argument. 
        customPitchDirection : If the pitchDirection argument is customPitchDirection this argument is used to define the direction the pitch
        angel is measured from. This can be several types of entities that can define a direction. 
        customYawDirection : If the yawDirection argument is customPitchDirection this argument is used to define the direction the yaw
        angel is measured from. This can be several types of entities that can define a direction. 
        Returns true if the operation was successful.
        """
        return _fusion.JointInput_setAsBallJointMotion(self, *args)

    def _get_jointMotion(self) -> "adsk::core::Ptr< adsk::fusion::JointMotion >" :
        """Returns an object derived from JointMotion that defines how the motion between the two joint geometries is defined."""
        return _fusion.JointInput__get_jointMotion(self)

    def _get_objectType(self) -> "char const *" : return _fusion.JointInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.JointInput__get_isValid(self)
JointInput_swigregister = _fusion.JointInput_swigregister
JointInput_swigregister(JointInput)

def JointInput_classType() -> "char const *" :
  return _fusion.JointInput_classType()
JointInput_classType = _fusion.JointInput_classType

JointInput.__swig_getmethods__["geometryOrOriginOne"] = JointInput._get_geometryOrOriginOne
JointInput.__swig_setmethods__["geometryOrOriginOne"] = JointInput._set_geometryOrOriginOne
JointInput.geometryOrOriginOne = property(JointInput._get_geometryOrOriginOne, JointInput._set_geometryOrOriginOne, doc="Gets and sets the first JointGeometry or JointOrigin for this joint.")

JointInput.__swig_getmethods__["geometryOrOriginTwo"] = JointInput._get_geometryOrOriginTwo
JointInput.__swig_setmethods__["geometryOrOriginTwo"] = JointInput._set_geometryOrOriginTwo
JointInput.geometryOrOriginTwo = property(JointInput._get_geometryOrOriginTwo, JointInput._set_geometryOrOriginTwo, doc="Gets and sets the second JointGeometry or JointOrigin for this joint.")

JointInput.__swig_getmethods__["angle"] = JointInput._get_angle
JointInput.__swig_setmethods__["angle"] = JointInput._set_angle
JointInput.angle = property(JointInput._get_angle, JointInput._set_angle, doc="Specifies the angle between two input geometries. This is effectively the\nangle between the two primary axes of the input geometries. When a new\nJointInput object is created, this value defaults to zero. When the joint\nis created this will become the value of the parameter that controls the joint angle.\nWhen using a real value to define the angle, the value is in radians. When\nusing a string the expression is evaluated using the document default units for angles.")

JointInput.__swig_getmethods__["offset"] = JointInput._get_offset
JointInput.__swig_setmethods__["offset"] = JointInput._set_offset
JointInput.offset = property(JointInput._get_offset, JointInput._set_offset, doc="Specifies the offset between two input geometries. This is effectively the\noffset distance between the two planes defined by the primary and secondary axes\nof the input geometries. When a new JointInput object is created, this value defaults to zero.\nWhen the joint is created this will become the value of the parameter that controls the joint offset.\nWhen using a real value to define the offset, the value is in centimeters. When\nusing a string the expression is evaluated using the document default units for distance.")

JointInput.__swig_getmethods__["isFlipped"] = JointInput._get_isFlipped
JointInput.__swig_setmethods__["isFlipped"] = JointInput._set_isFlipped
JointInput.isFlipped = property(JointInput._get_isFlipped, JointInput._set_isFlipped, doc="Gets and sets if the joint direction is flipped or not. This is effectively\nspecifying if the third axis of the two input geometries is facing (false) or\nopposed (true).")

JointInput.__swig_getmethods__["jointMotion"] = JointInput._get_jointMotion
JointInput.jointMotion = property(JointInput._get_jointMotion, doc="Returns an object derived from JointMotion that defines how the motion between the two joint geometries is defined.")

JointInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, JointInput) else None
JointInput.cast = lambda arg: arg if isinstance(arg, JointInput) else None

class JointLimits(Base):
    """Used to define limits for the range of motion of a joint."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JointLimits, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, JointLimits, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::JointLimits *" : return _fusion.JointLimits___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.JointLimits___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.JointLimits___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.JointLimits_classType
    if _newclass:classType = staticmethod(_fusion.JointLimits_classType)
    __swig_destroy__ = _fusion.delete_JointLimits
    __del__ = lambda self : None;
    def _get_minimumValue(self) -> "double" :
        """
        The minimum value of the value. This is in either centimeters
        or radians depending on if the joint value this is associated with
        defines a distance or an angle.
        """
        return _fusion.JointLimits__get_minimumValue(self)

    def _set_minimumValue(self, *args) -> "bool" :
        """
        The minimum value of the value. This is in either centimeters
        or radians depending on if the joint value this is associated with
        defines a distance or an angle.
        """
        return _fusion.JointLimits__set_minimumValue(self, *args)

    def _get_maximumValue(self) -> "double" :
        """
        The maximum value of the value. This is in either centimeters
        or radians depending on if the joint value this is associated with
        defines a distance or an angle.
        """
        return _fusion.JointLimits__get_maximumValue(self)

    def _set_maximumValue(self, *args) -> "bool" :
        """
        The maximum value of the value. This is in either centimeters
        or radians depending on if the joint value this is associated with
        defines a distance or an angle.
        """
        return _fusion.JointLimits__set_maximumValue(self, *args)

    def _get_restValue(self) -> "double" :
        """
        The resting state value. This is in either centimeters
        or radians depending on if the joint value this is associated with
        defines a distance or an angle.
        """
        return _fusion.JointLimits__get_restValue(self)

    def _set_restValue(self, *args) -> "bool" :
        """
        The resting state value. This is in either centimeters
        or radians depending on if the joint value this is associated with
        defines a distance or an angle.
        """
        return _fusion.JointLimits__set_restValue(self, *args)

    def _get_isMinimumValueEnabled(self) -> "bool" :
        """Gets and sets whether the minimum joint limit is enabled or not."""
        return _fusion.JointLimits__get_isMinimumValueEnabled(self)

    def _set_isMinimumValueEnabled(self, *args) -> "bool" :
        """Gets and sets whether the minimum joint limit is enabled or not."""
        return _fusion.JointLimits__set_isMinimumValueEnabled(self, *args)

    def _get_isMaximumValueEnabled(self) -> "bool" :
        """Gets and sets whether the maximum joint limit is enabled or not."""
        return _fusion.JointLimits__get_isMaximumValueEnabled(self)

    def _set_isMaximumValueEnabled(self, *args) -> "bool" :
        """Gets and sets whether the maximum joint limit is enabled or not."""
        return _fusion.JointLimits__set_isMaximumValueEnabled(self, *args)

    def _get_isRestValueEnabled(self) -> "bool" :
        """Gets and sets whether the resting joint value is enabled or not."""
        return _fusion.JointLimits__get_isRestValueEnabled(self)

    def _set_isRestValueEnabled(self, *args) -> "bool" :
        """Gets and sets whether the resting joint value is enabled or not."""
        return _fusion.JointLimits__set_isRestValueEnabled(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.JointLimits__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.JointLimits__get_isValid(self)
JointLimits_swigregister = _fusion.JointLimits_swigregister
JointLimits_swigregister(JointLimits)

def JointLimits_classType() -> "char const *" :
  return _fusion.JointLimits_classType()
JointLimits_classType = _fusion.JointLimits_classType

JointLimits.__swig_getmethods__["minimumValue"] = JointLimits._get_minimumValue
JointLimits.__swig_setmethods__["minimumValue"] = JointLimits._set_minimumValue
JointLimits.minimumValue = property(JointLimits._get_minimumValue, JointLimits._set_minimumValue, doc="The minimum value of the value. This is in either centimeters\nor radians depending on if the joint value this is associated with\ndefines a distance or an angle.")

JointLimits.__swig_getmethods__["maximumValue"] = JointLimits._get_maximumValue
JointLimits.__swig_setmethods__["maximumValue"] = JointLimits._set_maximumValue
JointLimits.maximumValue = property(JointLimits._get_maximumValue, JointLimits._set_maximumValue, doc="The maximum value of the value. This is in either centimeters\nor radians depending on if the joint value this is associated with\ndefines a distance or an angle.")

JointLimits.__swig_getmethods__["restValue"] = JointLimits._get_restValue
JointLimits.__swig_setmethods__["restValue"] = JointLimits._set_restValue
JointLimits.restValue = property(JointLimits._get_restValue, JointLimits._set_restValue, doc="The resting state value. This is in either centimeters\nor radians depending on if the joint value this is associated with\ndefines a distance or an angle.")

JointLimits.__swig_getmethods__["isMinimumValueEnabled"] = JointLimits._get_isMinimumValueEnabled
JointLimits.__swig_setmethods__["isMinimumValueEnabled"] = JointLimits._set_isMinimumValueEnabled
JointLimits.isMinimumValueEnabled = property(JointLimits._get_isMinimumValueEnabled, JointLimits._set_isMinimumValueEnabled, doc="Gets and sets whether the minimum joint limit is enabled or not.")

JointLimits.__swig_getmethods__["isMaximumValueEnabled"] = JointLimits._get_isMaximumValueEnabled
JointLimits.__swig_setmethods__["isMaximumValueEnabled"] = JointLimits._set_isMaximumValueEnabled
JointLimits.isMaximumValueEnabled = property(JointLimits._get_isMaximumValueEnabled, JointLimits._set_isMaximumValueEnabled, doc="Gets and sets whether the maximum joint limit is enabled or not.")

JointLimits.__swig_getmethods__["isRestValueEnabled"] = JointLimits._get_isRestValueEnabled
JointLimits.__swig_setmethods__["isRestValueEnabled"] = JointLimits._set_isRestValueEnabled
JointLimits.isRestValueEnabled = property(JointLimits._get_isRestValueEnabled, JointLimits._set_isRestValueEnabled, doc="Gets and sets whether the resting joint value is enabled or not.")

JointLimits.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, JointLimits) else None
JointLimits.cast = lambda arg: arg if isinstance(arg, JointLimits) else None

class JointList(Base):
    """A list of joints."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JointList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, JointList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::JointList *" : return _fusion.JointList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.JointList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.JointList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.JointList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::Joint >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.JointList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.JointList_classType
    if _newclass:classType = staticmethod(_fusion.JointList_classType)
    __swig_destroy__ = _fusion.delete_JointList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::Joint >" :
        """
        Function that returns the specified joint using an index into the list. 
        index : The index of the item within the list to return. The first item in the list has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.JointList_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::Joint >" :
        """
        Function that returns the specified joint using a name. 
        name : The name of the item within the list to return. 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.JointList_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns number of joints in the list."""
        return _fusion.JointList__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.JointList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.JointList__get_isValid(self)
JointList_swigregister = _fusion.JointList_swigregister
JointList_swigregister(JointList)

def JointList_classType() -> "char const *" :
  return _fusion.JointList_classType()
JointList_classType = _fusion.JointList_classType

JointList.__swig_getmethods__["count"] = JointList._get_count
JointList.count = property(JointList._get_count, doc="Returns number of joints in the list.")

JointList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, JointList) else None
JointList.cast = lambda arg: arg if isinstance(arg, JointList) else None

class JointMotion(Base):
    """
    The base class for the classes that represent all of the
    various joint types.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JointMotion, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, JointMotion, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::JointMotion *" : return _fusion.JointMotion___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.JointMotion___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.JointMotion___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.JointMotion_classType
    if _newclass:classType = staticmethod(_fusion.JointMotion_classType)
    __swig_destroy__ = _fusion.delete_JointMotion
    __del__ = lambda self : None;
    def _get_jointType(self) -> "adsk::fusion::JointTypes" :
        """Returns an enum value indicating the type of joint this joint represents."""
        return _fusion.JointMotion__get_jointType(self)

    def _get_objectType(self) -> "char const *" : return _fusion.JointMotion__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.JointMotion__get_isValid(self)
JointMotion_swigregister = _fusion.JointMotion_swigregister
JointMotion_swigregister(JointMotion)

def JointMotion_classType() -> "char const *" :
  return _fusion.JointMotion_classType()
JointMotion_classType = _fusion.JointMotion_classType

JointMotion.__swig_getmethods__["jointType"] = JointMotion._get_jointType
JointMotion.jointType = property(JointMotion._get_jointType, doc="Returns an enum value indicating the type of joint this joint represents.")

JointMotion.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, JointMotion) else None
JointMotion.cast = lambda arg: arg if isinstance(arg, JointMotion) else None

class JointOrigin(Base):
    """Represents an existing joint origin in a design."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JointOrigin, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, JointOrigin, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::JointOrigin *" : return _fusion.JointOrigin___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.JointOrigin___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.JointOrigin___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.JointOrigin_classType
    if _newclass:classType = staticmethod(_fusion.JointOrigin_classType)
    __swig_destroy__ = _fusion.delete_JointOrigin
    __del__ = lambda self : None;
    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this joint origin."""
        return _fusion.JointOrigin__get_parentComponent(self)

    def _get_name(self) -> "std::string" :
        """Gets and sets the name of this joint origin. This is the name seen by the user in the timeline."""
        return _fusion.JointOrigin__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Gets and sets the name of this joint origin. This is the name seen by the user in the timeline."""
        return _fusion.JointOrigin__set_name(self, *args)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::fusion::JointGeometry >" :
        """
        Gets and sets the joint geometry for this joint origin input. This
        defines the location of the joint origin.
        """
        return _fusion.JointOrigin__get_geometry(self)

    def _set_geometry(self, *args) -> "bool" :
        """
        Gets and sets the joint geometry for this joint origin input. This
        defines the location of the joint origin.
        """
        return _fusion.JointOrigin__set_geometry(self, *args)

    def _get_Angle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the parameter that controls the angle. The value can be changed
        using the functionality of the returned ModelParameter object.
        """
        return _fusion.JointOrigin__get_Angle(self)

    def _get_OffsetX(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the parameter that controls the X offset direction. The value can be changed
        using the functionality of the returned ModelParameter object.
        """
        return _fusion.JointOrigin__get_OffsetX(self)

    def _get_OffsetY(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the parameter that controls the Y offset direction. The value can be changed
        using the functionality of the returned ModelParameter object.
        """
        return _fusion.JointOrigin__get_OffsetY(self)

    def _get_OffsetZ(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the parameter that controls the Z offset direction. The value can be changed
        using the functionality of the returned ModelParameter object.
        """
        return _fusion.JointOrigin__get_OffsetZ(self)

    def _get_isFlipped(self) -> "bool" :
        """Gets and sets if the joint origin direction is flipped or not."""
        return _fusion.JointOrigin__get_isFlipped(self)

    def _set_isFlipped(self, *args) -> "bool" :
        """Gets and sets if the joint origin direction is flipped or not."""
        return _fusion.JointOrigin__set_isFlipped(self, *args)

    def _get_XAxisEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the entity that defines the X axis direction. This defaults
        to null meaning the X axis is inferred from the input geometry.
        """
        return _fusion.JointOrigin__get_XAxisEntity(self)

    def _set_XAxisEntity(self, *args) -> "bool" :
        """
        Gets and sets the entity that defines the X axis direction. This defaults
        to null meaning the X axis is inferred from the input geometry.
        """
        return _fusion.JointOrigin__set_XAxisEntity(self, *args)

    def _get_ZAxisEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the entity that defines the Z axis direction. This defaults
        to null meaning the Z axis is inferred from the input geometry.
        """
        return _fusion.JointOrigin__get_ZAxisEntity(self)

    def _set_ZAxisEntity(self, *args) -> "bool" :
        """
        Gets and sets the entity that defines the Z axis direction. This defaults
        to null meaning the Z axis is inferred from the input geometry.
        """
        return _fusion.JointOrigin__set_ZAxisEntity(self, *args)

    def _get_primaryAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Returns the direction of the primary axis that's been calculated for this joint origin."""
        return _fusion.JointOrigin__get_primaryAxisVector(self)

    def _get_secondaryAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Returns the direction of the secondary axis that's been calculated for this joint origin."""
        return _fusion.JointOrigin__get_secondaryAxisVector(self)

    def _get_thirdAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Returns the direction of the third axis that's been calculated for this joint origin."""
        return _fusion.JointOrigin__get_thirdAxisVector(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes this joint origin. 
        Returns true if successful.
        """
        return _fusion.JointOrigin_deleteMe(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this joint origin."""
        return _fusion.JointOrigin__get_timelineObject(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::JointOrigin >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.JointOrigin__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::JointOrigin >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.JointOrigin_createForAssemblyContext(self, *args)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.JointOrigin__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this joint origin."""
        return _fusion.JointOrigin__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.JointOrigin__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.JointOrigin__get_isValid(self)
JointOrigin_swigregister = _fusion.JointOrigin_swigregister
JointOrigin_swigregister(JointOrigin)

def JointOrigin_classType() -> "char const *" :
  return _fusion.JointOrigin_classType()
JointOrigin_classType = _fusion.JointOrigin_classType

JointOrigin.__swig_getmethods__["parentComponent"] = JointOrigin._get_parentComponent
JointOrigin.parentComponent = property(JointOrigin._get_parentComponent, doc="Returns the parent component that owns this joint origin.")

JointOrigin.__swig_getmethods__["name"] = JointOrigin._get_name
JointOrigin.__swig_setmethods__["name"] = JointOrigin._set_name
JointOrigin.name = property(JointOrigin._get_name, JointOrigin._set_name, doc="Gets and sets the name of this joint origin. This is the name seen by the user in the timeline.")

JointOrigin.__swig_getmethods__["geometry"] = JointOrigin._get_geometry
JointOrigin.__swig_setmethods__["geometry"] = JointOrigin._set_geometry
JointOrigin.geometry = property(JointOrigin._get_geometry, JointOrigin._set_geometry, doc="Gets and sets the joint geometry for this joint origin input. This\ndefines the location of the joint origin.")

JointOrigin.__swig_getmethods__["angle"] = JointOrigin._get_Angle
JointOrigin.angle = property(JointOrigin._get_Angle, doc="Gets the parameter that controls the angle. The value can be changed\nusing the functionality of the returned ModelParameter object.")

JointOrigin.__swig_getmethods__["offsetX"] = JointOrigin._get_OffsetX
JointOrigin.offsetX = property(JointOrigin._get_OffsetX, doc="Gets the parameter that controls the X offset direction. The value can be changed\nusing the functionality of the returned ModelParameter object.")

JointOrigin.__swig_getmethods__["offsetY"] = JointOrigin._get_OffsetY
JointOrigin.offsetY = property(JointOrigin._get_OffsetY, doc="Gets the parameter that controls the Y offset direction. The value can be changed\nusing the functionality of the returned ModelParameter object.")

JointOrigin.__swig_getmethods__["offsetZ"] = JointOrigin._get_OffsetZ
JointOrigin.offsetZ = property(JointOrigin._get_OffsetZ, doc="Gets the parameter that controls the Z offset direction. The value can be changed\nusing the functionality of the returned ModelParameter object.")

JointOrigin.__swig_getmethods__["isFlipped"] = JointOrigin._get_isFlipped
JointOrigin.__swig_setmethods__["isFlipped"] = JointOrigin._set_isFlipped
JointOrigin.isFlipped = property(JointOrigin._get_isFlipped, JointOrigin._set_isFlipped, doc="Gets and sets if the joint origin direction is flipped or not.")

JointOrigin.__swig_getmethods__["xAxisEntity"] = JointOrigin._get_XAxisEntity
JointOrigin.__swig_setmethods__["xAxisEntity"] = JointOrigin._set_XAxisEntity
JointOrigin.xAxisEntity = property(JointOrigin._get_XAxisEntity, JointOrigin._set_XAxisEntity, doc="Gets and sets the entity that defines the X axis direction. This defaults\nto null meaning the X axis is inferred from the input geometry.")

JointOrigin.__swig_getmethods__["zAxisEntity"] = JointOrigin._get_ZAxisEntity
JointOrigin.__swig_setmethods__["zAxisEntity"] = JointOrigin._set_ZAxisEntity
JointOrigin.zAxisEntity = property(JointOrigin._get_ZAxisEntity, JointOrigin._set_ZAxisEntity, doc="Gets and sets the entity that defines the Z axis direction. This defaults\nto null meaning the Z axis is inferred from the input geometry.")

JointOrigin.__swig_getmethods__["primaryAxisVector"] = JointOrigin._get_primaryAxisVector
JointOrigin.primaryAxisVector = property(JointOrigin._get_primaryAxisVector, doc="Returns the direction of the primary axis that's been calculated for this joint origin.")

JointOrigin.__swig_getmethods__["secondaryAxisVector"] = JointOrigin._get_secondaryAxisVector
JointOrigin.secondaryAxisVector = property(JointOrigin._get_secondaryAxisVector, doc="Returns the direction of the secondary axis that's been calculated for this joint origin.")

JointOrigin.__swig_getmethods__["thirdAxisVector"] = JointOrigin._get_thirdAxisVector
JointOrigin.thirdAxisVector = property(JointOrigin._get_thirdAxisVector, doc="Returns the direction of the third axis that's been calculated for this joint origin.")

JointOrigin.__swig_getmethods__["timelineObject"] = JointOrigin._get_timelineObject
JointOrigin.timelineObject = property(JointOrigin._get_timelineObject, doc="Returns the timeline object associated with this joint origin.")

JointOrigin.__swig_getmethods__["nativeObject"] = JointOrigin._get_nativeObject
JointOrigin.nativeObject = property(JointOrigin._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

JointOrigin.__swig_getmethods__["assemblyContext"] = JointOrigin._get_assemblyContext
JointOrigin.assemblyContext = property(JointOrigin._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")

JointOrigin.__swig_getmethods__["attributes"] = JointOrigin._get_attributes
JointOrigin.attributes = property(JointOrigin._get_attributes, doc="Returns the collection of attributes associated with this joint origin.")

JointOrigin.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, JointOrigin) else None
JointOrigin.cast = lambda arg: arg if isinstance(arg, JointOrigin) else None

class JointOriginInput(Base):
    """
    Defines all of the information required to create a new joint origin. This object provides
    equivalent functionality to the Joint Origin command dialog in that it gathers the required
    information to create a joint origin.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JointOriginInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, JointOriginInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::JointOriginInput *" : return _fusion.JointOriginInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.JointOriginInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.JointOriginInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.JointOriginInput_classType
    if _newclass:classType = staticmethod(_fusion.JointOriginInput_classType)
    __swig_destroy__ = _fusion.delete_JointOriginInput
    __del__ = lambda self : None;
    def _get_geometry(self) -> "adsk::core::Ptr< adsk::fusion::JointGeometry >" :
        """
        Gets and sets the joint geometry for this joint origin input. This
        defines the location of the joint origin.
        """
        return _fusion.JointOriginInput__get_geometry(self)

    def _set_geometry(self, *args) -> "bool" :
        """
        Gets and sets the joint geometry for this joint origin input. This
        defines the location of the joint origin.
        """
        return _fusion.JointOriginInput__set_geometry(self, *args)

    def _get_Angle(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Gets and sets the value that defines the angle for the joint origin. This defaults to zero
        if it's not specified. The value defines an angle and if the ValueInput is defined using
        the createByReal method the value is assumed to be radians.
        """
        return _fusion.JointOriginInput__get_Angle(self)

    def _set_Angle(self, *args) -> "bool" :
        """
        Gets and sets the value that defines the angle for the joint origin. This defaults to zero
        if it's not specified. The value defines an angle and if the ValueInput is defined using
        the createByReal method the value is assumed to be radians.
        """
        return _fusion.JointOriginInput__set_Angle(self, *args)

    def _get_OffsetX(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Gets and sets the value that defines the X offset direction. This defaults to zero
        if it's not specified. The value defines a distance and if the ValueInput is defined using
        the createByReal method the value is assumed to be centimeters.
        """
        return _fusion.JointOriginInput__get_OffsetX(self)

    def _set_OffsetX(self, *args) -> "bool" :
        """
        Gets and sets the value that defines the X offset direction. This defaults to zero
        if it's not specified. The value defines a distance and if the ValueInput is defined using
        the createByReal method the value is assumed to be centimeters.
        """
        return _fusion.JointOriginInput__set_OffsetX(self, *args)

    def _get_OffsetY(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Gets and sets the value that defines the Y offset direction. This defaults to zero
        if it's not specified. The value defines a distance and if the ValueInput is defined using
        the createByReal method the value is assumed to be centimeters.
        """
        return _fusion.JointOriginInput__get_OffsetY(self)

    def _set_OffsetY(self, *args) -> "bool" :
        """
        Gets and sets the value that defines the Y offset direction. This defaults to zero
        if it's not specified. The value defines a distance and if the ValueInput is defined using
        the createByReal method the value is assumed to be centimeters.
        """
        return _fusion.JointOriginInput__set_OffsetY(self, *args)

    def _get_OffsetZ(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Gets and sets the value that defines the Z offset direction. This defaults to zero
        if it's not specified. The value defines a distance and if the ValueInput is defined using
        the createByReal method the value is assumed to be centimeters.
        """
        return _fusion.JointOriginInput__get_OffsetZ(self)

    def _set_OffsetZ(self, *args) -> "bool" :
        """
        Gets and sets the value that defines the Z offset direction. This defaults to zero
        if it's not specified. The value defines a distance and if the ValueInput is defined using
        the createByReal method the value is assumed to be centimeters.
        """
        return _fusion.JointOriginInput__set_OffsetZ(self, *args)

    def _get_isFlipped(self) -> "bool" :
        """Gets and sets if the joint origin direction is flipped or not."""
        return _fusion.JointOriginInput__get_isFlipped(self)

    def _set_isFlipped(self, *args) -> "bool" :
        """Gets and sets if the joint origin direction is flipped or not."""
        return _fusion.JointOriginInput__set_isFlipped(self, *args)

    def _get_XAxisEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the entity that defines the X axis direction. This defaults
        to null meaning the X axis is inferred from the input geometry.
        """
        return _fusion.JointOriginInput__get_XAxisEntity(self)

    def _set_XAxisEntity(self, *args) -> "bool" :
        """
        Gets and sets the entity that defines the X axis direction. This defaults
        to null meaning the X axis is inferred from the input geometry.
        """
        return _fusion.JointOriginInput__set_XAxisEntity(self, *args)

    def _get_ZAxisEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the entity that defines the Z axis direction. This defaults
        to null meaning the Z axis is inferred from the input geometry.
        """
        return _fusion.JointOriginInput__get_ZAxisEntity(self)

    def _set_ZAxisEntity(self, *args) -> "bool" :
        """
        Gets and sets the entity that defines the Z axis direction. This defaults
        to null meaning the Z axis is inferred from the input geometry.
        """
        return _fusion.JointOriginInput__set_ZAxisEntity(self, *args)

    def _get_primaryAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Returns the direction of the primary axis that's been calculated for this joint origin."""
        return _fusion.JointOriginInput__get_primaryAxisVector(self)

    def _get_secondaryAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Returns the direction of the secondary axis that's been calculated for this joint origin."""
        return _fusion.JointOriginInput__get_secondaryAxisVector(self)

    def _get_thirdAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Returns the direction of the third axis that's been calculated for this joint origin."""
        return _fusion.JointOriginInput__get_thirdAxisVector(self)

    def _get_objectType(self) -> "char const *" : return _fusion.JointOriginInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.JointOriginInput__get_isValid(self)
JointOriginInput_swigregister = _fusion.JointOriginInput_swigregister
JointOriginInput_swigregister(JointOriginInput)

def JointOriginInput_classType() -> "char const *" :
  return _fusion.JointOriginInput_classType()
JointOriginInput_classType = _fusion.JointOriginInput_classType

JointOriginInput.__swig_getmethods__["geometry"] = JointOriginInput._get_geometry
JointOriginInput.__swig_setmethods__["geometry"] = JointOriginInput._set_geometry
JointOriginInput.geometry = property(JointOriginInput._get_geometry, JointOriginInput._set_geometry, doc="Gets and sets the joint geometry for this joint origin input. This\ndefines the location of the joint origin.")

JointOriginInput.__swig_getmethods__["angle"] = JointOriginInput._get_Angle
JointOriginInput.__swig_setmethods__["angle"] = JointOriginInput._set_Angle
JointOriginInput.angle = property(JointOriginInput._get_Angle, JointOriginInput._set_Angle, doc="Gets and sets the value that defines the angle for the joint origin. This defaults to zero\nif it's not specified. The value defines an angle and if the ValueInput is defined using\nthe createByReal method the value is assumed to be radians.")

JointOriginInput.__swig_getmethods__["offsetX"] = JointOriginInput._get_OffsetX
JointOriginInput.__swig_setmethods__["offsetX"] = JointOriginInput._set_OffsetX
JointOriginInput.offsetX = property(JointOriginInput._get_OffsetX, JointOriginInput._set_OffsetX, doc="Gets and sets the value that defines the X offset direction. This defaults to zero\nif it's not specified. The value defines a distance and if the ValueInput is defined using\nthe createByReal method the value is assumed to be centimeters.")

JointOriginInput.__swig_getmethods__["offsetY"] = JointOriginInput._get_OffsetY
JointOriginInput.__swig_setmethods__["offsetY"] = JointOriginInput._set_OffsetY
JointOriginInput.offsetY = property(JointOriginInput._get_OffsetY, JointOriginInput._set_OffsetY, doc="Gets and sets the value that defines the Y offset direction. This defaults to zero\nif it's not specified. The value defines a distance and if the ValueInput is defined using\nthe createByReal method the value is assumed to be centimeters.")

JointOriginInput.__swig_getmethods__["offsetZ"] = JointOriginInput._get_OffsetZ
JointOriginInput.__swig_setmethods__["offsetZ"] = JointOriginInput._set_OffsetZ
JointOriginInput.offsetZ = property(JointOriginInput._get_OffsetZ, JointOriginInput._set_OffsetZ, doc="Gets and sets the value that defines the Z offset direction. This defaults to zero\nif it's not specified. The value defines a distance and if the ValueInput is defined using\nthe createByReal method the value is assumed to be centimeters.")

JointOriginInput.__swig_getmethods__["isFlipped"] = JointOriginInput._get_isFlipped
JointOriginInput.__swig_setmethods__["isFlipped"] = JointOriginInput._set_isFlipped
JointOriginInput.isFlipped = property(JointOriginInput._get_isFlipped, JointOriginInput._set_isFlipped, doc="Gets and sets if the joint origin direction is flipped or not.")

JointOriginInput.__swig_getmethods__["xAxisEntity"] = JointOriginInput._get_XAxisEntity
JointOriginInput.__swig_setmethods__["xAxisEntity"] = JointOriginInput._set_XAxisEntity
JointOriginInput.xAxisEntity = property(JointOriginInput._get_XAxisEntity, JointOriginInput._set_XAxisEntity, doc="Gets and sets the entity that defines the X axis direction. This defaults\nto null meaning the X axis is inferred from the input geometry.")

JointOriginInput.__swig_getmethods__["zAxisEntity"] = JointOriginInput._get_ZAxisEntity
JointOriginInput.__swig_setmethods__["zAxisEntity"] = JointOriginInput._set_ZAxisEntity
JointOriginInput.zAxisEntity = property(JointOriginInput._get_ZAxisEntity, JointOriginInput._set_ZAxisEntity, doc="Gets and sets the entity that defines the Z axis direction. This defaults\nto null meaning the Z axis is inferred from the input geometry.")

JointOriginInput.__swig_getmethods__["primaryAxisVector"] = JointOriginInput._get_primaryAxisVector
JointOriginInput.primaryAxisVector = property(JointOriginInput._get_primaryAxisVector, doc="Returns the direction of the primary axis that's been calculated for this joint origin.")

JointOriginInput.__swig_getmethods__["secondaryAxisVector"] = JointOriginInput._get_secondaryAxisVector
JointOriginInput.secondaryAxisVector = property(JointOriginInput._get_secondaryAxisVector, doc="Returns the direction of the secondary axis that's been calculated for this joint origin.")

JointOriginInput.__swig_getmethods__["thirdAxisVector"] = JointOriginInput._get_thirdAxisVector
JointOriginInput.thirdAxisVector = property(JointOriginInput._get_thirdAxisVector, doc="Returns the direction of the third axis that's been calculated for this joint origin.")

JointOriginInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, JointOriginInput) else None
JointOriginInput.cast = lambda arg: arg if isinstance(arg, JointOriginInput) else None

class JointOriginList(Base):
    """A list of joint origins."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JointOriginList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, JointOriginList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::JointOriginList *" : return _fusion.JointOriginList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.JointOriginList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.JointOriginList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.JointOriginList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::JointOrigin >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.JointOriginList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.JointOriginList_classType
    if _newclass:classType = staticmethod(_fusion.JointOriginList_classType)
    __swig_destroy__ = _fusion.delete_JointOriginList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::JointOrigin >" :
        """
        Function that returns the specified joint origin using an index into the list. 
        index : The index of the item within the list to return. The first item in the list has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.JointOriginList_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::JointOrigin >" :
        """
        Function that returns the specified joint origin using a name. 
        name : The name of the item within the list to return. 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.JointOriginList_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns number of joint origins in the list."""
        return _fusion.JointOriginList__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.JointOriginList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.JointOriginList__get_isValid(self)
JointOriginList_swigregister = _fusion.JointOriginList_swigregister
JointOriginList_swigregister(JointOriginList)

def JointOriginList_classType() -> "char const *" :
  return _fusion.JointOriginList_classType()
JointOriginList_classType = _fusion.JointOriginList_classType

JointOriginList.__swig_getmethods__["count"] = JointOriginList._get_count
JointOriginList.count = property(JointOriginList._get_count, doc="Returns number of joint origins in the list.")

JointOriginList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, JointOriginList) else None
JointOriginList.cast = lambda arg: arg if isinstance(arg, JointOriginList) else None

class JointOrigins(Base):
    """
    The collection of joint origins in this component. This provides access to all existing 
    joint origins and supports the ability to create new joint origins.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JointOrigins, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, JointOrigins, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::JointOrigins *" : return _fusion.JointOrigins___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.JointOrigins___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.JointOrigins___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.JointOrigins___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::JointOrigin >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.JointOrigins___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.JointOrigins_classType
    if _newclass:classType = staticmethod(_fusion.JointOrigins_classType)
    __swig_destroy__ = _fusion.delete_JointOrigins
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::JointOrigin >" :
        """
        Function that returns the specified joint origin using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.JointOrigins_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::JointOrigin >" :
        """
        Function that returns the specified joint origin using a name. 
        name : The name of the item within the collection to return. 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.JointOrigins_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns number of joint origins in the collection."""
        return _fusion.JointOrigins__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::JointOriginInput >" :
        """
        Creates a JointOriginInput object which is used to collect all of the information 
        needed to create a simple joint origin. The creation of the input object takes the required
        input as the geometry argument and you can optionally use methods and properties on the created
        JointOriginInput to set other optional settings. The JointOrigin is created by calling the add 
        method of the JointOrigins object and passing it the JointOriginInput object. 
        geometry : A JointGeometry object that defines the geometry the joint origin will be created on. 
        Returns a JointOriginInput object if successfully created and null if it fails.
        """
        return _fusion.JointOrigins_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::JointOrigin >" :
        """
        Create a new joint origin. 
        input : A JointOriginInput object that full defines all of the information needed to create a joint origin.
        You create a JointOriginInput by using the createInput method of the JointOrigins object. 
        Returns a JointOrigin object if successfully created and null if it fails.
        """
        return _fusion.JointOrigins_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.JointOrigins__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.JointOrigins__get_isValid(self)
JointOrigins_swigregister = _fusion.JointOrigins_swigregister
JointOrigins_swigregister(JointOrigins)

def JointOrigins_classType() -> "char const *" :
  return _fusion.JointOrigins_classType()
JointOrigins_classType = _fusion.JointOrigins_classType

JointOrigins.__swig_getmethods__["count"] = JointOrigins._get_count
JointOrigins.count = property(JointOrigins._get_count, doc="Returns number of joint origins in the collection.")

JointOrigins.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, JointOrigins) else None
JointOrigins.cast = lambda arg: arg if isinstance(arg, JointOrigins) else None

class Joints(Base):
    """
    The collection of joints in this component. This provides access to all existing joints
    and supports the ability to create new joints.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Joints, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Joints, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::Joints *" : return _fusion.Joints___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Joints___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Joints___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.Joints___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::Joint >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.Joints___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Joints_classType
    if _newclass:classType = staticmethod(_fusion.Joints_classType)
    __swig_destroy__ = _fusion.delete_Joints
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::Joint >" :
        """
        Function that returns the specified joint using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.Joints_item(self, *args)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::JointInput >" :
        """
        Creates a JointInput object, which is the API equivalent to the Joint command dialog. You
        you use methods and properties on the returned class to set the desired options, similar to
        providing input and setting options in the Joint command dialog. Once the settings are defined
        you call the Joints.add method passing in the JointInput object to create the actual joint. 
        geometryOrOriginOne : A JointGeometry or JointOrigin object that defines the first set of geometry of the joint. 
        JointGeometry objects are created by using the various static methods on the JointGeometry class
        and JointOrigin objects are created through the JointOrigins object. 
        geometryOrOriginTwo : A JointGeometry or JointOrigin object that defines the second set of geometry of the joint. 
        JointGeometry objects are created by using the various static methods on the JointGeometry class
        and JointOrigin objects are created through the JointOrigins object. 
        Returns the JointInput object or null if the creation failed.
        """
        return _fusion.Joints_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::Joint >" :
        """
        Creates a new joint. 
        input : The JointInput object that defines the geometry and various inputs that fully define a joint.
        A JointInput object is created using the Joints.createInput method. 
        Returns the newly created Joint or null in the case of failure.
        """
        return _fusion.Joints_add(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns number of joints in the collection."""
        return _fusion.Joints__get_count(self)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::Joint >" :
        """
        Function that returns the specified joint using a name. 
        name : The name of the item within the collection to return. 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.Joints_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.Joints__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Joints__get_isValid(self)
Joints_swigregister = _fusion.Joints_swigregister
Joints_swigregister(Joints)

def Joints_classType() -> "char const *" :
  return _fusion.Joints_classType()
Joints_classType = _fusion.Joints_classType

Joints.__swig_getmethods__["count"] = Joints._get_count
Joints.count = property(Joints._get_count, doc="Returns number of joints in the collection.")

Joints.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Joints) else None
Joints.cast = lambda arg: arg if isinstance(arg, Joints) else None

class LoftCenterLineOrRail(Base):
    """Represent a centerline or a single rail used by a loft feature."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoftCenterLineOrRail, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoftCenterLineOrRail, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::LoftCenterLineOrRail *" : return _fusion.LoftCenterLineOrRail___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.LoftCenterLineOrRail___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.LoftCenterLineOrRail___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.LoftCenterLineOrRail_classType
    if _newclass:classType = staticmethod(_fusion.LoftCenterLineOrRail_classType)
    __swig_destroy__ = _fusion.delete_LoftCenterLineOrRail
    __del__ = lambda self : None;
    def _get_isCenterLine(self) -> "bool" :
        """Indicates if this object is a loft centerline (true) or a rail (false)."""
        return _fusion.LoftCenterLineOrRail__get_isCenterLine(self)

    def _get_entity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the entitiy that defines the centerline or rail. This can be a single sketch entity,
        a single BRepEdge, a Path, or a Profile.
        """
        return _fusion.LoftCenterLineOrRail__get_entity(self)

    def _set_entity(self, *args) -> "bool" :
        """
        Gets and sets the entitiy that defines the centerline or rail. This can be a single sketch entity,
        a single BRepEdge, a Path, or a Profile.
        """
        return _fusion.LoftCenterLineOrRail__set_entity(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the centerline or rail. 
        Returns true if the operation was successful.
        """
        return _fusion.LoftCenterLineOrRail_deleteMe(self)

    def _get_objectType(self) -> "char const *" : return _fusion.LoftCenterLineOrRail__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.LoftCenterLineOrRail__get_isValid(self)
LoftCenterLineOrRail_swigregister = _fusion.LoftCenterLineOrRail_swigregister
LoftCenterLineOrRail_swigregister(LoftCenterLineOrRail)

def LoftCenterLineOrRail_classType() -> "char const *" :
  return _fusion.LoftCenterLineOrRail_classType()
LoftCenterLineOrRail_classType = _fusion.LoftCenterLineOrRail_classType

LoftCenterLineOrRail.__swig_getmethods__["isCenterLine"] = LoftCenterLineOrRail._get_isCenterLine
LoftCenterLineOrRail.isCenterLine = property(LoftCenterLineOrRail._get_isCenterLine, doc="Indicates if this object is a loft centerline (true) or a rail (false).")

LoftCenterLineOrRail.__swig_getmethods__["entity"] = LoftCenterLineOrRail._get_entity
LoftCenterLineOrRail.__swig_setmethods__["entity"] = LoftCenterLineOrRail._set_entity
LoftCenterLineOrRail.entity = property(LoftCenterLineOrRail._get_entity, LoftCenterLineOrRail._set_entity, doc="Gets and sets the entitiy that defines the centerline or rail. This can be a single sketch entity,\na single BRepEdge, a Path, or a Profile.")

LoftCenterLineOrRail.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, LoftCenterLineOrRail) else None
LoftCenterLineOrRail.cast = lambda arg: arg if isinstance(arg, LoftCenterLineOrRail) else None

class LoftCenterLineOrRails(Base):
    """Defines a single centerline or one or more rails for a loft feature."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoftCenterLineOrRails, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoftCenterLineOrRails, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::LoftCenterLineOrRails *" : return _fusion.LoftCenterLineOrRails___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.LoftCenterLineOrRails___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.LoftCenterLineOrRails___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.LoftCenterLineOrRails___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::LoftCenterLineOrRail >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.LoftCenterLineOrRails___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.LoftCenterLineOrRails_classType
    if _newclass:classType = staticmethod(_fusion.LoftCenterLineOrRails_classType)
    __swig_destroy__ = _fusion.delete_LoftCenterLineOrRails
    __del__ = lambda self : None;
    def _get_count(self) -> "size_t" :
        """The number of centerlines or rails in the collection."""
        return _fusion.LoftCenterLineOrRails__get_count(self)

    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::LoftCenterLineOrRail >" :
        """
        Function that returns the specified LoftCenterLineOrRail using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.LoftCenterLineOrRails_item(self, *args)

    def _get_isCenterLine(self) -> "bool" :
        """Indicates if a centerline or rails are currently defined."""
        return _fusion.LoftCenterLineOrRails__get_isCenterLine(self)

    def addCenterLine(self, *args) -> "adsk::core::Ptr< adsk::fusion::LoftCenterLineOrRail >" :
        """
        Adds a centerline. A single centerline can be defined for a loft. If a centerline or rails have already
        been defined, they will be removed and the input will become the new single centerline. 
        entity : The entity that defines the center line. This can be a single sketch curve, a single BRepEdge, a Path consisting of
        connected B-Rep edges or sketch curves. 
        Returns the new LoftCenterLineOrRail object or null in the case of a failure.
        """
        return _fusion.LoftCenterLineOrRails_addCenterLine(self, *args)

    def addRail(self, *args) -> "adsk::core::Ptr< adsk::fusion::LoftCenterLineOrRail >" :
        """
        Add a rail to the loft definition. Multiple rails can be defined, so each call of this
        method adds a new rail. 
        entity : The entity that defines the rail. This can be a single sketch curve, a single BRepEdge, or a Path consisting of
        connected B-Rep edges or sketch curves. 
        Returns the new LoftCenterLineOrRail object or null in the case of a failure.
        """
        return _fusion.LoftCenterLineOrRails_addRail(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.LoftCenterLineOrRails__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.LoftCenterLineOrRails__get_isValid(self)
LoftCenterLineOrRails_swigregister = _fusion.LoftCenterLineOrRails_swigregister
LoftCenterLineOrRails_swigregister(LoftCenterLineOrRails)

def LoftCenterLineOrRails_classType() -> "char const *" :
  return _fusion.LoftCenterLineOrRails_classType()
LoftCenterLineOrRails_classType = _fusion.LoftCenterLineOrRails_classType

LoftCenterLineOrRails.__swig_getmethods__["count"] = LoftCenterLineOrRails._get_count
LoftCenterLineOrRails.count = property(LoftCenterLineOrRails._get_count, doc="The number of centerlines or rails in the collection.")

LoftCenterLineOrRails.__swig_getmethods__["isCenterLine"] = LoftCenterLineOrRails._get_isCenterLine
LoftCenterLineOrRails.isCenterLine = property(LoftCenterLineOrRails._get_isCenterLine, doc="Indicates if a centerline or rails are currently defined.")

LoftCenterLineOrRails.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, LoftCenterLineOrRails) else None
LoftCenterLineOrRails.cast = lambda arg: arg if isinstance(arg, LoftCenterLineOrRails) else None

class LoftEndCondition(Base):
    """The base class for all loft end conditions."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoftEndCondition, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoftEndCondition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::LoftEndCondition *" : return _fusion.LoftEndCondition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.LoftEndCondition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.LoftEndCondition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.LoftEndCondition_classType
    if _newclass:classType = staticmethod(_fusion.LoftEndCondition_classType)
    __swig_destroy__ = _fusion.delete_LoftEndCondition
    __del__ = lambda self : None;
    def _get_parentLoftSection(self) -> "adsk::core::Ptr< adsk::fusion::LoftSection >" :
        """Returns the parent loft section."""
        return _fusion.LoftEndCondition__get_parentLoftSection(self)

    def _get_objectType(self) -> "char const *" : return _fusion.LoftEndCondition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.LoftEndCondition__get_isValid(self)
LoftEndCondition_swigregister = _fusion.LoftEndCondition_swigregister
LoftEndCondition_swigregister(LoftEndCondition)

def LoftEndCondition_classType() -> "char const *" :
  return _fusion.LoftEndCondition_classType()
LoftEndCondition_classType = _fusion.LoftEndCondition_classType

LoftEndCondition.__swig_getmethods__["parentLoftSection"] = LoftEndCondition._get_parentLoftSection
LoftEndCondition.parentLoftSection = property(LoftEndCondition._get_parentLoftSection, doc="Returns the parent loft section.")

LoftEndCondition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, LoftEndCondition) else None
LoftEndCondition.cast = lambda arg: arg if isinstance(arg, LoftEndCondition) else None

class LoftFeatureInput(Base):
    """
    This object defines the all of the input necessary to create a loft feature. It is the 
    programming equivalent to the Loft command dialog. Through this object you provide
    the input needed to fully define a loft. To create the loft feature you pass 
    this object the the LoftFeatures.add method.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoftFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoftFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::LoftFeatureInput *" : return _fusion.LoftFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.LoftFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.LoftFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.LoftFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.LoftFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_LoftFeatureInput
    __del__ = lambda self : None;
    def _get_loftSections(self) -> "adsk::core::Ptr< adsk::fusion::LoftSections >" :
        """
        The set of sections, (or profiles as they're referred to in the user-interface), that the loft will pass through. Use the add method on the LoftSections
        object to specify new sections.
        """
        return _fusion.LoftFeatureInput__get_loftSections(self)

    def _get_centerLineOrRails(self) -> "adsk::core::Ptr< adsk::fusion::LoftCenterLineOrRails >" :
        """
        The single centerline or set of rails that define the shape of the loft. Use methods on the
        returned LoftCenterLineOrRails object to define the centerline or rails.
        """
        return _fusion.LoftFeatureInput__get_centerLineOrRails(self)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """Gets and sets the type of operation performed by the loft."""
        return _fusion.LoftFeatureInput__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """Gets and sets the type of operation performed by the loft."""
        return _fusion.LoftFeatureInput__set_operation(self, *args)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the loft is created based on geometry (e.g. a profile and/or face(s))
        when the loft is being created in another component AND the loft is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.LoftFeatureInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, *args) -> "bool" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the loft is created based on geometry (e.g. a profile and/or face(s))
        when the loft is being created in another component AND the loft is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.LoftFeatureInput__set_creationOccurrence(self, *args)

    def _get_isSolid(self) -> "bool" :
        """
        Specifies if the loft should be created as a solid or surface. This is
        initialized to true so a solid will attempt to be created if it's not changed.
        """
        return _fusion.LoftFeatureInput__get_isSolid(self)

    def _set_isSolid(self, *args) -> "bool" :
        """
        Specifies if the loft should be created as a solid or surface. This is
        initialized to true so a solid will attempt to be created if it's not changed.
        """
        return _fusion.LoftFeatureInput__set_isSolid(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.LoftFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.LoftFeatureInput__set_targetBaseFeature(self, *args)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >" :
        """
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        feature will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.LoftFeatureInput__get_participantBodies(self)

    def _set_participantBodies(self, *args) -> "bool" :
        """
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        feature will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.LoftFeatureInput__set_participantBodies(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.LoftFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.LoftFeatureInput__get_isValid(self)
LoftFeatureInput_swigregister = _fusion.LoftFeatureInput_swigregister
LoftFeatureInput_swigregister(LoftFeatureInput)

def LoftFeatureInput_classType() -> "char const *" :
  return _fusion.LoftFeatureInput_classType()
LoftFeatureInput_classType = _fusion.LoftFeatureInput_classType

LoftFeatureInput.__swig_getmethods__["loftSections"] = LoftFeatureInput._get_loftSections
LoftFeatureInput.loftSections = property(LoftFeatureInput._get_loftSections, doc="The set of sections, (or profiles as they're referred to in the user-interface), that the loft will pass through. Use the add method on the LoftSections\nobject to specify new sections.")

LoftFeatureInput.__swig_getmethods__["centerLineOrRails"] = LoftFeatureInput._get_centerLineOrRails
LoftFeatureInput.centerLineOrRails = property(LoftFeatureInput._get_centerLineOrRails, doc="The single centerline or set of rails that define the shape of the loft. Use methods on the\nreturned LoftCenterLineOrRails object to define the centerline or rails.")

LoftFeatureInput.__swig_getmethods__["operation"] = LoftFeatureInput._get_operation
LoftFeatureInput.__swig_setmethods__["operation"] = LoftFeatureInput._set_operation
LoftFeatureInput.operation = property(LoftFeatureInput._get_operation, LoftFeatureInput._set_operation, doc="Gets and sets the type of operation performed by the loft.")

LoftFeatureInput.__swig_getmethods__["creationOccurrence"] = LoftFeatureInput._get_creationOccurrence
LoftFeatureInput.__swig_setmethods__["creationOccurrence"] = LoftFeatureInput._set_creationOccurrence
LoftFeatureInput.creationOccurrence = property(LoftFeatureInput._get_creationOccurrence, LoftFeatureInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the loft is created based on geometry (e.g. a profile and/or face(s))\nwhen the loft is being created in another component AND the loft is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI")

LoftFeatureInput.__swig_getmethods__["isSolid"] = LoftFeatureInput._get_isSolid
LoftFeatureInput.__swig_setmethods__["isSolid"] = LoftFeatureInput._set_isSolid
LoftFeatureInput.isSolid = property(LoftFeatureInput._get_isSolid, LoftFeatureInput._set_isSolid, doc="Specifies if the loft should be created as a solid or surface. This is\ninitialized to true so a solid will attempt to be created if it's not changed.")

LoftFeatureInput.__swig_getmethods__["targetBaseFeature"] = LoftFeatureInput._get_targetBaseFeature
LoftFeatureInput.__swig_setmethods__["targetBaseFeature"] = LoftFeatureInput._set_targetBaseFeature
LoftFeatureInput.targetBaseFeature = property(LoftFeatureInput._get_targetBaseFeature, LoftFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

LoftFeatureInput.__swig_getmethods__["participantBodies"] = LoftFeatureInput._get_participantBodies
LoftFeatureInput.__swig_setmethods__["participantBodies"] = LoftFeatureInput._set_participantBodies
LoftFeatureInput.participantBodies = property(LoftFeatureInput._get_participantBodies, LoftFeatureInput._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.\nIf this property has not been set, the default behavior is that all bodies that are intersected by the\nfeature will participate.\nThis property can return null in the case where the feature has not been fully defined so that\npossible intersecting bodies can be computed.")

LoftFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, LoftFeatureInput) else None
LoftFeatureInput.cast = lambda arg: arg if isinstance(arg, LoftFeatureInput) else None

class LoftFeatures(Base):
    """Collection that provides access to all of the existing loft features in a design."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoftFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoftFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::LoftFeatures *" : return _fusion.LoftFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.LoftFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.LoftFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.LoftFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::LoftFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.LoftFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.LoftFeatures_classType
    if _newclass:classType = staticmethod(_fusion.LoftFeatures_classType)
    __swig_destroy__ = _fusion.delete_LoftFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::LoftFeature >" :
        """
        Function that returns the specified loft feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.LoftFeatures_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::LoftFeature >" :
        """
        Function that returns the specified loft feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.LoftFeatures_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of loft features in the collection."""
        return _fusion.LoftFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::LoftFeatureInput >" :
        """
        Creates a LoftFeatureInput object. Use properties and methods on the returned LoftFeatureInput
        object to provide the required input to create a loft feature. The LoftFeatureInput object can then be used as input to the 
        add method to create the loft feature. 
        operation : The feature operation to perform. 
        Returns the newly created LoftFeatureInput object or null if the creation failed.
        """
        return _fusion.LoftFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::LoftFeature >" :
        """
        Creates a new loft feature. 
        input : A LoftFeatureInput object that defines the desired loft feature. Use the createInput 
        method to create a new LoftFeatureInput object and then use methods on it 
        (the LoftFeatureInput object) to define the required input. 
        Returns the newly created LoftFeature object or null if the creation failed.
        """
        return _fusion.LoftFeatures_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.LoftFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.LoftFeatures__get_isValid(self)
LoftFeatures_swigregister = _fusion.LoftFeatures_swigregister
LoftFeatures_swigregister(LoftFeatures)

def LoftFeatures_classType() -> "char const *" :
  return _fusion.LoftFeatures_classType()
LoftFeatures_classType = _fusion.LoftFeatures_classType

LoftFeatures.__swig_getmethods__["count"] = LoftFeatures._get_count
LoftFeatures.count = property(LoftFeatures._get_count, doc="The number of loft features in the collection.")

LoftFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, LoftFeatures) else None
LoftFeatures.cast = lambda arg: arg if isinstance(arg, LoftFeatures) else None

class LoftSection(Base):
    """A single loft section."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoftSection, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoftSection, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::LoftSection *" : return _fusion.LoftSection___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.LoftSection___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.LoftSection___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.LoftSection_classType
    if _newclass:classType = staticmethod(_fusion.LoftSection_classType)
    __swig_destroy__ = _fusion.delete_LoftSection
    __del__ = lambda self : None;
    def _get_entity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Get and sets the entity that defines the section of the loft. This can be a BRepFace, Profile, Path, SketchPoint, ConstructionPoint, or an ObjectCollection
        of contiguous profiles.
        """
        return _fusion.LoftSection__get_entity(self)

    def _set_entity(self, *args) -> "bool" :
        """
        Get and sets the entity that defines the section of the loft. This can be a BRepFace, Profile, Path, SketchPoint, ConstructionPoint, or an ObjectCollection
        of contiguous profiles.
        """
        return _fusion.LoftSection__set_entity(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this LoftSection. 
        Returns true if the operation was successful.
        """
        return _fusion.LoftSection_deleteMe(self)

    def _get_index(self) -> "int" :
        """
        The position of this LoftSection within the collection. The first section has an index
        of 0. This is also the order of how the section will be used in the loft. The order
        can be modified by using the reorder method.
        """
        return _fusion.LoftSection__get_index(self)

    def reorder(self, *args) -> "bool" :
        """
        Repositions this section so that it has the new index specified. 
        newIndex : The new index value. For example, passing in zero as the new index will make this 
        the first section in the loft and (LoftSections.count - 1) will make it the last section.
        All other sections will be maintain their existing order but be shifted to allow space
        for this section. 
        Returns true if the reorder operation was successful.
        """
        return _fusion.LoftSection_reorder(self, *args)

    def _get_endCondition(self) -> "adsk::core::Ptr< adsk::fusion::LoftEndCondition >" :
        """
        Returns the current end condition. This is only valid for the first and last
        section and when the result is not closed. In other cases this will return null.
        This returns one of the several objects derived from LoftEndCondition and represents
        the current end condition. You can edit the existing condition using properties
        on the returned object. You can change the end condition using one of the set methods
        on the LoftSection object.
        """
        return _fusion.LoftSection__get_endCondition(self)

    def setFreeEndCondition(self) -> "bool" :
        """
        Sets the end condition to be a 'Free' end condition. This is the default
        end condition when a new section is added.
        This is valid for sections defined with all curve types. 
        Returns true if the operation was successful.
        """
        return _fusion.LoftSection_setFreeEndCondition(self)

    def setDirectionEndCondition(self, *args) -> "bool" :
        """
        Sets the end condition to be defined by a direction and weight.
        This is valid for sections defined with sketch curves. 
        angle : Input ValueInput object that specifies the direction by using an angle. This defaults to an angle of 0.0.
        If the ValueInput object is a string it must be an valid expression that can be evaluated as an angle.
        If the ValueInput is a value then it is in radians. 
        weight : Input ValueInput object that defines the weight or the amount of influence of end condition on the loft.
        This defaults to a value of 1.0. If the ValueInput object is a string it must be an valid expression that 
        can be evaluated as a unitless value. In any case, the value must be greater than 0. 
        Returns true if the operation was successful.
        """
        return _fusion.LoftSection_setDirectionEndCondition(self, *args)

    def setTangentEndCondition(self, *args) -> "bool" :
        """
        Sets the end condition to be tangent to the adjacent face. If the section is not defined by a BRepEdge,
        then this is ignored because there is no face to be tangent to.
        This is only valid on the first or last profile. 
        weight : Input ValueInput object that defines the weight or the amount of influence of end condition on the loft.
        This defaults to a value of 1.0. If the ValueInput object is a string it must be an valid expression that 
        can be evaluated as a unitless value. In any case, the value must be greater than 0. 
        Returns true if the operation was successful.
        """
        return _fusion.LoftSection_setTangentEndCondition(self, *args)

    def setSmoothEndCondition(self, *args) -> "bool" :
        """
        Sets the end condition to be smooth to the adjacent face. If the end profile is not defined by a BRepEdge,
        then this is ignored because there is no face to be smooth to.
        This is only valid on the first or last section. 
        weight : Input ValueInput object that defines the weight or the amount of influence of end condition on the loft.
        This defaults to a value of 1.0. If the ValueInput object is a string it must be an valid expression that 
        can be evaluated as a unitless value. In any case, the value must be greater than 0. 
        Returns true if the operation was successful.
        """
        return _fusion.LoftSection_setSmoothEndCondition(self, *args)

    def setPointSharpEndCondition(self) -> "bool" :
        """
        Sets the end condition to be sharp where the section is a point. This is the default condition for a point section. 
        Returns true if the operation was successful.
        """
        return _fusion.LoftSection_setPointSharpEndCondition(self)

    def setPointTangentEndCondition(self, *args) -> "bool" :
        """
        Set the end condition to a tangent condition in the case where the section is a point. 
        weight : Input ValueInput object that defines the weight or the amount of influence of end condition on the loft.
        This defaults to a value of 1.0. If the ValueInput object is a string it must be an valid expression that 
        can be evaluated as a unitless value. In any case, the value must be greater than 0. 
        Returns true if the operation was successful.
        """
        return _fusion.LoftSection_setPointTangentEndCondition(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.LoftSection__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.LoftSection__get_isValid(self)
LoftSection_swigregister = _fusion.LoftSection_swigregister
LoftSection_swigregister(LoftSection)

def LoftSection_classType() -> "char const *" :
  return _fusion.LoftSection_classType()
LoftSection_classType = _fusion.LoftSection_classType

LoftSection.__swig_getmethods__["entity"] = LoftSection._get_entity
LoftSection.__swig_setmethods__["entity"] = LoftSection._set_entity
LoftSection.entity = property(LoftSection._get_entity, LoftSection._set_entity, doc="Get and sets the entity that defines the section of the loft. This can be a BRepFace, Profile, Path, SketchPoint, ConstructionPoint, or an ObjectCollection\nof contiguous profiles.")

LoftSection.__swig_getmethods__["index"] = LoftSection._get_index
LoftSection.index = property(LoftSection._get_index, doc="The position of this LoftSection within the collection. The first section has an index\nof 0. This is also the order of how the section will be used in the loft. The order\ncan be modified by using the reorder method.")

LoftSection.__swig_getmethods__["endCondition"] = LoftSection._get_endCondition
LoftSection.endCondition = property(LoftSection._get_endCondition, doc="Returns the current end condition. This is only valid for the first and last\nsection and when the result is not closed. In other cases this will return null.\nThis returns one of the several objects derived from LoftEndCondition and represents\nthe current end condition. You can edit the existing condition using properties\non the returned object. You can change the end condition using one of the set methods\non the LoftSection object.")

LoftSection.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, LoftSection) else None
LoftSection.cast = lambda arg: arg if isinstance(arg, LoftSection) else None

class LoftSections(Base):
    """The set of two or more sections used to define the shape of the loft."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoftSections, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoftSections, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::LoftSections *" : return _fusion.LoftSections___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.LoftSections___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.LoftSections___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.LoftSections___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::LoftSection >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.LoftSections___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.LoftSections_classType
    if _newclass:classType = staticmethod(_fusion.LoftSections_classType)
    __swig_destroy__ = _fusion.delete_LoftSections
    __del__ = lambda self : None;
    def _get_count(self) -> "size_t" :
        """The number of LoftSections in the collection."""
        return _fusion.LoftSections__get_count(self)

    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::LoftSection >" :
        """
        Function that returns the specified LoftSection using an index into the collection. They are returned
        in the same order that they are used in the loft. Their order can be modified using the reorder method
        of the LoftSection object. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.LoftSections_item(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::LoftSection >" :
        """
        Adds a new section to the loft. The initial end condition is 'Free'. Additional methods on the
        returned LoftSection can be used to further define the section. 
        entity : Specifies the BRepFace, Profile, Path, SketchPoint, ConstructionPoint, or an ObjectCollection containing
        a contiguous set of Profile objects that defines the section. 
        Returns the newly created LoftSection object.
        """
        return _fusion.LoftSections_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.LoftSections__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.LoftSections__get_isValid(self)
LoftSections_swigregister = _fusion.LoftSections_swigregister
LoftSections_swigregister(LoftSections)

def LoftSections_classType() -> "char const *" :
  return _fusion.LoftSections_classType()
LoftSections_classType = _fusion.LoftSections_classType

LoftSections.__swig_getmethods__["count"] = LoftSections._get_count
LoftSections.count = property(LoftSections._get_count, doc="The number of LoftSections in the collection.")

LoftSections.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, LoftSections) else None
LoftSections.cast = lambda arg: arg if isinstance(arg, LoftSections) else None

class MeshBodies(Base):
    """
    Provides access to the MeshBodies in the parent Component and
    supports the creation of new mesh bodies.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MeshBodies, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MeshBodies, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::MeshBodies *" : return _fusion.MeshBodies___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.MeshBodies___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.MeshBodies___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.MeshBodies___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::MeshBody >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.MeshBodies___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.MeshBodies_classType
    if _newclass:classType = staticmethod(_fusion.MeshBodies_classType)
    __swig_destroy__ = _fusion.delete_MeshBodies
    __del__ = lambda self : None;
    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::MeshBodyList >" :
        """
        Creates a new mesh body by importing an .stl or .obj file.
        Because of a current limitation, if you want to create a mesh body in a parametric model, 
        you must first call the edit method of the base or form feature, use this method to create 
        the mesh body, and then call the finishEdit method of the base or form feature. The base 
        or form feature must be in an 'edit' state to be able to add any additional items to it. 
        fullFilename : The full filename (path and file) of a .stl or .obj file. 
        units : The units to use when importing the file. 
        baseOrFormFeature : The BaseFeature or FormFeature object that this mesh body will be associated with. This is an optional
        requirement and is required when the model design history is being captured (paremetric model) but is
        ignored otherwise (direct edit model). 
        Returns a list of the newly created mesh bodies or null if the creation failed. Multiple
        bodies can be created in the case where a .obj file that contains multiple bodies was imported.
        stl files always contain a single body.
        """
        return _fusion.MeshBodies_add(self, *args)

    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::MeshBody >" :
        """
        Provides access to a mesh body within the collection. 
        index : The index of the mesh body to return, where an index of 0 is the first mesh body in the collection. 
        Returns the specified mesh body or null in the case of a invalid index.
        """
        return _fusion.MeshBodies_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of mesh bodies in the collection."""
        return _fusion.MeshBodies__get_count(self)

    def addByTriangleMeshData(self, *args) -> "adsk::core::Ptr< adsk::fusion::MeshBody >" :
        """
        Createa a new mesh body using the mesh description provided. 
        coordinates : Input array of doubles that defines the X, Y, Z coordinates of each node in the mesh. Each set of three numbers define
        the coordinates of a node. 
        coordinateIndexList : An array of integers that represent indices into the coordinates to define the vertices of the triangles. If an empty
        array is provided, then it's assumed that the first three coordinates defines the first triangle, the next three define
        the second triangle, and so on. 
        normalVectors : An array of doubles that represent the x, y, z components of the normals at each coordinate. There should be a normal defined
        for each coordinate. If an empty array is provided for the normal vectors, Fusion 360 will automatically calculate normal vectors
        that are 90 degrees to the face of the triangle, making it appear flat. 
        normalIndexList : An array of integers that represent indices into the normal vectors to define the which vector corresponds to which vertex. This
        should be the same size as the vertex index list. If an empty array is input and normal vectors are provided, it is assumed that
        the normals match up one-to-one to each coordinate. 
        Returns the newly created MeshBody object or null in the case of a failure.
        """
        return _fusion.MeshBodies_addByTriangleMeshData(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.MeshBodies__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.MeshBodies__get_isValid(self)
MeshBodies_swigregister = _fusion.MeshBodies_swigregister
MeshBodies_swigregister(MeshBodies)

def MeshBodies_classType() -> "char const *" :
  return _fusion.MeshBodies_classType()
MeshBodies_classType = _fusion.MeshBodies_classType

MeshBodies.__swig_getmethods__["count"] = MeshBodies._get_count
MeshBodies.count = property(MeshBodies._get_count, doc="Returns the number of mesh bodies in the collection.")

MeshBodies.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MeshBodies) else None
MeshBodies.cast = lambda arg: arg if isinstance(arg, MeshBodies) else None

class MeshBody(Base):
    """Provides access to a mesh body."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MeshBody, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MeshBody, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::MeshBody *" : return _fusion.MeshBody___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.MeshBody___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.MeshBody___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.MeshBody_classType
    if _newclass:classType = staticmethod(_fusion.MeshBody_classType)
    __swig_destroy__ = _fusion.delete_MeshBody
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Gets and sets the name of the mesh body as displayed in the browser."""
        return _fusion.MeshBody__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Gets and sets the name of the mesh body as displayed in the browser."""
        return _fusion.MeshBody__set_name(self, *args)

    def _get_isSelectable(self) -> "bool" :
        """Gets and sets if the mesh body is selectable in the graphics window."""
        return _fusion.MeshBody__get_isSelectable(self)

    def _set_isSelectable(self, *args) -> "bool" :
        """Gets and sets if the mesh body is selectable in the graphics window."""
        return _fusion.MeshBody__set_isSelectable(self, *args)

    def _get_isLightBulbOn(self) -> "bool" :
        """
        Is the light bulb (as displayed in the browser) on.
        A mesh body will only be visible if the light bulb is switched on. However,
        the light bulb can be on and the mesh body is still invisible if the light bulb
        for all bodies or the owning component is off.
        """
        return _fusion.MeshBody__get_isLightBulbOn(self)

    def _set_isLightBulbOn(self, *args) -> "bool" :
        """
        Is the light bulb (as displayed in the browser) on.
        A mesh body will only be visible if the light bulb is switched on. However,
        the light bulb can be on and the mesh body is still invisible if the light bulb
        for all bodies or the owning component is off.
        """
        return _fusion.MeshBody__set_isLightBulbOn(self, *args)

    def _get_isVisible(self) -> "bool" :
        """Gets if the mesh body point is visible."""
        return _fusion.MeshBody__get_isVisible(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the mesh body. 
        Returns true in the case where the selection was successful.
        """
        return _fusion.MeshBody_deleteMe(self)

    def _get_mesh(self) -> "adsk::core::Ptr< adsk::fusion::PolygonMesh >" :
        """Returns the original mesh data that was imported. This can include triangles, quads, and polygons."""
        return _fusion.MeshBody__get_mesh(self)

    def _get_displayMesh(self) -> "adsk::core::Ptr< adsk::fusion::TriangleMesh >" :
        """Returns the associated mesh that is used for the display. This will always be triangles and includes any textures."""
        return _fusion.MeshBody__get_displayMesh(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent Component."""
        return _fusion.MeshBody__get_parentComponent(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.MeshBody__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::MeshBody >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.MeshBody__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::MeshBody >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence.
        Fails if this object is not the NativeObject. 
        occurrence : The occurrence that represents the context you want to create this proxy in. 
        Returns the proxy for the occurrence in the context of the specified occurrence. Returns null if it failed.
        """
        return _fusion.MeshBody_createForAssemblyContext(self, *args)

    def _get_baseOrFormFeature(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        This property returns the base or form feature that this mesh body is associated with. It
        returns null in the case where the modeling design history is not being captured (direct edit model).
        """
        return _fusion.MeshBody__get_baseOrFormFeature(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this mesh body."""
        return _fusion.MeshBody__get_attributes(self)

    def _get_material(self) -> "adsk::core::Ptr< adsk::core::Material >" :
        """Gets and sets the physical material assigned to this mesh body."""
        return _fusion.MeshBody__get_material(self)

    def _set_material(self, *args) -> "bool" :
        """Gets and sets the physical material assigned to this mesh body."""
        return _fusion.MeshBody__set_material(self, *args)

    def _get_appearance(self) -> "adsk::core::Ptr< adsk::core::Appearance >" :
        """
        Read-write property that gets and sets the current appearance of the body. Setting this property will result in applying
        an override appearance to the body and the AppearanceSourceType property will return OverrideAppearanceSource. Setting
        this property to null will remove any override.
        """
        return _fusion.MeshBody__get_appearance(self)

    def _set_appearance(self, *args) -> "bool" :
        """
        Read-write property that gets and sets the current appearance of the body. Setting this property will result in applying
        an override appearance to the body and the AppearanceSourceType property will return OverrideAppearanceSource. Setting
        this property to null will remove any override.
        """
        return _fusion.MeshBody__set_appearance(self, *args)

    def _get_appearanceSourceType(self) -> "adsk::core::AppearanceSourceTypes" :
        """
        Read-write property that gets the source of the appearance for the body. If this returns OverrideAppearanceSource, an override exists
        on this body. The override can be removed by setting the Appearance property to null.
        """
        return _fusion.MeshBody__get_appearanceSourceType(self)

    def _get_opacity(self) -> "double" :
        """
        Gets and sets the opacity override assigned to this body. A value of 1.0 specifies
        that is it completely opaque and a value of 0.0 specifies that is it completely transparent.
        This value is not necessarily related to what the user sees because the opacity is inherited.
        For example, if you this body is in a component and that component's opacity is set to something
        other than 1.0, the body will also be shown as slightly transparent even though the opacity 
        property for the body will return 1.0. Because the component that contains the body can be 
        referenced as an occurrence in other components and they can have different opacity settings, 
        it's possible that different instances of the same body can display using different opacity levels. 
        To get the opacity that it is being displayed with use the MeshBody.visibleOpacity property.
        This is the API equivalent of the 'Opacity Control' command available for the body in the browser.
        """
        return _fusion.MeshBody__get_opacity(self)

    def _set_opacity(self, *args) -> "bool" :
        """
        Gets and sets the opacity override assigned to this body. A value of 1.0 specifies
        that is it completely opaque and a value of 0.0 specifies that is it completely transparent.
        This value is not necessarily related to what the user sees because the opacity is inherited.
        For example, if you this body is in a component and that component's opacity is set to something
        other than 1.0, the body will also be shown as slightly transparent even though the opacity 
        property for the body will return 1.0. Because the component that contains the body can be 
        referenced as an occurrence in other components and they can have different opacity settings, 
        it's possible that different instances of the same body can display using different opacity levels. 
        To get the opacity that it is being displayed with use the MeshBody.visibleOpacity property.
        This is the API equivalent of the 'Opacity Control' command available for the body in the browser.
        """
        return _fusion.MeshBody__set_opacity(self, *args)

    def _get_visibleOpacity(self) -> "double" :
        """
        The user can set an override opacity for components and bodies these opacity overrides combine if
        children and parent components have overrides. This property returns the actual opacity that is
        being used to render the body. To set the opacity use the opacity property of the MeshBody object.
        """
        return _fusion.MeshBody__get_visibleOpacity(self)

    def _get_objectType(self) -> "char const *" : return _fusion.MeshBody__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.MeshBody__get_isValid(self)
MeshBody_swigregister = _fusion.MeshBody_swigregister
MeshBody_swigregister(MeshBody)

def MeshBody_classType() -> "char const *" :
  return _fusion.MeshBody_classType()
MeshBody_classType = _fusion.MeshBody_classType

MeshBody.__swig_getmethods__["name"] = MeshBody._get_name
MeshBody.__swig_setmethods__["name"] = MeshBody._set_name
MeshBody.name = property(MeshBody._get_name, MeshBody._set_name, doc="Gets and sets the name of the mesh body as displayed in the browser.")

MeshBody.__swig_getmethods__["isSelectable"] = MeshBody._get_isSelectable
MeshBody.__swig_setmethods__["isSelectable"] = MeshBody._set_isSelectable
MeshBody.isSelectable = property(MeshBody._get_isSelectable, MeshBody._set_isSelectable, doc="Gets and sets if the mesh body is selectable in the graphics window.")

MeshBody.__swig_getmethods__["isLightBulbOn"] = MeshBody._get_isLightBulbOn
MeshBody.__swig_setmethods__["isLightBulbOn"] = MeshBody._set_isLightBulbOn
MeshBody.isLightBulbOn = property(MeshBody._get_isLightBulbOn, MeshBody._set_isLightBulbOn, doc="Is the light bulb (as displayed in the browser) on.\nA mesh body will only be visible if the light bulb is switched on. However,\nthe light bulb can be on and the mesh body is still invisible if the light bulb\nfor all bodies or the owning component is off.")

MeshBody.__swig_getmethods__["isVisible"] = MeshBody._get_isVisible
MeshBody.isVisible = property(MeshBody._get_isVisible, doc="Gets if the mesh body point is visible.")

MeshBody.__swig_getmethods__["mesh"] = MeshBody._get_mesh
MeshBody.mesh = property(MeshBody._get_mesh, doc="Returns the original mesh data that was imported. This can include triangles, quads, and polygons.")

MeshBody.__swig_getmethods__["displayMesh"] = MeshBody._get_displayMesh
MeshBody.displayMesh = property(MeshBody._get_displayMesh, doc="Returns the associated mesh that is used for the display. This will always be triangles and includes any textures.")

MeshBody.__swig_getmethods__["parentComponent"] = MeshBody._get_parentComponent
MeshBody.parentComponent = property(MeshBody._get_parentComponent, doc="Returns the parent Component.")

MeshBody.__swig_getmethods__["assemblyContext"] = MeshBody._get_assemblyContext
MeshBody.assemblyContext = property(MeshBody._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")

MeshBody.__swig_getmethods__["nativeObject"] = MeshBody._get_nativeObject
MeshBody.nativeObject = property(MeshBody._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

MeshBody.__swig_getmethods__["baseOrFormFeature"] = MeshBody._get_baseOrFormFeature
MeshBody.baseOrFormFeature = property(MeshBody._get_baseOrFormFeature, doc="This property returns the base or form feature that this mesh body is associated with. It\nreturns null in the case where the modeling design history is not being captured (direct edit model).")

MeshBody.__swig_getmethods__["attributes"] = MeshBody._get_attributes
MeshBody.attributes = property(MeshBody._get_attributes, doc="Returns the collection of attributes associated with this mesh body.")

MeshBody.__swig_getmethods__["material"] = MeshBody._get_material
MeshBody.__swig_setmethods__["material"] = MeshBody._set_material
MeshBody.material = property(MeshBody._get_material, MeshBody._set_material, doc="Gets and sets the physical material assigned to this mesh body.")

MeshBody.__swig_getmethods__["appearance"] = MeshBody._get_appearance
MeshBody.__swig_setmethods__["appearance"] = MeshBody._set_appearance
MeshBody.appearance = property(MeshBody._get_appearance, MeshBody._set_appearance, doc="Read-write property that gets and sets the current appearance of the body. Setting this property will result in applying\nan override appearance to the body and the AppearanceSourceType property will return OverrideAppearanceSource. Setting\nthis property to null will remove any override.")

MeshBody.__swig_getmethods__["appearanceSourceType"] = MeshBody._get_appearanceSourceType
MeshBody.appearanceSourceType = property(MeshBody._get_appearanceSourceType, doc="Read-write property that gets the source of the appearance for the body. If this returns OverrideAppearanceSource, an override exists\non this body. The override can be removed by setting the Appearance property to null.")

MeshBody.__swig_getmethods__["opacity"] = MeshBody._get_opacity
MeshBody.__swig_setmethods__["opacity"] = MeshBody._set_opacity
MeshBody.opacity = property(MeshBody._get_opacity, MeshBody._set_opacity, doc="Gets and sets the opacity override assigned to this body. A value of 1.0 specifies\nthat is it completely opaque and a value of 0.0 specifies that is it completely transparent.\nThis value is not necessarily related to what the user sees because the opacity is inherited.\nFor example, if you this body is in a component and that component's opacity is set to something\nother than 1.0, the body will also be shown as slightly transparent even though the opacity\nproperty for the body will return 1.0. Because the component that contains the body can be\nreferenced as an occurrence in other components and they can have different opacity settings,\nit's possible that different instances of the same body can display using different opacity levels.\nTo get the opacity that it is being displayed with use the MeshBody.visibleOpacity property.\nThis is the API equivalent of the 'Opacity Control' command available for the body in the browser.")

MeshBody.__swig_getmethods__["visibleOpacity"] = MeshBody._get_visibleOpacity
MeshBody.visibleOpacity = property(MeshBody._get_visibleOpacity, doc="The user can set an override opacity for components and bodies these opacity overrides combine if\nchildren and parent components have overrides. This property returns the actual opacity that is\nbeing used to render the body. To set the opacity use the opacity property of the MeshBody object.")

MeshBody.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MeshBody) else None
MeshBody.cast = lambda arg: arg if isinstance(arg, MeshBody) else None

class MeshBodyList(Base):
    """Provides access to a list of MeshBody objects."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MeshBodyList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MeshBodyList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::MeshBodyList *" : return _fusion.MeshBodyList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.MeshBodyList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.MeshBodyList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.MeshBodyList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::MeshBody >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.MeshBodyList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.MeshBodyList_classType
    if _newclass:classType = staticmethod(_fusion.MeshBodyList_classType)
    __swig_destroy__ = _fusion.delete_MeshBodyList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::MeshBody >" :
        """
        Provides access to a mesh body within the collection. 
        index : The index of the mesh body to return, where an index of 0 is the first mesh body in the collection. 
        Returns the specified mesh body or null in the case of a invalid index.
        """
        return _fusion.MeshBodyList_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of mesh bodies in the collection."""
        return _fusion.MeshBodyList__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.MeshBodyList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.MeshBodyList__get_isValid(self)
MeshBodyList_swigregister = _fusion.MeshBodyList_swigregister
MeshBodyList_swigregister(MeshBodyList)

def MeshBodyList_classType() -> "char const *" :
  return _fusion.MeshBodyList_classType()
MeshBodyList_classType = _fusion.MeshBodyList_classType

MeshBodyList.__swig_getmethods__["count"] = MeshBodyList._get_count
MeshBodyList.count = property(MeshBodyList._get_count, doc="Returns the number of mesh bodies in the collection.")

MeshBodyList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MeshBodyList) else None
MeshBodyList.cast = lambda arg: arg if isinstance(arg, MeshBodyList) else None

class MeshManager(Base):
    """Provides access to meshes that approximate a B-Rep and T-Spline."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MeshManager, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MeshManager, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::MeshManager *" : return _fusion.MeshManager___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.MeshManager___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.MeshManager___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.MeshManager_classType
    if _newclass:classType = staticmethod(_fusion.MeshManager_classType)
    __swig_destroy__ = _fusion.delete_MeshManager
    __del__ = lambda self : None;
    def createMeshCalculator(self) -> "adsk::core::Ptr< adsk::fusion::TriangleMeshCalculator >" :
        """
        Creates a new MeshCalculator which is used to calculate
        new triangular meshes based on various parameters that control the calculation. 
        Returns the new MeshCalculator object or null if the creation failed.
        """
        return _fusion.MeshManager_createMeshCalculator(self)

    def _get_displayMeshes(self) -> "adsk::core::Ptr< adsk::fusion::TriangleMeshList >" :
        """
        Returns a collection that provides access to all of the
        existing display meshes.
        """
        return _fusion.MeshManager__get_displayMeshes(self)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the parent BRepBody, BRepFace, BRepLump, BRepShell, SculptBody, or SculptFace object."""
        return _fusion.MeshManager__get_parent(self)

    def _get_objectType(self) -> "char const *" : return _fusion.MeshManager__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.MeshManager__get_isValid(self)
MeshManager_swigregister = _fusion.MeshManager_swigregister
MeshManager_swigregister(MeshManager)

def MeshManager_classType() -> "char const *" :
  return _fusion.MeshManager_classType()
MeshManager_classType = _fusion.MeshManager_classType

MeshManager.__swig_getmethods__["displayMeshes"] = MeshManager._get_displayMeshes
MeshManager.displayMeshes = property(MeshManager._get_displayMeshes, doc="Returns a collection that provides access to all of the\nexisting display meshes.")

MeshManager.__swig_getmethods__["parent"] = MeshManager._get_parent
MeshManager.parent = property(MeshManager._get_parent, doc="Returns the parent BRepBody, BRepFace, BRepLump, BRepShell, SculptBody, or SculptFace object.")

MeshManager.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MeshManager) else None
MeshManager.cast = lambda arg: arg if isinstance(arg, MeshManager) else None

class MirrorFeatureInput(Base):
    """
    This class defines the methods and properties that pertain to the definition of a mirror 
    feature.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MirrorFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MirrorFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::MirrorFeatureInput *" : return _fusion.MirrorFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.MirrorFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.MirrorFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.MirrorFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.MirrorFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_MirrorFeatureInput
    __del__ = lambda self : None;
    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the entities that are mirrored. It can contain faces, features, bodies, or components. 
        The input must all be of a single type. For example, you can't provide a body and a component but 
        the collection must be either all bodies or all components.
        """
        return _fusion.MirrorFeatureInput__get_inputEntities(self)

    def _set_inputEntities(self, *args) -> "bool" :
        """
        Gets and sets the entities that are mirrored. It can contain faces, features, bodies, or components. 
        The input must all be of a single type. For example, you can't provide a body and a component but 
        the collection must be either all bodies or all components.
        """
        return _fusion.MirrorFeatureInput__set_inputEntities(self, *args)

    def _get_mirrorPlane(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets and sets the mirror plane. This can be either a planar face or construction plane."""
        return _fusion.MirrorFeatureInput__get_mirrorPlane(self)

    def _set_mirrorPlane(self, *args) -> "bool" :
        """Gets and sets the mirror plane. This can be either a planar face or construction plane."""
        return _fusion.MirrorFeatureInput__set_mirrorPlane(self, *args)

    def _get_patternComputeOption(self) -> "adsk::fusion::PatternComputeOptions" :
        """
        Gets and sets the compute option when mirroring features. The default value for this is AdjustPatternCompute.
        This property only applies when mirroring features and is ignored in the direct modeling environment.
        """
        return _fusion.MirrorFeatureInput__get_patternComputeOption(self)

    def _set_patternComputeOption(self, *args) -> "bool" :
        """
        Gets and sets the compute option when mirroring features. The default value for this is AdjustPatternCompute.
        This property only applies when mirroring features and is ignored in the direct modeling environment.
        """
        return _fusion.MirrorFeatureInput__set_patternComputeOption(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.MirrorFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.MirrorFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.MirrorFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.MirrorFeatureInput__get_isValid(self)
MirrorFeatureInput_swigregister = _fusion.MirrorFeatureInput_swigregister
MirrorFeatureInput_swigregister(MirrorFeatureInput)

def MirrorFeatureInput_classType() -> "char const *" :
  return _fusion.MirrorFeatureInput_classType()
MirrorFeatureInput_classType = _fusion.MirrorFeatureInput_classType

MirrorFeatureInput.__swig_getmethods__["inputEntities"] = MirrorFeatureInput._get_inputEntities
MirrorFeatureInput.__swig_setmethods__["inputEntities"] = MirrorFeatureInput._set_inputEntities
MirrorFeatureInput.inputEntities = property(MirrorFeatureInput._get_inputEntities, MirrorFeatureInput._set_inputEntities, doc="Gets and sets the entities that are mirrored. It can contain faces, features, bodies, or components.\nThe input must all be of a single type. For example, you can't provide a body and a component but\nthe collection must be either all bodies or all components.")

MirrorFeatureInput.__swig_getmethods__["mirrorPlane"] = MirrorFeatureInput._get_mirrorPlane
MirrorFeatureInput.__swig_setmethods__["mirrorPlane"] = MirrorFeatureInput._set_mirrorPlane
MirrorFeatureInput.mirrorPlane = property(MirrorFeatureInput._get_mirrorPlane, MirrorFeatureInput._set_mirrorPlane, doc="Gets and sets the mirror plane. This can be either a planar face or construction plane.")

MirrorFeatureInput.__swig_getmethods__["patternComputeOption"] = MirrorFeatureInput._get_patternComputeOption
MirrorFeatureInput.__swig_setmethods__["patternComputeOption"] = MirrorFeatureInput._set_patternComputeOption
MirrorFeatureInput.patternComputeOption = property(MirrorFeatureInput._get_patternComputeOption, MirrorFeatureInput._set_patternComputeOption, doc="Gets and sets the compute option when mirroring features. The default value for this is AdjustPatternCompute.\nThis property only applies when mirroring features and is ignored in the direct modeling environment.")

MirrorFeatureInput.__swig_getmethods__["targetBaseFeature"] = MirrorFeatureInput._get_targetBaseFeature
MirrorFeatureInput.__swig_setmethods__["targetBaseFeature"] = MirrorFeatureInput._set_targetBaseFeature
MirrorFeatureInput.targetBaseFeature = property(MirrorFeatureInput._get_targetBaseFeature, MirrorFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

MirrorFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MirrorFeatureInput) else None
MirrorFeatureInput.cast = lambda arg: arg if isinstance(arg, MirrorFeatureInput) else None

class MirrorFeatures(Base):
    """
    Collection that provides access to all of the existing mirror features in a component
    and supports the ability to create new mirror features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MirrorFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MirrorFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::MirrorFeatures *" : return _fusion.MirrorFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.MirrorFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.MirrorFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.MirrorFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::MirrorFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.MirrorFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.MirrorFeatures_classType
    if _newclass:classType = staticmethod(_fusion.MirrorFeatures_classType)
    __swig_destroy__ = _fusion.delete_MirrorFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::MirrorFeature >" :
        """
        Function that returns the specified mirror feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.MirrorFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of mirror features in the collection."""
        return _fusion.MirrorFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::MirrorFeatureInput >" :
        """
        Creates a MirrorFeatureInput object. Use properties and methods on this object
        to define the mirror you want to create and then use the Add method, passing in 
        the MirrorFeatureInput object. 
        inputEntities : A collection of the entities to mirror. It can contain faces, features, bodies, or components. 
        The input must all be of a single type. For example, you can't provide a body and a component but 
        the collection must be either all bodies or all components. 
        mirrorPlane : Input planar entity that defines the mirror plane. This can be either a planar face or a construction plane. 
        Returns the newly created MirrorFeatureInput object or null if the creation failed.
        """
        return _fusion.MirrorFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::MirrorFeature >" :
        """
        Creates a new mirror feature. 
        input : A MirrorFeatureInput object that defines the desired mirror. Use the createInput 
        method to create a new MirrorFeatureInput object and then use methods on it 
        (the MirrorFeatureInput object) to define the mirror. 
        Returns the newly created MirrorFeature object or null if the creation failed.
        """
        return _fusion.MirrorFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::MirrorFeature >" :
        """
        Function that returns the specified mirror feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.MirrorFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.MirrorFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.MirrorFeatures__get_isValid(self)
MirrorFeatures_swigregister = _fusion.MirrorFeatures_swigregister
MirrorFeatures_swigregister(MirrorFeatures)

def MirrorFeatures_classType() -> "char const *" :
  return _fusion.MirrorFeatures_classType()
MirrorFeatures_classType = _fusion.MirrorFeatures_classType

MirrorFeatures.__swig_getmethods__["count"] = MirrorFeatures._get_count
MirrorFeatures.count = property(MirrorFeatures._get_count, doc="The number of mirror features in the collection.")

MirrorFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MirrorFeatures) else None
MirrorFeatures.cast = lambda arg: arg if isinstance(arg, MirrorFeatures) else None

class ModelParameters(Base):
    """Provides access to the Model Parameters within a component."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModelParameters, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ModelParameters, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ModelParameters *" : return _fusion.ModelParameters___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ModelParameters___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ModelParameters___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.ModelParameters___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.ModelParameters___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ModelParameters_classType
    if _newclass:classType = staticmethod(_fusion.ModelParameters_classType)
    __swig_destroy__ = _fusion.delete_ModelParameters
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Function that returns the specified Model Parameter using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection 
        has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ModelParameters_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Function that returns the specified Model Parameter using the name of the parameter as it is 
        displayed in the parameters dialog. 
        name : The name of the Model Parameter as it is displayed in the parameters dialog 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.ModelParameters_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of parameters in the collection."""
        return _fusion.ModelParameters__get_count(self)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the component that owns the Model Parameters collection"""
        return _fusion.ModelParameters__get_component(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ModelParameters__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ModelParameters__get_isValid(self)
ModelParameters_swigregister = _fusion.ModelParameters_swigregister
ModelParameters_swigregister(ModelParameters)

def ModelParameters_classType() -> "char const *" :
  return _fusion.ModelParameters_classType()
ModelParameters_classType = _fusion.ModelParameters_classType

ModelParameters.__swig_getmethods__["count"] = ModelParameters._get_count
ModelParameters.count = property(ModelParameters._get_count, doc="Returns the number of parameters in the collection.")

ModelParameters.__swig_getmethods__["component"] = ModelParameters._get_component
ModelParameters.component = property(ModelParameters._get_component, doc="Returns the component that owns the Model Parameters collection")

ModelParameters.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ModelParameters) else None
ModelParameters.cast = lambda arg: arg if isinstance(arg, ModelParameters) else None

class MoveFeatureInput(Base):
    """This class defines the methods and properties that pertain to the definition of a move feature."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoveFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MoveFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::MoveFeatureInput *" : return _fusion.MoveFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.MoveFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.MoveFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.MoveFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.MoveFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_MoveFeatureInput
    __del__ = lambda self : None;
    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the entities to move.
        This collection can only contain BRepBody objects in parametric modeling.
        It can be BRep bodies, T-Spline bodies and mesh bodies mixed or faces and features mixed in non-parametric modeling.
        """
        return _fusion.MoveFeatureInput__get_inputEntities(self)

    def _set_inputEntities(self, *args) -> "bool" :
        """
        Gets and sets the entities to move.
        This collection can only contain BRepBody objects in parametric modeling.
        It can be BRep bodies, T-Spline bodies and mesh bodies mixed or faces and features mixed in non-parametric modeling.
        """
        return _fusion.MoveFeatureInput__set_inputEntities(self, *args)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >" :
        """
        Gets and sets the tranform to apply to the input entities. This can describe a move (translation) 
        or a rotation. The matrix must define an orthogonal transform. That is the axes remain 
        perpendicular to each other and there isn't any scale or mirror defined.
        """
        return _fusion.MoveFeatureInput__get_transform(self)

    def _set_transform(self, *args) -> "bool" :
        """
        Gets and sets the tranform to apply to the input entities. This can describe a move (translation) 
        or a rotation. The matrix must define an orthogonal transform. That is the axes remain 
        perpendicular to each other and there isn't any scale or mirror defined.
        """
        return _fusion.MoveFeatureInput__set_transform(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.MoveFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.MoveFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.MoveFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.MoveFeatureInput__get_isValid(self)
MoveFeatureInput_swigregister = _fusion.MoveFeatureInput_swigregister
MoveFeatureInput_swigregister(MoveFeatureInput)

def MoveFeatureInput_classType() -> "char const *" :
  return _fusion.MoveFeatureInput_classType()
MoveFeatureInput_classType = _fusion.MoveFeatureInput_classType

MoveFeatureInput.__swig_getmethods__["inputEntities"] = MoveFeatureInput._get_inputEntities
MoveFeatureInput.__swig_setmethods__["inputEntities"] = MoveFeatureInput._set_inputEntities
MoveFeatureInput.inputEntities = property(MoveFeatureInput._get_inputEntities, MoveFeatureInput._set_inputEntities, doc="Gets and sets the entities to move.\nThis collection can only contain BRepBody objects in parametric modeling.\nIt can be BRep bodies, T-Spline bodies and mesh bodies mixed or faces and features mixed in non-parametric modeling.")

MoveFeatureInput.__swig_getmethods__["transform"] = MoveFeatureInput._get_transform
MoveFeatureInput.__swig_setmethods__["transform"] = MoveFeatureInput._set_transform
MoveFeatureInput.transform = property(MoveFeatureInput._get_transform, MoveFeatureInput._set_transform, doc="Gets and sets the tranform to apply to the input entities. This can describe a move (translation)\nor a rotation. The matrix must define an orthogonal transform. That is the axes remain\nperpendicular to each other and there isn't any scale or mirror defined.")

MoveFeatureInput.__swig_getmethods__["targetBaseFeature"] = MoveFeatureInput._get_targetBaseFeature
MoveFeatureInput.__swig_setmethods__["targetBaseFeature"] = MoveFeatureInput._set_targetBaseFeature
MoveFeatureInput.targetBaseFeature = property(MoveFeatureInput._get_targetBaseFeature, MoveFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

MoveFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MoveFeatureInput) else None
MoveFeatureInput.cast = lambda arg: arg if isinstance(arg, MoveFeatureInput) else None

class MoveFeatures(Base):
    """
    Collection that provides access to all of the existing move features in a component
    and supports the ability to create new move features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoveFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MoveFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::MoveFeatures *" : return _fusion.MoveFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.MoveFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.MoveFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.MoveFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::MoveFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.MoveFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.MoveFeatures_classType
    if _newclass:classType = staticmethod(_fusion.MoveFeatures_classType)
    __swig_destroy__ = _fusion.delete_MoveFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::MoveFeature >" :
        """
        Function that returns the specified move feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.MoveFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of move features in the collection."""
        return _fusion.MoveFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::MoveFeatureInput >" :
        """
        Creates a MoveFeatureInput object. Use properties and methods on this object
        to define the move feature you want to create and then use the Add method, passing in 
        the MoveFeatureInput object. 
        inputEntities : Input the entities to move.
        This collection can only contain BRepBody objects in parametric modeling.
        It can be BRep bodies, T-Spline bodies, mesh bodies mixed or faces and features mixed in non-parametric modeling. 
        transform : The transform to apply to the input entities. This can describe a move (translation) or a rotation. The
        matrix must define an orthogonal transform. That is the axes remain perpendicular to each other and there
        isn't any scale or mirror defined. 
        Returns the newly created MoveFeatureInput object or null if the creation failed.
        """
        return _fusion.MoveFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::MoveFeature >" :
        """
        Creates a new move feature. 
        input : A MoveFeatureInput object that defines the desired move feature. Use the createInput 
        method to create a new MoveFeatureInput object and then use methods on it 
        (the MoveFeatureInput object) to define the move feature. 
        Returns the newly created MoveFeature object or null if the creation failed.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.MoveFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::MoveFeature >" :
        """
        Function that returns the specified move feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.MoveFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.MoveFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.MoveFeatures__get_isValid(self)
MoveFeatures_swigregister = _fusion.MoveFeatures_swigregister
MoveFeatures_swigregister(MoveFeatures)

def MoveFeatures_classType() -> "char const *" :
  return _fusion.MoveFeatures_classType()
MoveFeatures_classType = _fusion.MoveFeatures_classType

MoveFeatures.__swig_getmethods__["count"] = MoveFeatures._get_count
MoveFeatures.count = property(MoveFeatures._get_count, doc="The number of move features in the collection.")

MoveFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MoveFeatures) else None
MoveFeatures.cast = lambda arg: arg if isinstance(arg, MoveFeatures) else None

class Occurrence(Base):
    """Represents an occurrence of a component at any level within a subassembly."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Occurrence, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Occurrence, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::Occurrence *" : return _fusion.Occurrence___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Occurrence___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Occurrence___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Occurrence_classType
    if _newclass:classType = staticmethod(_fusion.Occurrence_classType)
    __swig_destroy__ = _fusion.delete_Occurrence
    __del__ = lambda self : None;
    def _get_sourceComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """
        This is the sourceComponent for the occurrence and is affected
        by the assembly context. 
        This is the top-level component where the path begins.
        """
        return _fusion.Occurrence__get_sourceComponent(self)

    def _get_childOccurrences(self) -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >" :
        """
        Returns a read only list of child occurrences where only the occurrences 
        in this occurrence's AssemblyContext are returned .
        """
        return _fusion.Occurrence__get_childOccurrences(self)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """The component this occurrence references."""
        return _fusion.Occurrence__get_component(self)

    def _get_name(self) -> "std::string" :
        """
        The name of the occurrence. This is the name as seen in the browser. It is a reflection
        of the component name with an added counter suffix (i.e. 'OccurrenceName:1').
        """
        return _fusion.Occurrence__get_name(self)

    def _get_fullPathName(self) -> "std::string" :
        """
        The name of the occurrence, including the full path of occurrences as seen in the browser.
        The top-level component will depend on the context but will typically be the root component
        of the design. A name for an occurrence that is at the third level of an assembly could be
        'Sub1:1+Sub2:1+PartA:1'.
        """
        return _fusion.Occurrence__get_fullPathName(self)

    def _get_appearance(self) -> "adsk::core::Ptr< adsk::core::Appearance >" :
        """
        Read-write property that gets and sets the appearance override for this occurrence. 
        This property can return null indicating there is no override appearance and that the
        contents of the occurrence are displayed using there defined appearance. 
        Setting the property to null will remove any override appearance for this occurrence.
        """
        return _fusion.Occurrence__get_appearance(self)

    def _set_appearance(self, *args) -> "bool" :
        """
        Read-write property that gets and sets the appearance override for this occurrence. 
        This property can return null indicating there is no override appearance and that the
        contents of the occurrence are displayed using there defined appearance. 
        Setting the property to null will remove any override appearance for this occurrence.
        """
        return _fusion.Occurrence__set_appearance(self, *args)

    def _get_isLightBulbOn(self) -> "bool" :
        """
        Gets and sets if the light bulb of this occurrence as displayed in the browser is on or off.
        An occurrence will only be visible if the light bulb is switched on. However,
        the light bulb can be on and the occurrence still invisible if a higher level occurrence 
        in the assembly context is not visible because its light bulb is off.
        """
        return _fusion.Occurrence__get_isLightBulbOn(self)

    def _set_isLightBulbOn(self, *args) -> "bool" :
        """
        Gets and sets if the light bulb of this occurrence as displayed in the browser is on or off.
        An occurrence will only be visible if the light bulb is switched on. However,
        the light bulb can be on and the occurrence still invisible if a higher level occurrence 
        in the assembly context is not visible because its light bulb is off.
        """
        return _fusion.Occurrence__set_isLightBulbOn(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        Gets whether the occurrence is visible. 
        This property is affected by the assembly context.
        """
        return _fusion.Occurrence__get_isVisible(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >" :
        """
        Gets and sets the 3d matrix data that defines this occurrences orientation and
        position in its assembly context
        """
        return _fusion.Occurrence__get_transform(self)

    def _set_transform(self, *args) -> "bool" :
        """
        Gets and sets the 3d matrix data that defines this occurrences orientation and
        position in its assembly context
        """
        return _fusion.Occurrence__set_transform(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the occurrence from the design. If this is the last occurrence
        referencing a specific Component, the component is also deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.Occurrence_deleteMe(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with the creation of this occurrence."""
        return _fusion.Occurrence__get_timelineObject(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        references the component the object is defined within.
        Returns null in the case where the object is not in the context of an assembly
        but is already the native object.
        """
        return _fusion.Occurrence__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        The NativeObject is the object outside the context of an assembly.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        The return type is strongly typed for each object.
        """
        return _fusion.Occurrence__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence.
        Fails if this object is not the NativeObject. 
        occurrence : The occurrence that represents the context you want to create this proxy in. 
        Returns the proxy for the occurrence in the context of the specified occurrence. 
        Returns null if it failed.
        """
        return _fusion.Occurrence_createForAssemblyContext(self, *args)

    def _get_isGrounded(self) -> "bool" :
        """Gets and sets whether this occurrence is grounded or not."""
        return _fusion.Occurrence__get_isGrounded(self)

    def _set_isGrounded(self, *args) -> "bool" :
        """Gets and sets whether this occurrence is grounded or not."""
        return _fusion.Occurrence__set_isGrounded(self, *args)

    def _get_isSelectable(self) -> "bool" :
        """Gets and sets whether this occurrence is selectable or not."""
        return _fusion.Occurrence__get_isSelectable(self)

    def _set_isSelectable(self, *args) -> "bool" :
        """Gets and sets whether this occurrence is selectable or not."""
        return _fusion.Occurrence__set_isSelectable(self, *args)

    def _get_isIsolated(self) -> "bool" :
        """
        Gets and sets whether this occurrence is isolated in the UI. When an occurrence
        is isolated it is the only one visible in the user-interface. Only one occurrence
        can be isolated at a time so setting this property to true will unisolate an occurrence
        that is currently isolated. Setting this property to false for an occurrence that is
        current isolated will unisolate it so that no occurrence will be isolated.
        """
        return _fusion.Occurrence__get_isIsolated(self)

    def _set_isIsolated(self, *args) -> "bool" :
        """
        Gets and sets whether this occurrence is isolated in the UI. When an occurrence
        is isolated it is the only one visible in the user-interface. Only one occurrence
        can be isolated at a time so setting this property to true will unisolate an occurrence
        that is currently isolated. Setting this property to false for an occurrence that is
        current isolated will unisolate it so that no occurrence will be isolated.
        """
        return _fusion.Occurrence__set_isIsolated(self, *args)

    def _get_isActive(self) -> "bool" :
        """
        Gets whether this occurrence is the active edit target in the user interface.
        This is the same as checking the state of the radio button next to the occurrence in the browser.
        To activate the occurrence use the Activate method.
        """
        return _fusion.Occurrence__get_isActive(self)

    def activate(self) -> "bool" :
        """
        Makes the occurrence the active edit target in the user interface. This is the same
        as enabling the radio button next to the occurrence in the browser. 
        Returns true if the activation was successful.
        """
        return _fusion.Occurrence_activate(self)

    def moveToComponent(self, *args) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Moves this occurrence from it's current component into the component owned by the specified occurrence.
        This occurrence and the target occurrence must be in the same context. 
        targetOccurrence : The target occurrence defines both the component and the transform to apply when moving the occurrence. The
        occurrence will be copied into the parent component of the target occurrence and the target occurrence also defines 
        the transform of how the occurrence will be copied so that the occurrence maintains it's same position in model space. 
        Returns the moved Occurrence or null in the case the move failed.
        """
        return _fusion.Occurrence_moveToComponent(self, *args)

    def _get_physicalProperties(self) -> "adsk::core::Ptr< adsk::fusion::PhysicalProperties >" :
        """
        Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc 
        of this occurrence. Property values will be calulated using the 'LowCalculationAccuracy' setting when using this property
        to get the PhysicalProperties object. To specify a higher calculation tolerance, use the getPhysicalProperties method instead.
        """
        return _fusion.Occurrence__get_physicalProperties(self)

    def _get_isReferencedComponent(self) -> "bool" :
        """Gets if this occurrence is referencing an external component."""
        return _fusion.Occurrence__get_isReferencedComponent(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of this occurrence."""
        return _fusion.Occurrence__get_boundingBox(self)

    def _get_joints(self) -> "adsk::core::Ptr< adsk::fusion::JointList >" :
        """
        Returns the joints that affect the position of this occurrence. For example, if a joint has
        been created between this occurrence and another occurrence, this property will return that
        joint. If the occurrence is a proxy, the joints returned will also be proxies in the same 
        context as the occurrence.
        """
        return _fusion.Occurrence__get_joints(self)

    def _get_rigidGroups(self) -> "adsk::core::Ptr< adsk::fusion::RigidGroupList >" :
        """
        Returns the rigid groups that this occurrence is a member of. If the occurrence is a proxy,
        the joints returned will also be proxies in the same context as the occurrence.
        """
        return _fusion.Occurrence__get_rigidGroups(self)

    def _get_asBuiltJoints(self) -> "adsk::core::Ptr< adsk::fusion::AsBuiltJointList >" :
        """
        Returns the as-built joints that affect the position of this occurrence. If the occurrence is a proxy,
        the as-built joints returned will also be proxies in the same context as the occurrence.
        """
        return _fusion.Occurrence__get_asBuiltJoints(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.Occurrence__get_attributes(self)

    def _get_bRepBodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the body proxies for the B-Rep bodies in the component referenced by this occurrence.
        For example if you get the occurrences from the root component and then use this property to
        get the bodies from those occurrences, the bodies returned will return information in the context of the root
        component, not the component they actually exist in.
        """
        return _fusion.Occurrence__get_bRepBodies(self)

    def getPhysicalProperties(self, *args) -> "adsk::core::Ptr< adsk::fusion::PhysicalProperties >" :
        """
        Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc 
        of this occurrence. 
        accuracy : Specifies the desired level of computational accuracy of the property calculations.
        The default value of 'LowCalculationAccuracy' returns results within a +/- 1% error margin.
        """
        return _fusion.Occurrence_getPhysicalProperties(self, *args)

    def _get_visibleOpacity(self) -> "double" :
        """
        The user can set an override opacity for components and these opacity overrides combine if
        children and parent components have overrides. This property returns the actual opacity that is
        being used to render the occurence. To set the opacity use the opacity property of the Component object.
        """
        return _fusion.Occurrence__get_visibleOpacity(self)

    def breakLink(self) -> "bool" :
        """
        When the component this occurrence references is an external reference (the isReferencedComponent property returns true),
        this will break the link and create a local Component that this occurrence will reference. The new local Component can 
        be accessed through the Occurrence using the component property.
        This method will fail if the occurrence is not referencing an external component. 
        Returns true if the break link was successful.
        """
        return _fusion.Occurrence_breakLink(self)

    def _get_objectType(self) -> "char const *" : return _fusion.Occurrence__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Occurrence__get_isValid(self)
Occurrence_swigregister = _fusion.Occurrence_swigregister
Occurrence_swigregister(Occurrence)

def Occurrence_classType() -> "char const *" :
  return _fusion.Occurrence_classType()
Occurrence_classType = _fusion.Occurrence_classType

Occurrence.__swig_getmethods__["sourceComponent"] = Occurrence._get_sourceComponent
Occurrence.sourceComponent = property(Occurrence._get_sourceComponent, doc="This is the sourceComponent for the occurrence and is affected\nby the assembly context.\nThis is the top-level component where the path begins.")

Occurrence.__swig_getmethods__["childOccurrences"] = Occurrence._get_childOccurrences
Occurrence.childOccurrences = property(Occurrence._get_childOccurrences, doc="Returns a read only list of child occurrences where only the occurrences\nin this occurrence's AssemblyContext are returned .")

Occurrence.__swig_getmethods__["component"] = Occurrence._get_component
Occurrence.component = property(Occurrence._get_component, doc="The component this occurrence references.")

Occurrence.__swig_getmethods__["name"] = Occurrence._get_name
Occurrence.name = property(Occurrence._get_name, doc="The name of the occurrence. This is the name as seen in the browser. It is a reflection\nof the component name with an added counter suffix (i.e. 'OccurrenceName:1').")

Occurrence.__swig_getmethods__["fullPathName"] = Occurrence._get_fullPathName
Occurrence.fullPathName = property(Occurrence._get_fullPathName, doc="The name of the occurrence, including the full path of occurrences as seen in the browser.\nThe top-level component will depend on the context but will typically be the root component\nof the design. A name for an occurrence that is at the third level of an assembly could be\n'Sub1:1+Sub2:1+PartA:1'.")

Occurrence.__swig_getmethods__["appearance"] = Occurrence._get_appearance
Occurrence.__swig_setmethods__["appearance"] = Occurrence._set_appearance
Occurrence.appearance = property(Occurrence._get_appearance, Occurrence._set_appearance, doc="Read-write property that gets and sets the appearance override for this occurrence.\nThis property can return null indicating there is no override appearance and that the\ncontents of the occurrence are displayed using there defined appearance.\nSetting the property to null will remove any override appearance for this occurrence.")

Occurrence.__swig_getmethods__["isLightBulbOn"] = Occurrence._get_isLightBulbOn
Occurrence.__swig_setmethods__["isLightBulbOn"] = Occurrence._set_isLightBulbOn
Occurrence.isLightBulbOn = property(Occurrence._get_isLightBulbOn, Occurrence._set_isLightBulbOn, doc="Gets and sets if the light bulb of this occurrence as displayed in the browser is on or off.\nAn occurrence will only be visible if the light bulb is switched on. However,\nthe light bulb can be on and the occurrence still invisible if a higher level occurrence\nin the assembly context is not visible because its light bulb is off.")

Occurrence.__swig_getmethods__["isVisible"] = Occurrence._get_isVisible
Occurrence.isVisible = property(Occurrence._get_isVisible, doc="Gets whether the occurrence is visible.\nThis property is affected by the assembly context.")

Occurrence.__swig_getmethods__["transform"] = Occurrence._get_transform
Occurrence.__swig_setmethods__["transform"] = Occurrence._set_transform
Occurrence.transform = property(Occurrence._get_transform, Occurrence._set_transform, doc="Gets and sets the 3d matrix data that defines this occurrences orientation and\nposition in its assembly context")

Occurrence.__swig_getmethods__["timelineObject"] = Occurrence._get_timelineObject
Occurrence.timelineObject = property(Occurrence._get_timelineObject, doc="Returns the timeline object associated with the creation of this occurrence.")

Occurrence.__swig_getmethods__["assemblyContext"] = Occurrence._get_assemblyContext
Occurrence.assemblyContext = property(Occurrence._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nreferences the component the object is defined within.\nReturns null in the case where the object is not in the context of an assembly\nbut is already the native object.")

Occurrence.__swig_getmethods__["nativeObject"] = Occurrence._get_nativeObject
Occurrence.nativeObject = property(Occurrence._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.\nThe return type is strongly typed for each object.")

Occurrence.__swig_getmethods__["isGrounded"] = Occurrence._get_isGrounded
Occurrence.__swig_setmethods__["isGrounded"] = Occurrence._set_isGrounded
Occurrence.isGrounded = property(Occurrence._get_isGrounded, Occurrence._set_isGrounded, doc="Gets and sets whether this occurrence is grounded or not.")

Occurrence.__swig_getmethods__["isSelectable"] = Occurrence._get_isSelectable
Occurrence.__swig_setmethods__["isSelectable"] = Occurrence._set_isSelectable
Occurrence.isSelectable = property(Occurrence._get_isSelectable, Occurrence._set_isSelectable, doc="Gets and sets whether this occurrence is selectable or not.")

Occurrence.__swig_getmethods__["isIsolated"] = Occurrence._get_isIsolated
Occurrence.__swig_setmethods__["isIsolated"] = Occurrence._set_isIsolated
Occurrence.isIsolated = property(Occurrence._get_isIsolated, Occurrence._set_isIsolated, doc="Gets and sets whether this occurrence is isolated in the UI. When an occurrence\nis isolated it is the only one visible in the user-interface. Only one occurrence\ncan be isolated at a time so setting this property to true will unisolate an occurrence\nthat is currently isolated. Setting this property to false for an occurrence that is\ncurrent isolated will unisolate it so that no occurrence will be isolated.")

Occurrence.__swig_getmethods__["isActive"] = Occurrence._get_isActive
Occurrence.isActive = property(Occurrence._get_isActive, doc="Gets whether this occurrence is the active edit target in the user interface.\nThis is the same as checking the state of the radio button next to the occurrence in the browser.\nTo activate the occurrence use the Activate method.")

Occurrence.__swig_getmethods__["physicalProperties"] = Occurrence._get_physicalProperties
Occurrence.physicalProperties = property(Occurrence._get_physicalProperties, doc="Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc\nof this occurrence. Property values will be calulated using the 'LowCalculationAccuracy' setting when using this property\nto get the PhysicalProperties object. To specify a higher calculation tolerance, use the getPhysicalProperties method instead.")

Occurrence.__swig_getmethods__["isReferencedComponent"] = Occurrence._get_isReferencedComponent
Occurrence.isReferencedComponent = property(Occurrence._get_isReferencedComponent, doc="Gets if this occurrence is referencing an external component.")

Occurrence.__swig_getmethods__["boundingBox"] = Occurrence._get_boundingBox
Occurrence.boundingBox = property(Occurrence._get_boundingBox, doc="Returns the bounding box of this occurrence.")

Occurrence.__swig_getmethods__["joints"] = Occurrence._get_joints
Occurrence.joints = property(Occurrence._get_joints, doc="Returns the joints that affect the position of this occurrence. For example, if a joint has\nbeen created between this occurrence and another occurrence, this property will return that\njoint. If the occurrence is a proxy, the joints returned will also be proxies in the same\ncontext as the occurrence.")

Occurrence.__swig_getmethods__["rigidGroups"] = Occurrence._get_rigidGroups
Occurrence.rigidGroups = property(Occurrence._get_rigidGroups, doc="Returns the rigid groups that this occurrence is a member of. If the occurrence is a proxy,\nthe joints returned will also be proxies in the same context as the occurrence.")

Occurrence.__swig_getmethods__["asBuiltJoints"] = Occurrence._get_asBuiltJoints
Occurrence.asBuiltJoints = property(Occurrence._get_asBuiltJoints, doc="Returns the as-built joints that affect the position of this occurrence. If the occurrence is a proxy,\nthe as-built joints returned will also be proxies in the same context as the occurrence.")

Occurrence.__swig_getmethods__["attributes"] = Occurrence._get_attributes
Occurrence.attributes = property(Occurrence._get_attributes, doc="Returns the collection of attributes associated with this face.")

Occurrence.__swig_getmethods__["bRepBodies"] = Occurrence._get_bRepBodies
Occurrence.bRepBodies = property(Occurrence._get_bRepBodies, doc="Returns the body proxies for the B-Rep bodies in the component referenced by this occurrence.\nFor example if you get the occurrences from the root component and then use this property to\nget the bodies from those occurrences, the bodies returned will return information in the context of the root\ncomponent, not the component they actually exist in.")

Occurrence.__swig_getmethods__["visibleOpacity"] = Occurrence._get_visibleOpacity
Occurrence.visibleOpacity = property(Occurrence._get_visibleOpacity, doc="The user can set an override opacity for components and these opacity overrides combine if\nchildren and parent components have overrides. This property returns the actual opacity that is\nbeing used to render the occurence. To set the opacity use the opacity property of the Component object.")

Occurrence.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Occurrence) else None
Occurrence.cast = lambda arg: arg if isinstance(arg, Occurrence) else None

class OccurrenceList(Base):
    """Provides a list of occurrences."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OccurrenceList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OccurrenceList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::OccurrenceList *" : return _fusion.OccurrenceList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.OccurrenceList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.OccurrenceList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.OccurrenceList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.OccurrenceList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.OccurrenceList_classType
    if _newclass:classType = staticmethod(_fusion.OccurrenceList_classType)
    __swig_destroy__ = _fusion.delete_OccurrenceList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the specified occurrence using an index into the collection. 
        index : The index of the occurrence within the collection to return. The first item has an index of 0. 
        Returns the specified occurrence or null in the case of an invalid index.
        """
        return _fusion.OccurrenceList_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of occurrences in the collection."""
        return _fusion.OccurrenceList__get_count(self)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the specified occurrence using the name of the occurrence. 
        name : The name of the occurrence to return. 
        Returns the occurrence or null if an invalid name was specified
        """
        return _fusion.OccurrenceList_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.OccurrenceList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.OccurrenceList__get_isValid(self)
OccurrenceList_swigregister = _fusion.OccurrenceList_swigregister
OccurrenceList_swigregister(OccurrenceList)

def OccurrenceList_classType() -> "char const *" :
  return _fusion.OccurrenceList_classType()
OccurrenceList_classType = _fusion.OccurrenceList_classType

OccurrenceList.__swig_getmethods__["count"] = OccurrenceList._get_count
OccurrenceList.count = property(OccurrenceList._get_count, doc="Returns the number of occurrences in the collection.")

OccurrenceList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, OccurrenceList) else None
OccurrenceList.cast = lambda arg: arg if isinstance(arg, OccurrenceList) else None

class Occurrences(Base):
    """
    Provides access to occurrences within a component and provides
    methods to create new occurrences.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Occurrences, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Occurrences, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::Occurrences *" : return _fusion.Occurrences___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Occurrences___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Occurrences___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.Occurrences___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.Occurrences___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Occurrences_classType
    if _newclass:classType = staticmethod(_fusion.Occurrences_classType)
    __swig_destroy__ = _fusion.delete_Occurrences
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Function that returns the specified occurrence using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.Occurrences_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of occurrences in the collection."""
        return _fusion.Occurrences__get_count(self)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the specified occurrence using the name of the occurrence. 
        name : The name of the occurrence to return. 
        Returns the occurrence or null if an invalid name was specified
        """
        return _fusion.Occurrences_itemByName(self, *args)

    def addExistingComponent(self, *args) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Method that creates a new occurrence using an existing component. This is the equivalent
        of copying and pasting an occurrence in the user interface. 
        component : The existing component to create a new occurrence of. 
        transform : A transform that defines the location for the new occurrence 
        Returns the newly created occurrence or null if the creation failed.
        """
        return _fusion.Occurrences_addExistingComponent(self, *args)

    def addNewComponent(self, *args) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Method that creates a new component and an occurrence that references it. 
        transform : A transform that defines the location for the new occurrence. 
        Returns the newly created occurrence or null if the creation failed.
        """
        return _fusion.Occurrences_addNewComponent(self, *args)

    def _get_asList(self) -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >" :
        """
        Returns the contents of this collection as an OccurrencesList object. This
        is useful when writing a function that traverses an assembly.
        """
        return _fusion.Occurrences__get_asList(self)

    def addByInsert(self, *args) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Method that inserts an existing file. 
        dataFile : The dataFile to insert. 
        transform : A transform that defines the location for the new occurrence. 
        isReferencedComponent : Indicates if the insert is to be an external reference or embedded within this document.
        This method will fail if the dataFile being inserted is not from the same project as the document 
        it is being inserted into while isReferencedComponent is True. 
        Returns the newly created occurrence or null if the insert failed.
        Insert will fail if the dataFile being inserted is not from the same project as the document 
        it is being inserted into while isReferencedComponent is True.
        """
        return _fusion.Occurrences_addByInsert(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.Occurrences__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Occurrences__get_isValid(self)
Occurrences_swigregister = _fusion.Occurrences_swigregister
Occurrences_swigregister(Occurrences)

def Occurrences_classType() -> "char const *" :
  return _fusion.Occurrences_classType()
Occurrences_classType = _fusion.Occurrences_classType

Occurrences.__swig_getmethods__["count"] = Occurrences._get_count
Occurrences.count = property(Occurrences._get_count, doc="Returns the number of occurrences in the collection.")

Occurrences.__swig_getmethods__["asList"] = Occurrences._get_asList
Occurrences.asList = property(Occurrences._get_asList, doc="Returns the contents of this collection as an OccurrencesList object. This\nis useful when writing a function that traverses an assembly.")

Occurrences.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Occurrences) else None
Occurrences.cast = lambda arg: arg if isinstance(arg, Occurrences) else None

class OffsetFacesFeatures(Base):
    """
    Collection that provides access to all of the existing Offset Face features in a design.
    Offset Face features are created in the UI using the 'Press Pull' command.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OffsetFacesFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OffsetFacesFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::OffsetFacesFeatures *" : return _fusion.OffsetFacesFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.OffsetFacesFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.OffsetFacesFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.OffsetFacesFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::OffsetFacesFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.OffsetFacesFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.OffsetFacesFeatures_classType
    if _newclass:classType = staticmethod(_fusion.OffsetFacesFeatures_classType)
    __swig_destroy__ = _fusion.delete_OffsetFacesFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::OffsetFacesFeature >" :
        """
        Function that returns the specified Offset Face feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.OffsetFacesFeatures_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::OffsetFacesFeature >" :
        """
        Function that returns the specified Offset Face feature using the name of the feature.
        Offset Face features are created in the UI using the 'Press Pull' command. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.OffsetFacesFeatures_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """
        The number of Offset Face features in the collection. 
        Offset Face features are created in the UI using the 'Press Pull' command.
        """
        return _fusion.OffsetFacesFeatures__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.OffsetFacesFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.OffsetFacesFeatures__get_isValid(self)
OffsetFacesFeatures_swigregister = _fusion.OffsetFacesFeatures_swigregister
OffsetFacesFeatures_swigregister(OffsetFacesFeatures)

def OffsetFacesFeatures_classType() -> "char const *" :
  return _fusion.OffsetFacesFeatures_classType()
OffsetFacesFeatures_classType = _fusion.OffsetFacesFeatures_classType

OffsetFacesFeatures.__swig_getmethods__["count"] = OffsetFacesFeatures._get_count
OffsetFacesFeatures.count = property(OffsetFacesFeatures._get_count, doc="The number of Offset Face features in the collection.\nOffset Face features are created in the UI using the 'Press Pull' command.")

OffsetFacesFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, OffsetFacesFeatures) else None
OffsetFacesFeatures.cast = lambda arg: arg if isinstance(arg, OffsetFacesFeatures) else None

class OffsetFeatureInput(Base):
    """This class defines the methods and properties that pertain to the definition of a offset feature."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OffsetFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OffsetFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::OffsetFeatureInput *" : return _fusion.OffsetFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.OffsetFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.OffsetFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.OffsetFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.OffsetFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_OffsetFeatureInput
    __del__ = lambda self : None;
    def _get_entities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """An ObjectCollection containing the BRepFace objects being offset."""
        return _fusion.OffsetFeatureInput__get_entities(self)

    def _set_entities(self, *args) -> "bool" :
        """An ObjectCollection containing the BRepFace objects being offset."""
        return _fusion.OffsetFeatureInput__set_entities(self, *args)

    def _get_isChainSelection(self) -> "bool" :
        """Get and sets whether faces that are tangentially connected to the input faces will be included in the offset."""
        return _fusion.OffsetFeatureInput__get_isChainSelection(self)

    def _set_isChainSelection(self, *args) -> "bool" :
        """Get and sets whether faces that are tangentially connected to the input faces will be included in the offset."""
        return _fusion.OffsetFeatureInput__set_isChainSelection(self, *args)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Gets and sets the ValueInput object that defines the offset distance. A positive distance value results
        in an offset in the positive normal direction of the faces.
        """
        return _fusion.OffsetFeatureInput__get_distance(self)

    def _set_distance(self, *args) -> "bool" :
        """
        Gets and sets the ValueInput object that defines the offset distance. A positive distance value results
        in an offset in the positive normal direction of the faces.
        """
        return _fusion.OffsetFeatureInput__set_distance(self, *args)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """Gets and sets the feature operation to perform. Can be 'NewBodyFeatureOperation' or 'NewComponentFeatureOperation'."""
        return _fusion.OffsetFeatureInput__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """Gets and sets the feature operation to perform. Can be 'NewBodyFeatureOperation' or 'NewComponentFeatureOperation'."""
        return _fusion.OffsetFeatureInput__set_operation(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.OffsetFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.OffsetFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.OffsetFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.OffsetFeatureInput__get_isValid(self)
OffsetFeatureInput_swigregister = _fusion.OffsetFeatureInput_swigregister
OffsetFeatureInput_swigregister(OffsetFeatureInput)

def OffsetFeatureInput_classType() -> "char const *" :
  return _fusion.OffsetFeatureInput_classType()
OffsetFeatureInput_classType = _fusion.OffsetFeatureInput_classType

OffsetFeatureInput.__swig_getmethods__["entities"] = OffsetFeatureInput._get_entities
OffsetFeatureInput.__swig_setmethods__["entities"] = OffsetFeatureInput._set_entities
OffsetFeatureInput.entities = property(OffsetFeatureInput._get_entities, OffsetFeatureInput._set_entities, doc="An ObjectCollection containing the BRepFace objects being offset.")

OffsetFeatureInput.__swig_getmethods__["isChainSelection"] = OffsetFeatureInput._get_isChainSelection
OffsetFeatureInput.__swig_setmethods__["isChainSelection"] = OffsetFeatureInput._set_isChainSelection
OffsetFeatureInput.isChainSelection = property(OffsetFeatureInput._get_isChainSelection, OffsetFeatureInput._set_isChainSelection, doc="Get and sets whether faces that are tangentially connected to the input faces will be included in the offset.")

OffsetFeatureInput.__swig_getmethods__["distance"] = OffsetFeatureInput._get_distance
OffsetFeatureInput.__swig_setmethods__["distance"] = OffsetFeatureInput._set_distance
OffsetFeatureInput.distance = property(OffsetFeatureInput._get_distance, OffsetFeatureInput._set_distance, doc="Gets and sets the ValueInput object that defines the offset distance. A positive distance value results\nin an offset in the positive normal direction of the faces.")

OffsetFeatureInput.__swig_getmethods__["operation"] = OffsetFeatureInput._get_operation
OffsetFeatureInput.__swig_setmethods__["operation"] = OffsetFeatureInput._set_operation
OffsetFeatureInput.operation = property(OffsetFeatureInput._get_operation, OffsetFeatureInput._set_operation, doc="Gets and sets the feature operation to perform. Can be 'NewBodyFeatureOperation' or 'NewComponentFeatureOperation'.")

OffsetFeatureInput.__swig_getmethods__["targetBaseFeature"] = OffsetFeatureInput._get_targetBaseFeature
OffsetFeatureInput.__swig_setmethods__["targetBaseFeature"] = OffsetFeatureInput._set_targetBaseFeature
OffsetFeatureInput.targetBaseFeature = property(OffsetFeatureInput._get_targetBaseFeature, OffsetFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

OffsetFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, OffsetFeatureInput) else None
OffsetFeatureInput.cast = lambda arg: arg if isinstance(arg, OffsetFeatureInput) else None

class OffsetFeatures(Base):
    """
    Collection that provides access to all of the existing Offset features in a component
    and supports the ability to create new Offset features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OffsetFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OffsetFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::OffsetFeatures *" : return _fusion.OffsetFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.OffsetFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.OffsetFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.OffsetFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::OffsetFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.OffsetFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.OffsetFeatures_classType
    if _newclass:classType = staticmethod(_fusion.OffsetFeatures_classType)
    __swig_destroy__ = _fusion.delete_OffsetFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::OffsetFeature >" :
        """
        Function that returns the specified offset feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.OffsetFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of Offset features in the collection."""
        return _fusion.OffsetFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::OffsetFeatureInput >" :
        """
        Creates a OffsetFeatureInput object. Use properties and methods on this object
        to define the offset feature you want to create and then use the Add method, passing in 
        the OffsetFeatureInput object to create the feature. 
        entities : An ObjectCollection containing the BRepFace objects to offset. Additional faces may be
        automatically used depending on the value of the isChainSelection argument.
        Input faces need not be from the same body. 
        distance : ValueInput object that defines the offset distance. A positive value is in the positive
        normal direction of the face being offset. 
        operation : The feature operation to perform. 'NewBodyFeatureOperation' and 'NewComponentFeatureOperation' are the 
        options supported. 
        isChainSelection : A boolean value for setting whether or not faces that are tangentially connected to 
        the input faces (if any) will be included in the offset. The default value is true. 
        Returns the newly created OffsetFeatureInput object or null if the creation failed.
        """
        return _fusion.OffsetFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::OffsetFeature >" :
        """
        Creates a new offset feature. 
        input : A FeatureInput object that defines the desired offset feature. Use the createInput 
        method to create a new OffsetFeatureInput object and then use methods on it 
        (the OffsetFeatureInput object) to define the offset feature. 
        Returns the newly created OffsetFeature object or null if the creation failed.
        """
        return _fusion.OffsetFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::OffsetFeature >" :
        """
        Function that returns the specified offset feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.OffsetFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.OffsetFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.OffsetFeatures__get_isValid(self)
OffsetFeatures_swigregister = _fusion.OffsetFeatures_swigregister
OffsetFeatures_swigregister(OffsetFeatures)

def OffsetFeatures_classType() -> "char const *" :
  return _fusion.OffsetFeatures_classType()
OffsetFeatures_classType = _fusion.OffsetFeatures_classType

OffsetFeatures.__swig_getmethods__["count"] = OffsetFeatures._get_count
OffsetFeatures.count = property(OffsetFeatures._get_count, doc="The number of Offset features in the collection.")

OffsetFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, OffsetFeatures) else None
OffsetFeatures.cast = lambda arg: arg if isinstance(arg, OffsetFeatures) else None

class Parameter(Base):
    """The base class Parameter object that can represent model or user parameters."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Parameter, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Parameter, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::Parameter *" : return _fusion.Parameter___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Parameter___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Parameter___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Parameter_classType
    if _newclass:classType = staticmethod(_fusion.Parameter_classType)
    __swig_destroy__ = _fusion.delete_Parameter
    __del__ = lambda self : None;
    def _get_value(self) -> "double" :
        """
        Gets and sets the real value (a double) of the parameter in database units. 
        Setting this property will set/reset the expression value for this parameter
        """
        return _fusion.Parameter__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """
        Gets and sets the real value (a double) of the parameter in database units. 
        Setting this property will set/reset the expression value for this parameter
        """
        return _fusion.Parameter__set_value(self, *args)

    def _get_expression(self) -> "std::string" :
        """Gets and sets the expression (ie. '22.064 mm') used to calculate the value of the parameter"""
        return _fusion.Parameter__get_expression(self)

    def _set_expression(self, *args) -> "bool" :
        """Gets and sets the expression (ie. '22.064 mm') used to calculate the value of the parameter"""
        return _fusion.Parameter__set_expression(self, *args)

    def _get_name(self) -> "std::string" :
        """
        Gets and sets the name of the parameter. Setting the name can fail if the name 
        is not unique with respect to all other parameters in the design.
        """
        return _fusion.Parameter__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """
        Gets and sets the name of the parameter. Setting the name can fail if the name 
        is not unique with respect to all other parameters in the design.
        """
        return _fusion.Parameter__set_name(self, *args)

    def _get_unit(self) -> "std::string" :
        """
        The unit type associated with this parameter. An empty string is returned for parameters
        that don't have a unit type.
        """
        return _fusion.Parameter__get_unit(self)

    def _get_comment(self) -> "std::string" :
        """The comment associated with this parameter"""
        return _fusion.Parameter__get_comment(self)

    def _set_comment(self, *args) -> "bool" :
        """The comment associated with this parameter"""
        return _fusion.Parameter__set_comment(self, *args)

    def _get_isFavorite(self) -> "bool" :
        """
        Gets and sets whether this parameter is included in the Favorites list in the
        parameters dialog
        """
        return _fusion.Parameter__get_isFavorite(self)

    def _set_isFavorite(self, *args) -> "bool" :
        """
        Gets and sets whether this parameter is included in the Favorites list in the
        parameters dialog
        """
        return _fusion.Parameter__set_isFavorite(self, *args)

    def _get_dependentParameters(self) -> "adsk::core::Ptr< adsk::fusion::ParameterList >" :
        """
        Returns a list of parameters that are dependent on this parameter as a result
        of this parameter being referenced in their equation.
        """
        return _fusion.Parameter__get_dependentParameters(self)

    def _get_isDeletable(self) -> "bool" :
        """
        Gets if this parameter can be deleted. Parameters that cannot be deleted are: Model Parameters and 
        User Parameters that have dependents.
        """
        return _fusion.Parameter__get_isDeletable(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.Parameter__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.Parameter__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Parameter__get_isValid(self)
Parameter_swigregister = _fusion.Parameter_swigregister
Parameter_swigregister(Parameter)

def Parameter_classType() -> "char const *" :
  return _fusion.Parameter_classType()
Parameter_classType = _fusion.Parameter_classType

Parameter.__swig_getmethods__["value"] = Parameter._get_value
Parameter.__swig_setmethods__["value"] = Parameter._set_value
Parameter.value = property(Parameter._get_value, Parameter._set_value, doc="Gets and sets the real value (a double) of the parameter in database units.\nSetting this property will set/reset the expression value for this parameter")

Parameter.__swig_getmethods__["expression"] = Parameter._get_expression
Parameter.__swig_setmethods__["expression"] = Parameter._set_expression
Parameter.expression = property(Parameter._get_expression, Parameter._set_expression, doc="Gets and sets the expression (ie. '22.064 mm') used to calculate the value of the parameter")

Parameter.__swig_getmethods__["name"] = Parameter._get_name
Parameter.__swig_setmethods__["name"] = Parameter._set_name
Parameter.name = property(Parameter._get_name, Parameter._set_name, doc="Gets and sets the name of the parameter. Setting the name can fail if the name\nis not unique with respect to all other parameters in the design.")

Parameter.__swig_getmethods__["unit"] = Parameter._get_unit
Parameter.unit = property(Parameter._get_unit, doc="The unit type associated with this parameter. An empty string is returned for parameters\nthat don't have a unit type.")

Parameter.__swig_getmethods__["comment"] = Parameter._get_comment
Parameter.__swig_setmethods__["comment"] = Parameter._set_comment
Parameter.comment = property(Parameter._get_comment, Parameter._set_comment, doc="The comment associated with this parameter")

Parameter.__swig_getmethods__["isFavorite"] = Parameter._get_isFavorite
Parameter.__swig_setmethods__["isFavorite"] = Parameter._set_isFavorite
Parameter.isFavorite = property(Parameter._get_isFavorite, Parameter._set_isFavorite, doc="Gets and sets whether this parameter is included in the Favorites list in the\nparameters dialog")

Parameter.__swig_getmethods__["dependentParameters"] = Parameter._get_dependentParameters
Parameter.dependentParameters = property(Parameter._get_dependentParameters, doc="Returns a list of parameters that are dependent on this parameter as a result\nof this parameter being referenced in their equation.")

Parameter.__swig_getmethods__["isDeletable"] = Parameter._get_isDeletable
Parameter.isDeletable = property(Parameter._get_isDeletable, doc="Gets if this parameter can be deleted. Parameters that cannot be deleted are: Model Parameters and\nUser Parameters that have dependents.")

Parameter.__swig_getmethods__["attributes"] = Parameter._get_attributes
Parameter.attributes = property(Parameter._get_attributes, doc="Returns the collection of attributes associated with this face.")

Parameter.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Parameter) else None
Parameter.cast = lambda arg: arg if isinstance(arg, Parameter) else None

class ParameterList(Base):
    """Transient object used to pass a set of parameters."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParameterList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ParameterList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ParameterList *" : return _fusion.ParameterList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ParameterList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ParameterList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.ParameterList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::Parameter >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.ParameterList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ParameterList_classType
    if _newclass:classType = staticmethod(_fusion.ParameterList_classType)
    __swig_getmethods__["create"] = lambda x: _fusion.ParameterList_create
    if _newclass:create = staticmethod(_fusion.ParameterList_create)
    __swig_destroy__ = _fusion.delete_ParameterList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::Parameter >" :
        """
        Function that returns the specified parameter using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ParameterList_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::Parameter >" :
        """
        Returns the specified parameter using the name of the parameter
        as it is displayed in the parameters dialog 
        name : The name of the parameter as it is displayed in the parameters dialog 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.ParameterList_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of parameters in the collection."""
        return _fusion.ParameterList__get_count(self)

    def add(self, *args) -> "bool" :
        """
        Adds a parameter to the list. This does not create a 
        new parameter, it adds an existing parameter to the list.
        Note that duplicates can exist in the list. 
        parameter : The existing parameter to add to the list 
        Returns true if successful. This method will fail if the list is read-only
        """
        return _fusion.ParameterList_add(self, *args)

    def removeByIndex(self, *args) -> "bool" :
        """
        Method that removes a parameter from the list using the index of the item
        in the list
        Will fail if the list is read only. 
        index : The index of the parameter to be removed from the list 
        Returns true if successful. This method will fail if the list is read-only
        """
        return _fusion.ParameterList_removeByIndex(self, *args)

    def removeByItem(self, *args) -> "bool" :
        """
        Method that removes a parameter from the list by specifying the parameter (item) 
        to remove 
        item : The parameter item to remove from the list 
        Returns true if successful. This method will fail if the list is read-only
        """
        return _fusion.ParameterList_removeByItem(self, *args)

    def find(self, *args) -> "int" :
        """
        Finds the specified parameter in the list. The search can be started at a specified 
        index rather than from the beginning of the list.
        If not found, -1 is returned. 
        parameter : The parameter to find 
        startIndex : the index in the list to start the search from 
        Returns the index of the parameter found in the list.
        """
        return _fusion.ParameterList_find(self, *args)

    def contains(self, *args) -> "bool" :
        """
        Indicates whether or not ParameterList collection contains a specified parameter 
        parameter : The parameter to look for in the list 
        Returns true if list contains the specified parameter
        """
        return _fusion.ParameterList_contains(self, *args)

    def _get_isReadOnly(self) -> "bool" :
        """
        Indicates if the list is read-only
        Some lists returned by API calls (instead of lists created by the
        user) are read only. Items cannot be added or remove from such a list.
        """
        return _fusion.ParameterList__get_isReadOnly(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ParameterList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ParameterList__get_isValid(self)
ParameterList_swigregister = _fusion.ParameterList_swigregister
ParameterList_swigregister(ParameterList)

def ParameterList_classType() -> "char const *" :
  return _fusion.ParameterList_classType()
ParameterList_classType = _fusion.ParameterList_classType

def ParameterList_create() -> "adsk::core::Ptr< adsk::fusion::ParameterList >" :
  return _fusion.ParameterList_create()
ParameterList_create = _fusion.ParameterList_create

ParameterList.__swig_getmethods__["count"] = ParameterList._get_count
ParameterList.count = property(ParameterList._get_count, doc="Returns the number of parameters in the collection.")

ParameterList.__swig_getmethods__["isReadOnly"] = ParameterList._get_isReadOnly
ParameterList.isReadOnly = property(ParameterList._get_isReadOnly, doc="Indicates if the list is read-only\nSome lists returned by API calls (instead of lists created by the\nuser) are read only. Items cannot be added or remove from such a list.")

ParameterList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ParameterList) else None
ParameterList.cast = lambda arg: arg if isinstance(arg, ParameterList) else None

class PatchFeatureInput(Base):
    """This class defines the methods and properties that pertain to the definition of a patch feature."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PatchFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PatchFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PatchFeatureInput *" : return _fusion.PatchFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PatchFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PatchFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PatchFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.PatchFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_PatchFeatureInput
    __del__ = lambda self : None;
    def _get_boundaryCurve(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and set the input geometry that will be used to define the boundary. This can be a sketch profile, 
        a single sketch curve, a single B-Rep edge, or a Path object. 
        If a single sketch curve or B-Rep edge is input, that is not closed, Fusion 360 will automatically find connected sketch curves 
        or B-Rep edges in order to define a closed loop. All sketch curves are valid as input. BRepEdges are valid if they are 
        an 'open' edge, which means they are only used by one face.
        If a Path is input it must define a closed shape and the B-Rep edges must be valid 'open' edges.
        """
        return _fusion.PatchFeatureInput__get_boundaryCurve(self)

    def _set_boundaryCurve(self, *args) -> "bool" :
        """
        Gets and set the input geometry that will be used to define the boundary. This can be a sketch profile, 
        a single sketch curve, a single B-Rep edge, or a Path object. 
        If a single sketch curve or B-Rep edge is input, that is not closed, Fusion 360 will automatically find connected sketch curves 
        or B-Rep edges in order to define a closed loop. All sketch curves are valid as input. BRepEdges are valid if they are 
        an 'open' edge, which means they are only used by one face.
        If a Path is input it must define a closed shape and the B-Rep edges must be valid 'open' edges.
        """
        return _fusion.PatchFeatureInput__set_boundaryCurve(self, *args)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """
        Gets and sets the type of operation performed by the patch feature. Only 'NewBodyFeatureOperation' and 'NewComponentFeatureOperation' are 
        valid operations for patch features.
        """
        return _fusion.PatchFeatureInput__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """
        Gets and sets the type of operation performed by the patch feature. Only 'NewBodyFeatureOperation' and 'NewComponentFeatureOperation' are 
        valid operations for patch features.
        """
        return _fusion.PatchFeatureInput__set_operation(self, *args)

    def _get_continuity(self) -> "adsk::fusion::SurfaceContinuityTypes" :
        """
        Gets and sets type of surface continuity to use when matching boundary edges to face edges. When a new PatchFeatureInput is 
        created, this is initialized to ConnectedSurfaceContinuityType. This value is ignored when creating a patch for sketch curves.
        """
        return _fusion.PatchFeatureInput__get_continuity(self)

    def _set_continuity(self, *args) -> "bool" :
        """
        Gets and sets type of surface continuity to use when matching boundary edges to face edges. When a new PatchFeatureInput is 
        created, this is initialized to ConnectedSurfaceContinuityType. This value is ignored when creating a patch for sketch curves.
        """
        return _fusion.PatchFeatureInput__set_continuity(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.PatchFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.PatchFeatureInput__set_targetBaseFeature(self, *args)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Patch feature is created based on geometry (e.g. a profile, edges, faces)
        in another component AND (the Patch feature) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.PatchFeatureInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, *args) -> "bool" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Patch feature is created based on geometry (e.g. a profile, edges, faces)
        in another component AND (the Patch feature) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.PatchFeatureInput__set_creationOccurrence(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.PatchFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PatchFeatureInput__get_isValid(self)
PatchFeatureInput_swigregister = _fusion.PatchFeatureInput_swigregister
PatchFeatureInput_swigregister(PatchFeatureInput)

def PatchFeatureInput_classType() -> "char const *" :
  return _fusion.PatchFeatureInput_classType()
PatchFeatureInput_classType = _fusion.PatchFeatureInput_classType

PatchFeatureInput.__swig_getmethods__["boundaryCurve"] = PatchFeatureInput._get_boundaryCurve
PatchFeatureInput.__swig_setmethods__["boundaryCurve"] = PatchFeatureInput._set_boundaryCurve
PatchFeatureInput.boundaryCurve = property(PatchFeatureInput._get_boundaryCurve, PatchFeatureInput._set_boundaryCurve, doc="Gets and set the input geometry that will be used to define the boundary. This can be a sketch profile,\na single sketch curve, a single B-Rep edge, or a Path object.\nIf a single sketch curve or B-Rep edge is input, that is not closed, Fusion 360 will automatically find connected sketch curves\nor B-Rep edges in order to define a closed loop. All sketch curves are valid as input. BRepEdges are valid if they are\nan 'open' edge, which means they are only used by one face.\nIf a Path is input it must define a closed shape and the B-Rep edges must be valid 'open' edges.")

PatchFeatureInput.__swig_getmethods__["operation"] = PatchFeatureInput._get_operation
PatchFeatureInput.__swig_setmethods__["operation"] = PatchFeatureInput._set_operation
PatchFeatureInput.operation = property(PatchFeatureInput._get_operation, PatchFeatureInput._set_operation, doc="Gets and sets the type of operation performed by the patch feature. Only 'NewBodyFeatureOperation' and 'NewComponentFeatureOperation' are\nvalid operations for patch features.")

PatchFeatureInput.__swig_getmethods__["continuity"] = PatchFeatureInput._get_continuity
PatchFeatureInput.__swig_setmethods__["continuity"] = PatchFeatureInput._set_continuity
PatchFeatureInput.continuity = property(PatchFeatureInput._get_continuity, PatchFeatureInput._set_continuity, doc="Gets and sets type of surface continuity to use when matching boundary edges to face edges. When a new PatchFeatureInput is\ncreated, this is initialized to ConnectedSurfaceContinuityType. This value is ignored when creating a patch for sketch curves.")

PatchFeatureInput.__swig_getmethods__["targetBaseFeature"] = PatchFeatureInput._get_targetBaseFeature
PatchFeatureInput.__swig_setmethods__["targetBaseFeature"] = PatchFeatureInput._set_targetBaseFeature
PatchFeatureInput.targetBaseFeature = property(PatchFeatureInput._get_targetBaseFeature, PatchFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

PatchFeatureInput.__swig_getmethods__["creationOccurrence"] = PatchFeatureInput._get_creationOccurrence
PatchFeatureInput.__swig_setmethods__["creationOccurrence"] = PatchFeatureInput._set_creationOccurrence
PatchFeatureInput.creationOccurrence = property(PatchFeatureInput._get_creationOccurrence, PatchFeatureInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the Patch feature is created based on geometry (e.g. a profile, edges, faces)\nin another component AND (the Patch feature) is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI")

PatchFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PatchFeatureInput) else None
PatchFeatureInput.cast = lambda arg: arg if isinstance(arg, PatchFeatureInput) else None

class PatchFeatures(Base):
    """
    Collection that provides access to all of the existing Patch features in a component
    and supports the ability to create new Patch features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PatchFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PatchFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PatchFeatures *" : return _fusion.PatchFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PatchFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PatchFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.PatchFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::PatchFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.PatchFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PatchFeatures_classType
    if _newclass:classType = staticmethod(_fusion.PatchFeatures_classType)
    __swig_destroy__ = _fusion.delete_PatchFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::PatchFeature >" :
        """
        Function that returns the specified patch feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.PatchFeatures_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::PatchFeature >" :
        """
        Function that returns the specified patch feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.PatchFeatures_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of Patch features in the collection."""
        return _fusion.PatchFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::PatchFeatureInput >" :
        """
        Creates a PatchFeatureInput object. Use properties and methods on the returned PatchFeatureInput
        object to set other settings. The PatchFeatureInput object can then be used as input to the 
        add method to create the patch feature. 
        boundaryCurve : Defines the input geometry that will be used to define the boundary. This can be a sketch profile, 
        a single sketch curve, a single B-Rep edge, or a Path object. 
        If a single sketch curve or B-Rep edge is input, that is not closed, Fusion 360 will automatically find connected sketch curves 
        or B-Rep edges in order to define a closed loop. All sketch curves are valid as input. BRepEdges are valid if they are 
        an 'open' edge, which means they are only used by one face.
        If a Path is input it must define a closed shape and the B-Rep edges must be valid 'open' edges. 
        operation : The feature operation to perform. Only 'NewBodyFeatureOperation' and 'NewComponentFeatureOperation' are 
        valid operations for patch features. 
        Returns the newly created PatchFeatureInput object or null if the creation failed.
        """
        return _fusion.PatchFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::PatchFeature >" :
        """
        Creates a new patch feature. 
        input : A PatchFeatureInput object that defines the desired patch feature. Use the createInput 
        method to create a new PatchFeatureInput object and then use methods on it 
        (the PatchFeatureInput object) to define the patch feature. 
        Returns the newly created PatchFeature object or null if the creation failed.
        """
        return _fusion.PatchFeatures_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.PatchFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PatchFeatures__get_isValid(self)
PatchFeatures_swigregister = _fusion.PatchFeatures_swigregister
PatchFeatures_swigregister(PatchFeatures)

def PatchFeatures_classType() -> "char const *" :
  return _fusion.PatchFeatures_classType()
PatchFeatures_classType = _fusion.PatchFeatures_classType

PatchFeatures.__swig_getmethods__["count"] = PatchFeatures._get_count
PatchFeatures.count = property(PatchFeatures._get_count, doc="The number of Patch features in the collection.")

PatchFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PatchFeatures) else None
PatchFeatures.cast = lambda arg: arg if isinstance(arg, PatchFeatures) else None

class Path(Base):
    """
    The Path object represents a single set of connected curves. The order of the objects within the collection is the same as the connection order of the entities.
    When using a Path to create a feature, the Path serves as a way to pass in the set of sketch entities and edges. When
    getting the Path of an existing feature it returns the actual path used to define the feature geometry. In cases like a
    sweep feature, this can result in using portions of the original input sketch curves or edges and the returned path
    will provide these 'partial' curves as the PathEntity objects.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Path, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Path, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::Path *" : return _fusion.Path___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Path___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Path___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.Path___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::PathEntity >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.Path___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Path_classType
    if _newclass:classType = staticmethod(_fusion.Path_classType)
    __swig_getmethods__["create"] = lambda x: _fusion.Path_create
    if _newclass:create = staticmethod(_fusion.Path_create)
    __swig_destroy__ = _fusion.delete_Path
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::PathEntity >" :
        """
        Function that returns the specified PathEntity using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.Path_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of curves in the path."""
        return _fusion.Path__get_count(self)

    def _get_isClosed(self) -> "bool" :
        """Indicates if the path is closed or not. Returns True in the case of a closed path."""
        return _fusion.Path__get_isClosed(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """This property is not supported for the Path object."""
        return _fusion.Path__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::Path >" :
        """This property is not supported for the Path object."""
        return _fusion.Path__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::Path >" :
        """
        This method is not supported for the Path object. 
        occurrence :
        """
        return _fusion.Path_createForAssemblyContext(self, *args)

    def addCurves(self, *args) -> "bool" :
        """
        Adds additional curves to the existing path. This can be useful when creating a complex path for a sweep and you
        want to include sets of curves from multiple sketches and edges from multiple bodies. 
        curves : A SketchCurve, BRepEdge, or an ObjectCollection containing multiple sketch entities and/or BRepEdges. If a single sketch curve
        or BRepEdge is input the chainCurves argument is used to determine if connected curves or edges (they do not need to be tangent)
        should be automatically found. Searching for connected curves is only performed within the same sketch or open edges on the same
        body. If multiple curves are provided the chainCurves argument is treated as false so only the specified input curves are
        used. The input curves need to geometrically connect for a path to be created. 
        chainOptions : If a single SketchCurve or BRepEdge is input, this argument is used to specify the rules in how chained entities should be found. If
        an ObjectCollection is input, this argument is ignored. 
        Returns a bool indicating if the process was successful or not.
        """
        return _fusion.Path_addCurves(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.Path__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Path__get_isValid(self)
Path_swigregister = _fusion.Path_swigregister
Path_swigregister(Path)

def Path_classType() -> "char const *" :
  return _fusion.Path_classType()
Path_classType = _fusion.Path_classType

def Path_create(*args) -> "adsk::core::Ptr< adsk::fusion::Path >" :
  return _fusion.Path_create(*args)
Path_create = _fusion.Path_create

Path.__swig_getmethods__["count"] = Path._get_count
Path.count = property(Path._get_count, doc="The number of curves in the path.")

Path.__swig_getmethods__["isClosed"] = Path._get_isClosed
Path.isClosed = property(Path._get_isClosed, doc="Indicates if the path is closed or not. Returns True in the case of a closed path.")

Path.__swig_getmethods__["assemblyContext"] = Path._get_assemblyContext
Path.assemblyContext = property(Path._get_assemblyContext, doc="This property is not supported for the Path object.")

Path.__swig_getmethods__["nativeObject"] = Path._get_nativeObject
Path.nativeObject = property(Path._get_nativeObject, doc="This property is not supported for the Path object.")

Path.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Path) else None
Path.cast = lambda arg: arg if isinstance(arg, Path) else None

class PathEntity(Base):
    """The PathEntity object represents a curve within a path"""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PathEntity, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PathEntity, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PathEntity *" : return _fusion.PathEntity___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PathEntity___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PathEntity___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PathEntity_classType
    if _newclass:classType = staticmethod(_fusion.PathEntity_classType)
    __swig_destroy__ = _fusion.delete_PathEntity
    __del__ = lambda self : None;
    def _get_curve(self) -> "adsk::core::Ptr< adsk::core::Curve3D >" :
        """
        Property that returns the geometry of the entity.
        This is different from the original path curve if the true start point is not the same as the start point of the original path curve.
        """
        return _fusion.PathEntity__get_curve(self)

    def _get_curveType(self) -> "adsk::core::Curve3DTypes" :
        """Property that returns the type of the curve referenced by the path entity. This property allows you to determine what type of object will be returned by the Curve property."""
        return _fusion.PathEntity__get_curveType(self)

    def _get_entity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Property that gets the sketch curve or edge this entity was derived from."""
        return _fusion.PathEntity__get_entity(self)

    def _get_parentPath(self) -> "adsk::core::Ptr< adsk::fusion::Path >" :
        """Property that returns the parent Path of the entity."""
        return _fusion.PathEntity__get_parentPath(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """This property is not supported for a PathEntity object."""
        return _fusion.PathEntity__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::PathEntity >" :
        """This property is not supported for a PathEntity object."""
        return _fusion.PathEntity__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::PathEntity >" :
        """
        This method is not supported for a PathEntity object. 
        occurrence :
        """
        return _fusion.PathEntity_createForAssemblyContext(self, *args)

    def _get_isOpposedToEntity(self) -> "bool" :
        """
        Indicates if the orientation of this PathEntity is in the same direction or opposed to the natural direction
        of the SketchCurve or BRepEdge object it is derived from.
        """
        return _fusion.PathEntity__get_isOpposedToEntity(self)

    def _get_objectType(self) -> "char const *" : return _fusion.PathEntity__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PathEntity__get_isValid(self)
PathEntity_swigregister = _fusion.PathEntity_swigregister
PathEntity_swigregister(PathEntity)

def PathEntity_classType() -> "char const *" :
  return _fusion.PathEntity_classType()
PathEntity_classType = _fusion.PathEntity_classType

PathEntity.__swig_getmethods__["curve"] = PathEntity._get_curve
PathEntity.curve = property(PathEntity._get_curve, doc="Property that returns the geometry of the entity.\nThis is different from the original path curve if the true start point is not the same as the start point of the original path curve.")

PathEntity.__swig_getmethods__["curveType"] = PathEntity._get_curveType
PathEntity.curveType = property(PathEntity._get_curveType, doc="Property that returns the type of the curve referenced by the path entity. This property allows you to determine what type of object will be returned by the Curve property.")

PathEntity.__swig_getmethods__["entity"] = PathEntity._get_entity
PathEntity.entity = property(PathEntity._get_entity, doc="Property that gets the sketch curve or edge this entity was derived from.")

PathEntity.__swig_getmethods__["parentPath"] = PathEntity._get_parentPath
PathEntity.parentPath = property(PathEntity._get_parentPath, doc="Property that returns the parent Path of the entity.")

PathEntity.__swig_getmethods__["assemblyContext"] = PathEntity._get_assemblyContext
PathEntity.assemblyContext = property(PathEntity._get_assemblyContext, doc="This property is not supported for a PathEntity object.")

PathEntity.__swig_getmethods__["nativeObject"] = PathEntity._get_nativeObject
PathEntity.nativeObject = property(PathEntity._get_nativeObject, doc="This property is not supported for a PathEntity object.")

PathEntity.__swig_getmethods__["isOpposedToEntity"] = PathEntity._get_isOpposedToEntity
PathEntity.isOpposedToEntity = property(PathEntity._get_isOpposedToEntity, doc="Indicates if the orientation of this PathEntity is in the same direction or opposed to the natural direction\nof the SketchCurve or BRepEdge object it is derived from.")

PathEntity.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PathEntity) else None
PathEntity.cast = lambda arg: arg if isinstance(arg, PathEntity) else None

class PathPatternFeatureInput(Base):
    """
    This class defines the methods and properties that pertain to the definition of a path pattern 
    feature.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PathPatternFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PathPatternFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PathPatternFeatureInput *" : return _fusion.PathPatternFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PathPatternFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PathPatternFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PathPatternFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.PathPatternFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_PathPatternFeatureInput
    __del__ = lambda self : None;
    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        """
        return _fusion.PathPatternFeatureInput__get_inputEntities(self)

    def _set_inputEntities(self, *args) -> "bool" :
        """
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        """
        return _fusion.PathPatternFeatureInput__set_inputEntities(self, *args)

    def _get_path(self) -> "adsk::core::Ptr< adsk::fusion::Path >" :
        """Gets and sets the path to create the pattern on path."""
        return _fusion.PathPatternFeatureInput__get_path(self)

    def _set_path(self, *args) -> "bool" :
        """Gets and sets the path to create the pattern on path."""
        return _fusion.PathPatternFeatureInput__set_path(self, *args)

    def _get_quantity(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets and sets quantity of the elements."""
        return _fusion.PathPatternFeatureInput__get_quantity(self)

    def _set_quantity(self, *args) -> "bool" :
        """Gets and sets quantity of the elements."""
        return _fusion.PathPatternFeatureInput__set_quantity(self, *args)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets and sets the distance."""
        return _fusion.PathPatternFeatureInput__get_distance(self)

    def _set_distance(self, *args) -> "bool" :
        """Gets and sets the distance."""
        return _fusion.PathPatternFeatureInput__set_distance(self, *args)

    def _get_startPoint(self) -> "double" :
        """
        Gets and sets the start point on the path to count the distance.
        It's between 0 and 1. 0 means start point of the path, 1 means end point of the path.
        """
        return _fusion.PathPatternFeatureInput__get_startPoint(self)

    def _set_startPoint(self, *args) -> "bool" :
        """
        Gets and sets the start point on the path to count the distance.
        It's between 0 and 1. 0 means start point of the path, 1 means end point of the path.
        """
        return _fusion.PathPatternFeatureInput__set_startPoint(self, *args)

    def _get_isFlipDirection(self) -> "bool" :
        """Gets and sets if flip the direction from start point."""
        return _fusion.PathPatternFeatureInput__get_isFlipDirection(self)

    def _set_isFlipDirection(self, *args) -> "bool" :
        """Gets and sets if flip the direction from start point."""
        return _fusion.PathPatternFeatureInput__set_isFlipDirection(self, *args)

    def _get_patternDistanceType(self) -> "adsk::fusion::PatternDistanceType" :
        """Gets and sets how the distance between elements is computed."""
        return _fusion.PathPatternFeatureInput__get_patternDistanceType(self)

    def _set_patternDistanceType(self, *args) -> "bool" :
        """Gets and sets how the distance between elements is computed."""
        return _fusion.PathPatternFeatureInput__set_patternDistanceType(self, *args)

    def _get_isSymmetric(self) -> "bool" :
        """Gets and sets if the pattern is in one direction or symmetric."""
        return _fusion.PathPatternFeatureInput__get_isSymmetric(self)

    def _set_isSymmetric(self, *args) -> "bool" :
        """Gets and sets if the pattern is in one direction or symmetric."""
        return _fusion.PathPatternFeatureInput__set_isSymmetric(self, *args)

    def _get_isOrientationAlongPath(self) -> "bool" :
        """
        Gets and sets if the orientation is along path.
        If false, the orientation is identical.
        """
        return _fusion.PathPatternFeatureInput__get_isOrientationAlongPath(self)

    def _set_isOrientationAlongPath(self, *args) -> "bool" :
        """
        Gets and sets if the orientation is along path.
        If false, the orientation is identical.
        """
        return _fusion.PathPatternFeatureInput__set_isOrientationAlongPath(self, *args)

    def _get_patternComputeOption(self) -> "adsk::fusion::PatternComputeOptions" :
        """
        Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        """
        return _fusion.PathPatternFeatureInput__get_patternComputeOption(self)

    def _set_patternComputeOption(self, *args) -> "bool" :
        """
        Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        """
        return _fusion.PathPatternFeatureInput__set_patternComputeOption(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.PathPatternFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.PathPatternFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.PathPatternFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PathPatternFeatureInput__get_isValid(self)
PathPatternFeatureInput_swigregister = _fusion.PathPatternFeatureInput_swigregister
PathPatternFeatureInput_swigregister(PathPatternFeatureInput)

def PathPatternFeatureInput_classType() -> "char const *" :
  return _fusion.PathPatternFeatureInput_classType()
PathPatternFeatureInput_classType = _fusion.PathPatternFeatureInput_classType

PathPatternFeatureInput.__swig_getmethods__["inputEntities"] = PathPatternFeatureInput._get_inputEntities
PathPatternFeatureInput.__swig_setmethods__["inputEntities"] = PathPatternFeatureInput._set_inputEntities
PathPatternFeatureInput.inputEntities = property(PathPatternFeatureInput._get_inputEntities, PathPatternFeatureInput._set_inputEntities, doc="Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.\nAll of the entities must be of a single type. For example, it can't contain features and occurrences\nbut only features or occurrences.")

PathPatternFeatureInput.__swig_getmethods__["path"] = PathPatternFeatureInput._get_path
PathPatternFeatureInput.__swig_setmethods__["path"] = PathPatternFeatureInput._set_path
PathPatternFeatureInput.path = property(PathPatternFeatureInput._get_path, PathPatternFeatureInput._set_path, doc="Gets and sets the path to create the pattern on path.")

PathPatternFeatureInput.__swig_getmethods__["quantity"] = PathPatternFeatureInput._get_quantity
PathPatternFeatureInput.__swig_setmethods__["quantity"] = PathPatternFeatureInput._set_quantity
PathPatternFeatureInput.quantity = property(PathPatternFeatureInput._get_quantity, PathPatternFeatureInput._set_quantity, doc="Gets and sets quantity of the elements.")

PathPatternFeatureInput.__swig_getmethods__["distance"] = PathPatternFeatureInput._get_distance
PathPatternFeatureInput.__swig_setmethods__["distance"] = PathPatternFeatureInput._set_distance
PathPatternFeatureInput.distance = property(PathPatternFeatureInput._get_distance, PathPatternFeatureInput._set_distance, doc="Gets and sets the distance.")

PathPatternFeatureInput.__swig_getmethods__["startPoint"] = PathPatternFeatureInput._get_startPoint
PathPatternFeatureInput.__swig_setmethods__["startPoint"] = PathPatternFeatureInput._set_startPoint
PathPatternFeatureInput.startPoint = property(PathPatternFeatureInput._get_startPoint, PathPatternFeatureInput._set_startPoint, doc="Gets and sets the start point on the path to count the distance.\nIt's between 0 and 1. 0 means start point of the path, 1 means end point of the path.")

PathPatternFeatureInput.__swig_getmethods__["isFlipDirection"] = PathPatternFeatureInput._get_isFlipDirection
PathPatternFeatureInput.__swig_setmethods__["isFlipDirection"] = PathPatternFeatureInput._set_isFlipDirection
PathPatternFeatureInput.isFlipDirection = property(PathPatternFeatureInput._get_isFlipDirection, PathPatternFeatureInput._set_isFlipDirection, doc="Gets and sets if flip the direction from start point.")

PathPatternFeatureInput.__swig_getmethods__["patternDistanceType"] = PathPatternFeatureInput._get_patternDistanceType
PathPatternFeatureInput.__swig_setmethods__["patternDistanceType"] = PathPatternFeatureInput._set_patternDistanceType
PathPatternFeatureInput.patternDistanceType = property(PathPatternFeatureInput._get_patternDistanceType, PathPatternFeatureInput._set_patternDistanceType, doc="Gets and sets how the distance between elements is computed.")

PathPatternFeatureInput.__swig_getmethods__["isSymmetric"] = PathPatternFeatureInput._get_isSymmetric
PathPatternFeatureInput.__swig_setmethods__["isSymmetric"] = PathPatternFeatureInput._set_isSymmetric
PathPatternFeatureInput.isSymmetric = property(PathPatternFeatureInput._get_isSymmetric, PathPatternFeatureInput._set_isSymmetric, doc="Gets and sets if the pattern is in one direction or symmetric.")

PathPatternFeatureInput.__swig_getmethods__["isOrientationAlongPath"] = PathPatternFeatureInput._get_isOrientationAlongPath
PathPatternFeatureInput.__swig_setmethods__["isOrientationAlongPath"] = PathPatternFeatureInput._set_isOrientationAlongPath
PathPatternFeatureInput.isOrientationAlongPath = property(PathPatternFeatureInput._get_isOrientationAlongPath, PathPatternFeatureInput._set_isOrientationAlongPath, doc="Gets and sets if the orientation is along path.\nIf false, the orientation is identical.")

PathPatternFeatureInput.__swig_getmethods__["patternComputeOption"] = PathPatternFeatureInput._get_patternComputeOption
PathPatternFeatureInput.__swig_setmethods__["patternComputeOption"] = PathPatternFeatureInput._set_patternComputeOption
PathPatternFeatureInput.patternComputeOption = property(PathPatternFeatureInput._get_patternComputeOption, PathPatternFeatureInput._set_patternComputeOption, doc="Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.\nThis property only applies when patterning features and is ignored in the direct modeling environment.")

PathPatternFeatureInput.__swig_getmethods__["targetBaseFeature"] = PathPatternFeatureInput._get_targetBaseFeature
PathPatternFeatureInput.__swig_setmethods__["targetBaseFeature"] = PathPatternFeatureInput._set_targetBaseFeature
PathPatternFeatureInput.targetBaseFeature = property(PathPatternFeatureInput._get_targetBaseFeature, PathPatternFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

PathPatternFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PathPatternFeatureInput) else None
PathPatternFeatureInput.cast = lambda arg: arg if isinstance(arg, PathPatternFeatureInput) else None

class PathPatternFeatures(Base):
    """
    Collection that provides access to all of the existing path pattern features in a component
    and supports the ability to create new path pattern features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PathPatternFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PathPatternFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PathPatternFeatures *" : return _fusion.PathPatternFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PathPatternFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PathPatternFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.PathPatternFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::PathPatternFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.PathPatternFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PathPatternFeatures_classType
    if _newclass:classType = staticmethod(_fusion.PathPatternFeatures_classType)
    __swig_destroy__ = _fusion.delete_PathPatternFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::PathPatternFeature >" :
        """
        Function that returns the specified path pattern feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.PathPatternFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of path pattern features in the collection."""
        return _fusion.PathPatternFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::PathPatternFeatureInput >" :
        """
        Creates a PathPatternFeatureInput object. Use properties and methods on this object
        to define the path pattern you want to create and then use the Add method, passing in 
        the PathPatternFeatureInput object. 
        inputEntities : The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences. 
        path : The Path object that represents a single set of connected curves along which to drive the pattern. 
        quantity : Specifies the number of instances in the first direction. 
        distance : Specifies the distance. How this value is used depends on the value of the PatternDistanceType property. A
        negative value can be used to change the direction.
        If the value is ExtentPatternDistanceType then it defines the total distance of the pattern.
        If the value is SpacingPatternDistanceType then it defines the distance between each element. 
        patternDistanceType : Specifies how the distance between elements is computed. 
        Returns the newly created PathPatternFeatureInput object or null if the creation failed.
        """
        return _fusion.PathPatternFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::PathPatternFeature >" :
        """
        Creates a new path pattern feature. 
        input : A PathPatternFeatureInput object that defines the desired path pattern. Use the createInput 
        method to create a new PathPatternFeatureInput object and then use methods on it 
        (the PathPatternFeatureInput object) to define the path pattern. 
        Returns the newly created PathPatternFeature object or null if the creation failed.
        """
        return _fusion.PathPatternFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::PathPatternFeature >" :
        """
        Function that returns the specified path pattern feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.PathPatternFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.PathPatternFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PathPatternFeatures__get_isValid(self)
PathPatternFeatures_swigregister = _fusion.PathPatternFeatures_swigregister
PathPatternFeatures_swigregister(PathPatternFeatures)

def PathPatternFeatures_classType() -> "char const *" :
  return _fusion.PathPatternFeatures_classType()
PathPatternFeatures_classType = _fusion.PathPatternFeatures_classType

PathPatternFeatures.__swig_getmethods__["count"] = PathPatternFeatures._get_count
PathPatternFeatures.count = property(PathPatternFeatures._get_count, doc="The number of path pattern features in the collection.")

PathPatternFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PathPatternFeatures) else None
PathPatternFeatures.cast = lambda arg: arg if isinstance(arg, PathPatternFeatures) else None

class PatternElement(Base):
    """This class defines the properties that pertain to the pattern element."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PatternElement, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PatternElement, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PatternElement *" : return _fusion.PatternElement___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PatternElement___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PatternElement___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PatternElement_classType
    if _newclass:classType = staticmethod(_fusion.PatternElement_classType)
    __swig_destroy__ = _fusion.delete_PatternElement
    __del__ = lambda self : None;
    def _get_faces(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepFace > > >" :
        """Gets the faces generated as a result of this particular element."""
        return _fusion.PatternElement__get_faces(self)

    def _get_id(self) -> "size_t" :
        """Gets the id of this element within the pattern."""
        return _fusion.PatternElement__get_id(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        """Gets the feature pattern this element is a member of."""
        return _fusion.PatternElement__get_parentFeature(self)

    def _get_isSuppressed(self) -> "bool" :
        """Gets and sets whether the element is suppressed or not. A value of True indicates it is suppressed"""
        return _fusion.PatternElement__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """Gets and sets whether the element is suppressed or not. A value of True indicates it is suppressed"""
        return _fusion.PatternElement__set_isSuppressed(self, *args)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >" :
        """
        Get the transform that describes this elements relative position to the parent object(s).
        The transform returned for the first element in a pattern will be an identity matrix.
        """
        return _fusion.PatternElement__get_transform(self)

    def _get_name(self) -> "std::string" :
        """Get the name of the pattern element."""
        return _fusion.PatternElement__get_name(self)

    def _get_occurrences(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Occurrence >,std::allocator< adsk::core::Ptr< adsk::fusion::Occurrence > > >" :
        """
        If the patternEntityType property of the parent feature returns OccurrencesPatternType
        then this property will return the occurrences associated with this particular pattern
        element.
        """
        return _fusion.PatternElement__get_occurrences(self)

    def _get_objectType(self) -> "char const *" : return _fusion.PatternElement__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PatternElement__get_isValid(self)
PatternElement_swigregister = _fusion.PatternElement_swigregister
PatternElement_swigregister(PatternElement)

def PatternElement_classType() -> "char const *" :
  return _fusion.PatternElement_classType()
PatternElement_classType = _fusion.PatternElement_classType

PatternElement.__swig_getmethods__["faces"] = PatternElement._get_faces
PatternElement.faces = property(PatternElement._get_faces, doc="Gets the faces generated as a result of this particular element.")

PatternElement.__swig_getmethods__["id"] = PatternElement._get_id
PatternElement.id = property(PatternElement._get_id, doc="Gets the id of this element within the pattern.")

PatternElement.__swig_getmethods__["parentFeature"] = PatternElement._get_parentFeature
PatternElement.parentFeature = property(PatternElement._get_parentFeature, doc="Gets the feature pattern this element is a member of.")

PatternElement.__swig_getmethods__["isSuppressed"] = PatternElement._get_isSuppressed
PatternElement.__swig_setmethods__["isSuppressed"] = PatternElement._set_isSuppressed
PatternElement.isSuppressed = property(PatternElement._get_isSuppressed, PatternElement._set_isSuppressed, doc="Gets and sets whether the element is suppressed or not. A value of True indicates it is suppressed")

PatternElement.__swig_getmethods__["transform"] = PatternElement._get_transform
PatternElement.transform = property(PatternElement._get_transform, doc="Get the transform that describes this elements relative position to the parent object(s).\nThe transform returned for the first element in a pattern will be an identity matrix.")

PatternElement.__swig_getmethods__["name"] = PatternElement._get_name
PatternElement.name = property(PatternElement._get_name, doc="Get the name of the pattern element.")

PatternElement.__swig_getmethods__["occurrences"] = PatternElement._get_occurrences
PatternElement.occurrences = property(PatternElement._get_occurrences, doc="If the patternEntityType property of the parent feature returns OccurrencesPatternType\nthen this property will return the occurrences associated with this particular pattern\nelement.")

PatternElement.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PatternElement) else None
PatternElement.cast = lambda arg: arg if isinstance(arg, PatternElement) else None

class PatternElements(Base):
    """Collection that provides access to pattern elements of mirror and pattern features."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PatternElements, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PatternElements, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PatternElements *" : return _fusion.PatternElements___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PatternElements___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PatternElements___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.PatternElements___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::PatternElement >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.PatternElements___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PatternElements_classType
    if _newclass:classType = staticmethod(_fusion.PatternElements_classType)
    __swig_destroy__ = _fusion.delete_PatternElements
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::PatternElement >" :
        """
        Function that returns the specified pattern element using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.PatternElements_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of pattern elements in the collection."""
        return _fusion.PatternElements__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.PatternElements__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PatternElements__get_isValid(self)
PatternElements_swigregister = _fusion.PatternElements_swigregister
PatternElements_swigregister(PatternElements)

def PatternElements_classType() -> "char const *" :
  return _fusion.PatternElements_classType()
PatternElements_classType = _fusion.PatternElements_classType

PatternElements.__swig_getmethods__["count"] = PatternElements._get_count
PatternElements.count = property(PatternElements._get_count, doc="The number of pattern elements in the collection.")

PatternElements.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PatternElements) else None
PatternElements.cast = lambda arg: arg if isinstance(arg, PatternElements) else None

class PhysicalProperties(Base):
    """The physical properties of a Component, Occurrence or BRepBody"""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PhysicalProperties, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PhysicalProperties, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PhysicalProperties *" : return _fusion.PhysicalProperties___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PhysicalProperties___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PhysicalProperties___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PhysicalProperties_classType
    if _newclass:classType = staticmethod(_fusion.PhysicalProperties_classType)
    __swig_destroy__ = _fusion.delete_PhysicalProperties
    __del__ = lambda self : None;
    def _get_area(self) -> "double" :
        """Gets the area in square centimeters."""
        return _fusion.PhysicalProperties__get_area(self)

    def _get_density(self) -> "double" :
        """Gets the density in kilograms per cubic centimeter."""
        return _fusion.PhysicalProperties__get_density(self)

    def _get_mass(self) -> "double" :
        """Gets the mass in kilograms."""
        return _fusion.PhysicalProperties__get_mass(self)

    def _get_volume(self) -> "double" :
        """Gets the volume in the cubic centimeters."""
        return _fusion.PhysicalProperties__get_volume(self)

    def _get_accuracy(self) -> "adsk::fusion::CalculationAccuracy" :
        """Returns the accuracy that was used for the calculation."""
        return _fusion.PhysicalProperties__get_accuracy(self)

    def _get_centerOfMass(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Returns the center of mass position"""
        return _fusion.PhysicalProperties__get_centerOfMass(self)

    def getPrincipalAxes(self) -> "bool" :
        """
        Method that returns the principal axes. 
        xAxis : The output Vector3D object that indicates the direction of the x axis. 
        yAxis : The output Vector3D object that indicates the direction of the y axis. 
        zAxis : The output Vector3D object that indicates the direction of the z axis. 
        Returns true if successful
        """
        return _fusion.PhysicalProperties_getPrincipalAxes(self)

    def getPrincipalMomentsOfInertia(self) -> "bool" :
        """
        Method that returns the moments of inertia about the principal axes. Unit for returned values is kg/cm^2. 
        i1 : Output Double that specifies the first moment of inertia. 
        i2 : Output Double that specifies the second moment of inertia. 
        i3 : Output Double that specifies the third moment of inertia. 
        Returns true if successful
        """
        return _fusion.PhysicalProperties_getPrincipalMomentsOfInertia(self)

    def getRadiusOfGyration(self) -> "bool" :
        """
        Method that returns the radius of gyration about the principal axes. Unit for returned values is cm. 
        kx : Output Double that returns the X partial radius of gyration. 
        ky : Output Double that returns the Y partial radius of gyration. 
        kz : Output Double that returns the Z partial radius of gyration. 
        Returns true if successful
        """
        return _fusion.PhysicalProperties_getRadiusOfGyration(self)

    def getRotationToPrincipal(self) -> "bool" :
        """
        Gets the rotation from the world coordinate system of the target to the principal coordinate system. 
        rx : 
        ry : 
        rz : 
        Returns true if successful
        """
        return _fusion.PhysicalProperties_getRotationToPrincipal(self)

    def getXYZMomentsOfInertia(self) -> "bool" :
        """
        Method that gets the moment of inertia about the world coordinate system.
        Unit for returned values is kg/cm^2. 
        xx : Output Double that returns the XX partial moment. 
        yy : Output Double that returns the YY partial moment. 
        zz : Output Double that returns the ZZ partial moment. 
        xy : Output Double that returns the XY partial moment. 
        yz : Output Double that returns the YZ partial moment. 
        xz : Output Double that returns the XZ partial moment. 
        Returns true if successful
        """
        return _fusion.PhysicalProperties_getXYZMomentsOfInertia(self)

    def _get_objectType(self) -> "char const *" : return _fusion.PhysicalProperties__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PhysicalProperties__get_isValid(self)
PhysicalProperties_swigregister = _fusion.PhysicalProperties_swigregister
PhysicalProperties_swigregister(PhysicalProperties)

def PhysicalProperties_classType() -> "char const *" :
  return _fusion.PhysicalProperties_classType()
PhysicalProperties_classType = _fusion.PhysicalProperties_classType

PhysicalProperties.__swig_getmethods__["area"] = PhysicalProperties._get_area
PhysicalProperties.area = property(PhysicalProperties._get_area, doc="Gets the area in square centimeters.")

PhysicalProperties.__swig_getmethods__["density"] = PhysicalProperties._get_density
PhysicalProperties.density = property(PhysicalProperties._get_density, doc="Gets the density in kilograms per cubic centimeter.")

PhysicalProperties.__swig_getmethods__["mass"] = PhysicalProperties._get_mass
PhysicalProperties.mass = property(PhysicalProperties._get_mass, doc="Gets the mass in kilograms.")

PhysicalProperties.__swig_getmethods__["volume"] = PhysicalProperties._get_volume
PhysicalProperties.volume = property(PhysicalProperties._get_volume, doc="Gets the volume in the cubic centimeters.")

PhysicalProperties.__swig_getmethods__["accuracy"] = PhysicalProperties._get_accuracy
PhysicalProperties.accuracy = property(PhysicalProperties._get_accuracy, doc="Returns the accuracy that was used for the calculation.")

PhysicalProperties.__swig_getmethods__["centerOfMass"] = PhysicalProperties._get_centerOfMass
PhysicalProperties.centerOfMass = property(PhysicalProperties._get_centerOfMass, doc="Returns the center of mass position")

PhysicalProperties.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PhysicalProperties) else None
PhysicalProperties.cast = lambda arg: arg if isinstance(arg, PhysicalProperties) else None

class PipeFeatures(Base):
    """Collection that provides access to all of the existing pipe features in a design."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PipeFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PipeFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PipeFeatures *" : return _fusion.PipeFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PipeFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PipeFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.PipeFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::PipeFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.PipeFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PipeFeatures_classType
    if _newclass:classType = staticmethod(_fusion.PipeFeatures_classType)
    __swig_destroy__ = _fusion.delete_PipeFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::PipeFeature >" :
        """
        Function that returns the specified pipe feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.PipeFeatures_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::PipeFeature >" :
        """
        Function that returns the specified pipe feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.PipeFeatures_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of pipe features in the collection."""
        return _fusion.PipeFeatures__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.PipeFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PipeFeatures__get_isValid(self)
PipeFeatures_swigregister = _fusion.PipeFeatures_swigregister
PipeFeatures_swigregister(PipeFeatures)

def PipeFeatures_classType() -> "char const *" :
  return _fusion.PipeFeatures_classType()
PipeFeatures_classType = _fusion.PipeFeatures_classType

PipeFeatures.__swig_getmethods__["count"] = PipeFeatures._get_count
PipeFeatures.count = property(PipeFeatures._get_count, doc="The number of pipe features in the collection.")

PipeFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PipeFeatures) else None
PipeFeatures.cast = lambda arg: arg if isinstance(arg, PipeFeatures) else None

class PolygonMesh(Base):
    """
    The PolygonMesh represents a mesh that can contain any
    combination of polygons, quads, and triangles.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolygonMesh, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PolygonMesh, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PolygonMesh *" : return _fusion.PolygonMesh___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PolygonMesh___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PolygonMesh___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PolygonMesh_classType
    if _newclass:classType = staticmethod(_fusion.PolygonMesh_classType)
    __swig_destroy__ = _fusion.delete_PolygonMesh
    __del__ = lambda self : None;
    def _get_nodeCount(self) -> "int" :
        """Returns the number of nodes in the mesh."""
        return _fusion.PolygonMesh__get_nodeCount(self)

    def _get_nodeCoordinatesAsDouble(self) -> "std::vector< double,std::allocator< double > >" :
        """
        Returns the node coordinates as an array of doubles where
        they are the x, y, z components of each coordinate.
        """
        return _fusion.PolygonMesh__get_nodeCoordinatesAsDouble(self)

    def _get_nodeCoordinatesAsFloat(self) -> "std::vector< float,std::allocator< float > >" :
        """
        Returns the node coordinates as an array of floats where
        they are the x, y, z components of each coordinate.
        """
        return _fusion.PolygonMesh__get_nodeCoordinatesAsFloat(self)

    def _get_nodeCoordinates(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D >,std::allocator< adsk::core::Ptr< adsk::core::Point3D > > >" :
        """Returns the node coordinates as an array of Point3D objects."""
        return _fusion.PolygonMesh__get_nodeCoordinates(self)

    def _get_triangleCount(self) -> "int" :
        """Returns the number of triangles in the mesh."""
        return _fusion.PolygonMesh__get_triangleCount(self)

    def _get_quadCount(self) -> "int" :
        """Returns the number of quads in the mesh."""
        return _fusion.PolygonMesh__get_quadCount(self)

    def _get_polygonCount(self) -> "int" :
        """Returns the number of polygons (more than 4 sides) in the mesh."""
        return _fusion.PolygonMesh__get_polygonCount(self)

    def _get_normalVectorsAsDouble(self) -> "std::vector< double,std::allocator< double > >" :
        """
        Returns the normal vectors as an array of doubles where
        they are the x, y, z components of each vector. There is one normal vector for each index.
        """
        return _fusion.PolygonMesh__get_normalVectorsAsDouble(self)

    def _get_normalVectorsAsFloat(self) -> "std::vector< float,std::allocator< float > >" :
        """Returns the normal vectors as an array of floats. There is one normal vector for each index."""
        return _fusion.PolygonMesh__get_normalVectorsAsFloat(self)

    def _get_normalVectors(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D >,std::allocator< adsk::core::Ptr< adsk::core::Vector3D > > >" :
        """Returns the normal vectors as an array of Vector 3D objects. There is one normal vector for each index."""
        return _fusion.PolygonMesh__get_normalVectors(self)

    def _get_triangleNodeIndices(self) -> "std::vector< int,std::allocator< int > >" :
        """
        Returns the index values that index into the NodeCoordinates and NormalVectors arrays to
        define the three coordinates of each triangle and the corresponding normal.
        """
        return _fusion.PolygonMesh__get_triangleNodeIndices(self)

    def _get_quadNodeIndices(self) -> "std::vector< int,std::allocator< int > >" :
        """
        Returns the index values that index into the NodeCoordinates and NormalVectors arrays to
        define the four coordinates of each quad and the corresponding normal.
        """
        return _fusion.PolygonMesh__get_quadNodeIndices(self)

    def _get_polygonNodeIndices(self) -> "std::vector< int,std::allocator< int > >" :
        """
        Returns the index values that index into the NodeCoordinates and NormalVectors arrays to
        define the coordinates of each polygon and the corresponding normal.
        """
        return _fusion.PolygonMesh__get_polygonNodeIndices(self)

    def _get_nodeCountPerPolygon(self) -> "std::vector< int,std::allocator< int > >" :
        """
        Returns the number of nodes that define each polygon. For example, 
        if NodeCountPerPolygon[0] returns 6 it indicates the first polygon
        is defined using 6 nodes. The first six indices returned by the 
        PolygonNodeIndices properties provide the look-up into the NodeCoordinates
        array.
        """
        return _fusion.PolygonMesh__get_nodeCountPerPolygon(self)

    def _get_objectType(self) -> "char const *" : return _fusion.PolygonMesh__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PolygonMesh__get_isValid(self)
PolygonMesh_swigregister = _fusion.PolygonMesh_swigregister
PolygonMesh_swigregister(PolygonMesh)

def PolygonMesh_classType() -> "char const *" :
  return _fusion.PolygonMesh_classType()
PolygonMesh_classType = _fusion.PolygonMesh_classType

PolygonMesh.__swig_getmethods__["nodeCount"] = PolygonMesh._get_nodeCount
PolygonMesh.nodeCount = property(PolygonMesh._get_nodeCount, doc="Returns the number of nodes in the mesh.")

PolygonMesh.__swig_getmethods__["nodeCoordinatesAsDouble"] = PolygonMesh._get_nodeCoordinatesAsDouble
PolygonMesh.nodeCoordinatesAsDouble = property(PolygonMesh._get_nodeCoordinatesAsDouble, doc="Returns the node coordinates as an array of doubles where\nthey are the x, y, z components of each coordinate.")

PolygonMesh.__swig_getmethods__["nodeCoordinatesAsFloat"] = PolygonMesh._get_nodeCoordinatesAsFloat
PolygonMesh.nodeCoordinatesAsFloat = property(PolygonMesh._get_nodeCoordinatesAsFloat, doc="Returns the node coordinates as an array of floats where\nthey are the x, y, z components of each coordinate.")

PolygonMesh.__swig_getmethods__["nodeCoordinates"] = PolygonMesh._get_nodeCoordinates
PolygonMesh.nodeCoordinates = property(PolygonMesh._get_nodeCoordinates, doc="Returns the node coordinates as an array of Point3D objects.")

PolygonMesh.__swig_getmethods__["triangleCount"] = PolygonMesh._get_triangleCount
PolygonMesh.triangleCount = property(PolygonMesh._get_triangleCount, doc="Returns the number of triangles in the mesh.")

PolygonMesh.__swig_getmethods__["quadCount"] = PolygonMesh._get_quadCount
PolygonMesh.quadCount = property(PolygonMesh._get_quadCount, doc="Returns the number of quads in the mesh.")

PolygonMesh.__swig_getmethods__["polygonCount"] = PolygonMesh._get_polygonCount
PolygonMesh.polygonCount = property(PolygonMesh._get_polygonCount, doc="Returns the number of polygons (more than 4 sides) in the mesh.")

PolygonMesh.__swig_getmethods__["normalVectorsAsDouble"] = PolygonMesh._get_normalVectorsAsDouble
PolygonMesh.normalVectorsAsDouble = property(PolygonMesh._get_normalVectorsAsDouble, doc="Returns the normal vectors as an array of doubles where\nthey are the x, y, z components of each vector. There is one normal vector for each index.")

PolygonMesh.__swig_getmethods__["normalVectorsAsFloat"] = PolygonMesh._get_normalVectorsAsFloat
PolygonMesh.normalVectorsAsFloat = property(PolygonMesh._get_normalVectorsAsFloat, doc="Returns the normal vectors as an array of floats. There is one normal vector for each index.")

PolygonMesh.__swig_getmethods__["normalVectors"] = PolygonMesh._get_normalVectors
PolygonMesh.normalVectors = property(PolygonMesh._get_normalVectors, doc="Returns the normal vectors as an array of Vector 3D objects. There is one normal vector for each index.")

PolygonMesh.__swig_getmethods__["triangleNodeIndices"] = PolygonMesh._get_triangleNodeIndices
PolygonMesh.triangleNodeIndices = property(PolygonMesh._get_triangleNodeIndices, doc="Returns the index values that index into the NodeCoordinates and NormalVectors arrays to\ndefine the three coordinates of each triangle and the corresponding normal.")

PolygonMesh.__swig_getmethods__["quadNodeIndices"] = PolygonMesh._get_quadNodeIndices
PolygonMesh.quadNodeIndices = property(PolygonMesh._get_quadNodeIndices, doc="Returns the index values that index into the NodeCoordinates and NormalVectors arrays to\ndefine the four coordinates of each quad and the corresponding normal.")

PolygonMesh.__swig_getmethods__["polygonNodeIndices"] = PolygonMesh._get_polygonNodeIndices
PolygonMesh.polygonNodeIndices = property(PolygonMesh._get_polygonNodeIndices, doc="Returns the index values that index into the NodeCoordinates and NormalVectors arrays to\ndefine the coordinates of each polygon and the corresponding normal.")

PolygonMesh.__swig_getmethods__["nodeCountPerPolygon"] = PolygonMesh._get_nodeCountPerPolygon
PolygonMesh.nodeCountPerPolygon = property(PolygonMesh._get_nodeCountPerPolygon, doc="Returns the number of nodes that define each polygon. For example,\nif NodeCountPerPolygon[0] returns 6 it indicates the first polygon\nis defined using 6 nodes. The first six indices returned by the\nPolygonNodeIndices properties provide the look-up into the NodeCoordinates\narray.")

PolygonMesh.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PolygonMesh) else None
PolygonMesh.cast = lambda arg: arg if isinstance(arg, PolygonMesh) else None

class Profile(Base):
    """
    Represents a profile in a sketch. Profiles are automatically computed by Fusion 360 and
    represent closed areas within the sketch.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Profile, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Profile, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::Profile *" : return _fusion.Profile___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Profile___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Profile___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Profile_classType
    if _newclass:classType = staticmethod(_fusion.Profile_classType)
    __swig_destroy__ = _fusion.delete_Profile
    __del__ = lambda self : None;
    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the 3D bounding box of the profile in sketch space."""
        return _fusion.Profile__get_boundingBox(self)

    def _get_plane(self) -> "adsk::core::Ptr< adsk::core::Plane >" :
        """
        Returns the plane the profile is defined in. Profiles are always planar and exist within 
        a single plane.
        """
        return _fusion.Profile__get_plane(self)

    def _get_profileLoops(self) -> "adsk::core::Ptr< adsk::fusion::ProfileLoops >" :
        """
        The loops or closed areas within this profile. There is always a single outer loop
        but there can be zero to many inner loops defining voids in the profile.
        """
        return _fusion.Profile__get_profileLoops(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch of the profile."""
        return _fusion.Profile__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.Profile__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::Profile >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.Profile__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::Profile >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence.
        Returns null if this isn't the NativeObject. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.Profile_createForAssemblyContext(self, *args)

    def areaProperties(self, *args) -> "adsk::core::Ptr< adsk::fusion::AreaProperties >" :
        """
        Returns the AreaProperties object that has properties for getting the area, perimeter, centroid, etc 
        of this profile. 
        accuracy : Specifies the desired level of computational accuracy of the property calculations.
        The default value of 'LowCalculationAccuracy' returns results within a +/- 1% error margin.
        """
        return _fusion.Profile_areaProperties(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.Profile__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Profile__get_isValid(self)
Profile_swigregister = _fusion.Profile_swigregister
Profile_swigregister(Profile)

def Profile_classType() -> "char const *" :
  return _fusion.Profile_classType()
Profile_classType = _fusion.Profile_classType

Profile.__swig_getmethods__["boundingBox"] = Profile._get_boundingBox
Profile.boundingBox = property(Profile._get_boundingBox, doc="Returns the 3D bounding box of the profile in sketch space.")

Profile.__swig_getmethods__["plane"] = Profile._get_plane
Profile.plane = property(Profile._get_plane, doc="Returns the plane the profile is defined in. Profiles are always planar and exist within\na single plane.")

Profile.__swig_getmethods__["profileLoops"] = Profile._get_profileLoops
Profile.profileLoops = property(Profile._get_profileLoops, doc="The loops or closed areas within this profile. There is always a single outer loop\nbut there can be zero to many inner loops defining voids in the profile.")

Profile.__swig_getmethods__["parentSketch"] = Profile._get_parentSketch
Profile.parentSketch = property(Profile._get_parentSketch, doc="Returns the parent sketch of the profile.")

Profile.__swig_getmethods__["assemblyContext"] = Profile._get_assemblyContext
Profile.assemblyContext = property(Profile._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nis acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")

Profile.__swig_getmethods__["nativeObject"] = Profile._get_nativeObject
Profile.nativeObject = property(Profile._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

Profile.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Profile) else None
Profile.cast = lambda arg: arg if isinstance(arg, Profile) else None

class ProfileCurve(Base):
    """A single curve in a profile."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProfileCurve, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ProfileCurve, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ProfileCurve *" : return _fusion.ProfileCurve___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ProfileCurve___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ProfileCurve___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ProfileCurve_classType
    if _newclass:classType = staticmethod(_fusion.ProfileCurve_classType)
    __swig_destroy__ = _fusion.delete_ProfileCurve
    __del__ = lambda self : None;
    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Curve3D >" :
        """Returns the geometric entity of this portion of the profile."""
        return _fusion.ProfileCurve__get_geometry(self)

    def _get_geometryType(self) -> "adsk::core::Curve3DTypes" :
        """Return the geometry type that the Geometry property will return."""
        return _fusion.ProfileCurve__get_geometryType(self)

    def _get_sketchEntity(self) -> "adsk::core::Ptr< adsk::fusion::SketchEntity >" :
        """Returns the associated sketch entity that defines this curve."""
        return _fusion.ProfileCurve__get_sketchEntity(self)

    def _get_parentProfileLoop(self) -> "adsk::core::Ptr< adsk::fusion::ProfileLoop >" :
        """Returns the parent ProfileLoop object."""
        return _fusion.ProfileCurve__get_parentProfileLoop(self)

    def _get_parentProfile(self) -> "adsk::core::Ptr< adsk::fusion::Profile >" :
        """Returns the parent Profile object."""
        return _fusion.ProfileCurve__get_parentProfile(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent Profile object."""
        return _fusion.ProfileCurve__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ProfileCurve__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ProfileCurve >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ProfileCurve__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::ProfileCurve >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence.
        Returns null if this isn't the NativeObject. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ProfileCurve_createForAssemblyContext(self, *args)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of the profile curve in sketch space."""
        return _fusion.ProfileCurve__get_boundingBox(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ProfileCurve__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ProfileCurve__get_isValid(self)
ProfileCurve_swigregister = _fusion.ProfileCurve_swigregister
ProfileCurve_swigregister(ProfileCurve)

def ProfileCurve_classType() -> "char const *" :
  return _fusion.ProfileCurve_classType()
ProfileCurve_classType = _fusion.ProfileCurve_classType

ProfileCurve.__swig_getmethods__["geometry"] = ProfileCurve._get_geometry
ProfileCurve.geometry = property(ProfileCurve._get_geometry, doc="Returns the geometric entity of this portion of the profile.")

ProfileCurve.__swig_getmethods__["geometryType"] = ProfileCurve._get_geometryType
ProfileCurve.geometryType = property(ProfileCurve._get_geometryType, doc="Return the geometry type that the Geometry property will return.")

ProfileCurve.__swig_getmethods__["sketchEntity"] = ProfileCurve._get_sketchEntity
ProfileCurve.sketchEntity = property(ProfileCurve._get_sketchEntity, doc="Returns the associated sketch entity that defines this curve.")

ProfileCurve.__swig_getmethods__["parentProfileLoop"] = ProfileCurve._get_parentProfileLoop
ProfileCurve.parentProfileLoop = property(ProfileCurve._get_parentProfileLoop, doc="Returns the parent ProfileLoop object.")

ProfileCurve.__swig_getmethods__["parentProfile"] = ProfileCurve._get_parentProfile
ProfileCurve.parentProfile = property(ProfileCurve._get_parentProfile, doc="Returns the parent Profile object.")

ProfileCurve.__swig_getmethods__["parentSketch"] = ProfileCurve._get_parentSketch
ProfileCurve.parentSketch = property(ProfileCurve._get_parentSketch, doc="Returns the parent Profile object.")

ProfileCurve.__swig_getmethods__["assemblyContext"] = ProfileCurve._get_assemblyContext
ProfileCurve.assemblyContext = property(ProfileCurve._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")

ProfileCurve.__swig_getmethods__["nativeObject"] = ProfileCurve._get_nativeObject
ProfileCurve.nativeObject = property(ProfileCurve._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

ProfileCurve.__swig_getmethods__["boundingBox"] = ProfileCurve._get_boundingBox
ProfileCurve.boundingBox = property(ProfileCurve._get_boundingBox, doc="Returns the bounding box of the profile curve in sketch space.")

ProfileCurve.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ProfileCurve) else None
ProfileCurve.cast = lambda arg: arg if isinstance(arg, ProfileCurve) else None

class ProfileCurves(Base):
    """A collection of profile curves within a profile loop."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProfileCurves, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ProfileCurves, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ProfileCurves *" : return _fusion.ProfileCurves___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ProfileCurves___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ProfileCurves___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.ProfileCurves___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::ProfileCurve >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.ProfileCurves___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ProfileCurves_classType
    if _newclass:classType = staticmethod(_fusion.ProfileCurves_classType)
    __swig_destroy__ = _fusion.delete_ProfileCurves
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::ProfileCurve >" :
        """
        Function that returns the specified profile curve using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ProfileCurves_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of curves in the collection."""
        return _fusion.ProfileCurves__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ProfileCurves__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ProfileCurves__get_isValid(self)
ProfileCurves_swigregister = _fusion.ProfileCurves_swigregister
ProfileCurves_swigregister(ProfileCurves)

def ProfileCurves_classType() -> "char const *" :
  return _fusion.ProfileCurves_classType()
ProfileCurves_classType = _fusion.ProfileCurves_classType

ProfileCurves.__swig_getmethods__["count"] = ProfileCurves._get_count
ProfileCurves.count = property(ProfileCurves._get_count, doc="Returns the number of curves in the collection.")

ProfileCurves.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ProfileCurves) else None
ProfileCurves.cast = lambda arg: arg if isinstance(arg, ProfileCurves) else None

class ProfileLoop(Base):
    """A loop within a profile."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProfileLoop, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ProfileLoop, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ProfileLoop *" : return _fusion.ProfileLoop___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ProfileLoop___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ProfileLoop___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ProfileLoop_classType
    if _newclass:classType = staticmethod(_fusion.ProfileLoop_classType)
    __swig_destroy__ = _fusion.delete_ProfileLoop
    __del__ = lambda self : None;
    def _get_isOuter(self) -> "bool" :
        """
        Indicates if this is an outer or inner loop. Profiles always have 
        one outer loop and have an zero to many inner loops defining voids.
        """
        return _fusion.ProfileLoop__get_isOuter(self)

    def _get_profileCurves(self) -> "adsk::core::Ptr< adsk::fusion::ProfileCurves >" :
        """Returns a collection of the curves making up this loop."""
        return _fusion.ProfileLoop__get_profileCurves(self)

    def _get_parentProfile(self) -> "adsk::core::Ptr< adsk::fusion::Profile >" :
        """Returns the parent Profile object."""
        return _fusion.ProfileLoop__get_parentProfile(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ProfileLoop__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ProfileLoop >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ProfileLoop__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::ProfileLoop >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence.
        Returns null if this isn't the NativeObject. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ProfileLoop_createForAssemblyContext(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ProfileLoop__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ProfileLoop__get_isValid(self)
ProfileLoop_swigregister = _fusion.ProfileLoop_swigregister
ProfileLoop_swigregister(ProfileLoop)

def ProfileLoop_classType() -> "char const *" :
  return _fusion.ProfileLoop_classType()
ProfileLoop_classType = _fusion.ProfileLoop_classType

ProfileLoop.__swig_getmethods__["isOuter"] = ProfileLoop._get_isOuter
ProfileLoop.isOuter = property(ProfileLoop._get_isOuter, doc="Indicates if this is an outer or inner loop. Profiles always have\none outer loop and have an zero to many inner loops defining voids.")

ProfileLoop.__swig_getmethods__["profileCurves"] = ProfileLoop._get_profileCurves
ProfileLoop.profileCurves = property(ProfileLoop._get_profileCurves, doc="Returns a collection of the curves making up this loop.")

ProfileLoop.__swig_getmethods__["parentProfile"] = ProfileLoop._get_parentProfile
ProfileLoop.parentProfile = property(ProfileLoop._get_parentProfile, doc="Returns the parent Profile object.")

ProfileLoop.__swig_getmethods__["assemblyContext"] = ProfileLoop._get_assemblyContext
ProfileLoop.assemblyContext = property(ProfileLoop._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")

ProfileLoop.__swig_getmethods__["nativeObject"] = ProfileLoop._get_nativeObject
ProfileLoop.nativeObject = property(ProfileLoop._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

ProfileLoop.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ProfileLoop) else None
ProfileLoop.cast = lambda arg: arg if isinstance(arg, ProfileLoop) else None

class ProfileLoops(Base):
    """A collection of loops within a Profile."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProfileLoops, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ProfileLoops, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ProfileLoops *" : return _fusion.ProfileLoops___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ProfileLoops___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ProfileLoops___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.ProfileLoops___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::ProfileLoop >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.ProfileLoops___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ProfileLoops_classType
    if _newclass:classType = staticmethod(_fusion.ProfileLoops_classType)
    __swig_destroy__ = _fusion.delete_ProfileLoops
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::ProfileLoop >" :
        """
        Function that returns the specified profile loop using an index into the collection. 
        index : The index of the item within the collection to return. 
        The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ProfileLoops_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of loops within this profile."""
        return _fusion.ProfileLoops__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ProfileLoops__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ProfileLoops__get_isValid(self)
ProfileLoops_swigregister = _fusion.ProfileLoops_swigregister
ProfileLoops_swigregister(ProfileLoops)

def ProfileLoops_classType() -> "char const *" :
  return _fusion.ProfileLoops_classType()
ProfileLoops_classType = _fusion.ProfileLoops_classType

ProfileLoops.__swig_getmethods__["count"] = ProfileLoops._get_count
ProfileLoops.count = property(ProfileLoops._get_count, doc="Returns the number of loops within this profile.")

ProfileLoops.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ProfileLoops) else None
ProfileLoops.cast = lambda arg: arg if isinstance(arg, ProfileLoops) else None

class Profiles(Base):
    """
    A collection of all of the closed profiles currently calculated for this sketch. Closed profiles are 
    automatically computed by Fusion 360 and represent closed areas within the sketch.
    This class also provides some additional utility functions to create open profiles and text based profiles
    that can be used as input for various features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Profiles, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Profiles, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::Profiles *" : return _fusion.Profiles___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Profiles___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Profiles___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.Profiles___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::Profile >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.Profiles___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Profiles_classType
    if _newclass:classType = staticmethod(_fusion.Profiles_classType)
    __swig_destroy__ = _fusion.delete_Profiles
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::Profile >" :
        """
        Function that returns the specified closed profile using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the 
        collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.Profiles_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of closed profiles in the sketch. Open and text based profiles are not included."""
        return _fusion.Profiles__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.Profiles__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Profiles__get_isValid(self)
Profiles_swigregister = _fusion.Profiles_swigregister
Profiles_swigregister(Profiles)

def Profiles_classType() -> "char const *" :
  return _fusion.Profiles_classType()
Profiles_classType = _fusion.Profiles_classType

Profiles.__swig_getmethods__["count"] = Profiles._get_count
Profiles.count = property(Profiles._get_count, doc="Returns the number of closed profiles in the sketch. Open and text based profiles are not included.")

Profiles.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Profiles) else None
Profiles.cast = lambda arg: arg if isinstance(arg, Profiles) else None

class RectangularPatternFeatureInput(Base):
    """
    This class defines the methods and properties that pertain to the definition of a rectangular pattern 
    feature.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RectangularPatternFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RectangularPatternFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::RectangularPatternFeatureInput *" : return _fusion.RectangularPatternFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.RectangularPatternFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.RectangularPatternFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.RectangularPatternFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.RectangularPatternFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_RectangularPatternFeatureInput
    __del__ = lambda self : None;
    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        """
        return _fusion.RectangularPatternFeatureInput__get_inputEntities(self)

    def _set_inputEntities(self, *args) -> "bool" :
        """
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        """
        return _fusion.RectangularPatternFeatureInput__set_inputEntities(self, *args)

    def setDirectionTwo(self, *args) -> "bool" :
        """
        Sets all of the input required to define the pattern in the second direction. 
        directionTwoEntity : Specifies the entity used to define the second direction entity. This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
        This argument can be null to indicate that the default second direction is to be used, which is 90 degrees to the first direction. 
        quantityTwo : Specifies the number of instances in the second direction. 
        distanceTwo : Specifies the distance in the second direction. How this value is used depends on the value of the PatternDistanceType property.
        If the value is ExtentPatternDistanceType then it defines the total distance of the pattern.
        If the value is SpacingPatternDistanceType then it defines the distance between each element. 
        Returns true if it was successful.
        """
        return _fusion.RectangularPatternFeatureInput_setDirectionTwo(self, *args)

    def _get_directionOneEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the first direction entity.
        This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
        """
        return _fusion.RectangularPatternFeatureInput__get_directionOneEntity(self)

    def _set_directionOneEntity(self, *args) -> "bool" :
        """
        Gets and sets the first direction entity.
        This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
        """
        return _fusion.RectangularPatternFeatureInput__set_directionOneEntity(self, *args)

    def _get_directionTwoEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the second direction entity.
        This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
        """
        return _fusion.RectangularPatternFeatureInput__get_directionTwoEntity(self)

    def _set_directionTwoEntity(self, *args) -> "bool" :
        """
        Gets and sets the second direction entity.
        This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
        """
        return _fusion.RectangularPatternFeatureInput__set_directionTwoEntity(self, *args)

    def _get_quantityOne(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets and sets the number of instances in the first direction."""
        return _fusion.RectangularPatternFeatureInput__get_quantityOne(self)

    def _set_quantityOne(self, *args) -> "bool" :
        """Gets and sets the number of instances in the first direction."""
        return _fusion.RectangularPatternFeatureInput__set_quantityOne(self, *args)

    def _get_quantityTwo(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets and sets the number of instances in the second direction."""
        return _fusion.RectangularPatternFeatureInput__get_quantityTwo(self)

    def _set_quantityTwo(self, *args) -> "bool" :
        """Gets and sets the number of instances in the second direction."""
        return _fusion.RectangularPatternFeatureInput__set_quantityTwo(self, *args)

    def _get_distanceOne(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets and sets the distance in the first direction."""
        return _fusion.RectangularPatternFeatureInput__get_distanceOne(self)

    def _set_distanceOne(self, *args) -> "bool" :
        """Gets and sets the distance in the first direction."""
        return _fusion.RectangularPatternFeatureInput__set_distanceOne(self, *args)

    def _get_distanceTwo(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets and sets the distance in the second direction."""
        return _fusion.RectangularPatternFeatureInput__get_distanceTwo(self)

    def _set_distanceTwo(self, *args) -> "bool" :
        """Gets and sets the distance in the second direction."""
        return _fusion.RectangularPatternFeatureInput__set_distanceTwo(self, *args)

    def _get_directionOne(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Returns a Vector3D indicating the positive direction of direction one."""
        return _fusion.RectangularPatternFeatureInput__get_directionOne(self)

    def _get_directionTwo(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Returns a Vector3D indicating the positive direction of direction two."""
        return _fusion.RectangularPatternFeatureInput__get_directionTwo(self)

    def _get_isSymmetricInDirectionOne(self) -> "bool" :
        """Gets and sets if the pattern in direction one is in one direction or symmetric."""
        return _fusion.RectangularPatternFeatureInput__get_isSymmetricInDirectionOne(self)

    def _set_isSymmetricInDirectionOne(self, *args) -> "bool" :
        """Gets and sets if the pattern in direction one is in one direction or symmetric."""
        return _fusion.RectangularPatternFeatureInput__set_isSymmetricInDirectionOne(self, *args)

    def _get_isSymmetricInDirectionTwo(self) -> "bool" :
        """Gets and sets if the pattern in direction two is in one direction or symmetric."""
        return _fusion.RectangularPatternFeatureInput__get_isSymmetricInDirectionTwo(self)

    def _set_isSymmetricInDirectionTwo(self, *args) -> "bool" :
        """Gets and sets if the pattern in direction two is in one direction or symmetric."""
        return _fusion.RectangularPatternFeatureInput__set_isSymmetricInDirectionTwo(self, *args)

    def _get_patternDistanceType(self) -> "adsk::fusion::PatternDistanceType" :
        """Gets and sets how the distance between elements is computed."""
        return _fusion.RectangularPatternFeatureInput__get_patternDistanceType(self)

    def _set_patternDistanceType(self, *args) -> "bool" :
        """Gets and sets how the distance between elements is computed."""
        return _fusion.RectangularPatternFeatureInput__set_patternDistanceType(self, *args)

    def _get_patternComputeOption(self) -> "adsk::fusion::PatternComputeOptions" :
        """
        Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        """
        return _fusion.RectangularPatternFeatureInput__get_patternComputeOption(self)

    def _set_patternComputeOption(self, *args) -> "bool" :
        """
        Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        """
        return _fusion.RectangularPatternFeatureInput__set_patternComputeOption(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.RectangularPatternFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.RectangularPatternFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.RectangularPatternFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.RectangularPatternFeatureInput__get_isValid(self)
RectangularPatternFeatureInput_swigregister = _fusion.RectangularPatternFeatureInput_swigregister
RectangularPatternFeatureInput_swigregister(RectangularPatternFeatureInput)

def RectangularPatternFeatureInput_classType() -> "char const *" :
  return _fusion.RectangularPatternFeatureInput_classType()
RectangularPatternFeatureInput_classType = _fusion.RectangularPatternFeatureInput_classType

RectangularPatternFeatureInput.__swig_getmethods__["inputEntities"] = RectangularPatternFeatureInput._get_inputEntities
RectangularPatternFeatureInput.__swig_setmethods__["inputEntities"] = RectangularPatternFeatureInput._set_inputEntities
RectangularPatternFeatureInput.inputEntities = property(RectangularPatternFeatureInput._get_inputEntities, RectangularPatternFeatureInput._set_inputEntities, doc="Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.\nAll of the entities must be of a single type. For example, it can't contain features and occurrences\nbut only features or occurrences.")

RectangularPatternFeatureInput.__swig_getmethods__["directionOneEntity"] = RectangularPatternFeatureInput._get_directionOneEntity
RectangularPatternFeatureInput.__swig_setmethods__["directionOneEntity"] = RectangularPatternFeatureInput._set_directionOneEntity
RectangularPatternFeatureInput.directionOneEntity = property(RectangularPatternFeatureInput._get_directionOneEntity, RectangularPatternFeatureInput._set_directionOneEntity, doc="Gets and sets the first direction entity.\nThis can be a linear edge, construction axis, sketch line or rectangular pattern feature.\nIf a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.")

RectangularPatternFeatureInput.__swig_getmethods__["directionTwoEntity"] = RectangularPatternFeatureInput._get_directionTwoEntity
RectangularPatternFeatureInput.__swig_setmethods__["directionTwoEntity"] = RectangularPatternFeatureInput._set_directionTwoEntity
RectangularPatternFeatureInput.directionTwoEntity = property(RectangularPatternFeatureInput._get_directionTwoEntity, RectangularPatternFeatureInput._set_directionTwoEntity, doc="Gets and sets the second direction entity.\nThis can be a linear edge, construction axis, sketch line or rectangular pattern feature.\nIf a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.")

RectangularPatternFeatureInput.__swig_getmethods__["quantityOne"] = RectangularPatternFeatureInput._get_quantityOne
RectangularPatternFeatureInput.__swig_setmethods__["quantityOne"] = RectangularPatternFeatureInput._set_quantityOne
RectangularPatternFeatureInput.quantityOne = property(RectangularPatternFeatureInput._get_quantityOne, RectangularPatternFeatureInput._set_quantityOne, doc="Gets and sets the number of instances in the first direction.")

RectangularPatternFeatureInput.__swig_getmethods__["quantityTwo"] = RectangularPatternFeatureInput._get_quantityTwo
RectangularPatternFeatureInput.__swig_setmethods__["quantityTwo"] = RectangularPatternFeatureInput._set_quantityTwo
RectangularPatternFeatureInput.quantityTwo = property(RectangularPatternFeatureInput._get_quantityTwo, RectangularPatternFeatureInput._set_quantityTwo, doc="Gets and sets the number of instances in the second direction.")

RectangularPatternFeatureInput.__swig_getmethods__["distanceOne"] = RectangularPatternFeatureInput._get_distanceOne
RectangularPatternFeatureInput.__swig_setmethods__["distanceOne"] = RectangularPatternFeatureInput._set_distanceOne
RectangularPatternFeatureInput.distanceOne = property(RectangularPatternFeatureInput._get_distanceOne, RectangularPatternFeatureInput._set_distanceOne, doc="Gets and sets the distance in the first direction.")

RectangularPatternFeatureInput.__swig_getmethods__["distanceTwo"] = RectangularPatternFeatureInput._get_distanceTwo
RectangularPatternFeatureInput.__swig_setmethods__["distanceTwo"] = RectangularPatternFeatureInput._set_distanceTwo
RectangularPatternFeatureInput.distanceTwo = property(RectangularPatternFeatureInput._get_distanceTwo, RectangularPatternFeatureInput._set_distanceTwo, doc="Gets and sets the distance in the second direction.")

RectangularPatternFeatureInput.__swig_getmethods__["directionOne"] = RectangularPatternFeatureInput._get_directionOne
RectangularPatternFeatureInput.directionOne = property(RectangularPatternFeatureInput._get_directionOne, doc="Returns a Vector3D indicating the positive direction of direction one.")

RectangularPatternFeatureInput.__swig_getmethods__["directionTwo"] = RectangularPatternFeatureInput._get_directionTwo
RectangularPatternFeatureInput.directionTwo = property(RectangularPatternFeatureInput._get_directionTwo, doc="Returns a Vector3D indicating the positive direction of direction two.")

RectangularPatternFeatureInput.__swig_getmethods__["isSymmetricInDirectionOne"] = RectangularPatternFeatureInput._get_isSymmetricInDirectionOne
RectangularPatternFeatureInput.__swig_setmethods__["isSymmetricInDirectionOne"] = RectangularPatternFeatureInput._set_isSymmetricInDirectionOne
RectangularPatternFeatureInput.isSymmetricInDirectionOne = property(RectangularPatternFeatureInput._get_isSymmetricInDirectionOne, RectangularPatternFeatureInput._set_isSymmetricInDirectionOne, doc="Gets and sets if the pattern in direction one is in one direction or symmetric.")

RectangularPatternFeatureInput.__swig_getmethods__["isSymmetricInDirectionTwo"] = RectangularPatternFeatureInput._get_isSymmetricInDirectionTwo
RectangularPatternFeatureInput.__swig_setmethods__["isSymmetricInDirectionTwo"] = RectangularPatternFeatureInput._set_isSymmetricInDirectionTwo
RectangularPatternFeatureInput.isSymmetricInDirectionTwo = property(RectangularPatternFeatureInput._get_isSymmetricInDirectionTwo, RectangularPatternFeatureInput._set_isSymmetricInDirectionTwo, doc="Gets and sets if the pattern in direction two is in one direction or symmetric.")

RectangularPatternFeatureInput.__swig_getmethods__["patternDistanceType"] = RectangularPatternFeatureInput._get_patternDistanceType
RectangularPatternFeatureInput.__swig_setmethods__["patternDistanceType"] = RectangularPatternFeatureInput._set_patternDistanceType
RectangularPatternFeatureInput.patternDistanceType = property(RectangularPatternFeatureInput._get_patternDistanceType, RectangularPatternFeatureInput._set_patternDistanceType, doc="Gets and sets how the distance between elements is computed.")

RectangularPatternFeatureInput.__swig_getmethods__["patternComputeOption"] = RectangularPatternFeatureInput._get_patternComputeOption
RectangularPatternFeatureInput.__swig_setmethods__["patternComputeOption"] = RectangularPatternFeatureInput._set_patternComputeOption
RectangularPatternFeatureInput.patternComputeOption = property(RectangularPatternFeatureInput._get_patternComputeOption, RectangularPatternFeatureInput._set_patternComputeOption, doc="Gets and sets the compute option when patterning features. The default value for this is AdjustPatternCompute.\nThis property only applies when patterning features and is ignored in the direct modeling environment.")

RectangularPatternFeatureInput.__swig_getmethods__["targetBaseFeature"] = RectangularPatternFeatureInput._get_targetBaseFeature
RectangularPatternFeatureInput.__swig_setmethods__["targetBaseFeature"] = RectangularPatternFeatureInput._set_targetBaseFeature
RectangularPatternFeatureInput.targetBaseFeature = property(RectangularPatternFeatureInput._get_targetBaseFeature, RectangularPatternFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

RectangularPatternFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RectangularPatternFeatureInput) else None
RectangularPatternFeatureInput.cast = lambda arg: arg if isinstance(arg, RectangularPatternFeatureInput) else None

class RectangularPatternFeatures(Base):
    """
    Collection that provides access to all of the existing rectangular pattern features in a component
    and supports the ability to create new rectangular pattern features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RectangularPatternFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RectangularPatternFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::RectangularPatternFeatures *" : return _fusion.RectangularPatternFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.RectangularPatternFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.RectangularPatternFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.RectangularPatternFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::RectangularPatternFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.RectangularPatternFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.RectangularPatternFeatures_classType
    if _newclass:classType = staticmethod(_fusion.RectangularPatternFeatures_classType)
    __swig_destroy__ = _fusion.delete_RectangularPatternFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::RectangularPatternFeature >" :
        """
        Function that returns the specified rectangular pattern feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.RectangularPatternFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of rectangular pattern features in the collection."""
        return _fusion.RectangularPatternFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::RectangularPatternFeatureInput >" :
        """
        Creates a RectangularPatternFeatureInput object. Use properties and methods on this object
        to define the rectangular pattern you want to create and then use the Add method, passing in 
        the RectangularPatternFeatureInput object. 
        inputEntities : The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences. 
        directionOneEntity : Specifies the entity used to define the first direction entity. This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature. 
        quantityOne : Specifies the number of instances in the first direction. 
        distanceOne : Specifies the distance in the first direction. How this value is used depends on the value of the PatternDistanceType property. A
        negative value can be used to change the direction.
        If the value is ExtentPatternDistanceType then it defines the total distance of the pattern.
        If the value is SpacingPatternDistanceType then it defines the distance between each element. 
        patternDistanceType : Specifies how the distance between elements is computed. 
        Returns the newly created RectangularPatternFeatureInput object or null if the creation failed.
        """
        return _fusion.RectangularPatternFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::RectangularPatternFeature >" :
        """
        Creates a new rectangular pattern feature. 
        input : A RectangularPatternFeatureInput object that defines the desired rectangular pattern. Use the createInput 
        method to create a new RectangularPatternFeatureInput object and then use methods on it 
        (the RectangularPatternFeatureInput object) to define the rectangular pattern. 
        Returns the newly created RectangularPatternFeature object or null if the creation failed.
        """
        return _fusion.RectangularPatternFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::RectangularPatternFeature >" :
        """
        Function that returns the specified rectangular pattern feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.RectangularPatternFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.RectangularPatternFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.RectangularPatternFeatures__get_isValid(self)
RectangularPatternFeatures_swigregister = _fusion.RectangularPatternFeatures_swigregister
RectangularPatternFeatures_swigregister(RectangularPatternFeatures)

def RectangularPatternFeatures_classType() -> "char const *" :
  return _fusion.RectangularPatternFeatures_classType()
RectangularPatternFeatures_classType = _fusion.RectangularPatternFeatures_classType

RectangularPatternFeatures.__swig_getmethods__["count"] = RectangularPatternFeatures._get_count
RectangularPatternFeatures.count = property(RectangularPatternFeatures._get_count, doc="The number of rectangular pattern features in the collection.")

RectangularPatternFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RectangularPatternFeatures) else None
RectangularPatternFeatures.cast = lambda arg: arg if isinstance(arg, RectangularPatternFeatures) else None

class RemoveFeatures(Base):
    """
    Collection that provides access to all of the existing Remove features in a component
    and supports the ability to create new Remove features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RemoveFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RemoveFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::RemoveFeatures *" : return _fusion.RemoveFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.RemoveFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.RemoveFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.RemoveFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::RemoveFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.RemoveFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.RemoveFeatures_classType
    if _newclass:classType = staticmethod(_fusion.RemoveFeatures_classType)
    __swig_destroy__ = _fusion.delete_RemoveFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::RemoveFeature >" :
        """
        Function that returns the specified Remove feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.RemoveFeatures_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::RemoveFeature >" :
        """
        Function that returns the specified remove feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.RemoveFeatures_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of Remove features in the collection."""
        return _fusion.RemoveFeatures__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::RemoveFeature >" :
        """
        Creates a new Remove feature. 
        itemToRemove : A single body (solid or surface) or component occurrence to remove. 
        Returns the newly created RemoveFeature object or null if the creation failed.
        """
        return _fusion.RemoveFeatures_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.RemoveFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.RemoveFeatures__get_isValid(self)
RemoveFeatures_swigregister = _fusion.RemoveFeatures_swigregister
RemoveFeatures_swigregister(RemoveFeatures)

def RemoveFeatures_classType() -> "char const *" :
  return _fusion.RemoveFeatures_classType()
RemoveFeatures_classType = _fusion.RemoveFeatures_classType

RemoveFeatures.__swig_getmethods__["count"] = RemoveFeatures._get_count
RemoveFeatures.count = property(RemoveFeatures._get_count, doc="The number of Remove features in the collection.")

RemoveFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RemoveFeatures) else None
RemoveFeatures.cast = lambda arg: arg if isinstance(arg, RemoveFeatures) else None

class ReplaceFaceFeatureInput(Base):
    """This class defines the methods and properties that pertain to the definition of a replace face feature."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ReplaceFaceFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ReplaceFaceFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ReplaceFaceFeatureInput *" : return _fusion.ReplaceFaceFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ReplaceFaceFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ReplaceFaceFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ReplaceFaceFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.ReplaceFaceFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_ReplaceFaceFeatureInput
    __del__ = lambda self : None;
    def _get_sourceFaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the entities that define the source faces to perform replace.
        The collection can contain the faces from a solid and/or from features. All the faces must be on the same body.
        """
        return _fusion.ReplaceFaceFeatureInput__get_sourceFaces(self)

    def _set_sourceFaces(self, *args) -> "bool" :
        """
        Gets and sets the entities that define the source faces to perform replace.
        The collection can contain the faces from a solid and/or from features. All the faces must be on the same body.
        """
        return _fusion.ReplaceFaceFeatureInput__set_sourceFaces(self, *args)

    def _get_targetFaces(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the entities that define the target faces. The new faces must completely intersect the part.
        The collection can contain the surface faces, surface bodies and construction planes.
        """
        return _fusion.ReplaceFaceFeatureInput__get_targetFaces(self)

    def _set_targetFaces(self, *args) -> "bool" :
        """
        Gets and sets the entities that define the target faces. The new faces must completely intersect the part.
        The collection can contain the surface faces, surface bodies and construction planes.
        """
        return _fusion.ReplaceFaceFeatureInput__set_targetFaces(self, *args)

    def _get_isTangentChain(self) -> "bool" :
        """
        Gets and sets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities. It defaults to true.
        """
        return _fusion.ReplaceFaceFeatureInput__get_isTangentChain(self)

    def _set_isTangentChain(self, *args) -> "bool" :
        """
        Gets and sets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities. It defaults to true.
        """
        return _fusion.ReplaceFaceFeatureInput__set_isTangentChain(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ReplaceFaceFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ReplaceFaceFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ReplaceFaceFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ReplaceFaceFeatureInput__get_isValid(self)
ReplaceFaceFeatureInput_swigregister = _fusion.ReplaceFaceFeatureInput_swigregister
ReplaceFaceFeatureInput_swigregister(ReplaceFaceFeatureInput)

def ReplaceFaceFeatureInput_classType() -> "char const *" :
  return _fusion.ReplaceFaceFeatureInput_classType()
ReplaceFaceFeatureInput_classType = _fusion.ReplaceFaceFeatureInput_classType

ReplaceFaceFeatureInput.__swig_getmethods__["sourceFaces"] = ReplaceFaceFeatureInput._get_sourceFaces
ReplaceFaceFeatureInput.__swig_setmethods__["sourceFaces"] = ReplaceFaceFeatureInput._set_sourceFaces
ReplaceFaceFeatureInput.sourceFaces = property(ReplaceFaceFeatureInput._get_sourceFaces, ReplaceFaceFeatureInput._set_sourceFaces, doc="Gets and sets the entities that define the source faces to perform replace.\nThe collection can contain the faces from a solid and/or from features. All the faces must be on the same body.")

ReplaceFaceFeatureInput.__swig_getmethods__["targetFaces"] = ReplaceFaceFeatureInput._get_targetFaces
ReplaceFaceFeatureInput.__swig_setmethods__["targetFaces"] = ReplaceFaceFeatureInput._set_targetFaces
ReplaceFaceFeatureInput.targetFaces = property(ReplaceFaceFeatureInput._get_targetFaces, ReplaceFaceFeatureInput._set_targetFaces, doc="Gets and sets the entities that define the target faces. The new faces must completely intersect the part.\nThe collection can contain the surface faces, surface bodies and construction planes.")

ReplaceFaceFeatureInput.__swig_getmethods__["isTangentChain"] = ReplaceFaceFeatureInput._get_isTangentChain
ReplaceFaceFeatureInput.__swig_setmethods__["isTangentChain"] = ReplaceFaceFeatureInput._set_isTangentChain
ReplaceFaceFeatureInput.isTangentChain = property(ReplaceFaceFeatureInput._get_isTangentChain, ReplaceFaceFeatureInput._set_isTangentChain, doc="Gets and sets if any faces that are tangentially connected to any of\nthe input faces will also be included in setting InputEntities. It defaults to true.")

ReplaceFaceFeatureInput.__swig_getmethods__["targetBaseFeature"] = ReplaceFaceFeatureInput._get_targetBaseFeature
ReplaceFaceFeatureInput.__swig_setmethods__["targetBaseFeature"] = ReplaceFaceFeatureInput._set_targetBaseFeature
ReplaceFaceFeatureInput.targetBaseFeature = property(ReplaceFaceFeatureInput._get_targetBaseFeature, ReplaceFaceFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

ReplaceFaceFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ReplaceFaceFeatureInput) else None
ReplaceFaceFeatureInput.cast = lambda arg: arg if isinstance(arg, ReplaceFaceFeatureInput) else None

class ReplaceFaceFeatures(Base):
    """
    Collection that provides access to all of the existing replace face features in a component
    and supports the ability to create new replace face features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ReplaceFaceFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ReplaceFaceFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ReplaceFaceFeatures *" : return _fusion.ReplaceFaceFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ReplaceFaceFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ReplaceFaceFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.ReplaceFaceFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::ReplaceFaceFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.ReplaceFaceFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ReplaceFaceFeatures_classType
    if _newclass:classType = staticmethod(_fusion.ReplaceFaceFeatures_classType)
    __swig_destroy__ = _fusion.delete_ReplaceFaceFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::ReplaceFaceFeature >" :
        """
        Function that returns the specified replace face feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ReplaceFaceFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of replace face features in the collection."""
        return _fusion.ReplaceFaceFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::ReplaceFaceFeatureInput >" :
        """
        Creates a ReplaceFaceFeatureInput object. Use properties and methods on this object
        to define the replace face you want to create and then use the Add method, passing in 
        the ReplaceFaceFeatureInput object. 
        sourceFaces : Input the entities that define the source faces (the faces to be replaced).
        The collection can contain the faces from a solid and/or features. All the faces must be on the same body. 
        isTangentChain : A boolean value for setting whether or not faces that are tangentially connected to 
        the input faces (if any) will also be included. A value of true indicates that tangent
        faces will be included. 
        targetFaces : Input the entities that define the target faces. The new faces must completely intersect the part.
        The collection can contain the surface faces, surface bodies and construction planes. 
        Returns the newly created ReplaceFaceFeatureInput object or null if the creation failed.
        """
        return _fusion.ReplaceFaceFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::ReplaceFaceFeature >" :
        """
        Creates a new replace face feature. 
        input : A ReplaceFaceFeatureInput object that defines the desired replace face. Use the createInput 
        method to create a new ReplaceFaceFeatureInput object and then use methods on it 
        (the ReplaceFaceFeatureInput object) to define the replace face. 
        Returns the newly created ReplaceFaceFeature object or null if the creation failed.
        """
        return _fusion.ReplaceFaceFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::ReplaceFaceFeature >" :
        """
        Function that returns the specified replace face feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.ReplaceFaceFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ReplaceFaceFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ReplaceFaceFeatures__get_isValid(self)
ReplaceFaceFeatures_swigregister = _fusion.ReplaceFaceFeatures_swigregister
ReplaceFaceFeatures_swigregister(ReplaceFaceFeatures)

def ReplaceFaceFeatures_classType() -> "char const *" :
  return _fusion.ReplaceFaceFeatures_classType()
ReplaceFaceFeatures_classType = _fusion.ReplaceFaceFeatures_classType

ReplaceFaceFeatures.__swig_getmethods__["count"] = ReplaceFaceFeatures._get_count
ReplaceFaceFeatures.count = property(ReplaceFaceFeatures._get_count, doc="The number of replace face features in the collection.")

ReplaceFaceFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ReplaceFaceFeatures) else None
ReplaceFaceFeatures.cast = lambda arg: arg if isinstance(arg, ReplaceFaceFeatures) else None

class ReverseNormalFeatures(Base):
    """
    Collection that provides access to all of the existing Reverse Normal features in a component
    and supports the ability to create new Reverse Normal features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ReverseNormalFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ReverseNormalFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ReverseNormalFeatures *" : return _fusion.ReverseNormalFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ReverseNormalFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ReverseNormalFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.ReverseNormalFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::ReverseNormalFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.ReverseNormalFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ReverseNormalFeatures_classType
    if _newclass:classType = staticmethod(_fusion.ReverseNormalFeatures_classType)
    __swig_destroy__ = _fusion.delete_ReverseNormalFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::ReverseNormalFeature >" :
        """
        Function that returns the specified Reverse Normal feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ReverseNormalFeatures_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::ReverseNormalFeature >" :
        """
        Function that returns the specified reverse normal feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.ReverseNormalFeatures_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of Reverse Normal features in the collection."""
        return _fusion.ReverseNormalFeatures__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::ReverseNormalFeature >" :
        """
        Creates a new Reverse Normal feature. 
        surfaces : One or more surface bodies (open BRepBodies) containing the faces whose normals are to be reversed. 
        All faces of the input surface bodies get reversed. 
        Returns the newly created ReverseNormalFeature object or null if the creation failed.
        """
        return _fusion.ReverseNormalFeatures_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ReverseNormalFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ReverseNormalFeatures__get_isValid(self)
ReverseNormalFeatures_swigregister = _fusion.ReverseNormalFeatures_swigregister
ReverseNormalFeatures_swigregister(ReverseNormalFeatures)

def ReverseNormalFeatures_classType() -> "char const *" :
  return _fusion.ReverseNormalFeatures_classType()
ReverseNormalFeatures_classType = _fusion.ReverseNormalFeatures_classType

ReverseNormalFeatures.__swig_getmethods__["count"] = ReverseNormalFeatures._get_count
ReverseNormalFeatures.count = property(ReverseNormalFeatures._get_count, doc="The number of Reverse Normal features in the collection.")

ReverseNormalFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ReverseNormalFeatures) else None
ReverseNormalFeatures.cast = lambda arg: arg if isinstance(arg, ReverseNormalFeatures) else None

class RevolveFeatureInput(Base):
    """
    This class defines the methods and properties that pertain to the definition of a revolve 
    feature.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RevolveFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RevolveFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::RevolveFeatureInput *" : return _fusion.RevolveFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.RevolveFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.RevolveFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.RevolveFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.RevolveFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_RevolveFeatureInput
    __del__ = lambda self : None;
    def _get_profile(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the profiles or planar faces used to define the shape of the revolve.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        This property returns null in the case where the feature is non-parametric.
        To create a surface (non-solid) revolution, you can use the createOpenProfile and createBRepEdgeProfile
        methods of the Component object to create an open profile. The isSolid property of the
        RevolveFeatureInput property must also be False.
        """
        return _fusion.RevolveFeatureInput__get_profile(self)

    def _set_profile(self, *args) -> "bool" :
        """
        Gets and sets the profiles or planar faces used to define the shape of the revolve.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        This property returns null in the case where the feature is non-parametric.
        To create a surface (non-solid) revolution, you can use the createOpenProfile and createBRepEdgeProfile
        methods of the Component object to create an open profile. The isSolid property of the
        RevolveFeatureInput property must also be False.
        """
        return _fusion.RevolveFeatureInput__set_profile(self, *args)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """Gets and sets the type of operation performed by the revolve."""
        return _fusion.RevolveFeatureInput__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """Gets and sets the type of operation performed by the revolve."""
        return _fusion.RevolveFeatureInput__set_operation(self, *args)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the entity used to define the axis of revolution.
        The axis can be a sketch line, construction axis, or linear edge. If it is not in
        the same plane as the profile, it is projected onto the profile plane.
        """
        return _fusion.RevolveFeatureInput__get_axis(self)

    def _set_axis(self, *args) -> "bool" :
        """
        Gets and sets the entity used to define the axis of revolution.
        The axis can be a sketch line, construction axis, or linear edge. If it is not in
        the same plane as the profile, it is projected onto the profile plane.
        """
        return _fusion.RevolveFeatureInput__set_axis(self, *args)

    def setAngleExtent(self, *args) -> "bool" :
        """
        Defines the extent of the revolution to be at a specified angle.
        An angle and whether the extent is symmetric or only in one direction
        is specified. If it's not symmetric a positive or negative angle can be
        used to control the direction. If symmetric, the angle is the angle on one
        side so the entire angle of the revolution will be twice the specified angle. 
        Use an angle of 360 deg or 2 pi radians to create a full revolve. 
        isSymmetric : Set to 'true' for a revolve symmetrical about the profile plane 
        angle : The ValueInput object that defines the angle of the revolution 
        Returns true if successful
        """
        return _fusion.RevolveFeatureInput_setAngleExtent(self, *args)

    def setTwoSideAngleExtent(self, *args) -> "bool" :
        """
        Defines the angle of the revolve to be to applied to both sides of the profile 
        at the specified angles. 
        angleOne : The ValueInput object that defines the angle for the first side of the revolution 
        angleTwo : The ValueInput object that defines the angle for the second side of the revolution 
        Returns true if successful
        """
        return _fusion.RevolveFeatureInput_setTwoSideAngleExtent(self, *args)

    def setOneSideToExtent(self, *args) -> "bool" :
        """
        Defines the extent of the revolve to be from the sketch or profile plane to the 
        specified 'To' face. 
        toEntity : The entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For a revolve it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        directionHint : Specifies the direction of the revolve. 
        Returns true if successful.
        """
        return _fusion.RevolveFeatureInput_setOneSideToExtent(self, *args)

    def setTwoSideToExtent(self, *args) -> "bool" :
        """
        Defines the extents of the revolve to be from the sketch plane to specified 
        faces in both directions. If the matchShape argument is true, the faces to revolve to
        are extended to fully intersect the revolve. 
        toEntityOne : The first entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For a revolve it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        toEntityTwo : The second entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For a revolve it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        Returns true if successful.
        """
        return _fusion.RevolveFeatureInput_setTwoSideToExtent(self, *args)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Revolve is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the Revolve) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.RevolveFeatureInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, *args) -> "bool" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the Revolve is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the Revolve) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.RevolveFeatureInput__set_creationOccurrence(self, *args)

    def _get_isSolid(self) -> "bool" :
        """
        Specifies if the revolution should be created as a solid or surface. If
        it's a surface then there aren't any end caps and it's open. This is
        initialized to true so a solid will be created if it's not changed.
        """
        return _fusion.RevolveFeatureInput__get_isSolid(self)

    def _set_isSolid(self, *args) -> "bool" :
        """
        Specifies if the revolution should be created as a solid or surface. If
        it's a surface then there aren't any end caps and it's open. This is
        initialized to true so a solid will be created if it's not changed.
        """
        return _fusion.RevolveFeatureInput__set_isSolid(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.RevolveFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.RevolveFeatureInput__set_targetBaseFeature(self, *args)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >" :
        """
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        feature will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.RevolveFeatureInput__get_participantBodies(self)

    def _set_participantBodies(self, *args) -> "bool" :
        """
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        feature will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.RevolveFeatureInput__set_participantBodies(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.RevolveFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.RevolveFeatureInput__get_isValid(self)
RevolveFeatureInput_swigregister = _fusion.RevolveFeatureInput_swigregister
RevolveFeatureInput_swigregister(RevolveFeatureInput)

def RevolveFeatureInput_classType() -> "char const *" :
  return _fusion.RevolveFeatureInput_classType()
RevolveFeatureInput_classType = _fusion.RevolveFeatureInput_classType

RevolveFeatureInput.__swig_getmethods__["profile"] = RevolveFeatureInput._get_profile
RevolveFeatureInput.__swig_setmethods__["profile"] = RevolveFeatureInput._set_profile
RevolveFeatureInput.profile = property(RevolveFeatureInput._get_profile, RevolveFeatureInput._set_profile, doc="Gets and sets the profiles or planar faces used to define the shape of the revolve.\nThis property can return or be set with a single Profile, a single planar face, or\nan ObjectCollection consisting of multiple profiles and planar faces. When an\nObjectCollection is used all of the profiles and faces must be co-planar.\nThis property returns null in the case where the feature is non-parametric.\nTo create a surface (non-solid) revolution, you can use the createOpenProfile and createBRepEdgeProfile\nmethods of the Component object to create an open profile. The isSolid property of the\nRevolveFeatureInput property must also be False.")

RevolveFeatureInput.__swig_getmethods__["operation"] = RevolveFeatureInput._get_operation
RevolveFeatureInput.__swig_setmethods__["operation"] = RevolveFeatureInput._set_operation
RevolveFeatureInput.operation = property(RevolveFeatureInput._get_operation, RevolveFeatureInput._set_operation, doc="Gets and sets the type of operation performed by the revolve.")

RevolveFeatureInput.__swig_getmethods__["axis"] = RevolveFeatureInput._get_axis
RevolveFeatureInput.__swig_setmethods__["axis"] = RevolveFeatureInput._set_axis
RevolveFeatureInput.axis = property(RevolveFeatureInput._get_axis, RevolveFeatureInput._set_axis, doc="Gets and sets the entity used to define the axis of revolution.\nThe axis can be a sketch line, construction axis, or linear edge. If it is not in\nthe same plane as the profile, it is projected onto the profile plane.")

RevolveFeatureInput.__swig_getmethods__["creationOccurrence"] = RevolveFeatureInput._get_creationOccurrence
RevolveFeatureInput.__swig_setmethods__["creationOccurrence"] = RevolveFeatureInput._set_creationOccurrence
RevolveFeatureInput.creationOccurrence = property(RevolveFeatureInput._get_creationOccurrence, RevolveFeatureInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the Revolve is created based on geometry (e.g. a profile and/or face(s))\nin another component AND (the Revolve) is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI")

RevolveFeatureInput.__swig_getmethods__["isSolid"] = RevolveFeatureInput._get_isSolid
RevolveFeatureInput.__swig_setmethods__["isSolid"] = RevolveFeatureInput._set_isSolid
RevolveFeatureInput.isSolid = property(RevolveFeatureInput._get_isSolid, RevolveFeatureInput._set_isSolid, doc="Specifies if the revolution should be created as a solid or surface. If\nit's a surface then there aren't any end caps and it's open. This is\ninitialized to true so a solid will be created if it's not changed.")

RevolveFeatureInput.__swig_getmethods__["targetBaseFeature"] = RevolveFeatureInput._get_targetBaseFeature
RevolveFeatureInput.__swig_setmethods__["targetBaseFeature"] = RevolveFeatureInput._set_targetBaseFeature
RevolveFeatureInput.targetBaseFeature = property(RevolveFeatureInput._get_targetBaseFeature, RevolveFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

RevolveFeatureInput.__swig_getmethods__["participantBodies"] = RevolveFeatureInput._get_participantBodies
RevolveFeatureInput.__swig_setmethods__["participantBodies"] = RevolveFeatureInput._set_participantBodies
RevolveFeatureInput.participantBodies = property(RevolveFeatureInput._get_participantBodies, RevolveFeatureInput._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.\nIf this property has not been set, the default behavior is that all bodies that are intersected by the\nfeature will participate.\nThis property can return null in the case where the feature has not been fully defined so that\npossible intersecting bodies can be computed.")

RevolveFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RevolveFeatureInput) else None
RevolveFeatureInput.cast = lambda arg: arg if isinstance(arg, RevolveFeatureInput) else None

class RevolveFeatures(Base):
    """
    Collection that provides access to all of the existing revolve features in a design
    and supports the ability to create new revolve features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RevolveFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RevolveFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::RevolveFeatures *" : return _fusion.RevolveFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.RevolveFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.RevolveFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.RevolveFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::RevolveFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.RevolveFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.RevolveFeatures_classType
    if _newclass:classType = staticmethod(_fusion.RevolveFeatures_classType)
    __swig_destroy__ = _fusion.delete_RevolveFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::RevolveFeature >" :
        """
        Function that returns the specified revolve feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.RevolveFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of revolve features in the collection."""
        return _fusion.RevolveFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::RevolveFeatureInput >" :
        """
        Creates a new RevolveFeatureInput object that is used to specify the input needed
        to create a new revolve feature. 
        profile : The profile argument can be a single Profile, a single
        planar face, or an ObjectCollection consisting of multiple profiles and planar faces.
        When an ObjectCollection is used all of the profiles and faces must be co-planar.
        To create a surface (non-solid) revolution, you can use the createOpenProfile and createBRepEdgeProfile
        methods of the Component object to create an open profile. You also need to set the isSolid property
        of the returned RevolveFeatureInput property to False. 
        axis : The axis can be a sketch line, construction axis, or linear edge. If it is not in
        the same plane as the profile, it is projected onto the profile plane. 
        operation : The operation type to perform. 
        Returns the newly created RevolveFeatureInput object or null if the creation failed.
        """
        return _fusion.RevolveFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::RevolveFeature >" :
        """
        Creates a new revolve feature based on the information provided by the provided 
        RevolveFeatureInput object.
        To create a new revolve, use the createInput function to create a new input object 
        and then use the methods and properties on that object to define the required input 
        for a revolve. Once the information is defined on the input object you can pass it 
        to the Add method to create the revolve. 
        input : The RevolveFeatureInput object that specifies the input needed to create a new extrude 
        Returns the newly created RevolveFeature or null if the creation failed.
        """
        return _fusion.RevolveFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::RevolveFeature >" :
        """
        Function that returns the specified revolve feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.RevolveFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.RevolveFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.RevolveFeatures__get_isValid(self)
RevolveFeatures_swigregister = _fusion.RevolveFeatures_swigregister
RevolveFeatures_swigregister(RevolveFeatures)

def RevolveFeatures_classType() -> "char const *" :
  return _fusion.RevolveFeatures_classType()
RevolveFeatures_classType = _fusion.RevolveFeatures_classType

RevolveFeatures.__swig_getmethods__["count"] = RevolveFeatures._get_count
RevolveFeatures.count = property(RevolveFeatures._get_count, doc="The number of revolve features in the collection.")

RevolveFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RevolveFeatures) else None
RevolveFeatures.cast = lambda arg: arg if isinstance(arg, RevolveFeatures) else None

class RibFeatures(Base):
    """Collection that provides access to all of the existing rib features in a design."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RibFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RibFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::RibFeatures *" : return _fusion.RibFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.RibFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.RibFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.RibFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::RibFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.RibFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.RibFeatures_classType
    if _newclass:classType = staticmethod(_fusion.RibFeatures_classType)
    __swig_destroy__ = _fusion.delete_RibFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::RibFeature >" :
        """
        Function that returns the specified Rib feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.RibFeatures_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::RibFeature >" :
        """
        Function that returns the specified Rib feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.RibFeatures_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of Rib features in the collection."""
        return _fusion.RibFeatures__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.RibFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.RibFeatures__get_isValid(self)
RibFeatures_swigregister = _fusion.RibFeatures_swigregister
RibFeatures_swigregister(RibFeatures)

def RibFeatures_classType() -> "char const *" :
  return _fusion.RibFeatures_classType()
RibFeatures_classType = _fusion.RibFeatures_classType

RibFeatures.__swig_getmethods__["count"] = RibFeatures._get_count
RibFeatures.count = property(RibFeatures._get_count, doc="The number of Rib features in the collection.")

RibFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RibFeatures) else None
RibFeatures.cast = lambda arg: arg if isinstance(arg, RibFeatures) else None

class RigidGroup(Base):
    """Represents a rigid group within an assembly."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RigidGroup, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RigidGroup, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::RigidGroup *" : return _fusion.RigidGroup___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.RigidGroup___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.RigidGroup___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.RigidGroup_classType
    if _newclass:classType = staticmethod(_fusion.RigidGroup_classType)
    __swig_destroy__ = _fusion.delete_RigidGroup
    __del__ = lambda self : None;
    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this rigid group."""
        return _fusion.RigidGroup__get_parentComponent(self)

    def _get_name(self) -> "std::string" :
        """Gets and sets the name of the rigid group as seen in the timeline."""
        return _fusion.RigidGroup__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Gets and sets the name of the rigid group as seen in the timeline."""
        return _fusion.RigidGroup__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this rigid group. 
        Returns True if the delete was successful.
        """
        return _fusion.RigidGroup_deleteMe(self)

    def _get_occurrences(self) -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >" :
        """Returns the list of occurrences that are part of the rigid group."""
        return _fusion.RigidGroup__get_occurrences(self)

    def setOccurrences(self, *args) -> "bool" :
        """
        Sets which occurrences are to be part of this rigid group. 
        occurrences : An ObjectCollection containing the occurrences to use in creating the rigid group. 
        includeChildren : Boolean indicating if the children of the input occurrences should be included in the rigid group. 
        Returns true if successful.
        """
        return _fusion.RigidGroup_setOccurrences(self, *args)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this rigid group."""
        return _fusion.RigidGroup__get_timelineObject(self)

    def _get_isSuppressed(self) -> "bool" :
        """Gets and sets if this rigid group is suppressed."""
        return _fusion.RigidGroup__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """Gets and sets if this rigid group is suppressed."""
        return _fusion.RigidGroup__set_isSuppressed(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::RigidGroup >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.RigidGroup__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::RigidGroup >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.RigidGroup_createForAssemblyContext(self, *args)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.RigidGroup__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this rigid group."""
        return _fusion.RigidGroup__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.RigidGroup__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.RigidGroup__get_isValid(self)
RigidGroup_swigregister = _fusion.RigidGroup_swigregister
RigidGroup_swigregister(RigidGroup)

def RigidGroup_classType() -> "char const *" :
  return _fusion.RigidGroup_classType()
RigidGroup_classType = _fusion.RigidGroup_classType

RigidGroup.__swig_getmethods__["parentComponent"] = RigidGroup._get_parentComponent
RigidGroup.parentComponent = property(RigidGroup._get_parentComponent, doc="Returns the parent component that owns this rigid group.")

RigidGroup.__swig_getmethods__["name"] = RigidGroup._get_name
RigidGroup.__swig_setmethods__["name"] = RigidGroup._set_name
RigidGroup.name = property(RigidGroup._get_name, RigidGroup._set_name, doc="Gets and sets the name of the rigid group as seen in the timeline.")

RigidGroup.__swig_getmethods__["occurrences"] = RigidGroup._get_occurrences
RigidGroup.occurrences = property(RigidGroup._get_occurrences, doc="Returns the list of occurrences that are part of the rigid group.")

RigidGroup.__swig_getmethods__["timelineObject"] = RigidGroup._get_timelineObject
RigidGroup.timelineObject = property(RigidGroup._get_timelineObject, doc="Returns the timeline object associated with this rigid group.")

RigidGroup.__swig_getmethods__["isSuppressed"] = RigidGroup._get_isSuppressed
RigidGroup.__swig_setmethods__["isSuppressed"] = RigidGroup._set_isSuppressed
RigidGroup.isSuppressed = property(RigidGroup._get_isSuppressed, RigidGroup._set_isSuppressed, doc="Gets and sets if this rigid group is suppressed.")

RigidGroup.__swig_getmethods__["nativeObject"] = RigidGroup._get_nativeObject
RigidGroup.nativeObject = property(RigidGroup._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

RigidGroup.__swig_getmethods__["assemblyContext"] = RigidGroup._get_assemblyContext
RigidGroup.assemblyContext = property(RigidGroup._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")

RigidGroup.__swig_getmethods__["attributes"] = RigidGroup._get_attributes
RigidGroup.attributes = property(RigidGroup._get_attributes, doc="Returns the collection of attributes associated with this rigid group.")

RigidGroup.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RigidGroup) else None
RigidGroup.cast = lambda arg: arg if isinstance(arg, RigidGroup) else None

class RigidGroupList(Base):
    """A list of rigid groups."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RigidGroupList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RigidGroupList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::RigidGroupList *" : return _fusion.RigidGroupList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.RigidGroupList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.RigidGroupList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.RigidGroupList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::RigidGroup >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.RigidGroupList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.RigidGroupList_classType
    if _newclass:classType = staticmethod(_fusion.RigidGroupList_classType)
    __swig_destroy__ = _fusion.delete_RigidGroupList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::RigidGroup >" :
        """
        Function that returns the specified rigid group using an index into the list. 
        index : The index of the item within the list to return. The first item in the list has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.RigidGroupList_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::RigidGroup >" :
        """
        Function that returns the specified rigid group using a name. 
        name : The name of the item within the list to return. 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.RigidGroupList_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns number of rigid groups in the list."""
        return _fusion.RigidGroupList__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.RigidGroupList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.RigidGroupList__get_isValid(self)
RigidGroupList_swigregister = _fusion.RigidGroupList_swigregister
RigidGroupList_swigregister(RigidGroupList)

def RigidGroupList_classType() -> "char const *" :
  return _fusion.RigidGroupList_classType()
RigidGroupList_classType = _fusion.RigidGroupList_classType

RigidGroupList.__swig_getmethods__["count"] = RigidGroupList._get_count
RigidGroupList.count = property(RigidGroupList._get_count, doc="Returns number of rigid groups in the list.")

RigidGroupList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RigidGroupList) else None
RigidGroupList.cast = lambda arg: arg if isinstance(arg, RigidGroupList) else None

class RigidGroups(Base):
    """
    The collection of rigid groups in this component. This provides access to all existing 
    rigid groups and supports the ability to create new rigid groups.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RigidGroups, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RigidGroups, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::RigidGroups *" : return _fusion.RigidGroups___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.RigidGroups___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.RigidGroups___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.RigidGroups___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::RigidGroup >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.RigidGroups___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.RigidGroups_classType
    if _newclass:classType = staticmethod(_fusion.RigidGroups_classType)
    __swig_destroy__ = _fusion.delete_RigidGroups
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::RigidGroup >" :
        """
        Function that returns the specified rigid group using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.RigidGroups_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::RigidGroup >" :
        """
        Function that returns the specified rigid group using a name. 
        name : The name of the item within the collection to return. 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.RigidGroups_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns number of joint origins in the collection."""
        return _fusion.RigidGroups__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::RigidGroup >" :
        """
        Creates a new rigid group. 
        occurrences : An ObjectCollection containing the occurrences to use in creating the rigid group. 
        includeChildren : Boolean indicating if the children of the input occurrences should be included in the rigid group. 
        Returns the new RigidGroup object or null in the case of failure.
        """
        return _fusion.RigidGroups_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.RigidGroups__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.RigidGroups__get_isValid(self)
RigidGroups_swigregister = _fusion.RigidGroups_swigregister
RigidGroups_swigregister(RigidGroups)

def RigidGroups_classType() -> "char const *" :
  return _fusion.RigidGroups_classType()
RigidGroups_classType = _fusion.RigidGroups_classType

RigidGroups.__swig_getmethods__["count"] = RigidGroups._get_count
RigidGroups.count = property(RigidGroups._get_count, doc="Returns number of joint origins in the collection.")

RigidGroups.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RigidGroups) else None
RigidGroups.cast = lambda arg: arg if isinstance(arg, RigidGroups) else None

class RuleFilletFeatures(Base):
    """Collection that provides access to all of the existing rule fillet features in a design."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RuleFilletFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RuleFilletFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::RuleFilletFeatures *" : return _fusion.RuleFilletFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.RuleFilletFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.RuleFilletFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.RuleFilletFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::RuleFilletFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.RuleFilletFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.RuleFilletFeatures_classType
    if _newclass:classType = staticmethod(_fusion.RuleFilletFeatures_classType)
    __swig_destroy__ = _fusion.delete_RuleFilletFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::RuleFilletFeature >" :
        """
        Function that returns the specified rule fillet feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.RuleFilletFeatures_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::RuleFilletFeature >" :
        """
        Function that returns the specified rule fillet feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.RuleFilletFeatures_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of rule fillet features in the collection."""
        return _fusion.RuleFilletFeatures__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.RuleFilletFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.RuleFilletFeatures__get_isValid(self)
RuleFilletFeatures_swigregister = _fusion.RuleFilletFeatures_swigregister
RuleFilletFeatures_swigregister(RuleFilletFeatures)

def RuleFilletFeatures_classType() -> "char const *" :
  return _fusion.RuleFilletFeatures_classType()
RuleFilletFeatures_classType = _fusion.RuleFilletFeatures_classType

RuleFilletFeatures.__swig_getmethods__["count"] = RuleFilletFeatures._get_count
RuleFilletFeatures.count = property(RuleFilletFeatures._get_count, doc="The number of rule fillet features in the collection.")

RuleFilletFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RuleFilletFeatures) else None
RuleFilletFeatures.cast = lambda arg: arg if isinstance(arg, RuleFilletFeatures) else None

class ScaleFeatureInput(Base):
    """
    This class defines the methods and properties that pertain to the definition of a scale 
    feature.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScaleFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScaleFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ScaleFeatureInput *" : return _fusion.ScaleFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ScaleFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ScaleFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ScaleFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.ScaleFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_ScaleFeatureInput
    __del__ = lambda self : None;
    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the input entities.
        This collection can contain sketches, BRep bodies and T-Spline bodies in parametric modeling.
        It can contain sketches, BRep bodies, T-Spline bodies, mesh bodies, root component and occurrences in non-parametric modeling.
        If the scaling is non-uniform (the isUniform property is false), this collection cannot contain sketches or components.
        """
        return _fusion.ScaleFeatureInput__get_inputEntities(self)

    def _set_inputEntities(self, *args) -> "bool" :
        """
        Gets and sets the input entities.
        This collection can contain sketches, BRep bodies and T-Spline bodies in parametric modeling.
        It can contain sketches, BRep bodies, T-Spline bodies, mesh bodies, root component and occurrences in non-parametric modeling.
        If the scaling is non-uniform (the isUniform property is false), this collection cannot contain sketches or components.
        """
        return _fusion.ScaleFeatureInput__set_inputEntities(self, *args)

    def _get_point(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets and sets the origin point of the scale. This can be a BRepVertex, a SketchPoint or a ConstructionPoint."""
        return _fusion.ScaleFeatureInput__get_point(self)

    def _set_point(self, *args) -> "bool" :
        """Gets and sets the origin point of the scale. This can be a BRepVertex, a SketchPoint or a ConstructionPoint."""
        return _fusion.ScaleFeatureInput__set_point(self, *args)

    def _get_scaleFactor(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Gets and sets the scale factor used for a uniform scale.
        Setting this value will cause the isUniform property to be set to true.
        """
        return _fusion.ScaleFeatureInput__get_scaleFactor(self)

    def _set_scaleFactor(self, *args) -> "bool" :
        """
        Gets and sets the scale factor used for a uniform scale.
        Setting this value will cause the isUniform property to be set to true.
        """
        return _fusion.ScaleFeatureInput__set_scaleFactor(self, *args)

    def _get_isUniform(self) -> "bool" :
        """Gets if the scale is uniform."""
        return _fusion.ScaleFeatureInput__get_isUniform(self)

    def setToNonUniform(self, *args) -> "bool" :
        """
        Sets the scale factor for the x, y, z directions to define a non-uniform scale.
        Calling this method will cause the isUniform property to be set to false.
        This will fail if the inputEntities collection contains sketches or components. 
        xScale : A ValueInput object that defines the scale in the X direction. 
        yScale : A ValueInput object that defines the scale in the Y direction. 
        zScale : A ValueInput object that defines the scale in the Z direction. 
        Returns true if successful.
        """
        return _fusion.ScaleFeatureInput_setToNonUniform(self, *args)

    def _get_xScale(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets the scale in X direction."""
        return _fusion.ScaleFeatureInput__get_xScale(self)

    def _get_yScale(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets the scale in Y direction."""
        return _fusion.ScaleFeatureInput__get_yScale(self)

    def _get_zScale(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets the scale in Z direction."""
        return _fusion.ScaleFeatureInput__get_zScale(self)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ScaleFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ScaleFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ScaleFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ScaleFeatureInput__get_isValid(self)
ScaleFeatureInput_swigregister = _fusion.ScaleFeatureInput_swigregister
ScaleFeatureInput_swigregister(ScaleFeatureInput)

def ScaleFeatureInput_classType() -> "char const *" :
  return _fusion.ScaleFeatureInput_classType()
ScaleFeatureInput_classType = _fusion.ScaleFeatureInput_classType

ScaleFeatureInput.__swig_getmethods__["inputEntities"] = ScaleFeatureInput._get_inputEntities
ScaleFeatureInput.__swig_setmethods__["inputEntities"] = ScaleFeatureInput._set_inputEntities
ScaleFeatureInput.inputEntities = property(ScaleFeatureInput._get_inputEntities, ScaleFeatureInput._set_inputEntities, doc="Gets and sets the input entities.\nThis collection can contain sketches, BRep bodies and T-Spline bodies in parametric modeling.\nIt can contain sketches, BRep bodies, T-Spline bodies, mesh bodies, root component and occurrences in non-parametric modeling.\nIf the scaling is non-uniform (the isUniform property is false), this collection cannot contain sketches or components.")

ScaleFeatureInput.__swig_getmethods__["point"] = ScaleFeatureInput._get_point
ScaleFeatureInput.__swig_setmethods__["point"] = ScaleFeatureInput._set_point
ScaleFeatureInput.point = property(ScaleFeatureInput._get_point, ScaleFeatureInput._set_point, doc="Gets and sets the origin point of the scale. This can be a BRepVertex, a SketchPoint or a ConstructionPoint.")

ScaleFeatureInput.__swig_getmethods__["scaleFactor"] = ScaleFeatureInput._get_scaleFactor
ScaleFeatureInput.__swig_setmethods__["scaleFactor"] = ScaleFeatureInput._set_scaleFactor
ScaleFeatureInput.scaleFactor = property(ScaleFeatureInput._get_scaleFactor, ScaleFeatureInput._set_scaleFactor, doc="Gets and sets the scale factor used for a uniform scale.\nSetting this value will cause the isUniform property to be set to true.")

ScaleFeatureInput.__swig_getmethods__["isUniform"] = ScaleFeatureInput._get_isUniform
ScaleFeatureInput.isUniform = property(ScaleFeatureInput._get_isUniform, doc="Gets if the scale is uniform.")

ScaleFeatureInput.__swig_getmethods__["xScale"] = ScaleFeatureInput._get_xScale
ScaleFeatureInput.xScale = property(ScaleFeatureInput._get_xScale, doc="Gets the scale in X direction.")

ScaleFeatureInput.__swig_getmethods__["yScale"] = ScaleFeatureInput._get_yScale
ScaleFeatureInput.yScale = property(ScaleFeatureInput._get_yScale, doc="Gets the scale in Y direction.")

ScaleFeatureInput.__swig_getmethods__["zScale"] = ScaleFeatureInput._get_zScale
ScaleFeatureInput.zScale = property(ScaleFeatureInput._get_zScale, doc="Gets the scale in Z direction.")

ScaleFeatureInput.__swig_getmethods__["targetBaseFeature"] = ScaleFeatureInput._get_targetBaseFeature
ScaleFeatureInput.__swig_setmethods__["targetBaseFeature"] = ScaleFeatureInput._set_targetBaseFeature
ScaleFeatureInput.targetBaseFeature = property(ScaleFeatureInput._get_targetBaseFeature, ScaleFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

ScaleFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ScaleFeatureInput) else None
ScaleFeatureInput.cast = lambda arg: arg if isinstance(arg, ScaleFeatureInput) else None

class ScaleFeatures(Base):
    """
    Collection that provides access to all of the existing scale features in a component
    and supports the ability to create new scale features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScaleFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScaleFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ScaleFeatures *" : return _fusion.ScaleFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ScaleFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ScaleFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.ScaleFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::ScaleFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.ScaleFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ScaleFeatures_classType
    if _newclass:classType = staticmethod(_fusion.ScaleFeatures_classType)
    __swig_destroy__ = _fusion.delete_ScaleFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::ScaleFeature >" :
        """
        Function that returns the specified scale feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ScaleFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of scale features in the collection."""
        return _fusion.ScaleFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::ScaleFeatureInput >" :
        """
        Creates a ScaleFeatureInput object. Use properties and methods on this object
        to define the scale you want to create and then use the Add method, passing in 
        the ScaleFeatureInput object. 
        inputEntities : This collection can contain sketches, BRep bodies and T-Spline bodies in parametric modeling.
        It can contain sketches, BRep bodies, T-Spline bodies, mesh bodies, root component and occurrences in non-parametric modeling. 
        point : Input a point as reference to scale. This can be a BRepVertex, a SketchPoint or a ConstructionPoint. 
        scaleFactor : The ValueInput object that defines the scale factor for uniform scale. 
        Returns the newly created ScaleFeatureInput object or null if the creation failed.
        """
        return _fusion.ScaleFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::ScaleFeature >" :
        """
        Creates a new scale feature. 
        input : A ScaleFeatureInput object that defines the desired scale. Use the createInput 
        method to create a new ScaleFeatureInput object and then use methods on it 
        (the ScaleFeatureInput object) to define the scale. 
        Returns the newly created ScaleFeature object or null if the creation failed.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ScaleFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::ScaleFeature >" :
        """
        Function that returns the specified scale feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.ScaleFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ScaleFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ScaleFeatures__get_isValid(self)
ScaleFeatures_swigregister = _fusion.ScaleFeatures_swigregister
ScaleFeatures_swigregister(ScaleFeatures)

def ScaleFeatures_classType() -> "char const *" :
  return _fusion.ScaleFeatures_classType()
ScaleFeatures_classType = _fusion.ScaleFeatures_classType

ScaleFeatures.__swig_getmethods__["count"] = ScaleFeatures._get_count
ScaleFeatures.count = property(ScaleFeatures._get_count, doc="The number of scale features in the collection.")

ScaleFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ScaleFeatures) else None
ScaleFeatures.cast = lambda arg: arg if isinstance(arg, ScaleFeatures) else None

class ShellFeatureInput(Base):
    """
    This class defines the methods and properties that pertain to the definition of a shell 
    feature.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShellFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShellFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ShellFeatureInput *" : return _fusion.ShellFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ShellFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ShellFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ShellFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.ShellFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_ShellFeatureInput
    __del__ = lambda self : None;
    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the input faces/bodies.
        If IsTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.
        Fails if any faces are input, and the owning bodies of the faces are also input.
        """
        return _fusion.ShellFeatureInput__get_inputEntities(self)

    def _set_inputEntities(self, *args) -> "bool" :
        """
        Gets and sets the input faces/bodies.
        If IsTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.
        Fails if any faces are input, and the owning bodies of the faces are also input.
        """
        return _fusion.ShellFeatureInput__set_inputEntities(self, *args)

    def _get_isTangentChain(self) -> "bool" :
        """
        Gets and sets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities. It defaults to true.
        """
        return _fusion.ShellFeatureInput__get_isTangentChain(self)

    def _set_isTangentChain(self, *args) -> "bool" :
        """
        Gets and sets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities. It defaults to true.
        """
        return _fusion.ShellFeatureInput__set_isTangentChain(self, *args)

    def _get_insideThickness(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets and sets the inside thickness."""
        return _fusion.ShellFeatureInput__get_insideThickness(self)

    def _set_insideThickness(self, *args) -> "bool" :
        """Gets and sets the inside thickness."""
        return _fusion.ShellFeatureInput__set_insideThickness(self, *args)

    def _get_outsideThickness(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets and sets the outside thickness."""
        return _fusion.ShellFeatureInput__get_outsideThickness(self)

    def _set_outsideThickness(self, *args) -> "bool" :
        """Gets and sets the outside thickness."""
        return _fusion.ShellFeatureInput__set_outsideThickness(self, *args)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the shell is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the shell) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ShellFeatureInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, *args) -> "bool" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the shell is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the shell) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.ShellFeatureInput__set_creationOccurrence(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ShellFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ShellFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ShellFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ShellFeatureInput__get_isValid(self)
ShellFeatureInput_swigregister = _fusion.ShellFeatureInput_swigregister
ShellFeatureInput_swigregister(ShellFeatureInput)

def ShellFeatureInput_classType() -> "char const *" :
  return _fusion.ShellFeatureInput_classType()
ShellFeatureInput_classType = _fusion.ShellFeatureInput_classType

ShellFeatureInput.__swig_getmethods__["inputEntities"] = ShellFeatureInput._get_inputEntities
ShellFeatureInput.__swig_setmethods__["inputEntities"] = ShellFeatureInput._set_inputEntities
ShellFeatureInput.inputEntities = property(ShellFeatureInput._get_inputEntities, ShellFeatureInput._set_inputEntities, doc="Gets and sets the input faces/bodies.\nIf IsTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.\nFails if any faces are input, and the owning bodies of the faces are also input.")

ShellFeatureInput.__swig_getmethods__["isTangentChain"] = ShellFeatureInput._get_isTangentChain
ShellFeatureInput.__swig_setmethods__["isTangentChain"] = ShellFeatureInput._set_isTangentChain
ShellFeatureInput.isTangentChain = property(ShellFeatureInput._get_isTangentChain, ShellFeatureInput._set_isTangentChain, doc="Gets and sets if any faces that are tangentially connected to any of\nthe input faces will also be included in setting InputEntities. It defaults to true.")

ShellFeatureInput.__swig_getmethods__["insideThickness"] = ShellFeatureInput._get_insideThickness
ShellFeatureInput.__swig_setmethods__["insideThickness"] = ShellFeatureInput._set_insideThickness
ShellFeatureInput.insideThickness = property(ShellFeatureInput._get_insideThickness, ShellFeatureInput._set_insideThickness, doc="Gets and sets the inside thickness.")

ShellFeatureInput.__swig_getmethods__["outsideThickness"] = ShellFeatureInput._get_outsideThickness
ShellFeatureInput.__swig_setmethods__["outsideThickness"] = ShellFeatureInput._set_outsideThickness
ShellFeatureInput.outsideThickness = property(ShellFeatureInput._get_outsideThickness, ShellFeatureInput._set_outsideThickness, doc="Gets and sets the outside thickness.")

ShellFeatureInput.__swig_getmethods__["creationOccurrence"] = ShellFeatureInput._get_creationOccurrence
ShellFeatureInput.__swig_setmethods__["creationOccurrence"] = ShellFeatureInput._set_creationOccurrence
ShellFeatureInput.creationOccurrence = property(ShellFeatureInput._get_creationOccurrence, ShellFeatureInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the shell is created based on geometry (e.g. a profile and/or face(s))\nin another component AND (the shell) is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI")

ShellFeatureInput.__swig_getmethods__["targetBaseFeature"] = ShellFeatureInput._get_targetBaseFeature
ShellFeatureInput.__swig_setmethods__["targetBaseFeature"] = ShellFeatureInput._set_targetBaseFeature
ShellFeatureInput.targetBaseFeature = property(ShellFeatureInput._get_targetBaseFeature, ShellFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

ShellFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ShellFeatureInput) else None
ShellFeatureInput.cast = lambda arg: arg if isinstance(arg, ShellFeatureInput) else None

class ShellFeatures(Base):
    """
    Collection that provides access to all of the existing shell features in a component
    and supports the ability to create new shell features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShellFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShellFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ShellFeatures *" : return _fusion.ShellFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ShellFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ShellFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.ShellFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::ShellFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.ShellFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ShellFeatures_classType
    if _newclass:classType = staticmethod(_fusion.ShellFeatures_classType)
    __swig_destroy__ = _fusion.delete_ShellFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::ShellFeature >" :
        """
        Function that returns the specified shell feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ShellFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of shell features in the collection."""
        return _fusion.ShellFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::ShellFeatureInput >" :
        """
        Creates a ShellFeatureInput object. Use properties and methods on this object
        to define the shell you want to create and then use the Add method, passing in 
        the ShellFeatureInput object. 
        inputEntities : The collection contains the faces to remove and the bodies to perform shell.
        Fails if any faces are input, and the owning bodies of the faces are also input. 
        isTangentChain : A boolean value for setting whether or not faces that are tangentially connected to 
        the input faces (if any) will also be included. It defaults to true. 
        Returns the newly created ShellFeatureInput object or null if the creation failed.
        """
        return _fusion.ShellFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::ShellFeature >" :
        """
        Creates a new shell feature. 
        input : A ShellFeatureInput object that defines the desired shell. Use the createInput 
        method to create a new ShellFeatureInput object and then use methods on it 
        (the ShellFeatureInput object) to define the shell. 
        Returns the newly created ShellFeature object or null if the creation failed.
        """
        return _fusion.ShellFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::ShellFeature >" :
        """
        Function that returns the specified shell feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.ShellFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ShellFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ShellFeatures__get_isValid(self)
ShellFeatures_swigregister = _fusion.ShellFeatures_swigregister
ShellFeatures_swigregister(ShellFeatures)

def ShellFeatures_classType() -> "char const *" :
  return _fusion.ShellFeatures_classType()
ShellFeatures_classType = _fusion.ShellFeatures_classType

ShellFeatures.__swig_getmethods__["count"] = ShellFeatures._get_count
ShellFeatures.count = property(ShellFeatures._get_count, doc="The number of shell features in the collection.")

ShellFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ShellFeatures) else None
ShellFeatures.cast = lambda arg: arg if isinstance(arg, ShellFeatures) else None

class SilhouetteSplitFeatureInput(Base):
    """This class defines the methods and properties that pertain to the definition of a silhouette split feature."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SilhouetteSplitFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SilhouetteSplitFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SilhouetteSplitFeatureInput *" : return _fusion.SilhouetteSplitFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SilhouetteSplitFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SilhouetteSplitFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SilhouetteSplitFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.SilhouetteSplitFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_SilhouetteSplitFeatureInput
    __del__ = lambda self : None;
    def _get_targetBody(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """Gets and sets the solid body to split."""
        return _fusion.SilhouetteSplitFeatureInput__get_targetBody(self)

    def _set_targetBody(self, *args) -> "bool" :
        """Gets and sets the solid body to split."""
        return _fusion.SilhouetteSplitFeatureInput__set_targetBody(self, *args)

    def _get_viewDirection(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the entity that defines the silhouette view direction, which can be a 
        construction axis, linear BRepEdge, planar BRepFace or a construction plane.
        """
        return _fusion.SilhouetteSplitFeatureInput__get_viewDirection(self)

    def _set_viewDirection(self, *args) -> "bool" :
        """
        Gets and sets the entity that defines the silhouette view direction, which can be a 
        construction axis, linear BRepEdge, planar BRepFace or a construction plane.
        """
        return _fusion.SilhouetteSplitFeatureInput__set_viewDirection(self, *args)

    def _get_operation(self) -> "adsk::fusion::SilhouetteSplitOperations" :
        """Gets and sets the type of silhouette split operation to perform."""
        return _fusion.SilhouetteSplitFeatureInput__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """Gets and sets the type of silhouette split operation to perform."""
        return _fusion.SilhouetteSplitFeatureInput__set_operation(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.SilhouetteSplitFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.SilhouetteSplitFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SilhouetteSplitFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SilhouetteSplitFeatureInput__get_isValid(self)
SilhouetteSplitFeatureInput_swigregister = _fusion.SilhouetteSplitFeatureInput_swigregister
SilhouetteSplitFeatureInput_swigregister(SilhouetteSplitFeatureInput)

def SilhouetteSplitFeatureInput_classType() -> "char const *" :
  return _fusion.SilhouetteSplitFeatureInput_classType()
SilhouetteSplitFeatureInput_classType = _fusion.SilhouetteSplitFeatureInput_classType

SilhouetteSplitFeatureInput.__swig_getmethods__["targetBody"] = SilhouetteSplitFeatureInput._get_targetBody
SilhouetteSplitFeatureInput.__swig_setmethods__["targetBody"] = SilhouetteSplitFeatureInput._set_targetBody
SilhouetteSplitFeatureInput.targetBody = property(SilhouetteSplitFeatureInput._get_targetBody, SilhouetteSplitFeatureInput._set_targetBody, doc="Gets and sets the solid body to split.")

SilhouetteSplitFeatureInput.__swig_getmethods__["viewDirection"] = SilhouetteSplitFeatureInput._get_viewDirection
SilhouetteSplitFeatureInput.__swig_setmethods__["viewDirection"] = SilhouetteSplitFeatureInput._set_viewDirection
SilhouetteSplitFeatureInput.viewDirection = property(SilhouetteSplitFeatureInput._get_viewDirection, SilhouetteSplitFeatureInput._set_viewDirection, doc="Gets and sets the entity that defines the silhouette view direction, which can be a\nconstruction axis, linear BRepEdge, planar BRepFace or a construction plane.")

SilhouetteSplitFeatureInput.__swig_getmethods__["operation"] = SilhouetteSplitFeatureInput._get_operation
SilhouetteSplitFeatureInput.__swig_setmethods__["operation"] = SilhouetteSplitFeatureInput._set_operation
SilhouetteSplitFeatureInput.operation = property(SilhouetteSplitFeatureInput._get_operation, SilhouetteSplitFeatureInput._set_operation, doc="Gets and sets the type of silhouette split operation to perform.")

SilhouetteSplitFeatureInput.__swig_getmethods__["targetBaseFeature"] = SilhouetteSplitFeatureInput._get_targetBaseFeature
SilhouetteSplitFeatureInput.__swig_setmethods__["targetBaseFeature"] = SilhouetteSplitFeatureInput._set_targetBaseFeature
SilhouetteSplitFeatureInput.targetBaseFeature = property(SilhouetteSplitFeatureInput._get_targetBaseFeature, SilhouetteSplitFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

SilhouetteSplitFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SilhouetteSplitFeatureInput) else None
SilhouetteSplitFeatureInput.cast = lambda arg: arg if isinstance(arg, SilhouetteSplitFeatureInput) else None

class SilhouetteSplitFeatures(Base):
    """
    Collection that provides access to all of the existing Silhouette Split features in a component
    and supports the ability to create new Silhouette Split features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SilhouetteSplitFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SilhouetteSplitFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SilhouetteSplitFeatures *" : return _fusion.SilhouetteSplitFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SilhouetteSplitFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SilhouetteSplitFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SilhouetteSplitFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SilhouetteSplitFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SilhouetteSplitFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SilhouetteSplitFeatures_classType
    if _newclass:classType = staticmethod(_fusion.SilhouetteSplitFeatures_classType)
    __swig_destroy__ = _fusion.delete_SilhouetteSplitFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SilhouetteSplitFeature >" :
        """
        Function that returns the specified silhouette split feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SilhouetteSplitFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of Silhouette Split features in the collection."""
        return _fusion.SilhouetteSplitFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::SilhouetteSplitFeatureInput >" :
        """
        Creates a SilhouetteSplitFeatureInput object. Use properties and methods on this object
        to define the silhouette split you want to create and then use the Add method, passing in 
        the SilhouetteSplitFeatureInput object. 
        viewDirection : A construction axis, linear BRepEdge, planar BRepFace or a construction plane that defines the view direction
        where the silhouette is calculated. 
        targetBody : Input the single solid body to split 
        operation : The type of silhouette split operation to perform. 
        Returns the newly created SilhouetteSplitFeatureInput object or null if the creation failed.
        """
        return _fusion.SilhouetteSplitFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::SilhouetteSplitFeature >" :
        """
        Creates a new silhouette split feature. 
        input : A SilhouetteSplitFeatureInput object that defines the desired silhouette split feature. Use the createInput 
        method to create a new SilhouetteSplitFeatureInput object and then use methods on it 
        (the SilhouetteSplitFeatureInput object) to define the silhouette split. 
        Returns the newly created SilhouetteSplitFeature object or null if the creation failed.
        """
        return _fusion.SilhouetteSplitFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::SilhouetteSplitFeature >" :
        """
        Function that returns the specified silhouette split feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.SilhouetteSplitFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SilhouetteSplitFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SilhouetteSplitFeatures__get_isValid(self)
SilhouetteSplitFeatures_swigregister = _fusion.SilhouetteSplitFeatures_swigregister
SilhouetteSplitFeatures_swigregister(SilhouetteSplitFeatures)

def SilhouetteSplitFeatures_classType() -> "char const *" :
  return _fusion.SilhouetteSplitFeatures_classType()
SilhouetteSplitFeatures_classType = _fusion.SilhouetteSplitFeatures_classType

SilhouetteSplitFeatures.__swig_getmethods__["count"] = SilhouetteSplitFeatures._get_count
SilhouetteSplitFeatures.count = property(SilhouetteSplitFeatures._get_count, doc="The number of Silhouette Split features in the collection.")

SilhouetteSplitFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SilhouetteSplitFeatures) else None
SilhouetteSplitFeatures.cast = lambda arg: arg if isinstance(arg, SilhouetteSplitFeatures) else None

class Sketch(Base):
    """Represents a sketch within a component."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Sketch, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Sketch, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::Sketch *" : return _fusion.Sketch___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Sketch___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Sketch___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Sketch_classType
    if _newclass:classType = staticmethod(_fusion.Sketch_classType)
    __swig_destroy__ = _fusion.delete_Sketch
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Gets and sets the name of this sketch as seen in the browser and timeline."""
        return _fusion.Sketch__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Gets and sets the name of this sketch as seen in the browser and timeline."""
        return _fusion.Sketch__set_name(self, *args)

    def _get_sketchPoints(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoints >" :
        """
        Returns the sketch points collection associated with this sketch.
        This provides access to the existing sketch points and supports
        the creation of new sketch points.
        """
        return _fusion.Sketch__get_sketchPoints(self)

    def _get_sketchCurves(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurves >" :
        """
        Returns the sketch curves collection associated with this sketch.
        This provides access to the existing sketch curves which is all
        geometry in the sketch except for sketch points. It is through this 
        collection that new sketch geometry gets created.
        """
        return _fusion.Sketch__get_sketchCurves(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensions >" :
        """
        Returns the sketch dimensions collection associated with this sketch.
        This provides access to the existing sketch dimensions and supports
        the creation of new sketch dimensions.
        """
        return _fusion.Sketch__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraints >" :
        """
        Returns the sketch constraints collection associated with this sketch.
        This provides access to the existing sketch constraints and supports
        the creation of new sketch constraints.
        """
        return _fusion.Sketch__get_geometricConstraints(self)

    def project(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Projects the specified entity onto the x-y plane of the sketch
        and returns the created sketch entity(s). 
        entity : The entity to project. This can be a sketch entity, an edge, a face to get all 
        of its edges, a vertex, a construction axis, a construction point, or a 
        construction plane that is perpendicular to the sketch to create a line. 
        Returns a collection of the sketch entities that were created as a result of the 
        projection.
        """
        return _fusion.Sketch_project(self, *args)

    def projectCutEdges(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Intersects the specified body with the sketch plane and creates new
        curves representing the intersection. 
        body : The body to be intersected by the sketch. 
        Returns a collection of the sketch entities that were created a a result of the 
        cut.
        """
        return _fusion.Sketch_projectCutEdges(self, *args)

    def include(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Creates new sketch curves and points that represent the specified entity 
        as sketch geometry. The sketch geometry is not projected but is created
        in the same location in space as the input geometry. 
        entity : The entity to include into the sketch. This can be a sketch entity from 
        another sketch, edge, face (which results in getting all of its edges, a 
        vertex, construction axis, or construction point. 
        Returns a collection of the sketch entities that were created as a result of the include.
        When including this curves it will be a single sketch curve, but for faces, multiple
        sketch curves will be created; one for each edge.
        """
        return _fusion.Sketch_include(self, *args)

    def findConnectedCurves(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Finds the sketch curves that are end connected to the input curve. This can be useful
        for many cases but is especially useful in gathering the input when creating an offset. 
        curve : The initial sketch curve that will be used to find the connected curves. 
        A collection of the connected curves. They are returned in their connected order with
        the original input curve being one of the curves.
        """
        return _fusion.Sketch_findConnectedCurves(self, *args)

    def offset(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Creates offset curves for the set of input curves. If the offset distance is not 
        provided, the offset distance is defined by the direction point. 
        curves : A set of end connected curves. The Sketch.FindConnectedCurves method is a convenient way to get 
        this set of curves. 
        directionPoint : Defines which side of the input curves to create the offset on 
        offset : The distance to offset the curves in centimeters. 
        A collection of the new offset sketch curves created
        """
        return _fusion.Sketch_offset(self, *args)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >" :
        """
        Gets and sets the transform of the sketch with respect to model space.
        This defines the transform from the parent component space
        to the sketch space. For example, if you have point coordinates in the space
        of the parent component and apply this transform it will result in the
        coordinates of the equivalent position in sketch space.
        The transform is sensitive to the assembly context.
        Setting the transform will fail in the case where the sketch is parametric
        """
        return _fusion.Sketch__get_transform(self)

    def _set_transform(self, *args) -> "bool" :
        """
        Gets and sets the transform of the sketch with respect to model space.
        This defines the transform from the parent component space
        to the sketch space. For example, if you have point coordinates in the space
        of the parent component and apply this transform it will result in the
        coordinates of the equivalent position in sketch space.
        The transform is sensitive to the assembly context.
        Setting the transform will fail in the case where the sketch is parametric
        """
        return _fusion.Sketch__set_transform(self, *args)

    def modelToSketchSpace(self, *args) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        A specified point in model space returns the equivalent point in sketch space.
        This is sensitive to the assembly context. 
        modelCoordinate : A coordinate in model space. 
        Returns the equivalent point in sketch space.
        """
        return _fusion.Sketch_modelToSketchSpace(self, *args)

    def sketchToModelSpace(self, *args) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        A specified point in sketch space returns the equivalent point in model space.
        This is sensitive to the assembly context. 
        sketchCoordinate : A coordinate in sketch space. 
        Returns the equivalent point in model space.
        """
        return _fusion.Sketch_sketchToModelSpace(self, *args)

    def _get_isParametric(self) -> "bool" :
        """
        Indicates if this sketch is parametric or not. For parametric sketches, you can also
        get the construction plane or face it is associative to using the ReferencePlane property.
        """
        return _fusion.Sketch__get_isParametric(self)

    def _get_isVisible(self) -> "bool" :
        """
        Gets if this sketch is currently visible in the graphics window. Use the
        isLightBulbOn to change if the light bulb beside the sketch node in the 
        browser is on or not. Parent nodes in the browser can have their light
        bulb off which affects all of their children. This property indicates 
        the final result and whether this body is actually visible or not.
        """
        return _fusion.Sketch__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """
        Gets if this sketch is currently visible in the graphics window. Use the
        isLightBulbOn to change if the light bulb beside the sketch node in the 
        browser is on or not. Parent nodes in the browser can have their light
        bulb off which affects all of their children. This property indicates 
        the final result and whether this body is actually visible or not.
        """
        return _fusion.Sketch__set_isVisible(self, *args)

    def _get_areDimensionsShown(self) -> "bool" :
        """
        Indicates if the dimensions of the sketch are displayed when the sketch is not active 
        (in sketch edit mode)
        """
        return _fusion.Sketch__get_areDimensionsShown(self)

    def _set_areDimensionsShown(self, *args) -> "bool" :
        """
        Indicates if the dimensions of the sketch are displayed when the sketch is not active 
        (in sketch edit mode)
        """
        return _fusion.Sketch__set_areDimensionsShown(self, *args)

    def _get_areProfilesShown(self) -> "bool" :
        """Indicates if the profiles of the sketch are displayed"""
        return _fusion.Sketch__get_areProfilesShown(self)

    def _set_areProfilesShown(self, *args) -> "bool" :
        """Indicates if the profiles of the sketch are displayed"""
        return _fusion.Sketch__set_areProfilesShown(self, *args)

    def _get_origin(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Returns the origin point of the sketch in model space."""
        return _fusion.Sketch__get_origin(self)

    def _get_xDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Returns the X direction of the sketch as defined in model space."""
        return _fusion.Sketch__get_xDirection(self)

    def _get_yDirection(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Returns the Y direction of the sketch as defined in model space."""
        return _fusion.Sketch__get_yDirection(self)

    def _get_referencePlane(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the construction plane or planar face the sketch is associated
        to. This is only valid when the IsParametric property is True otherwise this 
        returns null and setting the property will fail.
        Setting this property is the equivalent of the Redefine command.
        """
        return _fusion.Sketch__get_referencePlane(self)

    def _set_referencePlane(self, *args) -> "bool" :
        """
        Gets and sets the construction plane or planar face the sketch is associated
        to. This is only valid when the IsParametric property is True otherwise this 
        returns null and setting the property will fail.
        Setting this property is the equivalent of the Redefine command.
        """
        return _fusion.Sketch__set_referencePlane(self, *args)

    def _get_isComputeDeferred(self) -> "bool" :
        """
        Temporarily turns off the compute of the sketch. This is used to
        increase the performance as sketch geometry is created. Once the
        sketch is drawn the this property should be set to false to allow
        the sketch to recompute. This setting is not saved by the file and is 
        always false when a file is opened.
        """
        return _fusion.Sketch__get_isComputeDeferred(self)

    def _set_isComputeDeferred(self, *args) -> "bool" :
        """
        Temporarily turns off the compute of the sketch. This is used to
        increase the performance as sketch geometry is created. Once the
        sketch is drawn the this property should be set to false to allow
        the sketch to recompute. This setting is not saved by the file and is 
        always false when a file is opened.
        """
        return _fusion.Sketch__set_isComputeDeferred(self, *args)

    def move(self, *args) -> "bool" :
        """
        Moves the specified sketch entities using the specified transform.
        Transform respects any constraints that would normally prohibit the move. 
        sketchEntities : A collection of sketch entities to transform. 
        transform : The transform that defines the move, rotate or scale. 
        Returns true if the move was successful.
        """
        return _fusion.Sketch_move(self, *args)

    def copy(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Copies the specified sketch entities, applying the specified transform.
        Any geometric or dimension constraints associated with the entities will
        automatically be copied, if possible. For example, if there is a horizontal
        dimension and the transform defines a rotation then it will not be included in the
        result. This same behavior can be seen when performing a copy/paste operation
        in the user interface. 
        sketchEntities : The collection of sketch entities to copy. They must all exist in this sketch. 
        transform : The transform to apply to the copied entities. 
        targetSketch : Optionally specifies the sketch to copy the entities to. If not provided the entities are copied to this sketch. 
        Returns a collection of the new sketch entities that were created as a result of the copy.
        """
        return _fusion.Sketch_copy(self, *args)

    def _get_profiles(self) -> "adsk::core::Ptr< adsk::fusion::Profiles >" :
        """Returns the profiles currently computed for the sketch."""
        return _fusion.Sketch__get_profiles(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the sketch. 
        Returns true if the delete was successful.
        """
        return _fusion.Sketch_deleteMe(self)

    def saveAsDXF(self, *args) -> "bool" :
        """
        Saves the contents of the sketch to a specified DXF file. 
        fullFilename : The full filename, including the path, of the DXF file. 
        Returns true if the operation was successful.
        """
        return _fusion.Sketch_saveAsDXF(self, *args)

    def importSVG(self, *args) -> "bool" :
        """
        Imports the contents of an SVG file into the active sketch. 
        fullFilename : The full filename, including the path, of the SVG file. 
        xPosition : The X offset in centimeters in the sketch for the origin of the SVG data 
        relative to the sketch origin. 
        yPosition : The Y offset in centimeters in the sketch for the origin of the SVG data 
        relative to the sketch origin. 
        scale : The scale value to apply to the imported SVG data. 
        Returns true if the import was successful.
        """
        return _fusion.Sketch_importSVG(self, *args)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this sketch."""
        return _fusion.Sketch__get_timelineObject(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent Component."""
        return _fusion.Sketch__get_parentComponent(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this
        object in an assembly. This is only valid in the case where this
        is acting as a proxy in an assembly. Returns null 
        in the case where the object is not in the context of an assembly.
        but is already the native object.
        """
        return _fusion.Sketch__get_assemblyContext(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.Sketch__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.Sketch_createForAssemblyContext(self, *args)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the 3D bounding box of the sketch"""
        return _fusion.Sketch__get_boundingBox(self)

    def _get_sketchTexts(self) -> "adsk::core::Ptr< adsk::fusion::SketchTexts >" :
        """
        Returns the sketch text collection associated with this sketch.
        This provides access to existing text and supports the creation
        of new text.
        """
        return _fusion.Sketch__get_sketchTexts(self)

    def _get_originPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """
        Returns the sketch point that was automatically created by projecting the
        origin construction point into the sketch.
        """
        return _fusion.Sketch__get_originPoint(self)

    def _get_isFullyConstrained(self) -> "bool" :
        """Indicates if this sketch is fully constrained."""
        return _fusion.Sketch__get_isFullyConstrained(self)

    def redefine(self, *args) -> "bool" :
        """
        Changes which plane the sketch is based on. 
        planarEntity : A construction plane or planar face that defines the sketch plane 
        Returns true if the operation was successful.
        """
        return _fusion.Sketch_redefine(self, *args)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.Sketch__get_attributes(self)

    def _get_baseOrFormFeature(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        This property returns the base or form feature that this sketch is associated with. It returns
        null in the case wher the sketch is parametrically defined and is not related to a base or form
        feature. It also returns null in the case where the modeling design history is not being captured (direct edit model).
        """
        return _fusion.Sketch__get_baseOrFormFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of this sketch."""
        return _fusion.Sketch__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.Sketch__get_errorOrWarningMessage(self)

    def intersectWithSketchPlane(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity >,std::allocator< adsk::core::Ptr< adsk::fusion::SketchEntity > > >" :
        """
        Intersects the specified entities (BRepBody, BRepFace, BRepEdge, BRepVertex, SketchCurve, ConstructionPoint,
        ConstructionAxis, and ConstructionPlane) with the sketch plane and creates sketch geometry that represents
        the intersection. 
        entities : An array containing the entities to intersect with the sketch plane. 
        An array returning the sketch entities that were created as a result of the
        intersections. It's possible that this can come back empty in the case where the input
        entities don't intersect the sketch plane.
        """
        return _fusion.Sketch_intersectWithSketchPlane(self, *args)

    def projectToSurface(self, *args) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchEntity >,std::allocator< adsk::core::Ptr< adsk::fusion::SketchEntity > > >" :
        """
        Projects the specified set of curves onto the specified set of faces using the specified method of projection.
        if the projection type is along a vector, then the directionEntity argument must be supplied. if the projectionType
        is the closest point method, the directionEntity argument is ignored. 
        faces : An array of BRepFace objects that the curves will be projected onto. 
        curves : An array of various curve objects that will be projected onto the faces. The curves can be sketch curves and points,
        BRepEdge objects, ConstructionAxis objects, and ConstructionPoint objects. 
        projectType : Specifies which projection type to use which defines the direction of projection. If this is set to AlongVectorSurfaceProjectType
        the directionEntity argument must be provided. 
        directionEntity : if the projectType argument is AlongVectorSurfaceProjectType, this argument must be specified and defines the
        direction of projection. It can be a linear BRepEdge, a BRepFace where the normal will be used, a SketchLine, or 
        a ConstructionLine. 
        Returns an array of the sketch entities that were created as a result of projection the specified curves onto
        the faces.
        """
        return _fusion.Sketch_projectToSurface(self, *args)

    def _get_revisionId(self) -> "std::string" :
        """
        Returns the current revision ID of the sketch. This ID changes any time the sketch is modified in any way. By getting
        and saving the ID when you create any data that is dependent on the sketch, you can then compare the saved
        ID with the current ID to determine if the sketch has changed to know if you should update your data.
        """
        return _fusion.Sketch__get_revisionId(self)

    def _get_areConstraintsShown(self) -> "bool" :
        """Indicates if the constraints of the sketch are displayed when the sketch is active."""
        return _fusion.Sketch__get_areConstraintsShown(self)

    def _set_areConstraintsShown(self, *args) -> "bool" :
        """Indicates if the constraints of the sketch are displayed when the sketch is active."""
        return _fusion.Sketch__set_areConstraintsShown(self, *args)

    def _get_arePointsShown(self) -> "bool" :
        """
        Indicates if the sketch points in the sketch are displayed. Points that are not connected to any other
        geometry will continue to be shown.
        """
        return _fusion.Sketch__get_arePointsShown(self)

    def _set_arePointsShown(self, *args) -> "bool" :
        """
        Indicates if the sketch points in the sketch are displayed. Points that are not connected to any other
        geometry will continue to be shown.
        """
        return _fusion.Sketch__set_arePointsShown(self, *args)

    def _get_isLightBulbOn(self) -> "bool" :
        """
        Gets and set if the light bulb beside the sketch node in the 
        browser is on or not. Parent nodes in the browser can have their light
        bulb off which affects all of their children so this property does not
        indicate if the body is actually visible, just that it should be visible
        if all of it's parent nodes are also visible. Use the isVisible property
        to determine if it's actually visible.
        """
        return _fusion.Sketch__get_isLightBulbOn(self)

    def _set_isLightBulbOn(self, *args) -> "bool" :
        """
        Gets and set if the light bulb beside the sketch node in the 
        browser is on or not. Parent nodes in the browser can have their light
        bulb off which affects all of their children so this property does not
        indicate if the body is actually visible, just that it should be visible
        if all of it's parent nodes are also visible. Use the isVisible property
        to determine if it's actually visible.
        """
        return _fusion.Sketch__set_isLightBulbOn(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.Sketch__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Sketch__get_isValid(self)
Sketch_swigregister = _fusion.Sketch_swigregister
Sketch_swigregister(Sketch)

def Sketch_classType() -> "char const *" :
  return _fusion.Sketch_classType()
Sketch_classType = _fusion.Sketch_classType

Sketch.__swig_getmethods__["name"] = Sketch._get_name
Sketch.__swig_setmethods__["name"] = Sketch._set_name
Sketch.name = property(Sketch._get_name, Sketch._set_name, doc="Gets and sets the name of this sketch as seen in the browser and timeline.")

Sketch.__swig_getmethods__["sketchPoints"] = Sketch._get_sketchPoints
Sketch.sketchPoints = property(Sketch._get_sketchPoints, doc="Returns the sketch points collection associated with this sketch.\nThis provides access to the existing sketch points and supports\nthe creation of new sketch points.")

Sketch.__swig_getmethods__["sketchCurves"] = Sketch._get_sketchCurves
Sketch.sketchCurves = property(Sketch._get_sketchCurves, doc="Returns the sketch curves collection associated with this sketch.\nThis provides access to the existing sketch curves which is all\ngeometry in the sketch except for sketch points. It is through this\ncollection that new sketch geometry gets created.")

Sketch.__swig_getmethods__["sketchDimensions"] = Sketch._get_sketchDimensions
Sketch.sketchDimensions = property(Sketch._get_sketchDimensions, doc="Returns the sketch dimensions collection associated with this sketch.\nThis provides access to the existing sketch dimensions and supports\nthe creation of new sketch dimensions.")

Sketch.__swig_getmethods__["geometricConstraints"] = Sketch._get_geometricConstraints
Sketch.geometricConstraints = property(Sketch._get_geometricConstraints, doc="Returns the sketch constraints collection associated with this sketch.\nThis provides access to the existing sketch constraints and supports\nthe creation of new sketch constraints.")

Sketch.__swig_getmethods__["transform"] = Sketch._get_transform
Sketch.__swig_setmethods__["transform"] = Sketch._set_transform
Sketch.transform = property(Sketch._get_transform, Sketch._set_transform, doc="Gets and sets the transform of the sketch with respect to model space.\nThis defines the transform from the parent component space\nto the sketch space. For example, if you have point coordinates in the space\nof the parent component and apply this transform it will result in the\ncoordinates of the equivalent position in sketch space.\nThe transform is sensitive to the assembly context.\nSetting the transform will fail in the case where the sketch is parametric")

Sketch.__swig_getmethods__["isParametric"] = Sketch._get_isParametric
Sketch.isParametric = property(Sketch._get_isParametric, doc="Indicates if this sketch is parametric or not. For parametric sketches, you can also\nget the construction plane or face it is associative to using the ReferencePlane property.")

Sketch.__swig_getmethods__["isVisible"] = Sketch._get_isVisible
Sketch.__swig_setmethods__["isVisible"] = Sketch._set_isVisible
Sketch.isVisible = property(Sketch._get_isVisible, Sketch._set_isVisible, doc="Gets if this sketch is currently visible in the graphics window. Use the\nisLightBulbOn to change if the light bulb beside the sketch node in the\nbrowser is on or not. Parent nodes in the browser can have their light\nbulb off which affects all of their children. This property indicates\nthe final result and whether this body is actually visible or not.")

Sketch.__swig_getmethods__["areDimensionsShown"] = Sketch._get_areDimensionsShown
Sketch.__swig_setmethods__["areDimensionsShown"] = Sketch._set_areDimensionsShown
Sketch.areDimensionsShown = property(Sketch._get_areDimensionsShown, Sketch._set_areDimensionsShown, doc="Indicates if the dimensions of the sketch are displayed when the sketch is not active\n(in sketch edit mode)")

Sketch.__swig_getmethods__["areProfilesShown"] = Sketch._get_areProfilesShown
Sketch.__swig_setmethods__["areProfilesShown"] = Sketch._set_areProfilesShown
Sketch.areProfilesShown = property(Sketch._get_areProfilesShown, Sketch._set_areProfilesShown, doc="Indicates if the profiles of the sketch are displayed")

Sketch.__swig_getmethods__["origin"] = Sketch._get_origin
Sketch.origin = property(Sketch._get_origin, doc="Returns the origin point of the sketch in model space.")

Sketch.__swig_getmethods__["xDirection"] = Sketch._get_xDirection
Sketch.xDirection = property(Sketch._get_xDirection, doc="Returns the X direction of the sketch as defined in model space.")

Sketch.__swig_getmethods__["yDirection"] = Sketch._get_yDirection
Sketch.yDirection = property(Sketch._get_yDirection, doc="Returns the Y direction of the sketch as defined in model space.")

Sketch.__swig_getmethods__["referencePlane"] = Sketch._get_referencePlane
Sketch.__swig_setmethods__["referencePlane"] = Sketch._set_referencePlane
Sketch.referencePlane = property(Sketch._get_referencePlane, Sketch._set_referencePlane, doc="Gets and sets the construction plane or planar face the sketch is associated\nto. This is only valid when the IsParametric property is True otherwise this\nreturns null and setting the property will fail.\nSetting this property is the equivalent of the Redefine command.")

Sketch.__swig_getmethods__["isComputeDeferred"] = Sketch._get_isComputeDeferred
Sketch.__swig_setmethods__["isComputeDeferred"] = Sketch._set_isComputeDeferred
Sketch.isComputeDeferred = property(Sketch._get_isComputeDeferred, Sketch._set_isComputeDeferred, doc="Temporarily turns off the compute of the sketch. This is used to\nincrease the performance as sketch geometry is created. Once the\nsketch is drawn the this property should be set to false to allow\nthe sketch to recompute. This setting is not saved by the file and is\nalways false when a file is opened.")

Sketch.__swig_getmethods__["profiles"] = Sketch._get_profiles
Sketch.profiles = property(Sketch._get_profiles, doc="Returns the profiles currently computed for the sketch.")

Sketch.__swig_getmethods__["timelineObject"] = Sketch._get_timelineObject
Sketch.timelineObject = property(Sketch._get_timelineObject, doc="Returns the timeline object associated with this sketch.")

Sketch.__swig_getmethods__["parentComponent"] = Sketch._get_parentComponent
Sketch.parentComponent = property(Sketch._get_parentComponent, doc="Returns the parent Component.")

Sketch.__swig_getmethods__["assemblyContext"] = Sketch._get_assemblyContext
Sketch.assemblyContext = property(Sketch._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this\nobject in an assembly. This is only valid in the case where this\nis acting as a proxy in an assembly. Returns null\nin the case where the object is not in the context of an assembly.\nbut is already the native object.")

Sketch.__swig_getmethods__["nativeObject"] = Sketch._get_nativeObject
Sketch.nativeObject = property(Sketch._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

Sketch.__swig_getmethods__["boundingBox"] = Sketch._get_boundingBox
Sketch.boundingBox = property(Sketch._get_boundingBox, doc="Returns the 3D bounding box of the sketch")

Sketch.__swig_getmethods__["sketchTexts"] = Sketch._get_sketchTexts
Sketch.sketchTexts = property(Sketch._get_sketchTexts, doc="Returns the sketch text collection associated with this sketch.\nThis provides access to existing text and supports the creation\nof new text.")

Sketch.__swig_getmethods__["originPoint"] = Sketch._get_originPoint
Sketch.originPoint = property(Sketch._get_originPoint, doc="Returns the sketch point that was automatically created by projecting the\norigin construction point into the sketch.")

Sketch.__swig_getmethods__["isFullyConstrained"] = Sketch._get_isFullyConstrained
Sketch.isFullyConstrained = property(Sketch._get_isFullyConstrained, doc="Indicates if this sketch is fully constrained.")

Sketch.__swig_getmethods__["attributes"] = Sketch._get_attributes
Sketch.attributes = property(Sketch._get_attributes, doc="Returns the collection of attributes associated with this face.")

Sketch.__swig_getmethods__["baseOrFormFeature"] = Sketch._get_baseOrFormFeature
Sketch.baseOrFormFeature = property(Sketch._get_baseOrFormFeature, doc="This property returns the base or form feature that this sketch is associated with. It returns\nnull in the case wher the sketch is parametrically defined and is not related to a base or form\nfeature. It also returns null in the case where the modeling design history is not being captured (direct edit model).")

Sketch.__swig_getmethods__["healthState"] = Sketch._get_healthState
Sketch.healthState = property(Sketch._get_healthState, doc="Returns the current health state of this sketch.")

Sketch.__swig_getmethods__["errorOrWarningMessage"] = Sketch._get_errorOrWarningMessage
Sketch.errorOrWarningMessage = property(Sketch._get_errorOrWarningMessage, doc="Returns the error or warning message in the case where the healthState property returns either\nWarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.")

Sketch.__swig_getmethods__["revisionId"] = Sketch._get_revisionId
Sketch.revisionId = property(Sketch._get_revisionId, doc="Returns the current revision ID of the sketch. This ID changes any time the sketch is modified in any way. By getting\nand saving the ID when you create any data that is dependent on the sketch, you can then compare the saved\nID with the current ID to determine if the sketch has changed to know if you should update your data.")

Sketch.__swig_getmethods__["areConstraintsShown"] = Sketch._get_areConstraintsShown
Sketch.__swig_setmethods__["areConstraintsShown"] = Sketch._set_areConstraintsShown
Sketch.areConstraintsShown = property(Sketch._get_areConstraintsShown, Sketch._set_areConstraintsShown, doc="Indicates if the constraints of the sketch are displayed when the sketch is active.")

Sketch.__swig_getmethods__["arePointsShown"] = Sketch._get_arePointsShown
Sketch.__swig_setmethods__["arePointsShown"] = Sketch._set_arePointsShown
Sketch.arePointsShown = property(Sketch._get_arePointsShown, Sketch._set_arePointsShown, doc="Indicates if the sketch points in the sketch are displayed. Points that are not connected to any other\ngeometry will continue to be shown.")

Sketch.__swig_getmethods__["isLightBulbOn"] = Sketch._get_isLightBulbOn
Sketch.__swig_setmethods__["isLightBulbOn"] = Sketch._set_isLightBulbOn
Sketch.isLightBulbOn = property(Sketch._get_isLightBulbOn, Sketch._set_isLightBulbOn, doc="Gets and set if the light bulb beside the sketch node in the\nbrowser is on or not. Parent nodes in the browser can have their light\nbulb off which affects all of their children so this property does not\nindicate if the body is actually visible, just that it should be visible\nif all of it's parent nodes are also visible. Use the isVisible property\nto determine if it's actually visible.")

Sketch.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Sketch) else None
Sketch.cast = lambda arg: arg if isinstance(arg, Sketch) else None

class SketchArcs(Base):
    """
    The collection of arcs in a sketch. This provides access to the existing
    arcs and supports the methods to create new arcs.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchArcs, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchArcs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchArcs *" : return _fusion.SketchArcs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchArcs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchArcs___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SketchArcs___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchArc >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SketchArcs___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchArcs_classType
    if _newclass:classType = staticmethod(_fusion.SketchArcs_classType)
    __swig_destroy__ = _fusion.delete_SketchArcs
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchArc >" :
        """
        Function that returns the specified sketch arc using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchArcs_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of arcs in the sketch."""
        return _fusion.SketchArcs__get_count(self)

    def addByCenterStartSweep(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchArc >" :
        """
        Creates a sketch arc that is always parallel to the x-y plane of the sketch
        and is centered at the specified point. 
        centerPoint : The center point of the arc. This can be either an existing SketchPoint or a Point3D object. 
        startPoint : The start point of the arc. The distance between this point and the center defines the radius
        of the arc. This can be either an existing SketchPoint or a Point3D object. 
        sweepAngle : The sweep of the arc. This is defined in radians and a positive value defines a counter-clockwise sweep. 
        Returns the newly created SketchArc object or null if the creation failed.
        """
        return _fusion.SketchArcs_addByCenterStartSweep(self, *args)

    def addByThreePoints(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchArc >" :
        """
        Creates a sketch arc that passes through the three points. 
        startPoint : The start point of the arc. This can be either an existing SketchPoint or a Point3D object. 
        point : A point along the arc. This is a Point3D object. 
        endPoint : The end point of the arc. This can be either an existing SketchPoint or a Point3D object. 
        Returns the newly created SketchArc or null in the case of a failure.
        """
        return _fusion.SketchArcs_addByThreePoints(self, *args)

    def addFillet(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchArc >" :
        """
        Creates a fillet between two sketch entities
        The side (quadrant) the fillet is created on is determined by the points specified.
        The point for each entity can be its startSketchPoint or endSketchPoint 
        firstEntity : The first curve for the fillet definition. The curve must be open. 
        firstEntityPoint : A point on or closer to one end of the first curve that indicates the side to create the fillet on 
        secondEnitity : The second curve for the fillet definition. The curve must be open. 
        secondEntityPoint : A point on or closer to one end of the second curve that indicates the side to create the fillet on 
        radius : radius of the arc in centimeters 
        Returns the newly created SketchArc object (fillet) if the operation was successful or null if it failed.
        """
        return _fusion.SketchArcs_addFillet(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchArcs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchArcs__get_isValid(self)
SketchArcs_swigregister = _fusion.SketchArcs_swigregister
SketchArcs_swigregister(SketchArcs)

def SketchArcs_classType() -> "char const *" :
  return _fusion.SketchArcs_classType()
SketchArcs_classType = _fusion.SketchArcs_classType

SketchArcs.__swig_getmethods__["count"] = SketchArcs._get_count
SketchArcs.count = property(SketchArcs._get_count, doc="Returns the number of arcs in the sketch.")

SketchArcs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchArcs) else None
SketchArcs.cast = lambda arg: arg if isinstance(arg, SketchArcs) else None

class SketchCircles(Base):
    """
    The collection of circles in a sketch. This provides access to the existing
    circles and supports the methods to create new circles.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchCircles, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchCircles, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchCircles *" : return _fusion.SketchCircles___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchCircles___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchCircles___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SketchCircles___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchCircle >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SketchCircles___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchCircles_classType
    if _newclass:classType = staticmethod(_fusion.SketchCircles_classType)
    __swig_destroy__ = _fusion.delete_SketchCircles
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchCircle >" :
        """
        Function that returns the specified sketch circle using an index into the collection. 
        index : The index of the item within the collection to return. 
        The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchCircles_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of circles in the sketch."""
        return _fusion.SketchCircles__get_count(self)

    def addByCenterRadius(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchCircle >" :
        """
        Creates a sketch circle that is always parallel to the x-y plane of the sketch
        and is centered at the specified point. 
        centerPoint : The center point of the circle. It can be an existing SketchPoint or a Point3D object. 
        radius : The radius of the circle in centimeters. 
        Returns the newly created SketchCircle object or null if the creation failed.
        """
        return _fusion.SketchCircles_addByCenterRadius(self, *args)

    def addByTwoPoints(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchCircle >" :
        """
        Creates a sketch circle where the circle passes through the two points and the
        distance between the two points is the diameter of the circle. 
        pointOne : A Point3D object that defines a point is sketch space and lies on the x-y plane of the sketch. 
        pointTwo : A Point3D object that defines a point is sketch space and lies on the x-y plane of the sketch. 
        Returns the newly created SketchCircle object or null if the creation failed.
        """
        return _fusion.SketchCircles_addByTwoPoints(self, *args)

    def addByThreePoints(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchCircle >" :
        """
        Creates a sketch circle that passes through the three points. The three points must
        lie on the x-y plane of the sketch. 
        pointOne : The first point that the circle will pass through. The z component must be zero. 
        pointTwo : The second point that the circle will pass through. The z component must be zero. 
        pointThree : The third point that the circle will pass through. The z component must be zero. 
        Returns the newly created SketchCircle object or null if the creation failed.
        """
        return _fusion.SketchCircles_addByThreePoints(self, *args)

    def addByTwoTangents(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchCircle >" :
        """
        Creates a sketch circle that is tangent to the two input lines.
        The two lines must lie on the x-y plane of the sketch. 
        tangentOne : The first line that the circle will be tangent to.
        The line must lie on the x-y plane of the sketch. 
        tangentTwo : The second line that the circle will be tangent to.
        The line must lie on the x-y plane of the sketch and cannot 
        be parallel to the first line. 
        radius : The radius of the circle in centimeters. 
        hintPoint : A point that specifies which of the possible four solutions to use
        when creating the circle. If you consider the two input lines to be infinite
        they create four quadrants which results in four possible solutions for the
        creation of the circle. The hint point is a point anywhere within the quadrant
        where you want the circle created. 
        Returns the newly created SketchCircle object or null if the creation failed.
        """
        return _fusion.SketchCircles_addByTwoTangents(self, *args)

    def addByThreeTangents(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchCircle >" :
        """
        Creates a sketch circle that is tangent to the three input lines.
        The three lines must lie on the x-y plane of the sketch. 
        tangentOne : The first line that the circle will be tangent to.
        The line must lie on the x-y plane of the sketch and cannot be parallel 
        to the second or third line. 
        tangentTwo : The second line that the circle will be tangent to.
        The line must lie on the x-y plane of the sketch and cannot be parallel 
        to the first or third line. 
        tangentThree : The third line that the circle will be tangent to.
        The line must lie on the x-y plane of the sketch and cannot be parallel 
        to the first or second line. 
        hintPoint : A point that specifies which of the possible multiple solutions to use
        when creating the circle. If you consider the three input lines to be infinite
        there are many possible solutions when creating a circle that is tangent to all
        three lines. The hint point is a point anywhere within the area defined by the
        three lines where the circle is to be created. 
        Returns the newly created SketchCircle object or null if the creation failed.
        """
        return _fusion.SketchCircles_addByThreeTangents(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchCircles__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchCircles__get_isValid(self)
SketchCircles_swigregister = _fusion.SketchCircles_swigregister
SketchCircles_swigregister(SketchCircles)

def SketchCircles_classType() -> "char const *" :
  return _fusion.SketchCircles_classType()
SketchCircles_classType = _fusion.SketchCircles_classType

SketchCircles.__swig_getmethods__["count"] = SketchCircles._get_count
SketchCircles.count = property(SketchCircles._get_count, doc="Returns the number of circles in the sketch.")

SketchCircles.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchCircles) else None
SketchCircles.cast = lambda arg: arg if isinstance(arg, SketchCircles) else None

class SketchConicCurves(Base):
    """
    The collection of conic curves in a sketch. This provides access to the existing
    conic curves and supports the method to create new conic curves.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchConicCurves, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchConicCurves, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchConicCurves *" : return _fusion.SketchConicCurves___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchConicCurves___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchConicCurves___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SketchConicCurves___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchConicCurve >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SketchConicCurves___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchConicCurves_classType
    if _newclass:classType = staticmethod(_fusion.SketchConicCurves_classType)
    __swig_destroy__ = _fusion.delete_SketchConicCurves
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchConicCurve >" :
        """
        Function that returns the specified conic curve using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchConicCurves_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of conic curves in the sketch."""
        return _fusion.SketchConicCurves__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchConicCurves__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchConicCurves__get_isValid(self)
SketchConicCurves_swigregister = _fusion.SketchConicCurves_swigregister
SketchConicCurves_swigregister(SketchConicCurves)

def SketchConicCurves_classType() -> "char const *" :
  return _fusion.SketchConicCurves_classType()
SketchConicCurves_classType = _fusion.SketchConicCurves_classType

SketchConicCurves.__swig_getmethods__["count"] = SketchConicCurves._get_count
SketchConicCurves.count = property(SketchConicCurves._get_count, doc="Returns the number of conic curves in the sketch.")

SketchConicCurves.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchConicCurves) else None
SketchConicCurves.cast = lambda arg: arg if isinstance(arg, SketchConicCurves) else None

class SketchCurves(Base):
    """
    A collection of sketch curves in a sketch. This also provides access to collections
    for the specific types of curves where you can get the curves based on type and
    create new curves.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchCurves, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchCurves, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchCurves *" : return _fusion.SketchCurves___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchCurves___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchCurves___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SketchCurves___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SketchCurves___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchCurves_classType
    if _newclass:classType = staticmethod(_fusion.SketchCurves_classType)
    __swig_destroy__ = _fusion.delete_SketchCurves
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >" :
        """
        Function that returns the specified sketch curve using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchCurves_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of sketch curves in the sketch."""
        return _fusion.SketchCurves__get_count(self)

    def _get_sketchArcs(self) -> "adsk::core::Ptr< adsk::fusion::SketchArcs >" :
        """
        Returns the sketch arcs collection associated with this sketch.
        This provides access to the existing sketch arcs and supports
        the creation of new sketch arcs.
        """
        return _fusion.SketchCurves__get_sketchArcs(self)

    def _get_sketchCircles(self) -> "adsk::core::Ptr< adsk::fusion::SketchCircles >" :
        """
        Returns the sketch circles collection associated with this sketch.
        This provides access to the existing sketch circles and supports
        the creation of new sketch circles.
        """
        return _fusion.SketchCurves__get_sketchCircles(self)

    def _get_sketchEllipses(self) -> "adsk::core::Ptr< adsk::fusion::SketchEllipses >" :
        """
        Returns the sketch ellipses collection associated with this sketch.
        This provides access to the existing sketch ellipses and supports
        the creation of new sketch ellipses.
        """
        return _fusion.SketchCurves__get_sketchEllipses(self)

    def _get_sketchEllipticalArcs(self) -> "adsk::core::Ptr< adsk::fusion::SketchEllipticalArcs >" :
        """
        Returns the sketch elliptical arcs collection associated with this sketch.
        This provides access to the existing sketch elliptical arcs and supports
        the creation of new sketch elliptical arcs.
        """
        return _fusion.SketchCurves__get_sketchEllipticalArcs(self)

    def _get_sketchLines(self) -> "adsk::core::Ptr< adsk::fusion::SketchLines >" :
        """
        Returns the sketch lines collection associated with this sketch.
        This provides access to the existing sketch lines and supports
        the creation of new sketch lines.
        """
        return _fusion.SketchCurves__get_sketchLines(self)

    def _get_sketchFittedSplines(self) -> "adsk::core::Ptr< adsk::fusion::SketchFittedSplines >" :
        """
        Returns the sketch splines collection associated with this sketch.
        This provides access to the existing sketch splines and supports
        the creation of new sketch splines.
        """
        return _fusion.SketchCurves__get_sketchFittedSplines(self)

    def _get_sketchFixedSplines(self) -> "adsk::core::Ptr< adsk::fusion::SketchFixedSplines >" :
        """
        Returns the fixed sketch splines collection associated with this sketch.
        This provides access to the existing fixed sketch splines and supports
        the creation of new fixed sketch splines.
        """
        return _fusion.SketchCurves__get_sketchFixedSplines(self)

    def _get_sketchConicCurves(self) -> "adsk::core::Ptr< adsk::fusion::SketchConicCurves >" :
        """
        Returns the conic curves collection associated with this sketch.
        This provides access to the existing conic curves and support the
        creation of new conic curves.
        """
        return _fusion.SketchCurves__get_sketchConicCurves(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchCurves__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchCurves__get_isValid(self)
SketchCurves_swigregister = _fusion.SketchCurves_swigregister
SketchCurves_swigregister(SketchCurves)

def SketchCurves_classType() -> "char const *" :
  return _fusion.SketchCurves_classType()
SketchCurves_classType = _fusion.SketchCurves_classType

SketchCurves.__swig_getmethods__["count"] = SketchCurves._get_count
SketchCurves.count = property(SketchCurves._get_count, doc="Returns the number of sketch curves in the sketch.")

SketchCurves.__swig_getmethods__["sketchArcs"] = SketchCurves._get_sketchArcs
SketchCurves.sketchArcs = property(SketchCurves._get_sketchArcs, doc="Returns the sketch arcs collection associated with this sketch.\nThis provides access to the existing sketch arcs and supports\nthe creation of new sketch arcs.")

SketchCurves.__swig_getmethods__["sketchCircles"] = SketchCurves._get_sketchCircles
SketchCurves.sketchCircles = property(SketchCurves._get_sketchCircles, doc="Returns the sketch circles collection associated with this sketch.\nThis provides access to the existing sketch circles and supports\nthe creation of new sketch circles.")

SketchCurves.__swig_getmethods__["sketchEllipses"] = SketchCurves._get_sketchEllipses
SketchCurves.sketchEllipses = property(SketchCurves._get_sketchEllipses, doc="Returns the sketch ellipses collection associated with this sketch.\nThis provides access to the existing sketch ellipses and supports\nthe creation of new sketch ellipses.")

SketchCurves.__swig_getmethods__["sketchEllipticalArcs"] = SketchCurves._get_sketchEllipticalArcs
SketchCurves.sketchEllipticalArcs = property(SketchCurves._get_sketchEllipticalArcs, doc="Returns the sketch elliptical arcs collection associated with this sketch.\nThis provides access to the existing sketch elliptical arcs and supports\nthe creation of new sketch elliptical arcs.")

SketchCurves.__swig_getmethods__["sketchLines"] = SketchCurves._get_sketchLines
SketchCurves.sketchLines = property(SketchCurves._get_sketchLines, doc="Returns the sketch lines collection associated with this sketch.\nThis provides access to the existing sketch lines and supports\nthe creation of new sketch lines.")

SketchCurves.__swig_getmethods__["sketchFittedSplines"] = SketchCurves._get_sketchFittedSplines
SketchCurves.sketchFittedSplines = property(SketchCurves._get_sketchFittedSplines, doc="Returns the sketch splines collection associated with this sketch.\nThis provides access to the existing sketch splines and supports\nthe creation of new sketch splines.")

SketchCurves.__swig_getmethods__["sketchFixedSplines"] = SketchCurves._get_sketchFixedSplines
SketchCurves.sketchFixedSplines = property(SketchCurves._get_sketchFixedSplines, doc="Returns the fixed sketch splines collection associated with this sketch.\nThis provides access to the existing fixed sketch splines and supports\nthe creation of new fixed sketch splines.")

SketchCurves.__swig_getmethods__["sketchConicCurves"] = SketchCurves._get_sketchConicCurves
SketchCurves.sketchConicCurves = property(SketchCurves._get_sketchConicCurves, doc="Returns the conic curves collection associated with this sketch.\nThis provides access to the existing conic curves and support the\ncreation of new conic curves.")

SketchCurves.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchCurves) else None
SketchCurves.cast = lambda arg: arg if isinstance(arg, SketchCurves) else None

class SketchDimension(Base):
    """The base class for the all sketch dimensions."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchDimension, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchDimension, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchDimension *" : return _fusion.SketchDimension___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchDimension___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchDimension___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchDimension_classType
    if _newclass:classType = staticmethod(_fusion.SketchDimension_classType)
    __swig_destroy__ = _fusion.delete_SketchDimension
    __del__ = lambda self : None;
    def deleteMe(self) -> "bool" :
        """
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this dimension is deletable."""
        return _fusion.SketchDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchDimension__get_textPosition(self)

    def _set_textPosition(self, *args) -> "bool" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchDimension__set_textPosition(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.SketchDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchDimension__get_isDriving(self)

    def _set_isDriving(self, *args) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchDimension__set_isDriving(self, *args)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchDimension__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchDimension__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchDimension__get_isValid(self)
SketchDimension_swigregister = _fusion.SketchDimension_swigregister
SketchDimension_swigregister(SketchDimension)

def SketchDimension_classType() -> "char const *" :
  return _fusion.SketchDimension_classType()
SketchDimension_classType = _fusion.SketchDimension_classType

SketchDimension.__swig_getmethods__["isDeletable"] = SketchDimension._get_isDeletable
SketchDimension.isDeletable = property(SketchDimension._get_isDeletable, doc="Indicates if this dimension is deletable.")

SketchDimension.__swig_getmethods__["textPosition"] = SketchDimension._get_textPosition
SketchDimension.__swig_setmethods__["textPosition"] = SketchDimension._set_textPosition
SketchDimension.textPosition = property(SketchDimension._get_textPosition, SketchDimension._set_textPosition, doc="Gets and sets position of the dimension text.")

SketchDimension.__swig_getmethods__["parentSketch"] = SketchDimension._get_parentSketch
SketchDimension.parentSketch = property(SketchDimension._get_parentSketch, doc="Returns the parent sketch object.")

SketchDimension.__swig_getmethods__["parameter"] = SketchDimension._get_parameter
SketchDimension.parameter = property(SketchDimension._get_parameter, doc="Returns the associated parameter or null if there is no associated parameter.")

SketchDimension.__swig_getmethods__["assemblyContext"] = SketchDimension._get_assemblyContext
SketchDimension.assemblyContext = property(SketchDimension._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")

SketchDimension.__swig_getmethods__["isDriving"] = SketchDimension._get_isDriving
SketchDimension.__swig_setmethods__["isDriving"] = SketchDimension._set_isDriving
SketchDimension.isDriving = property(SketchDimension._get_isDriving, SketchDimension._set_isDriving, doc="Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension\nmay fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.")

SketchDimension.__swig_getmethods__["attributes"] = SketchDimension._get_attributes
SketchDimension.attributes = property(SketchDimension._get_attributes, doc="Returns the collection of attributes associated with this sketch dimension.")

SketchDimension.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchDimension) else None
SketchDimension.cast = lambda arg: arg if isinstance(arg, SketchDimension) else None

class SketchDimensionList(Base):
    """A list of sketch dimensions."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchDimensionList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchDimensionList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchDimensionList *" : return _fusion.SketchDimensionList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchDimensionList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchDimensionList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SketchDimensionList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchDimension >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SketchDimensionList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchDimensionList_classType
    if _newclass:classType = staticmethod(_fusion.SketchDimensionList_classType)
    __swig_destroy__ = _fusion.delete_SketchDimensionList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchDimension >" :
        """
        Function that returns the specified sketch dimension using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection 
        has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchDimensionList_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of sketch dimensions in the sketch."""
        return _fusion.SketchDimensionList__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchDimensionList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchDimensionList__get_isValid(self)
SketchDimensionList_swigregister = _fusion.SketchDimensionList_swigregister
SketchDimensionList_swigregister(SketchDimensionList)

def SketchDimensionList_classType() -> "char const *" :
  return _fusion.SketchDimensionList_classType()
SketchDimensionList_classType = _fusion.SketchDimensionList_classType

SketchDimensionList.__swig_getmethods__["count"] = SketchDimensionList._get_count
SketchDimensionList.count = property(SketchDimensionList._get_count, doc="Returns the number of sketch dimensions in the sketch.")

SketchDimensionList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchDimensionList) else None
SketchDimensionList.cast = lambda arg: arg if isinstance(arg, SketchDimensionList) else None

class SketchDimensions(Base):
    """
    A collection of the dimensions in a sketch. This object also supports the methods to add 
    new sketch dimensions.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchDimensions, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchDimensions, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchDimensions *" : return _fusion.SketchDimensions___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchDimensions___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchDimensions___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SketchDimensions___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchDimension >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SketchDimensions___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchDimensions_classType
    if _newclass:classType = staticmethod(_fusion.SketchDimensions_classType)
    __swig_destroy__ = _fusion.delete_SketchDimensions
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchDimension >" :
        """
        Function that returns the specified sketch dimension using an index into the 
        collection. 
        index : The index of the item within the collection to return. The first item in the 
        collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchDimensions_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of sketch dimensions in the sketch."""
        return _fusion.SketchDimensions__get_count(self)

    def addDistanceDimension(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchLinearDimension >" :
        """
        Creates a new linear dimension constraint between the two input entities. 
        pointOne : The first SketchPoint to dimension to. 
        pointTwo : The second SketchPoint to dimension to.. 
        orientation : The orientation of the dimension. 
        textPoint : A Point3D object that defines the position of the dimension text. 
        isDriving : Optional argument that specifies if a driving (the dimension controls the geoemtry) 
        or a driven (the geometry controls the dimension) dimension is created. If not provided
        a driving dimension will be created. 
        Returns the newly created dimension or null if the creation failed.
        """
        return _fusion.SketchDimensions_addDistanceDimension(self, *args)

    def addOffsetDimension(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchOffsetDimension >" :
        """
        Creates a new linear dimension constraint between the two input entities. The first input
        entity must be a sketch line. The second entity can be a point or a line that is parallel
        to the first. The dimension controls the distance as measured perpendicular to the first
        input line. 
        line : The SketchLine to dimension to. 
        entityTwo : The parallel SketchLine or SketchPoint to dimension to. If a SketchLine is used it must be 
        parallel to the first line. 
        textPoint : A Point3D object that defines the position of the dimension text. 
        isDriving : Optional argument that specifies if a driving (the dimension controls the geoemtry) 
        or a driven (the geometry controls the dimension) dimension is created. If not provided
        a driving dimension will be created. 
        Returns the newly created dimension or null if the creation failed.
        """
        return _fusion.SketchDimensions_addOffsetDimension(self, *args)

    def addAngularDimension(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchAngularDimension >" :
        """
        Creates a new angular dimension constraint between the two input lines. 
        The position of the text controls which of the four quadrants will be dimensioned. 
        lineOne : The first SketchLine to dimension to. 
        lineTwo : The second SketchLine to dimension to. 
        textPoint : A Point3D object that defines the position of the dimension text. The position of this
        text defines which quadrant will be dimensioned. 
        isDriving : Optional argument that specifies if a driving (the dimension controls the geoemtry) 
        or a driven (the geometry controls the dimension) dimension is created. If not provided
        a driving dimension will be created. 
        Returns the newly created dimension or null if the creation failed.
        """
        return _fusion.SketchDimensions_addAngularDimension(self, *args)

    def addDiameterDimension(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchDiameterDimension >" :
        """
        Creates a new diameter dimension constraint on the arc or circle. 
        entity : The SketchCircle or SketchArc to dimension. 
        textPoint : A Point3D object that defines the position of the dimension text. 
        isDriving : Optional argument that specifies if a driving (the dimension controls the geoemtry) 
        or a driven (the geometry controls the dimension) dimension is created. If not provided
        a driving dimension will be created. 
        Returns the newly created dimension or null if the creation failed.
        """
        return _fusion.SketchDimensions_addDiameterDimension(self, *args)

    def addRadialDimension(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchRadialDimension >" :
        """
        Creates a new radial dimension constraint on the arc or circle. 
        entity : The SketchCircle or SketchArc to dimension. 
        textPoint : A Point3D object that defines the position of the dimension text. 
        isDriving : Optional argument that specifies if a driving (the dimension controls the geoemtry) 
        or a driven (the geometry controls the dimension) dimension is created. If not provided
        a driving dimension will be created. 
        Returns the newly created dimension or null if the creation failed.
        """
        return _fusion.SketchDimensions_addRadialDimension(self, *args)

    def addEllipseMajorRadiusDimension(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchEllipseMajorRadiusDimension >" :
        """
        Creates a new dimension constraint on the major radius of an ellipse. 
        ellipse : The SketchEllipse to dimension. 
        textPoint : A Point3D object that defines the position of the dimension text. 
        isDriving : Optional argument that specifies if a driving (the dimension controls the geoemtry) 
        or a driven (the geometry controls the dimension) dimension is created. If not provided
        a driving dimension will be created. 
        Returns the newly created dimension or null if the creation failed.
        """
        return _fusion.SketchDimensions_addEllipseMajorRadiusDimension(self, *args)

    def addEllipseMinorRadiusDimension(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchEllipseMinorRadiusDimension >" :
        """
        Creates a new dimension constraint on the minor radius of an ellipse. 
        ellipse : The SketchEllipse to dimension. 
        textPoint : A Point3D object that defines the position of the dimension text. 
        isDriving : Optional argument that specifies if a driving (the dimension controls the geoemtry) 
        or a driven (the geometry controls the dimension) dimension is created. If not provided
        a driving dimension will be created. 
        Returns the newly created dimension or null if the creation failed.
        """
        return _fusion.SketchDimensions_addEllipseMinorRadiusDimension(self, *args)

    def addConcentricCircleDimension(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchConcentricCircleDimension >" :
        """
        Creates a new dimension constraint between to concentric circles or arcs. 
        circleOne : The first SketchCircle or SketchArc to dimension. 
        circleTwo : The second SketchCircle or SketchArc to dimension. 
        textPoint : A Point3D object that defines the position of the dimension text. 
        isDriving : Optional argument that specifies if a driving (the dimension controls the geoemtry) 
        or a driven (the geometry controls the dimension) dimension is created. If not provided
        a driving dimension will be created. 
        Returns the newly created dimension or null if the creation failed.
        """
        return _fusion.SketchDimensions_addConcentricCircleDimension(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchDimensions__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchDimensions__get_isValid(self)
SketchDimensions_swigregister = _fusion.SketchDimensions_swigregister
SketchDimensions_swigregister(SketchDimensions)

def SketchDimensions_classType() -> "char const *" :
  return _fusion.SketchDimensions_classType()
SketchDimensions_classType = _fusion.SketchDimensions_classType

SketchDimensions.__swig_getmethods__["count"] = SketchDimensions._get_count
SketchDimensions.count = property(SketchDimensions._get_count, doc="Returns the number of sketch dimensions in the sketch.")

SketchDimensions.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchDimensions) else None
SketchDimensions.cast = lambda arg: arg if isinstance(arg, SketchDimensions) else None

class SketchEllipses(Base):
    """
    The collection of ellipses in a sketch. This provides access to the existing
    ellipses and supports the methods to create new ellipses.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchEllipses, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchEllipses, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchEllipses *" : return _fusion.SketchEllipses___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchEllipses___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchEllipses___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SketchEllipses___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchEllipse >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SketchEllipses___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchEllipses_classType
    if _newclass:classType = staticmethod(_fusion.SketchEllipses_classType)
    __swig_destroy__ = _fusion.delete_SketchEllipses
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchEllipse >" :
        """
        Function that returns the specified sketch ellipse using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchEllipses_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of ellipses in the sketch."""
        return _fusion.SketchEllipses__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchEllipse >" :
        """
        Creates a sketch ellipse using the center point, a point defining the major axis
        and a third point anywhere along the ellipse. The created ellipse is parallel to the 
        x-y plane of the sketch. 
        centerPoint : The center point of the ellipse. This can be either an existing SketchPoint or a Point3D object. 
        majorAxisPoint : A point3D object that defines both the major axis direction and major axis radius. 
        point : A point3D object that the ellipse will pass through. 
        Returns the newly created SketchEllipse object if the creation was successful or null if it failed.
        """
        return _fusion.SketchEllipses_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchEllipses__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchEllipses__get_isValid(self)
SketchEllipses_swigregister = _fusion.SketchEllipses_swigregister
SketchEllipses_swigregister(SketchEllipses)

def SketchEllipses_classType() -> "char const *" :
  return _fusion.SketchEllipses_classType()
SketchEllipses_classType = _fusion.SketchEllipses_classType

SketchEllipses.__swig_getmethods__["count"] = SketchEllipses._get_count
SketchEllipses.count = property(SketchEllipses._get_count, doc="Returns the number of ellipses in the sketch.")

SketchEllipses.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchEllipses) else None
SketchEllipses.cast = lambda arg: arg if isinstance(arg, SketchEllipses) else None

class SketchEllipticalArcs(Base):
    """
    The collection of elliptical arcs in a sketch. This provides access to the existing
    elliptical arcs and supports the methods to create new elliptical arcs.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchEllipticalArcs, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchEllipticalArcs, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchEllipticalArcs *" : return _fusion.SketchEllipticalArcs___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchEllipticalArcs___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchEllipticalArcs___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SketchEllipticalArcs___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchEllipticalArc >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SketchEllipticalArcs___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchEllipticalArcs_classType
    if _newclass:classType = staticmethod(_fusion.SketchEllipticalArcs_classType)
    __swig_destroy__ = _fusion.delete_SketchEllipticalArcs
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchEllipticalArc >" :
        """
        Function that returns the specified sketch elliptical arc using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchEllipticalArcs_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of elliptical arcs in the sketch."""
        return _fusion.SketchEllipticalArcs__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchEllipticalArcs__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchEllipticalArcs__get_isValid(self)
SketchEllipticalArcs_swigregister = _fusion.SketchEllipticalArcs_swigregister
SketchEllipticalArcs_swigregister(SketchEllipticalArcs)

def SketchEllipticalArcs_classType() -> "char const *" :
  return _fusion.SketchEllipticalArcs_classType()
SketchEllipticalArcs_classType = _fusion.SketchEllipticalArcs_classType

SketchEllipticalArcs.__swig_getmethods__["count"] = SketchEllipticalArcs._get_count
SketchEllipticalArcs.count = property(SketchEllipticalArcs._get_count, doc="Returns the number of elliptical arcs in the sketch.")

SketchEllipticalArcs.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchEllipticalArcs) else None
SketchEllipticalArcs.cast = lambda arg: arg if isinstance(arg, SketchEllipticalArcs) else None

class SketchEntity(Base):
    """
    This object represents all geometry in a sketch, including
    points and lines and the various curves.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchEntity, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchEntity, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchEntity *" : return _fusion.SketchEntity___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchEntity___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchEntity___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchEntity_classType
    if _newclass:classType = staticmethod(_fusion.SketchEntity_classType)
    __swig_destroy__ = _fusion.delete_SketchEntity
    __del__ = lambda self : None;
    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch."""
        return _fusion.SketchEntity__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >" :
        """Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchEntity__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >" :
        """Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchEntity__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool" :
        """Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchEntity__get_is2D(self)

    def _get_isReference(self) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchEntity__get_isReference(self)

    def _set_isReference(self, *args) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchEntity__set_isReference(self, *args)

    def _get_isFixed(self) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchEntity__get_isFixed(self)

    def _set_isFixed(self, *args) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchEntity__set_isFixed(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchEntity__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchEntity__get_boundingBox(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchEntity_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchEntity__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchEntity__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool" :
        """
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchEntity__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool" :
        """Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchEntity__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.SketchEntity__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchEntity__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchEntity__get_isValid(self)
SketchEntity_swigregister = _fusion.SketchEntity_swigregister
SketchEntity_swigregister(SketchEntity)

def SketchEntity_classType() -> "char const *" :
  return _fusion.SketchEntity_classType()
SketchEntity_classType = _fusion.SketchEntity_classType

SketchEntity.__swig_getmethods__["parentSketch"] = SketchEntity._get_parentSketch
SketchEntity.parentSketch = property(SketchEntity._get_parentSketch, doc="Returns the parent sketch.")

SketchEntity.__swig_getmethods__["sketchDimensions"] = SketchEntity._get_sketchDimensions
SketchEntity.sketchDimensions = property(SketchEntity._get_sketchDimensions, doc="Returns the sketch dimensions that are attached to this curve.")

SketchEntity.__swig_getmethods__["geometricConstraints"] = SketchEntity._get_geometricConstraints
SketchEntity.geometricConstraints = property(SketchEntity._get_geometricConstraints, doc="Returns the sketch constraints that are attached to this curve.")

SketchEntity.__swig_getmethods__["is2D"] = SketchEntity._get_is2D
SketchEntity.is2D = property(SketchEntity._get_is2D, doc="Indicates if this curve lies entirely on the sketch x-y plane.")

SketchEntity.__swig_getmethods__["isReference"] = SketchEntity._get_isReference
SketchEntity.__swig_setmethods__["isReference"] = SketchEntity._set_isReference
SketchEntity.isReference = property(SketchEntity._get_isReference, SketchEntity._set_isReference, doc="Indicates if this geometry is a reference.\nChanging this property from true to false removes the reference.\nThis property can not be set to true if it is already false.")

SketchEntity.__swig_getmethods__["isFixed"] = SketchEntity._get_isFixed
SketchEntity.__swig_setmethods__["isFixed"] = SketchEntity._set_isFixed
SketchEntity.isFixed = property(SketchEntity._get_isFixed, SketchEntity._set_isFixed, doc="Indicates if this geometry is 'fixed'.")

SketchEntity.__swig_getmethods__["isVisible"] = SketchEntity._get_isVisible
SketchEntity.isVisible = property(SketchEntity._get_isVisible, doc="When a sketch is created, geometry is sometimes automatically added to the sketch.\nFor example a sketch point that references the origin point is always included and\nif a face was selected to create the sketch on, geometry from the face is also included.\nThis automatically created geometry behaves in a special way in that it is invisible\nbut is available for selection and it also participates in profile calculations. It's\nnot possible to make them visible but they can be deleted and they can be used for any\nother standard sketch operation.")

SketchEntity.__swig_getmethods__["boundingBox"] = SketchEntity._get_boundingBox
SketchEntity.boundingBox = property(SketchEntity._get_boundingBox, doc="Returns the bounding box of the entity in sketch space.")

SketchEntity.__swig_getmethods__["referencedEntity"] = SketchEntity._get_referencedEntity
SketchEntity.referencedEntity = property(SketchEntity._get_referencedEntity, doc="Returns the referenced entity in the case where IsReference\nis true. However, this property can also return null when\nIsReference is true in the case where the reference is not\nparametric.")

SketchEntity.__swig_getmethods__["assemblyContext"] = SketchEntity._get_assemblyContext
SketchEntity.assemblyContext = property(SketchEntity._get_assemblyContext, doc="Returns the assembly occurrence (i.e. the occurrence) of this object\nin an assembly. This is only valid in the case where this is acting\nas a proxy in an assembly. Returns null in the case where the object\nis not in the context of an assembly but is already the native object.")

SketchEntity.__swig_getmethods__["isDeletable"] = SketchEntity._get_isDeletable
SketchEntity.isDeletable = property(SketchEntity._get_isDeletable, doc="Indicates if this sketch entity can be deleted. There are cases, especially with sketch\npoints where another entity is dependent on an entity so deleting it is not allowed.\nFor example, you can't delete the center point of circle by itself but deleting the circle\nwill delete the point. The same is true for the end points of a line.")

SketchEntity.__swig_getmethods__["isFullyConstrained"] = SketchEntity._get_isFullyConstrained
SketchEntity.isFullyConstrained = property(SketchEntity._get_isFullyConstrained, doc="Indicates if this sketch entity is fully constrained.")

SketchEntity.__swig_getmethods__["attributes"] = SketchEntity._get_attributes
SketchEntity.attributes = property(SketchEntity._get_attributes, doc="Returns the collection of attributes associated with this face.")

SketchEntity.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchEntity) else None
SketchEntity.cast = lambda arg: arg if isinstance(arg, SketchEntity) else None

class SketchEntityList(Base):
    """A list of sketch entities."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchEntityList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchEntityList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchEntityList *" : return _fusion.SketchEntityList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchEntityList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchEntityList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SketchEntityList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchEntity >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SketchEntityList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchEntityList_classType
    if _newclass:classType = staticmethod(_fusion.SketchEntityList_classType)
    __swig_destroy__ = _fusion.delete_SketchEntityList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchEntity >" :
        """
        Function that returns the specified sketch entity using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchEntityList_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of sketch entities in the list."""
        return _fusion.SketchEntityList__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchEntityList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchEntityList__get_isValid(self)
SketchEntityList_swigregister = _fusion.SketchEntityList_swigregister
SketchEntityList_swigregister(SketchEntityList)

def SketchEntityList_classType() -> "char const *" :
  return _fusion.SketchEntityList_classType()
SketchEntityList_classType = _fusion.SketchEntityList_classType

SketchEntityList.__swig_getmethods__["count"] = SketchEntityList._get_count
SketchEntityList.count = property(SketchEntityList._get_count, doc="Returns the number of sketch entities in the list.")

SketchEntityList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchEntityList) else None
SketchEntityList.cast = lambda arg: arg if isinstance(arg, SketchEntityList) else None

class Sketches(Base):
    """
    Provides access to the sketches within a design and provides
    methods to create new sketches.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Sketches, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Sketches, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::Sketches *" : return _fusion.Sketches___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Sketches___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Sketches___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.Sketches___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.Sketches___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Sketches_classType
    if _newclass:classType = staticmethod(_fusion.Sketches_classType)
    __swig_destroy__ = _fusion.delete_Sketches
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """
        Function that returns the specified sketch using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the 
        collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.Sketches_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """
        Returns the sketch with the specified name. 
        name : The name of the sketch as seen in the browser and the timeline. 
        Returns the sketch or null if there isn't a sketch with that name.
        """
        return _fusion.Sketches_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of sketches in a component"""
        return _fusion.Sketches__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """
        Creates a new sketch on the specified planar entity. 
        planarEntity : A construction plane or planar face that defines the sketch plane 
        occurrenceForCreation : A creation occurrence is needed if the planarEntity is in another component AND the 
        sketch is not in the root component. The occurrenceForCreation is analogous 
        to the active occurrence in the UI. 
        Returns the newly created Sketch or null if the creation failed.
        """
        return _fusion.Sketches_add(self, *args)

    def addToBaseOrFormFeature(self, *args) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """
        Creates a parametric sketch that is associated with a base feature.
        Because of a current limitation, if you want to create a sketch associated with a base
        feature, you must first call the edit method of the base feature, use this method to 
        create the sketch, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it. 
        planarEntity : A construction plane or planar face that defines the sketch plane. 
        targetBaseOrFormFeature : The existing base feature that you want to associate this sketch with. 
        includeFaceEdges : When a BrepFace is used as the planarEntity argument, this defines if the edges of the face
        should be included in the sketch. 
        Returns the newly created Sketch or null if the creation failed.
        """
        return _fusion.Sketches_addToBaseOrFormFeature(self, *args)

    def addWithoutEdges(self, *args) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """
        Creates a new sketch on the specified planar entity. If a BRepFace is provided, the edges of the face
        are not projected into the sketch so the result of creating a new sketch with this method will
        always be a new empty sketch. 
        planarEntity : A construction plane or planar face that defines the sketch plane. 
        occurrenceForCreation : A creation occurrence is needed if the planarEntity is in another component AND the 
        sketch is not in the root component. The occurrenceForCreation is analogous 
        to the active occurrence in the UI. 
        Returns the newly created Sketch or null if the creation failed.
        """
        return _fusion.Sketches_addWithoutEdges(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.Sketches__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Sketches__get_isValid(self)
Sketches_swigregister = _fusion.Sketches_swigregister
Sketches_swigregister(Sketches)

def Sketches_classType() -> "char const *" :
  return _fusion.Sketches_classType()
Sketches_classType = _fusion.Sketches_classType

Sketches.__swig_getmethods__["count"] = Sketches._get_count
Sketches.count = property(Sketches._get_count, doc="Returns the number of sketches in a component")

Sketches.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Sketches) else None
Sketches.cast = lambda arg: arg if isinstance(arg, Sketches) else None

class SketchFittedSplines(Base):
    """
    The collection of fitted splines in a sketch. This provides access to the existing
    fitted splines and supports the methods to create new fitted splines.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchFittedSplines, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchFittedSplines, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchFittedSplines *" : return _fusion.SketchFittedSplines___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchFittedSplines___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchFittedSplines___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SketchFittedSplines___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchFittedSpline >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SketchFittedSplines___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchFittedSplines_classType
    if _newclass:classType = staticmethod(_fusion.SketchFittedSplines_classType)
    __swig_destroy__ = _fusion.delete_SketchFittedSplines
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchFittedSpline >" :
        """
        Function that returns the specified sketch fitted spline using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchFittedSplines_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of fitted splines in the sketch."""
        return _fusion.SketchFittedSplines__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchFittedSpline >" :
        """
        Creates a new fitted spline through the specified points. 
        fitPoints : A collection of points that the curve will fit through. They
        can be any combination of existing SketchPoint or Point3D objects. 
        Returns the newly created SketchFittedSpline object if the creation was successful or null if it failed.
        """
        return _fusion.SketchFittedSplines_add(self, *args)

    def addByNurbsCurve(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchFittedSpline >" :
        """
        Creates a new fitted spline using the input NurbsCurve3D to define the shape. Fit points are created
        to create a curve that exactly matches the input curve. 
        nurbsCurve : A NurbsCurve3D object that defines a valid NURBS curve. 
        Returns the newly created SketchFittedSpline object if the creation was successful or null if it failed.
        """
        return _fusion.SketchFittedSplines_addByNurbsCurve(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchFittedSplines__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchFittedSplines__get_isValid(self)
SketchFittedSplines_swigregister = _fusion.SketchFittedSplines_swigregister
SketchFittedSplines_swigregister(SketchFittedSplines)

def SketchFittedSplines_classType() -> "char const *" :
  return _fusion.SketchFittedSplines_classType()
SketchFittedSplines_classType = _fusion.SketchFittedSplines_classType

SketchFittedSplines.__swig_getmethods__["count"] = SketchFittedSplines._get_count
SketchFittedSplines.count = property(SketchFittedSplines._get_count, doc="Returns the number of fitted splines in the sketch.")

SketchFittedSplines.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchFittedSplines) else None
SketchFittedSplines.cast = lambda arg: arg if isinstance(arg, SketchFittedSplines) else None

class SketchFixedSplines(Base):
    """
    The collection of fixed splines in a sketch. Fixed splines are splines that were created
    as the result of some operation (i.e. intersection) and is not directly editable.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchFixedSplines, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchFixedSplines, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchFixedSplines *" : return _fusion.SketchFixedSplines___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchFixedSplines___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchFixedSplines___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SketchFixedSplines___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchFixedSpline >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SketchFixedSplines___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchFixedSplines_classType
    if _newclass:classType = staticmethod(_fusion.SketchFixedSplines_classType)
    __swig_destroy__ = _fusion.delete_SketchFixedSplines
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchFixedSpline >" :
        """
        Function that returns the specified sketch fixed spline using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchFixedSplines_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of fitted splines in the sketch."""
        return _fusion.SketchFixedSplines__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchFixedSplines__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchFixedSplines__get_isValid(self)
SketchFixedSplines_swigregister = _fusion.SketchFixedSplines_swigregister
SketchFixedSplines_swigregister(SketchFixedSplines)

def SketchFixedSplines_classType() -> "char const *" :
  return _fusion.SketchFixedSplines_classType()
SketchFixedSplines_classType = _fusion.SketchFixedSplines_classType

SketchFixedSplines.__swig_getmethods__["count"] = SketchFixedSplines._get_count
SketchFixedSplines.count = property(SketchFixedSplines._get_count, doc="Returns the number of fitted splines in the sketch.")

SketchFixedSplines.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchFixedSplines) else None
SketchFixedSplines.cast = lambda arg: arg if isinstance(arg, SketchFixedSplines) else None

class SketchLineList(Base):
    """A list of sketch lines."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchLineList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchLineList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchLineList *" : return _fusion.SketchLineList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchLineList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchLineList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SketchLineList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SketchLineList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchLineList_classType
    if _newclass:classType = staticmethod(_fusion.SketchLineList_classType)
    __swig_destroy__ = _fusion.delete_SketchLineList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """
        Function that returns the specified sketch line using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchLineList_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of sketch lines in the list."""
        return _fusion.SketchLineList__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchLineList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchLineList__get_isValid(self)
SketchLineList_swigregister = _fusion.SketchLineList_swigregister
SketchLineList_swigregister(SketchLineList)

def SketchLineList_classType() -> "char const *" :
  return _fusion.SketchLineList_classType()
SketchLineList_classType = _fusion.SketchLineList_classType

SketchLineList.__swig_getmethods__["count"] = SketchLineList._get_count
SketchLineList.count = property(SketchLineList._get_count, doc="Returns the number of sketch lines in the list.")

SketchLineList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchLineList) else None
SketchLineList.cast = lambda arg: arg if isinstance(arg, SketchLineList) else None

class SketchLines(Base):
    """
    The collection of lines in a sketch. This provides access to the existing
    lines and supports the methods to create new lines.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchLines, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchLines, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchLines *" : return _fusion.SketchLines___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchLines___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchLines___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SketchLines___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SketchLines___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchLines_classType
    if _newclass:classType = staticmethod(_fusion.SketchLines_classType)
    __swig_destroy__ = _fusion.delete_SketchLines
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """
        Function that returns the specified sketch line using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchLines_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of lines in the sketch."""
        return _fusion.SketchLines__get_count(self)

    def addByTwoPoints(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """
        Creates a sketch line between the two input points. The input points
        can be either existing SketchPoints or Point3D objects. If a SketchPoint
        is used the new line will be based on that sketch point and update if the
        sketch point is modified. 
        startPoint : The start point of the line. It can be a SketchPoint or Point3D object. 
        endPoint : The end point of the line. It can be a SketchPoint or Point3D object. 
        Returns the newly created SketchLine object or null if the creation failed.
        """
        return _fusion.SketchLines_addByTwoPoints(self, *args)

    def addTwoPointRectangle(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchLineList >" :
        """
        Creates four sketch lines representing a rectangle where the two points are the opposing corners
        of the rectangle. The input points can be either existing SketchPoints or Point3D objects.
        If a SketchPoint is used the new lines will be based on that sketch point and update if the
        sketch point is modified. 
        pointOne : The first corner of the rectangle. It can be a SketchPoint or Point3D object. 
        pointTwo : The second corner of the rectangle. It can be a SketchPoint or Point3D object. 
        Returns the four new sketch lines or null if the creation failed.
        """
        return _fusion.SketchLines_addTwoPointRectangle(self, *args)

    def addThreePointRectangle(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchLineList >" :
        """
        Creates four sketch lines representing a rectangle where the first two points are the base corners
        of the rectangle and the third point defines the height. 
        pointOne : The first corner of the rectangle. It can be a SketchPoint or Point3D object. 
        pointTwo : The first corner of the rectangle. It can be a SketchPoint or Point3D object. 
        pointThree : The first corner of the rectangle. a Point3D object defining the height of the rectangle. 
        Returns the four new sketch lines or null if the creation failed.
        """
        return _fusion.SketchLines_addThreePointRectangle(self, *args)

    def addCenterPointRectangle(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchLineList >" :
        """
        Creates four sketch lines representing a rectangle where the first point represents the center of 
        the rectangle. The second point is the corner of the rectangle and can be either an existing 
        SketchPoint or Point3D object. The four sketch lines are returned. 
        centerPoint : The center point of the rectangle 
        cornerPoint : The corner of the rectangle. It can be a SketchPoint or Point3D object. 
        Returns the four new sketch lines or null if the creation failed.
        """
        return _fusion.SketchLines_addCenterPointRectangle(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchLines__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchLines__get_isValid(self)
SketchLines_swigregister = _fusion.SketchLines_swigregister
SketchLines_swigregister(SketchLines)

def SketchLines_classType() -> "char const *" :
  return _fusion.SketchLines_classType()
SketchLines_classType = _fusion.SketchLines_classType

SketchLines.__swig_getmethods__["count"] = SketchLines._get_count
SketchLines.count = property(SketchLines._get_count, doc="Returns the number of lines in the sketch.")

SketchLines.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchLines) else None
SketchLines.cast = lambda arg: arg if isinstance(arg, SketchLines) else None

class SketchPointList(Base):
    """A list of sketch points."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchPointList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchPointList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchPointList *" : return _fusion.SketchPointList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchPointList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchPointList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SketchPointList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SketchPointList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchPointList_classType
    if _newclass:classType = staticmethod(_fusion.SketchPointList_classType)
    __swig_destroy__ = _fusion.delete_SketchPointList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """
        Function that returns the specified sketch point using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchPointList_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of sketch points in the list."""
        return _fusion.SketchPointList__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchPointList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchPointList__get_isValid(self)
SketchPointList_swigregister = _fusion.SketchPointList_swigregister
SketchPointList_swigregister(SketchPointList)

def SketchPointList_classType() -> "char const *" :
  return _fusion.SketchPointList_classType()
SketchPointList_classType = _fusion.SketchPointList_classType

SketchPointList.__swig_getmethods__["count"] = SketchPointList._get_count
SketchPointList.count = property(SketchPointList._get_count, doc="Returns the number of sketch points in the list.")

SketchPointList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchPointList) else None
SketchPointList.cast = lambda arg: arg if isinstance(arg, SketchPointList) else None

class SketchPoints(Base):
    """A collection of sketch points."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchPoints, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchPoints, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchPoints *" : return _fusion.SketchPoints___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchPoints___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchPoints___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SketchPoints___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SketchPoints___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchPoints_classType
    if _newclass:classType = staticmethod(_fusion.SketchPoints_classType)
    __swig_destroy__ = _fusion.delete_SketchPoints
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """
        Function that returns the specified sketch using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchPoints_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of sketch points in the sketch."""
        return _fusion.SketchPoints__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """
        Creates a point at the specified location. This is the equivalent
        of creating a sketch point using the Point command in the user
        interface and will create a visible point in the graphics window. 
        point : The coordinate location to create the sketch point. 
        Returns the new sketch point or null if the creation fails.
        """
        return _fusion.SketchPoints_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchPoints__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchPoints__get_isValid(self)
SketchPoints_swigregister = _fusion.SketchPoints_swigregister
SketchPoints_swigregister(SketchPoints)

def SketchPoints_classType() -> "char const *" :
  return _fusion.SketchPoints_classType()
SketchPoints_classType = _fusion.SketchPoints_classType

SketchPoints.__swig_getmethods__["count"] = SketchPoints._get_count
SketchPoints.count = property(SketchPoints._get_count, doc="Returns the number of sketch points in the sketch.")

SketchPoints.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchPoints) else None
SketchPoints.cast = lambda arg: arg if isinstance(arg, SketchPoints) else None

class SketchTextInput(Base):
    """
    The SketchTextInput object is equivalent to the Sketch Text dialog in that it collects all of the input required
    to create sketch text. Once the properties of the SketchTextInput object have been defined, use the add method
    to create the sketch text. A SketchTextInput object is created by using the createInput of the SketchTexts object.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchTextInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchTextInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchTextInput *" : return _fusion.SketchTextInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchTextInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchTextInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchTextInput_classType
    if _newclass:classType = staticmethod(_fusion.SketchTextInput_classType)
    __swig_destroy__ = _fusion.delete_SketchTextInput
    __del__ = lambda self : None;
    def _get_height(self) -> "double" :
        """Gets and sets the height of the text in centimeters."""
        return _fusion.SketchTextInput__get_height(self)

    def _set_height(self, *args) -> "bool" :
        """Gets and sets the height of the text in centimeters."""
        return _fusion.SketchTextInput__set_height(self, *args)

    def _get_text(self) -> "std::string" :
        """Gets and sets the text."""
        return _fusion.SketchTextInput__get_text(self)

    def _set_text(self, *args) -> "bool" :
        """Gets and sets the text."""
        return _fusion.SketchTextInput__set_text(self, *args)

    def _get_position(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        Gets and sets the position of the text on the x-y plane of the sketch. The text must lie on the x-y plane so the Z component
        of the point is ignored and always treated as zero.
        """
        return _fusion.SketchTextInput__get_position(self)

    def _set_position(self, *args) -> "bool" :
        """
        Gets and sets the position of the text on the x-y plane of the sketch. The text must lie on the x-y plane so the Z component
        of the point is ignored and always treated as zero.
        """
        return _fusion.SketchTextInput__set_position(self, *args)

    def _get_fontName(self) -> "std::string" :
        """Gets and sets the name of the font to use."""
        return _fusion.SketchTextInput__get_fontName(self)

    def _set_fontName(self, *args) -> "bool" :
        """Gets and sets the name of the font to use."""
        return _fusion.SketchTextInput__set_fontName(self, *args)

    def _get_angle(self) -> "double" :
        """Gets and sets the angle of the text relative to the x-axis of the x-y plane of the sketch."""
        return _fusion.SketchTextInput__get_angle(self)

    def _set_angle(self, *args) -> "bool" :
        """Gets and sets the angle of the text relative to the x-axis of the x-y plane of the sketch."""
        return _fusion.SketchTextInput__set_angle(self, *args)

    def _get_textStyle(self) -> "adsk::fusion::TextStyles" :
        """
        Gets and sets the text style to apply to the entire text. This is a bitwise enum so styles
        can be combined to apply multiple styles. For example you can apply bold and underline.
        """
        return _fusion.SketchTextInput__get_textStyle(self)

    def _set_textStyle(self, *args) -> "bool" :
        """
        Gets and sets the text style to apply to the entire text. This is a bitwise enum so styles
        can be combined to apply multiple styles. For example you can apply bold and underline.
        """
        return _fusion.SketchTextInput__set_textStyle(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchTextInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchTextInput__get_isValid(self)
SketchTextInput_swigregister = _fusion.SketchTextInput_swigregister
SketchTextInput_swigregister(SketchTextInput)

def SketchTextInput_classType() -> "char const *" :
  return _fusion.SketchTextInput_classType()
SketchTextInput_classType = _fusion.SketchTextInput_classType

SketchTextInput.__swig_getmethods__["height"] = SketchTextInput._get_height
SketchTextInput.__swig_setmethods__["height"] = SketchTextInput._set_height
SketchTextInput.height = property(SketchTextInput._get_height, SketchTextInput._set_height, doc="Gets and sets the height of the text in centimeters.")

SketchTextInput.__swig_getmethods__["text"] = SketchTextInput._get_text
SketchTextInput.__swig_setmethods__["text"] = SketchTextInput._set_text
SketchTextInput.text = property(SketchTextInput._get_text, SketchTextInput._set_text, doc="Gets and sets the text.")

SketchTextInput.__swig_getmethods__["position"] = SketchTextInput._get_position
SketchTextInput.__swig_setmethods__["position"] = SketchTextInput._set_position
SketchTextInput.position = property(SketchTextInput._get_position, SketchTextInput._set_position, doc="Gets and sets the position of the text on the x-y plane of the sketch. The text must lie on the x-y plane so the Z component\nof the point is ignored and always treated as zero.")

SketchTextInput.__swig_getmethods__["fontName"] = SketchTextInput._get_fontName
SketchTextInput.__swig_setmethods__["fontName"] = SketchTextInput._set_fontName
SketchTextInput.fontName = property(SketchTextInput._get_fontName, SketchTextInput._set_fontName, doc="Gets and sets the name of the font to use.")

SketchTextInput.__swig_getmethods__["angle"] = SketchTextInput._get_angle
SketchTextInput.__swig_setmethods__["angle"] = SketchTextInput._set_angle
SketchTextInput.angle = property(SketchTextInput._get_angle, SketchTextInput._set_angle, doc="Gets and sets the angle of the text relative to the x-axis of the x-y plane of the sketch.")

SketchTextInput.__swig_getmethods__["textStyle"] = SketchTextInput._get_textStyle
SketchTextInput.__swig_setmethods__["textStyle"] = SketchTextInput._set_textStyle
SketchTextInput.textStyle = property(SketchTextInput._get_textStyle, SketchTextInput._set_textStyle, doc="Gets and sets the text style to apply to the entire text. This is a bitwise enum so styles\ncan be combined to apply multiple styles. For example you can apply bold and underline.")

SketchTextInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchTextInput) else None
SketchTextInput.cast = lambda arg: arg if isinstance(arg, SketchTextInput) else None

class SketchTexts(Base):
    """
    The collection of text blocks in a sketch. This provides access to the existing
    text blocks and supports creating new text blocks.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchTexts, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchTexts, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchTexts *" : return _fusion.SketchTexts___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchTexts___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchTexts___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SketchTexts___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchText >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SketchTexts___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchTexts_classType
    if _newclass:classType = staticmethod(_fusion.SketchTexts_classType)
    __swig_destroy__ = _fusion.delete_SketchTexts
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchText >" :
        """
        Function that returns the specified sketch text using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SketchTexts_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of texts in the sketch."""
        return _fusion.SketchTexts__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchTextInput >" :
        """
        Creates a SketchTextInput object that can be used to define additional settings when creating sketch text. The 
        SketchTextInput object is equivalent to the Sketch Text dialog in that it collects all of the input required
        to create sketch text. Once the properties of the SketchTextInput object have been defined, use the add method
        to create the sketch text. 
        formattedText : The text used for the sketch text. This is a simple string as no additional formatting is currently supported. 
        height : The height of the text in centimeters. 
        position : The position of the text on the x-y plane of the sketch. The text must lie on the x-y plane so the Z component
        of the point is ignored and always treated as zero. 
        Returns a SketchTextInput object that can be used to set additional formatting and is used as input to the add method.
        """
        return _fusion.SketchTexts_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchText >" :
        """
        Creates a sketch text. 
        input : A SketchTextInput object created using the SketchTexts.createInput method. 
        Returns the newly created SketchText object or null in the case of failure.
        """
        return _fusion.SketchTexts_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchTexts__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchTexts__get_isValid(self)
SketchTexts_swigregister = _fusion.SketchTexts_swigregister
SketchTexts_swigregister(SketchTexts)

def SketchTexts_classType() -> "char const *" :
  return _fusion.SketchTexts_classType()
SketchTexts_classType = _fusion.SketchTexts_classType

SketchTexts.__swig_getmethods__["count"] = SketchTexts._get_count
SketchTexts.count = property(SketchTexts._get_count, doc="Returns the number of texts in the sketch.")

SketchTexts.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchTexts) else None
SketchTexts.cast = lambda arg: arg if isinstance(arg, SketchTexts) else None

class Snapshot(Base):
    """Object that represents a Snapshot in the timeline"""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Snapshot, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Snapshot, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::Snapshot *" : return _fusion.Snapshot___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Snapshot___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Snapshot___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Snapshot_classType
    if _newclass:classType = staticmethod(_fusion.Snapshot_classType)
    __swig_destroy__ = _fusion.delete_Snapshot
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Gets and sets the name of the snapshot as seen in the timeline."""
        return _fusion.Snapshot__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Gets and sets the name of the snapshot as seen in the timeline."""
        return _fusion.Snapshot__set_name(self, *args)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this snapshot."""
        return _fusion.Snapshot__get_timelineObject(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes this snapshot. 
        Returns true if the delete was successful.
        """
        return _fusion.Snapshot_deleteMe(self)

    def _get_objectType(self) -> "char const *" : return _fusion.Snapshot__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Snapshot__get_isValid(self)
Snapshot_swigregister = _fusion.Snapshot_swigregister
Snapshot_swigregister(Snapshot)

def Snapshot_classType() -> "char const *" :
  return _fusion.Snapshot_classType()
Snapshot_classType = _fusion.Snapshot_classType

Snapshot.__swig_getmethods__["name"] = Snapshot._get_name
Snapshot.__swig_setmethods__["name"] = Snapshot._set_name
Snapshot.name = property(Snapshot._get_name, Snapshot._set_name, doc="Gets and sets the name of the snapshot as seen in the timeline.")

Snapshot.__swig_getmethods__["timelineObject"] = Snapshot._get_timelineObject
Snapshot.timelineObject = property(Snapshot._get_timelineObject, doc="Returns the timeline object associated with this snapshot.")

Snapshot.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Snapshot) else None
Snapshot.cast = lambda arg: arg if isinstance(arg, Snapshot) else None

class Snapshots(Base):
    """
    Provides access to the Snapshots within a design and provides 
    methods to create new Snapshots.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Snapshots, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Snapshots, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::Snapshots *" : return _fusion.Snapshots___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Snapshots___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Snapshots___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.Snapshots___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::Snapshot >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.Snapshots___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Snapshots_classType
    if _newclass:classType = staticmethod(_fusion.Snapshots_classType)
    __swig_destroy__ = _fusion.delete_Snapshots
    __del__ = lambda self : None;
    def add(self) -> "adsk::core::Ptr< adsk::fusion::Snapshot >" :
        """
        Creates a new snapshot. Creating a snapshot is only valid when the HasPendingTransforms property returns true. 
        Returns the newly created snapshot.
        """
        return _fusion.Snapshots_add(self)

    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::Snapshot >" :
        """
        Function that returns the specified snapshot in the collection using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.Snapshots_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of items in the collection."""
        return _fusion.Snapshots__get_count(self)

    def _get_hasPendingSnapshot(self) -> "bool" :
        """Indicates if there are any changes that have been made than can be snapshot."""
        return _fusion.Snapshots__get_hasPendingSnapshot(self)

    def revertPendingSnapshot(self) -> "bool" :
        """
        Reverts and changes that have been made that can be snapshot. This effectively
        reverts the design back to the last snapshot. This is only valid when the
        HasPendingSnapshot property returns true. 
        Returns true if the revert was successful.
        """
        return _fusion.Snapshots_revertPendingSnapshot(self)

    def _get_objectType(self) -> "char const *" : return _fusion.Snapshots__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Snapshots__get_isValid(self)
Snapshots_swigregister = _fusion.Snapshots_swigregister
Snapshots_swigregister(Snapshots)

def Snapshots_classType() -> "char const *" :
  return _fusion.Snapshots_classType()
Snapshots_classType = _fusion.Snapshots_classType

Snapshots.__swig_getmethods__["count"] = Snapshots._get_count
Snapshots.count = property(Snapshots._get_count, doc="The number of items in the collection.")

Snapshots.__swig_getmethods__["hasPendingSnapshot"] = Snapshots._get_hasPendingSnapshot
Snapshots.hasPendingSnapshot = property(Snapshots._get_hasPendingSnapshot, doc="Indicates if there are any changes that have been made than can be snapshot.")

Snapshots.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Snapshots) else None
Snapshots.cast = lambda arg: arg if isinstance(arg, Snapshots) else None

class SphereFeatures(Base):
    """Collection that provides access to all of the existing torus features in a design."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SphereFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SphereFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SphereFeatures *" : return _fusion.SphereFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SphereFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SphereFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SphereFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SphereFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SphereFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SphereFeatures_classType
    if _newclass:classType = staticmethod(_fusion.SphereFeatures_classType)
    __swig_destroy__ = _fusion.delete_SphereFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SphereFeature >" :
        """
        Function that returns the specified sphere feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SphereFeatures_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::SphereFeature >" :
        """
        Function that returns the specified sphere feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.SphereFeatures_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of sphere features in the collection."""
        return _fusion.SphereFeatures__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SphereFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SphereFeatures__get_isValid(self)
SphereFeatures_swigregister = _fusion.SphereFeatures_swigregister
SphereFeatures_swigregister(SphereFeatures)

def SphereFeatures_classType() -> "char const *" :
  return _fusion.SphereFeatures_classType()
SphereFeatures_classType = _fusion.SphereFeatures_classType

SphereFeatures.__swig_getmethods__["count"] = SphereFeatures._get_count
SphereFeatures.count = property(SphereFeatures._get_count, doc="The number of sphere features in the collection.")

SphereFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SphereFeatures) else None
SphereFeatures.cast = lambda arg: arg if isinstance(arg, SphereFeatures) else None

class SplitBodyFeatureInput(Base):
    """This class defines the methods and properties that pertain to the definition of a split body feature."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SplitBodyFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SplitBodyFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SplitBodyFeatureInput *" : return _fusion.SplitBodyFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SplitBodyFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SplitBodyFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SplitBodyFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.SplitBodyFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_SplitBodyFeatureInput
    __del__ = lambda self : None;
    def _get_splitBodies(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the input solid or open bodies to be split. This can be a 
        single BRepBody or an ObjectCollection if multiple bodies are to be split.
        """
        return _fusion.SplitBodyFeatureInput__get_splitBodies(self)

    def _set_splitBodies(self, *args) -> "bool" :
        """
        Gets and sets the input solid or open bodies to be split. This can be a 
        single BRepBody or an ObjectCollection if multiple bodies are to be split.
        """
        return _fusion.SplitBodyFeatureInput__set_splitBodies(self, *args)

    def _get_splittingTool(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the entity that defines the splitting tool. The splitting tool is a single 
        entity that can be either a solid or open BRepBody, construction plane, profile, or a face.
        """
        return _fusion.SplitBodyFeatureInput__get_splittingTool(self)

    def _set_splittingTool(self, *args) -> "bool" :
        """
        Gets and sets the entity that defines the splitting tool. The splitting tool is a single 
        entity that can be either a solid or open BRepBody, construction plane, profile, or a face.
        """
        return _fusion.SplitBodyFeatureInput__set_splittingTool(self, *args)

    def _get_isSplittingToolExtended(self) -> "bool" :
        """
        Gets and sets whether or not the splitting tool is to be automatically extended (if possible) so as to
        completely intersect the bodyToSplit.
        """
        return _fusion.SplitBodyFeatureInput__get_isSplittingToolExtended(self)

    def _set_isSplittingToolExtended(self, *args) -> "bool" :
        """
        Gets and sets whether or not the splitting tool is to be automatically extended (if possible) so as to
        completely intersect the bodyToSplit.
        """
        return _fusion.SplitBodyFeatureInput__set_isSplittingToolExtended(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.SplitBodyFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.SplitBodyFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SplitBodyFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SplitBodyFeatureInput__get_isValid(self)
SplitBodyFeatureInput_swigregister = _fusion.SplitBodyFeatureInput_swigregister
SplitBodyFeatureInput_swigregister(SplitBodyFeatureInput)

def SplitBodyFeatureInput_classType() -> "char const *" :
  return _fusion.SplitBodyFeatureInput_classType()
SplitBodyFeatureInput_classType = _fusion.SplitBodyFeatureInput_classType

SplitBodyFeatureInput.__swig_getmethods__["splitBodies"] = SplitBodyFeatureInput._get_splitBodies
SplitBodyFeatureInput.__swig_setmethods__["splitBodies"] = SplitBodyFeatureInput._set_splitBodies
SplitBodyFeatureInput.splitBodies = property(SplitBodyFeatureInput._get_splitBodies, SplitBodyFeatureInput._set_splitBodies, doc="Gets and sets the input solid or open bodies to be split. This can be a\nsingle BRepBody or an ObjectCollection if multiple bodies are to be split.")

SplitBodyFeatureInput.__swig_getmethods__["splittingTool"] = SplitBodyFeatureInput._get_splittingTool
SplitBodyFeatureInput.__swig_setmethods__["splittingTool"] = SplitBodyFeatureInput._set_splittingTool
SplitBodyFeatureInput.splittingTool = property(SplitBodyFeatureInput._get_splittingTool, SplitBodyFeatureInput._set_splittingTool, doc="Gets and sets the entity that defines the splitting tool. The splitting tool is a single\nentity that can be either a solid or open BRepBody, construction plane, profile, or a face.")

SplitBodyFeatureInput.__swig_getmethods__["isSplittingToolExtended"] = SplitBodyFeatureInput._get_isSplittingToolExtended
SplitBodyFeatureInput.__swig_setmethods__["isSplittingToolExtended"] = SplitBodyFeatureInput._set_isSplittingToolExtended
SplitBodyFeatureInput.isSplittingToolExtended = property(SplitBodyFeatureInput._get_isSplittingToolExtended, SplitBodyFeatureInput._set_isSplittingToolExtended, doc="Gets and sets whether or not the splitting tool is to be automatically extended (if possible) so as to\ncompletely intersect the bodyToSplit.")

SplitBodyFeatureInput.__swig_getmethods__["targetBaseFeature"] = SplitBodyFeatureInput._get_targetBaseFeature
SplitBodyFeatureInput.__swig_setmethods__["targetBaseFeature"] = SplitBodyFeatureInput._set_targetBaseFeature
SplitBodyFeatureInput.targetBaseFeature = property(SplitBodyFeatureInput._get_targetBaseFeature, SplitBodyFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

SplitBodyFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SplitBodyFeatureInput) else None
SplitBodyFeatureInput.cast = lambda arg: arg if isinstance(arg, SplitBodyFeatureInput) else None

class SplitBodyFeatures(Base):
    """
    Collection that provides access to all of the existing split body features in a component
    and supports the ability to create new split body features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SplitBodyFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SplitBodyFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SplitBodyFeatures *" : return _fusion.SplitBodyFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SplitBodyFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SplitBodyFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SplitBodyFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SplitBodyFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SplitBodyFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SplitBodyFeatures_classType
    if _newclass:classType = staticmethod(_fusion.SplitBodyFeatures_classType)
    __swig_destroy__ = _fusion.delete_SplitBodyFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SplitBodyFeature >" :
        """
        Function that returns the specified split body feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SplitBodyFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of split body features in the collection."""
        return _fusion.SplitBodyFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::SplitBodyFeatureInput >" :
        """
        Creates a SplitBodyFeatureInput object. Use properties and methods on this object
        to define the split body you want to create and then use the Add method, passing in 
        the SplitBodyFeatureInput object. 
        splitBodies : Input solid body or open bodies to be split. This can be a single BRepBody or an ObjectCollection if multliple
        bodies are to be split. 
        splittingTool : Input entity that defines the splitting tool. The splitting tool is a single entity that can be either a solid or open BRepBody,
        construction plane, profile, or a face. 
        isSplittingToolExtended : A boolean value for setting whether or not the splitting tool is to be automatically extended (if possible) so as to
        completely intersect the bodyToSplit. 
        Returns the newly created SplitBodyFeatureInput object or null if the creation failed.
        """
        return _fusion.SplitBodyFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::SplitBodyFeature >" :
        """
        Creates a new split body feature. 
        input : A SplitBodyFeatureInput object that defines the desired split body feature. Use the createInput 
        method to create a new SplitBodyFeatureInput object and then use methods on it 
        (the SplitBodyFeatureInput object) to define the split body. 
        Returns the newly created SplitBodyFeature object or null if the creation failed.
        """
        return _fusion.SplitBodyFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::SplitBodyFeature >" :
        """
        Function that returns the specified split body feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.SplitBodyFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SplitBodyFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SplitBodyFeatures__get_isValid(self)
SplitBodyFeatures_swigregister = _fusion.SplitBodyFeatures_swigregister
SplitBodyFeatures_swigregister(SplitBodyFeatures)

def SplitBodyFeatures_classType() -> "char const *" :
  return _fusion.SplitBodyFeatures_classType()
SplitBodyFeatures_classType = _fusion.SplitBodyFeatures_classType

SplitBodyFeatures.__swig_getmethods__["count"] = SplitBodyFeatures._get_count
SplitBodyFeatures.count = property(SplitBodyFeatures._get_count, doc="The number of split body features in the collection.")

SplitBodyFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SplitBodyFeatures) else None
SplitBodyFeatures.cast = lambda arg: arg if isinstance(arg, SplitBodyFeatures) else None

class SplitFaceFeatureInput(Base):
    """This class defines the methods and properties that pertain to the definition of a split face feature."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SplitFaceFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SplitFaceFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SplitFaceFeatureInput *" : return _fusion.SplitFaceFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SplitFaceFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SplitFaceFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SplitFaceFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.SplitFaceFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_SplitFaceFeatureInput
    __del__ = lambda self : None;
    def _get_facesToSplit(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the faces to be split.
        The collection can contain one or more faces selected from solid and/or open bodies.
        """
        return _fusion.SplitFaceFeatureInput__get_facesToSplit(self)

    def _set_facesToSplit(self, *args) -> "bool" :
        """
        Gets and sets the faces to be split.
        The collection can contain one or more faces selected from solid and/or open bodies.
        """
        return _fusion.SplitFaceFeatureInput__set_facesToSplit(self, *args)

    def _get_splittingTool(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the entity(s) that define the splitting tool(s). The splitting tool can be a single entity or an 
        ObjectCollection containing solid and/or open bodies, construction planes, faces, or sketch curves that partially 
        or fully intersect the faces that are being split.
        """
        return _fusion.SplitFaceFeatureInput__get_splittingTool(self)

    def _set_splittingTool(self, *args) -> "bool" :
        """
        Gets and sets the entity(s) that define the splitting tool(s). The splitting tool can be a single entity or an 
        ObjectCollection containing solid and/or open bodies, construction planes, faces, or sketch curves that partially 
        or fully intersect the faces that are being split.
        """
        return _fusion.SplitFaceFeatureInput__set_splittingTool(self, *args)

    def _get_isSplittingToolExtended(self) -> "bool" :
        """
        Gets and sets whether or not the splittingTool is to be automatically extended (if possible) so as to
        completely intersect the facesToSplit.
        """
        return _fusion.SplitFaceFeatureInput__get_isSplittingToolExtended(self)

    def _set_isSplittingToolExtended(self, *args) -> "bool" :
        """
        Gets and sets whether or not the splittingTool is to be automatically extended (if possible) so as to
        completely intersect the facesToSplit.
        """
        return _fusion.SplitFaceFeatureInput__set_isSplittingToolExtended(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.SplitFaceFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.SplitFaceFeatureInput__set_targetBaseFeature(self, *args)

    def setAlongVectorSplitType(self, *args) -> "bool" :
        """
        Sets the split type to project the splitting tool along the direction defined by the
        specified entity. 
        directionEntity : An entity that defines the direction of projection of the splitting tool. This can be
        a linear BRepEdge, SketchLine, ConstructionLine, or a planar face where the face
        normal is used. 
        Returns true is setting the split type was successful.
        """
        return _fusion.SplitFaceFeatureInput_setAlongVectorSplitType(self, *args)

    def setClosestPointSplitType(self) -> "bool" :
        """
        Sets the split type to be a curve that defined by projecting the splitting curve to the
        closest point on the surface. 
        Returns true is setting the split type was successful.
        """
        return _fusion.SplitFaceFeatureInput_setClosestPointSplitType(self)

    def setSurfaceIntersectionSplitType(self, *args) -> "bool" :
        """
        Set the split type to be a surface to surface intersection. If the split tool is a curve
        it will be extruded into a surface to use in the split. If it's a surface, the surface will
        be used and optionally extended to fully intersect the faces to be split. 
        isSplittingToolExtended : Specifies if the splitting tool should be extended so that is fully intersects the faces to be split. 
        Returns true is setting the split type was successful.
        """
        return _fusion.SplitFaceFeatureInput_setSurfaceIntersectionSplitType(self, *args)

    def _get_splitType(self) -> "adsk::fusion::SplitFaceSplitTypes" :
        """Returns the type of split type currently defined."""
        return _fusion.SplitFaceFeatureInput__get_splitType(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SplitFaceFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SplitFaceFeatureInput__get_isValid(self)
SplitFaceFeatureInput_swigregister = _fusion.SplitFaceFeatureInput_swigregister
SplitFaceFeatureInput_swigregister(SplitFaceFeatureInput)

def SplitFaceFeatureInput_classType() -> "char const *" :
  return _fusion.SplitFaceFeatureInput_classType()
SplitFaceFeatureInput_classType = _fusion.SplitFaceFeatureInput_classType

SplitFaceFeatureInput.__swig_getmethods__["facesToSplit"] = SplitFaceFeatureInput._get_facesToSplit
SplitFaceFeatureInput.__swig_setmethods__["facesToSplit"] = SplitFaceFeatureInput._set_facesToSplit
SplitFaceFeatureInput.facesToSplit = property(SplitFaceFeatureInput._get_facesToSplit, SplitFaceFeatureInput._set_facesToSplit, doc="Gets and sets the faces to be split.\nThe collection can contain one or more faces selected from solid and/or open bodies.")

SplitFaceFeatureInput.__swig_getmethods__["splittingTool"] = SplitFaceFeatureInput._get_splittingTool
SplitFaceFeatureInput.__swig_setmethods__["splittingTool"] = SplitFaceFeatureInput._set_splittingTool
SplitFaceFeatureInput.splittingTool = property(SplitFaceFeatureInput._get_splittingTool, SplitFaceFeatureInput._set_splittingTool, doc="Gets and sets the entity(s) that define the splitting tool(s). The splitting tool can be a single entity or an\nObjectCollection containing solid and/or open bodies, construction planes, faces, or sketch curves that partially\nor fully intersect the faces that are being split.")

SplitFaceFeatureInput.__swig_getmethods__["isSplittingToolExtended"] = SplitFaceFeatureInput._get_isSplittingToolExtended
SplitFaceFeatureInput.__swig_setmethods__["isSplittingToolExtended"] = SplitFaceFeatureInput._set_isSplittingToolExtended
SplitFaceFeatureInput.isSplittingToolExtended = property(SplitFaceFeatureInput._get_isSplittingToolExtended, SplitFaceFeatureInput._set_isSplittingToolExtended, doc="Gets and sets whether or not the splittingTool is to be automatically extended (if possible) so as to\ncompletely intersect the facesToSplit.")

SplitFaceFeatureInput.__swig_getmethods__["targetBaseFeature"] = SplitFaceFeatureInput._get_targetBaseFeature
SplitFaceFeatureInput.__swig_setmethods__["targetBaseFeature"] = SplitFaceFeatureInput._set_targetBaseFeature
SplitFaceFeatureInput.targetBaseFeature = property(SplitFaceFeatureInput._get_targetBaseFeature, SplitFaceFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

SplitFaceFeatureInput.__swig_getmethods__["splitType"] = SplitFaceFeatureInput._get_splitType
SplitFaceFeatureInput.splitType = property(SplitFaceFeatureInput._get_splitType, doc="Returns the type of split type currently defined.")

SplitFaceFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SplitFaceFeatureInput) else None
SplitFaceFeatureInput.cast = lambda arg: arg if isinstance(arg, SplitFaceFeatureInput) else None

class SplitFaceFeatures(Base):
    """
    Collection that provides access to all of the existing split face features in a component
    and supports the ability to create new split face features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SplitFaceFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SplitFaceFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SplitFaceFeatures *" : return _fusion.SplitFaceFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SplitFaceFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SplitFaceFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SplitFaceFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SplitFaceFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SplitFaceFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SplitFaceFeatures_classType
    if _newclass:classType = staticmethod(_fusion.SplitFaceFeatures_classType)
    __swig_destroy__ = _fusion.delete_SplitFaceFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SplitFaceFeature >" :
        """
        Function that returns the specified split face feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SplitFaceFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of split face features in the collection."""
        return _fusion.SplitFaceFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::SplitFaceFeatureInput >" :
        """
        Creates a SplitFaceFeatureInput object. Use properties and methods on this object
        to define the split face you want to create and then use the Add method, passing in 
        the SplitFaceFeatureInput object. 
        A newly created SplitFaceFeatureInput object defaults to creating a split face feature 
        using the 'Split with Surface' option. You can use functions on the SplitFaceFeatureInput
        object to define a different type of split type. 
        facesToSplit : Input the faces to be split. The collection can contain one or more faces from solid and/or open bodies. 
        splittingTool : Input entity(s) that defines the splitting tool. The splitting tool can be a single entity or an ObjectCollection
        containing solid and/or open bodies, construction planes, faces, or sketch curves that partially or fully intersect
        the faces that are being split. 
        isSplittingToolExtended : A boolean value for setting whether or not the splittingTool is to be automatically extended (if possible) so as to
        completely intersect the faces that are to be split. This is only used when the split type is 'split with surface'
        which is the default type when a new createInput is created. Use functions on the returned SplitFaceFeatureInput
        to define a different type of split type. 
        Returns the newly created SplitFaceFeatureInput object or null if the creation failed.
        """
        return _fusion.SplitFaceFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::SplitFaceFeature >" :
        """
        Creates a new split face feature. 
        input : A SplitFaceFeatureInput object that defines the desired split face feature. Use the createInput 
        method to create a new SplitFaceFeatureInput object and then use methods on it 
        (the SplitFaceFeatureInput object) to define the split face. 
        Returns the newly created SplitFaceFeature object or null if the creation failed.
        """
        return _fusion.SplitFaceFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::SplitFaceFeature >" :
        """
        Function that returns the specified split face feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.SplitFaceFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SplitFaceFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SplitFaceFeatures__get_isValid(self)
SplitFaceFeatures_swigregister = _fusion.SplitFaceFeatures_swigregister
SplitFaceFeatures_swigregister(SplitFaceFeatures)

def SplitFaceFeatures_classType() -> "char const *" :
  return _fusion.SplitFaceFeatures_classType()
SplitFaceFeatures_classType = _fusion.SplitFaceFeatures_classType

SplitFaceFeatures.__swig_getmethods__["count"] = SplitFaceFeatures._get_count
SplitFaceFeatures.count = property(SplitFaceFeatures._get_count, doc="The number of split face features in the collection.")

SplitFaceFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SplitFaceFeatures) else None
SplitFaceFeatures.cast = lambda arg: arg if isinstance(arg, SplitFaceFeatures) else None

class StitchFeatureInput(Base):
    """This class defines the methods and properties that pertain to the definition of a stitch feature."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StitchFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StitchFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::StitchFeatureInput *" : return _fusion.StitchFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.StitchFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.StitchFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.StitchFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.StitchFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_StitchFeatureInput
    __del__ = lambda self : None;
    def _get_stitchSurfaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """Gets and sets the surfaces to stitch together."""
        return _fusion.StitchFeatureInput__get_stitchSurfaces(self)

    def _set_stitchSurfaces(self, *args) -> "bool" :
        """Gets and sets the surfaces to stitch together."""
        return _fusion.StitchFeatureInput__set_stitchSurfaces(self, *args)

    def _get_tolerance(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets and sets the ValueInput object that defines the stitching tolerance. It must define a length."""
        return _fusion.StitchFeatureInput__get_tolerance(self)

    def _set_tolerance(self, *args) -> "bool" :
        """Gets and sets the ValueInput object that defines the stitching tolerance. It must define a length."""
        return _fusion.StitchFeatureInput__set_tolerance(self, *args)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """
        Gets and sets the feature operation to perform. This property value is only valid if the isSolid property returns
        true. Otherwise the value of this property is ignored.
        """
        return _fusion.StitchFeatureInput__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """
        Gets and sets the feature operation to perform. This property value is only valid if the isSolid property returns
        true. Otherwise the value of this property is ignored.
        """
        return _fusion.StitchFeatureInput__set_operation(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.StitchFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.StitchFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.StitchFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.StitchFeatureInput__get_isValid(self)
StitchFeatureInput_swigregister = _fusion.StitchFeatureInput_swigregister
StitchFeatureInput_swigregister(StitchFeatureInput)

def StitchFeatureInput_classType() -> "char const *" :
  return _fusion.StitchFeatureInput_classType()
StitchFeatureInput_classType = _fusion.StitchFeatureInput_classType

StitchFeatureInput.__swig_getmethods__["stitchSurfaces"] = StitchFeatureInput._get_stitchSurfaces
StitchFeatureInput.__swig_setmethods__["stitchSurfaces"] = StitchFeatureInput._set_stitchSurfaces
StitchFeatureInput.stitchSurfaces = property(StitchFeatureInput._get_stitchSurfaces, StitchFeatureInput._set_stitchSurfaces, doc="Gets and sets the surfaces to stitch together.")

StitchFeatureInput.__swig_getmethods__["tolerance"] = StitchFeatureInput._get_tolerance
StitchFeatureInput.__swig_setmethods__["tolerance"] = StitchFeatureInput._set_tolerance
StitchFeatureInput.tolerance = property(StitchFeatureInput._get_tolerance, StitchFeatureInput._set_tolerance, doc="Gets and sets the ValueInput object that defines the stitching tolerance. It must define a length.")

StitchFeatureInput.__swig_getmethods__["operation"] = StitchFeatureInput._get_operation
StitchFeatureInput.__swig_setmethods__["operation"] = StitchFeatureInput._set_operation
StitchFeatureInput.operation = property(StitchFeatureInput._get_operation, StitchFeatureInput._set_operation, doc="Gets and sets the feature operation to perform. This property value is only valid if the isSolid property returns\ntrue. Otherwise the value of this property is ignored.")

StitchFeatureInput.__swig_getmethods__["targetBaseFeature"] = StitchFeatureInput._get_targetBaseFeature
StitchFeatureInput.__swig_setmethods__["targetBaseFeature"] = StitchFeatureInput._set_targetBaseFeature
StitchFeatureInput.targetBaseFeature = property(StitchFeatureInput._get_targetBaseFeature, StitchFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

StitchFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, StitchFeatureInput) else None
StitchFeatureInput.cast = lambda arg: arg if isinstance(arg, StitchFeatureInput) else None

class StitchFeatures(Base):
    """
    Collection that provides access to all of the existing Stitch features in a component
    and supports the ability to create new Stitch features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StitchFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StitchFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::StitchFeatures *" : return _fusion.StitchFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.StitchFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.StitchFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.StitchFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::StitchFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.StitchFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.StitchFeatures_classType
    if _newclass:classType = staticmethod(_fusion.StitchFeatures_classType)
    __swig_destroy__ = _fusion.delete_StitchFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::StitchFeature >" :
        """
        Function that returns the specified stitch feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.StitchFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of Stitch features in the collection."""
        return _fusion.StitchFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::StitchFeatureInput >" :
        """
        Creates a StitchFeatureInput object. Use properties and methods on this object
        to define the stitch feature you want to create and then use the Add method, passing in 
        the StitchFeatureInput object. 
        stitchSurfaces : The surfaces (open BRepBodies) to stitch together.
        Stitching surfaces can form multiple closed volumes resulting in multiple solids.
        Stitch Surfaces can form multiple BRepShells (entirely connected set of entities) that would result in a 
        single non-solid BRepBody. 
        tolerance : ValueInput object that defines the stitching tolerance. It must define a distance value. 
        operation : Specifies the operation type for the result when the final result is a closed solid. Otherwise
        this argument is ignored. 
        Returns the newly created StitchFeatureInput object or null if the creation failed.
        """
        return _fusion.StitchFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::StitchFeature >" :
        """
        Creates a new stitch feature. 
        input : A StitchFeatureInput object that defines the desired stitch feature. Use the createInput 
        method to create a new StitchFeatureInput object and then use methods on it 
        (the StitchFeatureInput object) to define the stitch feature. 
        Returns the newly created StitchFeature object or null if the creation failed.
        """
        return _fusion.StitchFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::StitchFeature >" :
        """
        Function that returns the specified stitch feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.StitchFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.StitchFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.StitchFeatures__get_isValid(self)
StitchFeatures_swigregister = _fusion.StitchFeatures_swigregister
StitchFeatures_swigregister(StitchFeatures)

def StitchFeatures_classType() -> "char const *" :
  return _fusion.StitchFeatures_classType()
StitchFeatures_classType = _fusion.StitchFeatures_classType

StitchFeatures.__swig_getmethods__["count"] = StitchFeatures._get_count
StitchFeatures.count = property(StitchFeatures._get_count, doc="The number of Stitch features in the collection.")

StitchFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, StitchFeatures) else None
StitchFeatures.cast = lambda arg: arg if isinstance(arg, StitchFeatures) else None

class SurfaceDeleteFaceFeatures(Base):
    """
    Collection that provides access to all of the existing SurfaceDeleteFaceFeature features in a component
    and supports the ability to create new SurfaceDeleteFaceFeature features.
    The SurfaceDeleteFaceFeature and DeleteFaceFeature differ in that the SurfaceDeleteFaceFeature
    can delete any face without any restrictions. If the body is a solid, it will become a surface
    when the first face is deleted. The specified face is deleted without any other changes being
    made to the body. The DeleteFaceFeature deletes the specified face and also modifies the other faces
    in the body to heal or fill in the area of the deleted face. This means that a solid body will
    remain solid.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SurfaceDeleteFaceFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SurfaceDeleteFaceFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SurfaceDeleteFaceFeatures *" : return _fusion.SurfaceDeleteFaceFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SurfaceDeleteFaceFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SurfaceDeleteFaceFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SurfaceDeleteFaceFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SurfaceDeleteFaceFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SurfaceDeleteFaceFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SurfaceDeleteFaceFeatures_classType
    if _newclass:classType = staticmethod(_fusion.SurfaceDeleteFaceFeatures_classType)
    __swig_destroy__ = _fusion.delete_SurfaceDeleteFaceFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SurfaceDeleteFaceFeature >" :
        """
        Function that returns the specified SurfaceDeleteFaceFeature object using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SurfaceDeleteFaceFeatures_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::SurfaceDeleteFaceFeature >" :
        """
        Function that returns the specified SurfaceDeleteFaceFeature object using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.SurfaceDeleteFaceFeatures_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of SurfaceDeleteFaceFeature objects in the collection."""
        return _fusion.SurfaceDeleteFaceFeatures__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::SurfaceDeleteFaceFeature >" :
        """
        Creates a new SurfaceDeleteFaceFeature feature. This deletes the specified faces
        from their bodies without any attempt to heal the openings. This is equivalent
        to selecting and deleting faces when in the Patch workspace. 
        facesToDelete : A single BRepFace or an ObjectCollection containing multiple BRepFace objects. 
        Returns the newly created SurfaceDeleteFaceFeature object or null if the creation failed.
        """
        return _fusion.SurfaceDeleteFaceFeatures_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SurfaceDeleteFaceFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SurfaceDeleteFaceFeatures__get_isValid(self)
SurfaceDeleteFaceFeatures_swigregister = _fusion.SurfaceDeleteFaceFeatures_swigregister
SurfaceDeleteFaceFeatures_swigregister(SurfaceDeleteFaceFeatures)

def SurfaceDeleteFaceFeatures_classType() -> "char const *" :
  return _fusion.SurfaceDeleteFaceFeatures_classType()
SurfaceDeleteFaceFeatures_classType = _fusion.SurfaceDeleteFaceFeatures_classType

SurfaceDeleteFaceFeatures.__swig_getmethods__["count"] = SurfaceDeleteFaceFeatures._get_count
SurfaceDeleteFaceFeatures.count = property(SurfaceDeleteFaceFeatures._get_count, doc="The number of SurfaceDeleteFaceFeature objects in the collection.")

SurfaceDeleteFaceFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SurfaceDeleteFaceFeatures) else None
SurfaceDeleteFaceFeatures.cast = lambda arg: arg if isinstance(arg, SurfaceDeleteFaceFeatures) else None

class SweepFeatureInput(Base):
    """
    This class defines the methods and properties that pertain to the definition of a sweep 
    feature.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SweepFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SweepFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SweepFeatureInput *" : return _fusion.SweepFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SweepFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SweepFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SweepFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.SweepFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_SweepFeatureInput
    __del__ = lambda self : None;
    def _get_profile(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the profiles or planar faces used to define the shape of the sweep.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        """
        return _fusion.SweepFeatureInput__get_profile(self)

    def _set_profile(self, *args) -> "bool" :
        """
        Gets and sets the profiles or planar faces used to define the shape of the sweep.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        """
        return _fusion.SweepFeatureInput__set_profile(self, *args)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """Gets and sets the type of operation performed by the sweep."""
        return _fusion.SweepFeatureInput__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """Gets and sets the type of operation performed by the sweep."""
        return _fusion.SweepFeatureInput__set_operation(self, *args)

    def _get_path(self) -> "adsk::core::Ptr< adsk::fusion::Path >" :
        """Gets and sets the path to create the sweep."""
        return _fusion.SweepFeatureInput__get_path(self)

    def _set_path(self, *args) -> "bool" :
        """Gets and sets the path to create the sweep."""
        return _fusion.SweepFeatureInput__set_path(self, *args)

    def _get_distanceOne(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Gets and sets the distance for the first side.
        The distance is a value from 0 to 1 indicating the position along the path where 0
        is at the start and 1 is at the end. The value is default to 1.0.
        """
        return _fusion.SweepFeatureInput__get_distanceOne(self)

    def _set_distanceOne(self, *args) -> "bool" :
        """
        Gets and sets the distance for the first side.
        The distance is a value from 0 to 1 indicating the position along the path where 0
        is at the start and 1 is at the end. The value is default to 1.0.
        """
        return _fusion.SweepFeatureInput__set_distanceOne(self, *args)

    def _get_distanceTwo(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Gets and sets the distance for the second side.
        The distance is a value from 0 to 1 indicating the position along the path where 0
        is at the start and 1 is at the end. The value defaults to 0 in the case where the path is closed, otherwise it defaults to 1.0.
        It is ignored if the path is only on one side of the profile or if the sweep definition includes a guide rail.
        It's always the distance against the normal of the profile if available.
        """
        return _fusion.SweepFeatureInput__get_distanceTwo(self)

    def _set_distanceTwo(self, *args) -> "bool" :
        """
        Gets and sets the distance for the second side.
        The distance is a value from 0 to 1 indicating the position along the path where 0
        is at the start and 1 is at the end. The value defaults to 0 in the case where the path is closed, otherwise it defaults to 1.0.
        It is ignored if the path is only on one side of the profile or if the sweep definition includes a guide rail.
        It's always the distance against the normal of the profile if available.
        """
        return _fusion.SweepFeatureInput__set_distanceTwo(self, *args)

    def _get_orientation(self) -> "adsk::fusion::SweepOrientationTypes" :
        """
        Gets and sets the sweep orientation. It defaults to PerpendicularOrientationType.
        This property is ignored when a guide rail has been specified.
        """
        return _fusion.SweepFeatureInput__get_orientation(self)

    def _set_orientation(self, *args) -> "bool" :
        """
        Gets and sets the sweep orientation. It defaults to PerpendicularOrientationType.
        This property is ignored when a guide rail has been specified.
        """
        return _fusion.SweepFeatureInput__set_orientation(self, *args)

    def _get_creationOccurrence(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the sweep is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the sweep) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.SweepFeatureInput__get_creationOccurrence(self)

    def _set_creationOccurrence(self, *args) -> "bool" :
        """
        In order for geometry to be transformed correctly, an Occurrence for creation needs to be
        specified when the sweep is created based on geometry (e.g. a profile and/or face(s))
        in another component AND (the sweep) is not in the root component.
        The CreationOccurrence is analogous to the active occurrence in the UI
        """
        return _fusion.SweepFeatureInput__set_creationOccurrence(self, *args)

    def _get_isSolid(self) -> "bool" :
        """
        Specifies if the sweep should be created as a solid or surface. If
        it's a surface then there aren't any end caps and it's open. This is
        initialized to true so a solid will be created if it's not changed.
        """
        return _fusion.SweepFeatureInput__get_isSolid(self)

    def _set_isSolid(self, *args) -> "bool" :
        """
        Specifies if the sweep should be created as a solid or surface. If
        it's a surface then there aren't any end caps and it's open. This is
        initialized to true so a solid will be created if it's not changed.
        """
        return _fusion.SweepFeatureInput__set_isSolid(self, *args)

    def _get_guideRail(self) -> "adsk::core::Ptr< adsk::fusion::Path >" :
        """
        Gets and sets the guide rail to create the sweep. This can be set to 
        null to remove the guide rail definition and have a single path sweep feature.
        """
        return _fusion.SweepFeatureInput__get_guideRail(self)

    def _set_guideRail(self, *args) -> "bool" :
        """
        Gets and sets the guide rail to create the sweep. This can be set to 
        null to remove the guide rail definition and have a single path sweep feature.
        """
        return _fusion.SweepFeatureInput__set_guideRail(self, *args)

    def _get_isDirectionFlipped(self) -> "bool" :
        """
        Gets and sets if the direction of the sweep is flipped. 
        This property only applies to sweep features that include a guide rail and whose path runs on both 
        sides of the profile.
        """
        return _fusion.SweepFeatureInput__get_isDirectionFlipped(self)

    def _set_isDirectionFlipped(self, *args) -> "bool" :
        """
        Gets and sets if the direction of the sweep is flipped. 
        This property only applies to sweep features that include a guide rail and whose path runs on both 
        sides of the profile.
        """
        return _fusion.SweepFeatureInput__set_isDirectionFlipped(self, *args)

    def _get_profileScaling(self) -> "adsk::fusion::SweepProfileScalingOptions" :
        """
        Gets and sets the sweep profile scaling option. It defaults to SweepProfileScaleOption.
        This property is only used when a guide rail has been specified.
        """
        return _fusion.SweepFeatureInput__get_profileScaling(self)

    def _set_profileScaling(self, *args) -> "bool" :
        """
        Gets and sets the sweep profile scaling option. It defaults to SweepProfileScaleOption.
        This property is only used when a guide rail has been specified.
        """
        return _fusion.SweepFeatureInput__set_profileScaling(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.SweepFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.SweepFeatureInput__set_targetBaseFeature(self, *args)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >" :
        """
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        feature will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.SweepFeatureInput__get_participantBodies(self)

    def _set_participantBodies(self, *args) -> "bool" :
        """
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        If this property has not been set, the default behavior is that all bodies that are intersected by the 
        feature will participate.
        This property can return null in the case where the feature has not been fully defined so that
        possible intersecting bodies can be computed.
        """
        return _fusion.SweepFeatureInput__set_participantBodies(self, *args)

    def _get_taperAngle(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Gets and sets the taper angle of the sweep. This property is initialized with a taper angle of zero.
        A negative angle will taper the sweep inward while a positive value will taper
        the sweep outward. This property is valid for both parametric and non-parametric extrusions.
        """
        return _fusion.SweepFeatureInput__get_taperAngle(self)

    def _set_taperAngle(self, *args) -> "bool" :
        """
        Gets and sets the taper angle of the sweep. This property is initialized with a taper angle of zero.
        A negative angle will taper the sweep inward while a positive value will taper
        the sweep outward. This property is valid for both parametric and non-parametric extrusions.
        """
        return _fusion.SweepFeatureInput__set_taperAngle(self, *args)

    def _get_twistAngle(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Gets and sets the taper angle of the sweep. This property is initialized with a taper angle of zero.
        A negative angle will taper the sweep inward while a positive value will taper
        the sweep outward. This property is valid for both parametric and non-parametric extrusions.
        """
        return _fusion.SweepFeatureInput__get_twistAngle(self)

    def _set_twistAngle(self, *args) -> "bool" :
        """
        Gets and sets the taper angle of the sweep. This property is initialized with a taper angle of zero.
        A negative angle will taper the sweep inward while a positive value will taper
        the sweep outward. This property is valid for both parametric and non-parametric extrusions.
        """
        return _fusion.SweepFeatureInput__set_twistAngle(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SweepFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SweepFeatureInput__get_isValid(self)
SweepFeatureInput_swigregister = _fusion.SweepFeatureInput_swigregister
SweepFeatureInput_swigregister(SweepFeatureInput)

def SweepFeatureInput_classType() -> "char const *" :
  return _fusion.SweepFeatureInput_classType()
SweepFeatureInput_classType = _fusion.SweepFeatureInput_classType

SweepFeatureInput.__swig_getmethods__["profile"] = SweepFeatureInput._get_profile
SweepFeatureInput.__swig_setmethods__["profile"] = SweepFeatureInput._set_profile
SweepFeatureInput.profile = property(SweepFeatureInput._get_profile, SweepFeatureInput._set_profile, doc="Gets and sets the profiles or planar faces used to define the shape of the sweep.\nThis property can return or be set with a single Profile, a single planar face, or\nan ObjectCollection consisting of multiple profiles and planar faces. When an\nObjectCollection is used all of the profiles and faces must be co-planar.")

SweepFeatureInput.__swig_getmethods__["operation"] = SweepFeatureInput._get_operation
SweepFeatureInput.__swig_setmethods__["operation"] = SweepFeatureInput._set_operation
SweepFeatureInput.operation = property(SweepFeatureInput._get_operation, SweepFeatureInput._set_operation, doc="Gets and sets the type of operation performed by the sweep.")

SweepFeatureInput.__swig_getmethods__["path"] = SweepFeatureInput._get_path
SweepFeatureInput.__swig_setmethods__["path"] = SweepFeatureInput._set_path
SweepFeatureInput.path = property(SweepFeatureInput._get_path, SweepFeatureInput._set_path, doc="Gets and sets the path to create the sweep.")

SweepFeatureInput.__swig_getmethods__["distanceOne"] = SweepFeatureInput._get_distanceOne
SweepFeatureInput.__swig_setmethods__["distanceOne"] = SweepFeatureInput._set_distanceOne
SweepFeatureInput.distanceOne = property(SweepFeatureInput._get_distanceOne, SweepFeatureInput._set_distanceOne, doc="Gets and sets the distance for the first side.\nThe distance is a value from 0 to 1 indicating the position along the path where 0\nis at the start and 1 is at the end. The value is default to 1.0.")

SweepFeatureInput.__swig_getmethods__["distanceTwo"] = SweepFeatureInput._get_distanceTwo
SweepFeatureInput.__swig_setmethods__["distanceTwo"] = SweepFeatureInput._set_distanceTwo
SweepFeatureInput.distanceTwo = property(SweepFeatureInput._get_distanceTwo, SweepFeatureInput._set_distanceTwo, doc="Gets and sets the distance for the second side.\nThe distance is a value from 0 to 1 indicating the position along the path where 0\nis at the start and 1 is at the end. The value defaults to 0 in the case where the path is closed, otherwise it defaults to 1.0.\nIt is ignored if the path is only on one side of the profile or if the sweep definition includes a guide rail.\nIt's always the distance against the normal of the profile if available.")

SweepFeatureInput.__swig_getmethods__["orientation"] = SweepFeatureInput._get_orientation
SweepFeatureInput.__swig_setmethods__["orientation"] = SweepFeatureInput._set_orientation
SweepFeatureInput.orientation = property(SweepFeatureInput._get_orientation, SweepFeatureInput._set_orientation, doc="Gets and sets the sweep orientation. It defaults to PerpendicularOrientationType.\nThis property is ignored when a guide rail has been specified.")

SweepFeatureInput.__swig_getmethods__["creationOccurrence"] = SweepFeatureInput._get_creationOccurrence
SweepFeatureInput.__swig_setmethods__["creationOccurrence"] = SweepFeatureInput._set_creationOccurrence
SweepFeatureInput.creationOccurrence = property(SweepFeatureInput._get_creationOccurrence, SweepFeatureInput._set_creationOccurrence, doc="In order for geometry to be transformed correctly, an Occurrence for creation needs to be\nspecified when the sweep is created based on geometry (e.g. a profile and/or face(s))\nin another component AND (the sweep) is not in the root component.\nThe CreationOccurrence is analogous to the active occurrence in the UI")

SweepFeatureInput.__swig_getmethods__["isSolid"] = SweepFeatureInput._get_isSolid
SweepFeatureInput.__swig_setmethods__["isSolid"] = SweepFeatureInput._set_isSolid
SweepFeatureInput.isSolid = property(SweepFeatureInput._get_isSolid, SweepFeatureInput._set_isSolid, doc="Specifies if the sweep should be created as a solid or surface. If\nit's a surface then there aren't any end caps and it's open. This is\ninitialized to true so a solid will be created if it's not changed.")

SweepFeatureInput.__swig_getmethods__["guideRail"] = SweepFeatureInput._get_guideRail
SweepFeatureInput.__swig_setmethods__["guideRail"] = SweepFeatureInput._set_guideRail
SweepFeatureInput.guideRail = property(SweepFeatureInput._get_guideRail, SweepFeatureInput._set_guideRail, doc="Gets and sets the guide rail to create the sweep. This can be set to\nnull to remove the guide rail definition and have a single path sweep feature.")

SweepFeatureInput.__swig_getmethods__["isDirectionFlipped"] = SweepFeatureInput._get_isDirectionFlipped
SweepFeatureInput.__swig_setmethods__["isDirectionFlipped"] = SweepFeatureInput._set_isDirectionFlipped
SweepFeatureInput.isDirectionFlipped = property(SweepFeatureInput._get_isDirectionFlipped, SweepFeatureInput._set_isDirectionFlipped, doc="Gets and sets if the direction of the sweep is flipped.\nThis property only applies to sweep features that include a guide rail and whose path runs on both\nsides of the profile.")

SweepFeatureInput.__swig_getmethods__["profileScaling"] = SweepFeatureInput._get_profileScaling
SweepFeatureInput.__swig_setmethods__["profileScaling"] = SweepFeatureInput._set_profileScaling
SweepFeatureInput.profileScaling = property(SweepFeatureInput._get_profileScaling, SweepFeatureInput._set_profileScaling, doc="Gets and sets the sweep profile scaling option. It defaults to SweepProfileScaleOption.\nThis property is only used when a guide rail has been specified.")

SweepFeatureInput.__swig_getmethods__["targetBaseFeature"] = SweepFeatureInput._get_targetBaseFeature
SweepFeatureInput.__swig_setmethods__["targetBaseFeature"] = SweepFeatureInput._set_targetBaseFeature
SweepFeatureInput.targetBaseFeature = property(SweepFeatureInput._get_targetBaseFeature, SweepFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

SweepFeatureInput.__swig_getmethods__["participantBodies"] = SweepFeatureInput._get_participantBodies
SweepFeatureInput.__swig_setmethods__["participantBodies"] = SweepFeatureInput._set_participantBodies
SweepFeatureInput.participantBodies = property(SweepFeatureInput._get_participantBodies, SweepFeatureInput._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.\nIf this property has not been set, the default behavior is that all bodies that are intersected by the\nfeature will participate.\nThis property can return null in the case where the feature has not been fully defined so that\npossible intersecting bodies can be computed.")

SweepFeatureInput.__swig_getmethods__["taperAngle"] = SweepFeatureInput._get_taperAngle
SweepFeatureInput.__swig_setmethods__["taperAngle"] = SweepFeatureInput._set_taperAngle
SweepFeatureInput.taperAngle = property(SweepFeatureInput._get_taperAngle, SweepFeatureInput._set_taperAngle, doc="Gets and sets the taper angle of the sweep. This property is initialized with a taper angle of zero.\nA negative angle will taper the sweep inward while a positive value will taper\nthe sweep outward. This property is valid for both parametric and non-parametric extrusions.")

SweepFeatureInput.__swig_getmethods__["twistAngle"] = SweepFeatureInput._get_twistAngle
SweepFeatureInput.__swig_setmethods__["twistAngle"] = SweepFeatureInput._set_twistAngle
SweepFeatureInput.twistAngle = property(SweepFeatureInput._get_twistAngle, SweepFeatureInput._set_twistAngle, doc="Gets and sets the taper angle of the sweep. This property is initialized with a taper angle of zero.\nA negative angle will taper the sweep inward while a positive value will taper\nthe sweep outward. This property is valid for both parametric and non-parametric extrusions.")

SweepFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SweepFeatureInput) else None
SweepFeatureInput.cast = lambda arg: arg if isinstance(arg, SweepFeatureInput) else None

class SweepFeatures(Base):
    """
    Collection that provides access to all of the existing sweep features in a component
    and supports the ability to create new sweep features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SweepFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SweepFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SweepFeatures *" : return _fusion.SweepFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SweepFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SweepFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.SweepFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::SweepFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.SweepFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SweepFeatures_classType
    if _newclass:classType = staticmethod(_fusion.SweepFeatures_classType)
    __swig_destroy__ = _fusion.delete_SweepFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::SweepFeature >" :
        """
        Function that returns the specified sweep feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.SweepFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of sweep features in the collection."""
        return _fusion.SweepFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::SweepFeatureInput >" :
        """
        Creates a SweepFeatureInput object for defining a simple sweep feature with only a path and no guide rail. 
        Use properties and methods on this object to define the sweep you want to create and then use the Add method, 
        passing in the SweepFeatureInput object. 
        profile : The profile argument can be a single Profile, a single
        planar face, or an ObjectCollection consisting of multiple profiles and planar faces.
        When an ObjectCollection is used all of the profiles and faces must be co-planar. 
        path : The path to create the sweep. 
        operation : The feature operation to perform 
        Returns the newly created SweepFeatureInput object or null if the creation failed.
        """
        return _fusion.SweepFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::SweepFeature >" :
        """
        Creates a new sweep feature. 
        input : A SweepFeatureInput object that defines the desired sweep. Use the createInput 
        method to create a new SweepFeatureInput object and then use methods on it 
        (the SweepFeatureInput object) to define the sweep. 
        Returns the newly created SweepFeature object or null if the creation failed.
        """
        return _fusion.SweepFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::SweepFeature >" :
        """
        Function that returns the specified sweep feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.SweepFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SweepFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SweepFeatures__get_isValid(self)
SweepFeatures_swigregister = _fusion.SweepFeatures_swigregister
SweepFeatures_swigregister(SweepFeatures)

def SweepFeatures_classType() -> "char const *" :
  return _fusion.SweepFeatures_classType()
SweepFeatures_classType = _fusion.SweepFeatures_classType

SweepFeatures.__swig_getmethods__["count"] = SweepFeatures._get_count
SweepFeatures.count = property(SweepFeatures._get_count, doc="The number of sweep features in the collection.")

SweepFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SweepFeatures) else None
SweepFeatures.cast = lambda arg: arg if isinstance(arg, SweepFeatures) else None

class TemporaryBRepManager(Base):
    """
    A utility object that provides functionality to create and manipulate B-Rep data outside
    the context of a document. The provides direct access to the modeling core without the
    overhead of parametrics, persistence, transactions, or graphics. It also provides a way
    of directly defining and creating B-Rep data.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TemporaryBRepManager, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TemporaryBRepManager, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TemporaryBRepManager *" : return _fusion.TemporaryBRepManager___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TemporaryBRepManager___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TemporaryBRepManager___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TemporaryBRepManager_classType
    if _newclass:classType = staticmethod(_fusion.TemporaryBRepManager_classType)
    __swig_getmethods__["get"] = lambda x: _fusion.TemporaryBRepManager_get
    if _newclass:get = staticmethod(_fusion.TemporaryBRepManager_get)
    __swig_destroy__ = _fusion.delete_TemporaryBRepManager
    __del__ = lambda self : None;
    def copy(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Creates a temporary copy of the input BRepBody, BRepFace, or BRepEdge object. 
        bRepEntity : The BRepBody, BRepFace, BRepLoop, or BRepEdge to create a copy of. This can be a parametric
        B-Rep entity or a temporary B-Rep entity. 
        Returns a BRepBody that contains the result. If a BRepBody is input the copy is
        of the entire body. If a BRepFace is input, then the result is a BRepBody that 
        contains a single face. If a BRepLoop is input then the result is a BRepBody that
        contains a wire where each edge in the loop will have a corresponding edge in the wire.
        If a BRepEdge is input then the result is a BRepBody that contains a wire that contains 
        the single edge.
        """
        return _fusion.TemporaryBRepManager_copy(self, *args)

    def planeIntersection(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Calculates the intersection between the input body and plane and creates a
        wire body that represents the intersection curves. 
        body : The BRepBody to intersection. 
        plane : The geometry Plane to intersect with the body. 
        Returns a BRepBody that contains a wire body that represents the intersection.
        """
        return _fusion.TemporaryBRepManager_planeIntersection(self, *args)

    def createRuledSurface(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Creates a new body by creating a ruled surface between the two input wire bodies. 
        sectionOne : BRepWire that defines the shape of the first section. 
        sectionTwo : BRepWire that defines the shape of the second section. 
        Returns the created ruled surface as a BRepBody object.
        """
        return _fusion.TemporaryBRepManager_createRuledSurface(self, *args)

    def createSilhouetteCurves(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Calculates the silhouette curve geometry for a given face as viewed from a given direction. 
        face : Input BRepFace object to calculate the silhouette curve for. 
        viewDirection : Input Vector3D object that defines the view direction to calculate the silhouette curve relative to. 
        The silhouette curve(s) will lie along the path where the face normal is perpendicular to the view direction. 
        returnCoincidentSilhouettes : Input Boolean that specifies if silhouette curves that are coincident to the edges of the face should be 
        returned or not. If true, these curves will be returned. 
        Returns a SurfaceBody object that will contain one or more BRepWire objects that represent the silhouette curve(s). 
        This method can return null in the case where there is not a silhouette curve for the specified face.
        """
        return _fusion.TemporaryBRepManager_createSilhouetteCurves(self, *args)

    def deleteFaces(self, *args) -> "bool" :
        """
        Deletes one or more faces from a temporary BRepBody. The body that will be modified is determined
        by getting the parent body of the input faces. 
        faces : An array of BRepFace objects to delete. If more than one face is provided,
        all of the faces must exist within the same body. 
        deleteSpecifiedFaces : This allows you to either delete the faces that were input or to keep those faces and delete all the
        other faces in the body. 
        Returns true if the operation was successful.
        """
        return _fusion.TemporaryBRepManager_deleteFaces(self, *args)

    def booleanOperation(self, *args) -> "bool" :
        """
        Performs the specified Boolean operation between the two input bodies. The input bodies need
        not be solid but can be faces that are combined or trimmed. 
        targetBody : The target body that will be modified as a result of the Boolean operation. 
        toolBody : The tool body that will be used to operate on the target body. 
        booleanType : The type of Boolean operation to perform. 
        Returns true if the operation was successful. If successful, the target body is modified as a result of the 
        Boolean operation. Because of this the targetBody must always be a temporary BRepBody. The toolbody is not 
        modified. This is analogous to a machining operation where you have the target that is being machined and 
        the tool that removes material.
        """
        return _fusion.TemporaryBRepManager_booleanOperation(self, *args)

    def transform(self, *args) -> "bool" :
        """
        Transforms the input body using the specified transformation matrix. 
        body : The BRepBody object to transform. 
        transform : The transformation matrix that defines the transform to apply to the body. 
        Returns true if the specified transform was successfully applied to the body.
        """
        return _fusion.TemporaryBRepManager_transform(self, *args)

    def createFromFile(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Creates new BRepBody objects based on the contents of the specified file. 
        filename : The full path and name of the file to read in. This can be a SMT, SMB, SAT, or SAB file. 
        A BRepBodies collection object is returned which can contain multiple BRepBody objects.
        null is returned in the case where it was unable to read the file.
        """
        return _fusion.TemporaryBRepManager_createFromFile(self, *args)

    def exportToFile(self, *args) -> "bool" :
        """
        Exports the input bodies to the specified file. 
        bodies : An array of BRepBody objects that you want to export. 
        filename : The filename to write the BRepBody objects to. The type of file to create
        is inferred from the extension of the file. The valid extensions are '.sat' and '.smt'. 
        Returns true if the export was successful.
        """
        return _fusion.TemporaryBRepManager_exportToFile(self, *args)

    def createBox(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Creates a new temporary solid box BRepBody object. 
        box : The OrientedBoundingBox3D object that defines the position, orientation, and
        size of the box to crate. 
        Returns the newly created temporary BRepBody object or null in the case of failure.
        """
        return _fusion.TemporaryBRepManager_createBox(self, *args)

    def createCylinderOrCone(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Creates a temporary solid cylinder or cone BRepBody object. 
        pointOne : A point at one end of the cylinder or cone. 
        pointOneRadius : The radius of the cylinder or cone at the point one end, in centimeters. 
        pointTwo : A point at the opposite end of the cylinder or cone. 
        pointTwoRadius : The radius of the cylinder or cone at the point two end, in centimeters.
        For a cylinder the pointTwoRadius should be equal to the pointOneRadius. 
        Returns the newly created temporary BRepBody object or null in the case of failure.
        """
        return _fusion.TemporaryBRepManager_createCylinderOrCone(self, *args)

    def createEllipticalCylinderOrCone(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Creates a temporary elliptical solid cylinder or cone BrepBody object. 
        pointOne : A point at one end of the cylinder or cone. 
        pointOneMajorRadius : The major radius of the cylinder or cone at the point one end, in centimeters. 
        pointOneMinorRadius : The minor radius of the cylinder or cone at the point one end, in centimeters. 
        pointTwo : A point at the opposite end of the cone. 
        pointTwoMajorRadius : The major radius of the cylinder or cone at the point two end, in centimeters. The 
        minor radius is automatically determined using the point one ratio of the minor and major
        radii. 
        majorAxisDirection : A Vector3D object that defines the direction of the major axis. 
        Returns the newly created temporary BRepBody object or null in the case of failure.
        """
        return _fusion.TemporaryBRepManager_createEllipticalCylinderOrCone(self, *args)

    def createSphere(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Creates a temporary spherical BRepBody object. 
        center : The center point of the sphere. 
        radius : The radius of the sphere in centimeters. 
        Returns the newly created temporary BRepBody object or null in the case of failure.
        """
        return _fusion.TemporaryBRepManager_createSphere(self, *args)

    def createTorus(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Creates a temporary torioidal BRepBody object. 
        center : The center point of the torus. 
        axis : The axis of the torus. 
        majorRadius : The radius, in centimeters, of the major radius of the torus. If the torus was created
        by sweeping a circle around another cirlce this would be the radius of the path circle. 
        minorRadius : The radius, in centimeters, of the minor radius of the torus. If the torus was created
        by sweeping a circle around another cirlce this would be the radius of the profile circle. 
        Returns the newly created temporary BRepBody object or null in the case of failure.
        """
        return _fusion.TemporaryBRepManager_createTorus(self, *args)

    def createFaceFromPlanarWires(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Creates a body from multiple wires that all lie within the same plane. Multiple wires are
        used when creating a plane with interior holes. One wire defines the outer shape and the
        other wires define the interior loops of the created face. 
        wireBodies : An array of bodies that contiain planar wires. Each wire must be closed, they should not overlap,
        and they should all lie on the same plane. 
        Returns a BRepBody containing the created BRepFace object or null in the case of failure.
        """
        return _fusion.TemporaryBRepManager_createFaceFromPlanarWires(self, *args)

    def imprintOverlapBodies(self, *args) -> "bool" :
        """
        <p>Method that finds regions of faces on two bodies which overlap and creates new bodies where the faces 
        are split at the edges of the overlaps. This does not modify the original bodies but creates new 
        temporary bodies that contain the imprints.</p>
        <p>The picture below shows an example of imprinting. The picture on the left shows the initial two bodies 
        that are positioned so there are coincident faces. The picture on the right shows the two bodies individually 
        so you can see the result of the imprint and how the coincident faces were split. </p>
        <br/><br/><center><img src='../Images/ImprintBodies.png'></center><br/>
        <p>The ability to imprint solids can be important to applications that need to mesh models. By creating edges 
        at the poins where solids connect, it guarantees that there will be mesh nodes along those boundaries.</p> 
        bodyOne : Input BRepBody that will participate in the imprint operation. This body can be either a parametric 
        or temporary body. 
        bodyTwo : Input BRepBody that will participate in the imprint operation. This body can be either a parametric 
        or temporary body. 
        imprintCoincidentEdges : <p>Input Boolean that indicates if overlapping edges should be included in the result. The picture below 
        shows an example of when this argument will make a difference. The two bodies have overlapping faces 
        and there is also an overlapping edge. If this argument is true, then the edge shown in red below 
        will be included in the output as an overlapping edge. If False it will not be included and only 
        the edges of the overlapping faces will be in the overlapping faces collections.</p>
        <br/><br/><center><img src='../Images/ImprintOverlappingEdges.png'></center> 
        resultBodyOne : Output temporary BRepBody that contains the imprinted body that corresponds to the body provided through the bodyOne argument. 
        resultBodyTwo : Output temporary BRepBody that contains the imprinted body that corresponds to the body provided through the bodyTwo argument. 
        bodyOneOverlappingFaces : Output array of BRepFace objects that represent the overlapping faces that are part of resultBodyOne. Faces at the same index within the
        collection returned here and that returned by the bodyTwoOverlappingFaces are overlapping. 
        bodyTwoOverlappingFaces : Output array of BRepFace objects that represent the overlapping faces that are part of resultBodyTwo. Faces at the same index within the
        collection returned here and that returned by the bodyOneOverlappingFaces are overlapping. 
        bodyOneOverlappingEdges : Output array of BRepEdge objects that represent the overlapping edges that are part of resultBodyOne. Edges at the same index within the
        collection returned here and that returned by the bodyTwoOverlappingEdges are overlapping. 
        bodyTwoOverlappingEdges : Output array of BRepEdge objects that represent the overlapping edges that are part of resultBodyTwo. Edges at the same index within the
        collection returned here and that returned by the bodyOneOverlappingEdges are overlapping. 
        tolerance : Optional Input double that specifies the tolerance, in centimeters, to use when comparing the bodies. If not specified, or a value of zero
        is specified, the internal modeling tolerance will be used. 
        Returns true if the imprint calculation was successful.
        """
        return _fusion.TemporaryBRepManager_imprintOverlapBodies(self, *args)

    def createWireFromCurves(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Give an array of curve geometry objects, this method creates a new wire body. 
        curves : An array containing the input Curve3D objects. These can be Arc3D, Circle3D, Ellipse3D, EllipticalArc3D or Line3D objects. 
        edgeMap : An array of edges in the returned body. The order that the edges are in this collection is the
        same order as the original corresponding Curve3D object is in the input curves array. This allows you to 
        map between the original input curve and created edge. 
        allowSelfIntersections : Specifies if you want to allow self-intersection in the input curves or not. 
        Returns the B-Rep body containing the created wire or null in the case of failure.
        """
        return _fusion.TemporaryBRepManager_createWireFromCurves(self, *args)

    def createHelixWire(self, *args) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """
        Creates a B-Rep body that contains a wire with a single edge that represents a helical curve. 
        axisPoint : A Point3D object that defines a point along the axis of the helix. 
        axisVector : A Vector3D object that defines the direction of the axis of the hellix. 
        startPoint : A Point3D that defines the start point of the helix. This is a point on the helix and defines the starting
        point of the helix. The distance of this point to the axis defines the starting radius of the helix. 
        pitch : The pitch of the helix, or the distance between each of the turns, in centimeters. 
        turns : The number of turns of the helix. 
        taperAngle : The taper angle of the helix in radians.
        """
        return _fusion.TemporaryBRepManager_createHelixWire(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.TemporaryBRepManager__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TemporaryBRepManager__get_isValid(self)
TemporaryBRepManager_swigregister = _fusion.TemporaryBRepManager_swigregister
TemporaryBRepManager_swigregister(TemporaryBRepManager)

def TemporaryBRepManager_classType() -> "char const *" :
  return _fusion.TemporaryBRepManager_classType()
TemporaryBRepManager_classType = _fusion.TemporaryBRepManager_classType

def TemporaryBRepManager_get() -> "adsk::core::Ptr< adsk::fusion::TemporaryBRepManager >" :
  return _fusion.TemporaryBRepManager_get()
TemporaryBRepManager_get = _fusion.TemporaryBRepManager_get

TemporaryBRepManager.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TemporaryBRepManager) else None
TemporaryBRepManager.cast = lambda arg: arg if isinstance(arg, TemporaryBRepManager) else None

class TextureImage(Base):
    """Provides access to the image data associated with a texture map."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TextureImage, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TextureImage, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TextureImage *" : return _fusion.TextureImage___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TextureImage___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TextureImage___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TextureImage_classType
    if _newclass:classType = staticmethod(_fusion.TextureImage_classType)
    __swig_destroy__ = _fusion.delete_TextureImage
    __del__ = lambda self : None;
    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix2D >" :
        """The transform of the texture image in parametric space."""
        return _fusion.TextureImage__get_transform(self)

    def _get_objectType(self) -> "char const *" : return _fusion.TextureImage__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TextureImage__get_isValid(self)
TextureImage_swigregister = _fusion.TextureImage_swigregister
TextureImage_swigregister(TextureImage)

def TextureImage_classType() -> "char const *" :
  return _fusion.TextureImage_classType()
TextureImage_classType = _fusion.TextureImage_classType

TextureImage.__swig_getmethods__["transform"] = TextureImage._get_transform
TextureImage.transform = property(TextureImage._get_transform, doc="The transform of the texture image in parametric space.")

TextureImage.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TextureImage) else None
TextureImage.cast = lambda arg: arg if isinstance(arg, TextureImage) else None

class ThickenFeatureInput(Base):
    """This class defines the methods and properties that pertain to the definition of a Thicken feature."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThickenFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThickenFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ThickenFeatureInput *" : return _fusion.ThickenFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ThickenFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ThickenFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ThickenFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.ThickenFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_ThickenFeatureInput
    __del__ = lambda self : None;
    def _get_inputFaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """An ObjectCollection containing the face and/or patch bodies to thicken."""
        return _fusion.ThickenFeatureInput__get_inputFaces(self)

    def _set_inputFaces(self, *args) -> "bool" :
        """An ObjectCollection containing the face and/or patch bodies to thicken."""
        return _fusion.ThickenFeatureInput__set_inputFaces(self, *args)

    def _get_thickness(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """Gets and sets the ValueInput object that defines the thickness distance."""
        return _fusion.ThickenFeatureInput__get_thickness(self)

    def _set_thickness(self, *args) -> "bool" :
        """Gets and sets the ValueInput object that defines the thickness distance."""
        return _fusion.ThickenFeatureInput__set_thickness(self, *args)

    def _get_isSymmetric(self) -> "bool" :
        """Gets and sets whether to add thickness symetrically or only on one side of the face/s to thicken"""
        return _fusion.ThickenFeatureInput__get_isSymmetric(self)

    def _set_isSymmetric(self, *args) -> "bool" :
        """Gets and sets whether to add thickness symetrically or only on one side of the face/s to thicken"""
        return _fusion.ThickenFeatureInput__set_isSymmetric(self, *args)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """Gets and sets the feature operation to perform."""
        return _fusion.ThickenFeatureInput__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """Gets and sets the feature operation to perform."""
        return _fusion.ThickenFeatureInput__set_operation(self, *args)

    def _get_isChainSelection(self) -> "bool" :
        """Get and sets whether faces that are tangentially connected to the input faces will be included in the thicken feature."""
        return _fusion.ThickenFeatureInput__get_isChainSelection(self)

    def _set_isChainSelection(self, *args) -> "bool" :
        """Get and sets whether faces that are tangentially connected to the input faces will be included in the thicken feature."""
        return _fusion.ThickenFeatureInput__set_isChainSelection(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ThickenFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ThickenFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ThickenFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ThickenFeatureInput__get_isValid(self)
ThickenFeatureInput_swigregister = _fusion.ThickenFeatureInput_swigregister
ThickenFeatureInput_swigregister(ThickenFeatureInput)

def ThickenFeatureInput_classType() -> "char const *" :
  return _fusion.ThickenFeatureInput_classType()
ThickenFeatureInput_classType = _fusion.ThickenFeatureInput_classType

ThickenFeatureInput.__swig_getmethods__["inputFaces"] = ThickenFeatureInput._get_inputFaces
ThickenFeatureInput.__swig_setmethods__["inputFaces"] = ThickenFeatureInput._set_inputFaces
ThickenFeatureInput.inputFaces = property(ThickenFeatureInput._get_inputFaces, ThickenFeatureInput._set_inputFaces, doc="An ObjectCollection containing the face and/or patch bodies to thicken.")

ThickenFeatureInput.__swig_getmethods__["thickness"] = ThickenFeatureInput._get_thickness
ThickenFeatureInput.__swig_setmethods__["thickness"] = ThickenFeatureInput._set_thickness
ThickenFeatureInput.thickness = property(ThickenFeatureInput._get_thickness, ThickenFeatureInput._set_thickness, doc="Gets and sets the ValueInput object that defines the thickness distance.")

ThickenFeatureInput.__swig_getmethods__["isSymmetric"] = ThickenFeatureInput._get_isSymmetric
ThickenFeatureInput.__swig_setmethods__["isSymmetric"] = ThickenFeatureInput._set_isSymmetric
ThickenFeatureInput.isSymmetric = property(ThickenFeatureInput._get_isSymmetric, ThickenFeatureInput._set_isSymmetric, doc="Gets and sets whether to add thickness symetrically or only on one side of the face/s to thicken")

ThickenFeatureInput.__swig_getmethods__["operation"] = ThickenFeatureInput._get_operation
ThickenFeatureInput.__swig_setmethods__["operation"] = ThickenFeatureInput._set_operation
ThickenFeatureInput.operation = property(ThickenFeatureInput._get_operation, ThickenFeatureInput._set_operation, doc="Gets and sets the feature operation to perform.")

ThickenFeatureInput.__swig_getmethods__["isChainSelection"] = ThickenFeatureInput._get_isChainSelection
ThickenFeatureInput.__swig_setmethods__["isChainSelection"] = ThickenFeatureInput._set_isChainSelection
ThickenFeatureInput.isChainSelection = property(ThickenFeatureInput._get_isChainSelection, ThickenFeatureInput._set_isChainSelection, doc="Get and sets whether faces that are tangentially connected to the input faces will be included in the thicken feature.")

ThickenFeatureInput.__swig_getmethods__["targetBaseFeature"] = ThickenFeatureInput._get_targetBaseFeature
ThickenFeatureInput.__swig_setmethods__["targetBaseFeature"] = ThickenFeatureInput._set_targetBaseFeature
ThickenFeatureInput.targetBaseFeature = property(ThickenFeatureInput._get_targetBaseFeature, ThickenFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

ThickenFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ThickenFeatureInput) else None
ThickenFeatureInput.cast = lambda arg: arg if isinstance(arg, ThickenFeatureInput) else None

class ThickenFeatures(Base):
    """
    Collection that provides access to all of the existing Thicken features in a component
    and supports the ability to create new Thicken features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThickenFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThickenFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ThickenFeatures *" : return _fusion.ThickenFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ThickenFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ThickenFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.ThickenFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::ThickenFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.ThickenFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ThickenFeatures_classType
    if _newclass:classType = staticmethod(_fusion.ThickenFeatures_classType)
    __swig_destroy__ = _fusion.delete_ThickenFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::ThickenFeature >" :
        """
        Function that returns the specified Thicken feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ThickenFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of Thicken features in the collection."""
        return _fusion.ThickenFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::ThickenFeatureInput >" :
        """
        Creates a ThickenFeatureInput object. Use properties and methods on this object
        to define the Thicken feature you want to create and then use the Add method, passing in 
        the ThickenFeatureInput object to create the feature. 
        inputFaces : The faces or patch bodies to thicken. Faces need not be from the same component or body, nor do they need to be 
        connected or touching one another. 
        thickness : ValueInput object that defines the thickness. 
        isSymmetric : A boolean value for setting whether to add thickness symetrically or only on one side of the face/s to thicken 
        operation : The feature operation to perform. 
        isChainSelection : A boolean value for setting whether or not faces that are tangentially connected to 
        the input faces (if any) will be included in the thicken. The default value is true. 
        Returns the newly created ThickenFeatureInput object or null if the creation failed.
        """
        return _fusion.ThickenFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::ThickenFeature >" :
        """
        Creates a new Thicken feature. 
        input : A FeatureInput object that defines the desired Thicken feature. Use the createInput 
        method to create a new ThickenFeatureInput object and then use methods on it 
        (the ThickenFeatureInput object) to define the Thicken feature. 
        Returns the newly created ThickenFeature object or null if the creation failed.
        """
        return _fusion.ThickenFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::ThickenFeature >" :
        """
        Function that returns the specified thicken feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.ThickenFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ThickenFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ThickenFeatures__get_isValid(self)
ThickenFeatures_swigregister = _fusion.ThickenFeatures_swigregister
ThickenFeatures_swigregister(ThickenFeatures)

def ThickenFeatures_classType() -> "char const *" :
  return _fusion.ThickenFeatures_classType()
ThickenFeatures_classType = _fusion.ThickenFeatures_classType

ThickenFeatures.__swig_getmethods__["count"] = ThickenFeatures._get_count
ThickenFeatures.count = property(ThickenFeatures._get_count, doc="The number of Thicken features in the collection.")

ThickenFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ThickenFeatures) else None
ThickenFeatures.cast = lambda arg: arg if isinstance(arg, ThickenFeatures) else None

class ThreadDataQuery(Base):
    """This object provides methods to query the thread data contained in the XML files under ThreadData folder."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThreadDataQuery, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThreadDataQuery, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ThreadDataQuery *" : return _fusion.ThreadDataQuery___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ThreadDataQuery___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ThreadDataQuery___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ThreadDataQuery_classType
    if _newclass:classType = staticmethod(_fusion.ThreadDataQuery_classType)
    __swig_destroy__ = _fusion.delete_ThreadDataQuery
    __del__ = lambda self : None;
    def _get_allThreadTypes(self) -> "std::vector< std::string,std::allocator< std::string > >" :
        """Gets all the available thread types (families)."""
        return _fusion.ThreadDataQuery__get_allThreadTypes(self)

    def allSizes(self, *args) -> "std::vector< std::string,std::allocator< std::string > >" :
        """
        Method that returns all the available thread sizes for a given thread type. 
        threadType : Specify the thread type. 
        Returns the specified thread sizes or empty array if an invalid thread type was specified.
        """
        return _fusion.ThreadDataQuery_allSizes(self, *args)

    def allDesignations(self, *args) -> "std::vector< std::string,std::allocator< std::string > >" :
        """
        Method that returns all the available thread designations for a thread type of a given size. 
        threadType : Specify the thread type. 
        size : Specify the thread size. 
        Returns the specified thread designations or empty array if an invalid thread type or size was specified.
        """
        return _fusion.ThreadDataQuery_allDesignations(self, *args)

    def allClasses(self, *args) -> "std::vector< std::string,std::allocator< std::string > >" :
        """
        Method that returns all the available classes for a thread type of a given thread designation. 
        isInternal : Indicates if the thread is an internal or external thread. 
        threadType : Specify the thread type. 
        designation : Specify the thread designation. 
        Returns the specified thread classes or empty array if an invalid thread type or designation was specified.
        """
        return _fusion.ThreadDataQuery_allClasses(self, *args)

    def threadTypeCustomName(self, *args) -> "std::string" :
        """
        Method that returns the custom name for a given thread type. 
        threadType : Thread type identifier string. 
        Returns the specified custom name or empty string if an invalid thread type was specified.
        """
        return _fusion.ThreadDataQuery_threadTypeCustomName(self, *args)

    def threadTypeUnit(self, *args) -> "std::string" :
        """
        Method that returns the unit for a given thread type. 
        threadType : Specify the thread type. 
        Returns the specified unit or empty string if an invalid thread type was specified.
        """
        return _fusion.ThreadDataQuery_threadTypeUnit(self, *args)

    def recommendThreadData(self, *args) -> "bool" :
        """
        Method that gets the recommended thread data for a given model diameter. 
        modelDiameter : The model diameter. The unit is centimeter. 
        isInternal : Indicates if the thread is an internal or external thread. 
        threadType : Specifies the thread type to query the thread data. 
        designation : The output thread designation. 
        threadClass : The output thread class. 
        Returns true if successful.
        """
        return _fusion.ThreadDataQuery_recommendThreadData(self, *args)

    def _get_defaultInchThreadType(self) -> "std::string" :
        """Gets the default inch thread type."""
        return _fusion.ThreadDataQuery__get_defaultInchThreadType(self)

    def _get_defaultMetricThreadType(self) -> "std::string" :
        """Gets the default metric thread type."""
        return _fusion.ThreadDataQuery__get_defaultMetricThreadType(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ThreadDataQuery__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ThreadDataQuery__get_isValid(self)
ThreadDataQuery_swigregister = _fusion.ThreadDataQuery_swigregister
ThreadDataQuery_swigregister(ThreadDataQuery)

def ThreadDataQuery_classType() -> "char const *" :
  return _fusion.ThreadDataQuery_classType()
ThreadDataQuery_classType = _fusion.ThreadDataQuery_classType

ThreadDataQuery.__swig_getmethods__["allThreadTypes"] = ThreadDataQuery._get_allThreadTypes
ThreadDataQuery.allThreadTypes = property(ThreadDataQuery._get_allThreadTypes, doc="Gets all the available thread types (families).")

ThreadDataQuery.__swig_getmethods__["defaultInchThreadType"] = ThreadDataQuery._get_defaultInchThreadType
ThreadDataQuery.defaultInchThreadType = property(ThreadDataQuery._get_defaultInchThreadType, doc="Gets the default inch thread type.")

ThreadDataQuery.__swig_getmethods__["defaultMetricThreadType"] = ThreadDataQuery._get_defaultMetricThreadType
ThreadDataQuery.defaultMetricThreadType = property(ThreadDataQuery._get_defaultMetricThreadType, doc="Gets the default metric thread type.")

ThreadDataQuery.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ThreadDataQuery) else None
ThreadDataQuery.cast = lambda arg: arg if isinstance(arg, ThreadDataQuery) else None

class ThreadFeatureInput(Base):
    """
    This class defines the methods and properties that pertain to the definition of a thread 
    feature.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThreadFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThreadFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ThreadFeatureInput *" : return _fusion.ThreadFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ThreadFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ThreadFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ThreadFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.ThreadFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_ThreadFeatureInput
    __del__ = lambda self : None;
    def _get_inputCylindricalFace(self) -> "adsk::core::Ptr< adsk::fusion::BRepFace >" :
        """
        Gets and sets the threaded face. In the case where there are multiple faces, only the first one is returned.
        Setting this results in a thread being applied to only a single face.
        It is recommended that you use the inputCylindricalfaces property in order to have full access to the collection of faces
        to be threaded.
        """
        return _fusion.ThreadFeatureInput__get_inputCylindricalFace(self)

    def _set_inputCylindricalFace(self, *args) -> "bool" :
        """
        Gets and sets the threaded face. In the case where there are multiple faces, only the first one is returned.
        Setting this results in a thread being applied to only a single face.
        It is recommended that you use the inputCylindricalfaces property in order to have full access to the collection of faces
        to be threaded.
        """
        return _fusion.ThreadFeatureInput__set_inputCylindricalFace(self, *args)

    def _get_isModeled(self) -> "bool" :
        """
        Gets and sets if the thread is physical or cosmetic thread. A value of true indicates a physical thread.
        It defaults to false.
        """
        return _fusion.ThreadFeatureInput__get_isModeled(self)

    def _set_isModeled(self, *args) -> "bool" :
        """
        Gets and sets if the thread is physical or cosmetic thread. A value of true indicates a physical thread.
        It defaults to false.
        """
        return _fusion.ThreadFeatureInput__set_isModeled(self, *args)

    def _get_isFullLength(self) -> "bool" :
        """
        Gets and sets if this thread is the full length of the cylinder.
        It defaults to true.
        """
        return _fusion.ThreadFeatureInput__get_isFullLength(self)

    def _set_isFullLength(self, *args) -> "bool" :
        """
        Gets and sets if this thread is the full length of the cylinder.
        It defaults to true.
        """
        return _fusion.ThreadFeatureInput__set_isFullLength(self, *args)

    def _get_threadLength(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Gets and sets the thread length. 
        It is only used in the case where the isFullLength property is false.
        """
        return _fusion.ThreadFeatureInput__get_threadLength(self)

    def _set_threadLength(self, *args) -> "bool" :
        """
        Gets and sets the thread length. 
        It is only used in the case where the isFullLength property is false.
        """
        return _fusion.ThreadFeatureInput__set_threadLength(self, *args)

    def _get_threadOffset(self) -> "adsk::core::Ptr< adsk::core::ValueInput >" :
        """
        Gets and sets the thread offset. 
        The offset is the distance along the axis of the cylinder from the edge to the start of the thread.
        It is only used in the case where the isFullLength property is false.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ThreadFeatureInput__get_threadOffset(self)

    def _set_threadOffset(self, *args) -> "bool" :
        """
        Gets and sets the thread offset. 
        The offset is the distance along the axis of the cylinder from the edge to the start of the thread.
        It is only used in the case where the isFullLength property is false.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ThreadFeatureInput__set_threadOffset(self, *args)

    def _get_threadLocation(self) -> "adsk::fusion::ThreadLocations" :
        """
        Gets and sets where the thread length is measured from.
        This property is only used in the case where the isFullLength property is false.
        """
        return _fusion.ThreadFeatureInput__get_threadLocation(self)

    def _set_threadLocation(self, *args) -> "bool" :
        """
        Gets and sets where the thread length is measured from.
        This property is only used in the case where the isFullLength property is false.
        """
        return _fusion.ThreadFeatureInput__set_threadLocation(self, *args)

    def _get_threadInfo(self) -> "adsk::core::Ptr< adsk::fusion::ThreadInfo >" :
        """Gets and sets the thread data."""
        return _fusion.ThreadFeatureInput__get_threadInfo(self)

    def _set_threadInfo(self, *args) -> "bool" :
        """Gets and sets the thread data."""
        return _fusion.ThreadFeatureInput__set_threadInfo(self, *args)

    def _get_isRightHanded(self) -> "bool" :
        """
        Gets and sets if the thread is right or left-handed thread. A value of true indicates a right-handed thread.
        It defaults to true.
        """
        return _fusion.ThreadFeatureInput__get_isRightHanded(self)

    def _set_isRightHanded(self, *args) -> "bool" :
        """
        Gets and sets if the thread is right or left-handed thread. A value of true indicates a right-handed thread.
        It defaults to true.
        """
        return _fusion.ThreadFeatureInput__set_isRightHanded(self, *args)

    def _get_inputCylindricalFaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """Gets and sets the cylindrical input faces."""
        return _fusion.ThreadFeatureInput__get_inputCylindricalFaces(self)

    def _set_inputCylindricalFaces(self, *args) -> "bool" :
        """Gets and sets the cylindrical input faces."""
        return _fusion.ThreadFeatureInput__set_inputCylindricalFaces(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ThreadFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.ThreadFeatureInput__set_targetBaseFeature(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ThreadFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ThreadFeatureInput__get_isValid(self)
ThreadFeatureInput_swigregister = _fusion.ThreadFeatureInput_swigregister
ThreadFeatureInput_swigregister(ThreadFeatureInput)

def ThreadFeatureInput_classType() -> "char const *" :
  return _fusion.ThreadFeatureInput_classType()
ThreadFeatureInput_classType = _fusion.ThreadFeatureInput_classType

ThreadFeatureInput.__swig_getmethods__["inputCylindricalFace"] = ThreadFeatureInput._get_inputCylindricalFace
ThreadFeatureInput.__swig_setmethods__["inputCylindricalFace"] = ThreadFeatureInput._set_inputCylindricalFace
ThreadFeatureInput.inputCylindricalFace = property(ThreadFeatureInput._get_inputCylindricalFace, ThreadFeatureInput._set_inputCylindricalFace, doc="Gets and sets the threaded face. In the case where there are multiple faces, only the first one is returned.\nSetting this results in a thread being applied to only a single face.\nIt is recommended that you use the inputCylindricalfaces property in order to have full access to the collection of faces\nto be threaded.")

ThreadFeatureInput.__swig_getmethods__["isModeled"] = ThreadFeatureInput._get_isModeled
ThreadFeatureInput.__swig_setmethods__["isModeled"] = ThreadFeatureInput._set_isModeled
ThreadFeatureInput.isModeled = property(ThreadFeatureInput._get_isModeled, ThreadFeatureInput._set_isModeled, doc="Gets and sets if the thread is physical or cosmetic thread. A value of true indicates a physical thread.\nIt defaults to false.")

ThreadFeatureInput.__swig_getmethods__["isFullLength"] = ThreadFeatureInput._get_isFullLength
ThreadFeatureInput.__swig_setmethods__["isFullLength"] = ThreadFeatureInput._set_isFullLength
ThreadFeatureInput.isFullLength = property(ThreadFeatureInput._get_isFullLength, ThreadFeatureInput._set_isFullLength, doc="Gets and sets if this thread is the full length of the cylinder.\nIt defaults to true.")

ThreadFeatureInput.__swig_getmethods__["threadLength"] = ThreadFeatureInput._get_threadLength
ThreadFeatureInput.__swig_setmethods__["threadLength"] = ThreadFeatureInput._set_threadLength
ThreadFeatureInput.threadLength = property(ThreadFeatureInput._get_threadLength, ThreadFeatureInput._set_threadLength, doc="Gets and sets the thread length.\nIt is only used in the case where the isFullLength property is false.")

ThreadFeatureInput.__swig_getmethods__["threadOffset"] = ThreadFeatureInput._get_threadOffset
ThreadFeatureInput.__swig_setmethods__["threadOffset"] = ThreadFeatureInput._set_threadOffset
ThreadFeatureInput.threadOffset = property(ThreadFeatureInput._get_threadOffset, ThreadFeatureInput._set_threadOffset, doc="Gets and sets the thread offset.\nThe offset is the distance along the axis of the cylinder from the edge to the start of the thread.\nIt is only used in the case where the isFullLength property is false.\nReturns nothing in the case where the feature is non-parametric.")

ThreadFeatureInput.__swig_getmethods__["threadLocation"] = ThreadFeatureInput._get_threadLocation
ThreadFeatureInput.__swig_setmethods__["threadLocation"] = ThreadFeatureInput._set_threadLocation
ThreadFeatureInput.threadLocation = property(ThreadFeatureInput._get_threadLocation, ThreadFeatureInput._set_threadLocation, doc="Gets and sets where the thread length is measured from.\nThis property is only used in the case where the isFullLength property is false.")

ThreadFeatureInput.__swig_getmethods__["threadInfo"] = ThreadFeatureInput._get_threadInfo
ThreadFeatureInput.__swig_setmethods__["threadInfo"] = ThreadFeatureInput._set_threadInfo
ThreadFeatureInput.threadInfo = property(ThreadFeatureInput._get_threadInfo, ThreadFeatureInput._set_threadInfo, doc="Gets and sets the thread data.")

ThreadFeatureInput.__swig_getmethods__["isRightHanded"] = ThreadFeatureInput._get_isRightHanded
ThreadFeatureInput.__swig_setmethods__["isRightHanded"] = ThreadFeatureInput._set_isRightHanded
ThreadFeatureInput.isRightHanded = property(ThreadFeatureInput._get_isRightHanded, ThreadFeatureInput._set_isRightHanded, doc="Gets and sets if the thread is right or left-handed thread. A value of true indicates a right-handed thread.\nIt defaults to true.")

ThreadFeatureInput.__swig_getmethods__["inputCylindricalFaces"] = ThreadFeatureInput._get_inputCylindricalFaces
ThreadFeatureInput.__swig_setmethods__["inputCylindricalFaces"] = ThreadFeatureInput._set_inputCylindricalFaces
ThreadFeatureInput.inputCylindricalFaces = property(ThreadFeatureInput._get_inputCylindricalFaces, ThreadFeatureInput._set_inputCylindricalFaces, doc="Gets and sets the cylindrical input faces.")

ThreadFeatureInput.__swig_getmethods__["targetBaseFeature"] = ThreadFeatureInput._get_targetBaseFeature
ThreadFeatureInput.__swig_setmethods__["targetBaseFeature"] = ThreadFeatureInput._set_targetBaseFeature
ThreadFeatureInput.targetBaseFeature = property(ThreadFeatureInput._get_targetBaseFeature, ThreadFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

ThreadFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ThreadFeatureInput) else None
ThreadFeatureInput.cast = lambda arg: arg if isinstance(arg, ThreadFeatureInput) else None

class ThreadFeatures(Base):
    """
    Collection that provides access to all of the existing thread features in a component
    and supports the ability to create new thread features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThreadFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThreadFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ThreadFeatures *" : return _fusion.ThreadFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ThreadFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ThreadFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.ThreadFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::ThreadFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.ThreadFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ThreadFeatures_classType
    if _newclass:classType = staticmethod(_fusion.ThreadFeatures_classType)
    __swig_destroy__ = _fusion.delete_ThreadFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::ThreadFeature >" :
        """
        Function that returns the specified thread feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.ThreadFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of thread features in the collection."""
        return _fusion.ThreadFeatures__get_count(self)

    def _get_threadDataQuery(self) -> "adsk::core::Ptr< adsk::fusion::ThreadDataQuery >" :
        """
        Property that returns the ThreadDataQuery object. 
        This object has methods to query the thread data contained in the XML files under ThreadData folder.
        It's a singleton object.
        """
        return _fusion.ThreadFeatures__get_threadDataQuery(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::ThreadFeatureInput >" :
        """
        Creates a ThreadFeatureInput object. Use properties and methods on this object
        to define the thread you want to create and then use the Add method, passing in 
        the ThreadFeatureInput object. 
        inputCylindricalFaces : A single cylindrical BRep face or a collection of cylindrical BRep faces to thread.
        A collection of faces must all be from either holes (for internal threading) or all from cylinders (for external threading).
        Both internal and external threads cannot be created in the same feature.
        The faces in a collection can come from different bodies or components. 
        threadInfo : The thread data to create the thread. 
        Returns the newly created ThreadFeatureInput object or null if the creation failed.
        """
        return _fusion.ThreadFeatures_createInput(self, *args)

    def createThreadInfo(self, *args) -> "adsk::core::Ptr< adsk::fusion::ThreadInfo >" :
        """
        Method that creates a new ThreadInfo object that can be used in creating thread features. 
        isInternal : Input Boolean that indicates if the thread is an internal or external thread. A value of true indicates an internal thread. 
        threadType : Input string that defines the thread type. 
        threadDesignation : Input string that contains the thread designation.
        This is input as the full thread designation that will be used in a drawing for the thread callout.
        The nominal size and pitch information are extracted from the designation. 
        threadClass : Input string that defines the thread class. 
        Returns the newly created ThreadInfo object or null if the creation failed.
        """
        return _fusion.ThreadFeatures_createThreadInfo(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::ThreadFeature >" :
        """
        Creates a new thread feature. 
        input : A ThreadFeatureInput object that defines the desired thread. Use the createInput 
        method to create a new ThreadFeatureInput object and then use methods on it 
        (the ThreadFeatureInput object) to define the thread. 
        Returns the newly created ThreadFeature object or null if the creation failed.
        """
        return _fusion.ThreadFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::ThreadFeature >" :
        """
        Function that returns the specified thread feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.ThreadFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.ThreadFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ThreadFeatures__get_isValid(self)
ThreadFeatures_swigregister = _fusion.ThreadFeatures_swigregister
ThreadFeatures_swigregister(ThreadFeatures)

def ThreadFeatures_classType() -> "char const *" :
  return _fusion.ThreadFeatures_classType()
ThreadFeatures_classType = _fusion.ThreadFeatures_classType

ThreadFeatures.__swig_getmethods__["count"] = ThreadFeatures._get_count
ThreadFeatures.count = property(ThreadFeatures._get_count, doc="The number of thread features in the collection.")

ThreadFeatures.__swig_getmethods__["threadDataQuery"] = ThreadFeatures._get_threadDataQuery
ThreadFeatures.threadDataQuery = property(ThreadFeatures._get_threadDataQuery, doc="Property that returns the ThreadDataQuery object.\nThis object has methods to query the thread data contained in the XML files under ThreadData folder.\nIt's a singleton object.")

ThreadFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ThreadFeatures) else None
ThreadFeatures.cast = lambda arg: arg if isinstance(arg, ThreadFeatures) else None

class ThreadInfo(Base):
    """
    This class defines the methods and properties that pertain to the thread data of a thread feature.
    If the ThreadInfo object is returned from a thread feature, setting this ThreadInfo will cause the thread feature to be edited.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThreadInfo, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThreadInfo, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ThreadInfo *" : return _fusion.ThreadInfo___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ThreadInfo___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ThreadInfo___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ThreadInfo_classType
    if _newclass:classType = staticmethod(_fusion.ThreadInfo_classType)
    __swig_destroy__ = _fusion.delete_ThreadInfo
    __del__ = lambda self : None;
    def _get_threadType(self) -> "std::string" :
        """Gets and sets the string that defines the thread type."""
        return _fusion.ThreadInfo__get_threadType(self)

    def _set_threadType(self, *args) -> "bool" :
        """Gets and sets the string that defines the thread type."""
        return _fusion.ThreadInfo__set_threadType(self, *args)

    def _get_threadSize(self) -> "std::string" :
        """Gets the string that defines the thread size."""
        return _fusion.ThreadInfo__get_threadSize(self)

    def _get_threadDesignation(self) -> "std::string" :
        """Gets and sets the string that defines the thread designation."""
        return _fusion.ThreadInfo__get_threadDesignation(self)

    def _set_threadDesignation(self, *args) -> "bool" :
        """Gets and sets the string that defines the thread designation."""
        return _fusion.ThreadInfo__set_threadDesignation(self, *args)

    def _get_threadClass(self) -> "std::string" :
        """Gets and sets the string that defines the thread class."""
        return _fusion.ThreadInfo__get_threadClass(self)

    def _set_threadClass(self, *args) -> "bool" :
        """Gets and sets the string that defines the thread class."""
        return _fusion.ThreadInfo__set_threadClass(self, *args)

    def _get_isInternal(self) -> "bool" :
        """
        Gets and sets if the thread is an internal or external thread. A value of true indicates an internal thread.
        It defaults to true.
        """
        return _fusion.ThreadInfo__get_isInternal(self)

    def _set_isInternal(self, *args) -> "bool" :
        """
        Gets and sets if the thread is an internal or external thread. A value of true indicates an internal thread.
        It defaults to true.
        """
        return _fusion.ThreadInfo__set_isInternal(self, *args)

    def _get_threadAngle(self) -> "double" :
        """Gets the value that defines the thread angle."""
        return _fusion.ThreadInfo__get_threadAngle(self)

    def _get_threadPitch(self) -> "double" :
        """Gets the value that defines the thread pitch."""
        return _fusion.ThreadInfo__get_threadPitch(self)

    def _get_majorDiameter(self) -> "double" :
        """Gets the value that defines the major diameter."""
        return _fusion.ThreadInfo__get_majorDiameter(self)

    def _get_minorDiameter(self) -> "double" :
        """Gets the value that defines the minor diameter."""
        return _fusion.ThreadInfo__get_minorDiameter(self)

    def _get_pitchDiameter(self) -> "double" :
        """Gets the value that defines the pitch diameter."""
        return _fusion.ThreadInfo__get_pitchDiameter(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ThreadInfo__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ThreadInfo__get_isValid(self)
ThreadInfo_swigregister = _fusion.ThreadInfo_swigregister
ThreadInfo_swigregister(ThreadInfo)

def ThreadInfo_classType() -> "char const *" :
  return _fusion.ThreadInfo_classType()
ThreadInfo_classType = _fusion.ThreadInfo_classType

ThreadInfo.__swig_getmethods__["threadType"] = ThreadInfo._get_threadType
ThreadInfo.__swig_setmethods__["threadType"] = ThreadInfo._set_threadType
ThreadInfo.threadType = property(ThreadInfo._get_threadType, ThreadInfo._set_threadType, doc="Gets and sets the string that defines the thread type.")

ThreadInfo.__swig_getmethods__["threadSize"] = ThreadInfo._get_threadSize
ThreadInfo.threadSize = property(ThreadInfo._get_threadSize, doc="Gets the string that defines the thread size.")

ThreadInfo.__swig_getmethods__["threadDesignation"] = ThreadInfo._get_threadDesignation
ThreadInfo.__swig_setmethods__["threadDesignation"] = ThreadInfo._set_threadDesignation
ThreadInfo.threadDesignation = property(ThreadInfo._get_threadDesignation, ThreadInfo._set_threadDesignation, doc="Gets and sets the string that defines the thread designation.")

ThreadInfo.__swig_getmethods__["threadClass"] = ThreadInfo._get_threadClass
ThreadInfo.__swig_setmethods__["threadClass"] = ThreadInfo._set_threadClass
ThreadInfo.threadClass = property(ThreadInfo._get_threadClass, ThreadInfo._set_threadClass, doc="Gets and sets the string that defines the thread class.")

ThreadInfo.__swig_getmethods__["isInternal"] = ThreadInfo._get_isInternal
ThreadInfo.__swig_setmethods__["isInternal"] = ThreadInfo._set_isInternal
ThreadInfo.isInternal = property(ThreadInfo._get_isInternal, ThreadInfo._set_isInternal, doc="Gets and sets if the thread is an internal or external thread. A value of true indicates an internal thread.\nIt defaults to true.")

ThreadInfo.__swig_getmethods__["threadAngle"] = ThreadInfo._get_threadAngle
ThreadInfo.threadAngle = property(ThreadInfo._get_threadAngle, doc="Gets the value that defines the thread angle.")

ThreadInfo.__swig_getmethods__["threadPitch"] = ThreadInfo._get_threadPitch
ThreadInfo.threadPitch = property(ThreadInfo._get_threadPitch, doc="Gets the value that defines the thread pitch.")

ThreadInfo.__swig_getmethods__["majorDiameter"] = ThreadInfo._get_majorDiameter
ThreadInfo.majorDiameter = property(ThreadInfo._get_majorDiameter, doc="Gets the value that defines the major diameter.")

ThreadInfo.__swig_getmethods__["minorDiameter"] = ThreadInfo._get_minorDiameter
ThreadInfo.minorDiameter = property(ThreadInfo._get_minorDiameter, doc="Gets the value that defines the minor diameter.")

ThreadInfo.__swig_getmethods__["pitchDiameter"] = ThreadInfo._get_pitchDiameter
ThreadInfo.pitchDiameter = property(ThreadInfo._get_pitchDiameter, doc="Gets the value that defines the pitch diameter.")

ThreadInfo.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ThreadInfo) else None
ThreadInfo.cast = lambda arg: arg if isinstance(arg, ThreadInfo) else None

class Timeline(Base):
    """A collection of TimelineObjects in a parametric design."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Timeline, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Timeline, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::Timeline *" : return _fusion.Timeline___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Timeline___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Timeline___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.Timeline___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.Timeline___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Timeline_classType
    if _newclass:classType = staticmethod(_fusion.Timeline_classType)
    __swig_destroy__ = _fusion.delete_Timeline
    __del__ = lambda self : None;
    def moveToBeginning(self) -> "bool" :
        """
        Moves the marker to the beginning of the timeline. 
        Returns true if the move is successful
        """
        return _fusion.Timeline_moveToBeginning(self)

    def moveToEnd(self) -> "bool" :
        """
        Moves the marker to the end of the timeline. 
        Returns true if the move is successful
        """
        return _fusion.Timeline_moveToEnd(self)

    def movetoNextStep(self) -> "bool" :
        """
        Moves the marker to the next step in the timeline. 
        Returns true if the move is successful
        """
        return _fusion.Timeline_movetoNextStep(self)

    def moveToPreviousStep(self) -> "bool" :
        """
        Moves the marker to the previous step in the timeline. 
        Returns true if the move is successful
        """
        return _fusion.Timeline_moveToPreviousStep(self)

    def play(self) -> "bool" :
        """
        Plays the timeline beginning at the current position of the marker. 
        Returns true if playing the timeline was successful
        """
        return _fusion.Timeline_play(self)

    def _get_markerPosition(self) -> "int" :
        """
        Gets and sets the current position of the marker where
        0 is at the beginning of the timeline and the value of Timeline.count is the end of the
        timeline.
        """
        return _fusion.Timeline__get_markerPosition(self)

    def _set_markerPosition(self, *args) -> "bool" :
        """
        Gets and sets the current position of the marker where
        0 is at the beginning of the timeline and the value of Timeline.count is the end of the
        timeline.
        """
        return _fusion.Timeline__set_markerPosition(self, *args)

    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """
        Function that returns the specified item in the timeline using an index into the collection.
        The items are returned in the order they appear in the timeline. 
        index : The index of the item within the collection to return. The first item in the collection
        has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.Timeline_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of items in the collection."""
        return _fusion.Timeline__get_count(self)

    def _get_timelineGroups(self) -> "adsk::core::Ptr< adsk::fusion::TimelineGroups >" :
        """Returns the collection of groups within the timeline."""
        return _fusion.Timeline__get_timelineGroups(self)

    def deleteAllAfterMarker(self) -> "bool" :
        """
        Deletes all objects in the timeline that are after the current position of the marker. 
        Returns true if successful.
        """
        return _fusion.Timeline_deleteAllAfterMarker(self)

    def _get_objectType(self) -> "char const *" : return _fusion.Timeline__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Timeline__get_isValid(self)
Timeline_swigregister = _fusion.Timeline_swigregister
Timeline_swigregister(Timeline)

def Timeline_classType() -> "char const *" :
  return _fusion.Timeline_classType()
Timeline_classType = _fusion.Timeline_classType

Timeline.__swig_getmethods__["markerPosition"] = Timeline._get_markerPosition
Timeline.__swig_setmethods__["markerPosition"] = Timeline._set_markerPosition
Timeline.markerPosition = property(Timeline._get_markerPosition, Timeline._set_markerPosition, doc="Gets and sets the current position of the marker where\n0 is at the beginning of the timeline and the value of Timeline.count is the end of the\ntimeline.")

Timeline.__swig_getmethods__["count"] = Timeline._get_count
Timeline.count = property(Timeline._get_count, doc="Returns the number of items in the collection.")

Timeline.__swig_getmethods__["timelineGroups"] = Timeline._get_timelineGroups
Timeline.timelineGroups = property(Timeline._get_timelineGroups, doc="Returns the collection of groups within the timeline.")

Timeline.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Timeline) else None
Timeline.cast = lambda arg: arg if isinstance(arg, Timeline) else None

class TimelineGroups(Base):
    """
    Provides access to the time line groups within a design and provides 
    methods to create new groups.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimelineGroups, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TimelineGroups, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TimelineGroups *" : return _fusion.TimelineGroups___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TimelineGroups___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TimelineGroups___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.TimelineGroups___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::TimelineGroup >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.TimelineGroups___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TimelineGroups_classType
    if _newclass:classType = staticmethod(_fusion.TimelineGroups_classType)
    __swig_destroy__ = _fusion.delete_TimelineGroups
    __del__ = lambda self : None;
    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::TimelineGroup >" :
        """
        Creates a new group within the timeline. The sequential set of items defined
        by the start and end indices will be included in the group. A group cannot contains
        another group so none of the items being grouped can be a group of this will fail. 
        startIndex : The index of the first item in the timeline that will be added to the group. 
        endIndex : The index of the last item in the timeline that will be added to the group. 
        Returns the created TimelineGroup object or null in the case of failure.
        """
        return _fusion.TimelineGroups_add(self, *args)

    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::TimelineGroup >" :
        """
        Function that returns the specified timeline group using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.TimelineGroups_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of items in the collection."""
        return _fusion.TimelineGroups__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.TimelineGroups__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TimelineGroups__get_isValid(self)
TimelineGroups_swigregister = _fusion.TimelineGroups_swigregister
TimelineGroups_swigregister(TimelineGroups)

def TimelineGroups_classType() -> "char const *" :
  return _fusion.TimelineGroups_classType()
TimelineGroups_classType = _fusion.TimelineGroups_classType

TimelineGroups.__swig_getmethods__["count"] = TimelineGroups._get_count
TimelineGroups.count = property(TimelineGroups._get_count, doc="Returns the number of items in the collection.")

TimelineGroups.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TimelineGroups) else None
TimelineGroups.cast = lambda arg: arg if isinstance(arg, TimelineGroups) else None

class TimelineObject(Base):
    """Represents an object in the timeline."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimelineObject, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TimelineObject, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TimelineObject *" : return _fusion.TimelineObject___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TimelineObject___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TimelineObject___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TimelineObject_classType
    if _newclass:classType = staticmethod(_fusion.TimelineObject_classType)
    __swig_destroy__ = _fusion.delete_TimelineObject
    __del__ = lambda self : None;
    def _get_isSuppressed(self) -> "bool" :
        """Gets and sets if this object is suppressed."""
        return _fusion.TimelineObject__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """Gets and sets if this object is suppressed."""
        return _fusion.TimelineObject__set_isSuppressed(self, *args)

    def _get_parentGroup(self) -> "adsk::core::Ptr< adsk::fusion::TimelineGroup >" :
        """
        Returns the parent group, if this object is part of a group.
        Returns null if this object is not part of a group.
        """
        return _fusion.TimelineObject__get_parentGroup(self)

    def _get_index(self) -> "int" :
        """
        Returns the position of this item within the timeline where
        the first item has an index of 0.
        This property can return -1 in the two cases where this object
        is not currently represented in the timeline. The two cases are:
        1. When this is a TimelineGroup object and the group is expanded.
        2. When this object is part of a group and the group is collapsed.
        """
        return _fusion.TimelineObject__get_index(self)

    def _get_isRolledBack(self) -> "bool" :
        """
        Indicates if this item is currently not being computed
        because it has been rolled back.
        If this is a timelineGroup object and the group is expanded
        the value of this property should be ignored.
        """
        return _fusion.TimelineObject__get_isRolledBack(self)

    def rollTo(self, *args) -> "bool" :
        """
        Rolls the timeline by repositioning the marker to either before or after this object.
        This method will fail if this is a timelineGroup object and the group is expanded. 
        rollBefore : Set rollBefore to true to reposition the marker before this object or to false to
        reposition the marker after this object 
        Returns true if the move was successful
        """
        return _fusion.TimelineObject_rollTo(self, *args)

    def _get_entity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the entity associated with this timeline object.
        Edit operations can be performed by getting the object
        representing the associated entity and using the methods
        and properties on that entity to make changes.
        Returns null if this is a TimelineGroup object
        """
        return _fusion.TimelineObject__get_entity(self)

    def canReorder(self, *args) -> "bool" :
        """
        Checks to see if this object can be reordered to the specified position.
        The default value of -1 indicates the end of the timeline.
        This method will fail if this is a timelineGroup object and the group is expanded. 
        beforeIndex : The index number of the position in the timeline to check 
        Returns true if the object can be reordered to the specified position
        """
        return _fusion.TimelineObject_canReorder(self, *args)

    def reorder(self, *args) -> "bool" :
        """
        Reorders this object to the position specified.
        The default value of -1 indicates the end of the timeline. 
        beforeIndex : The index number of the position in the timeline to place this object before 
        Returns true if the reorder operation was successful
        This method will fail and return false if this is a timelineGroup object and the 
        group is expanded.
        """
        return _fusion.TimelineObject_reorder(self, *args)

    def _get_isGroup(self) -> "bool" :
        """
        Indicates if this TimelineObject represents a group. If True you can
        operate on this object as a TimelineGroup object.
        """
        return _fusion.TimelineObject__get_isGroup(self)

    def _get_name(self) -> "std::string" :
        """
        Gets and sets the name of this timeline object. This name is shared by the object
        the timeline object represents. For example, if the TimelineObject represents a Sketch
        and you change the name using the TimelineObject, the name of the sketch in the browser
        is also changed. The reverse is also true. Setting the name of an object; sketch, feature
        construction geometry, etc, will also change the name of the associated node in the timeline.
        """
        return _fusion.TimelineObject__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """
        Gets and sets the name of this timeline object. This name is shared by the object
        the timeline object represents. For example, if the TimelineObject represents a Sketch
        and you change the name using the TimelineObject, the name of the sketch in the browser
        is also changed. The reverse is also true. Setting the name of an object; sketch, feature
        construction geometry, etc, will also change the name of the associated node in the timeline.
        """
        return _fusion.TimelineObject__set_name(self, *args)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the object associated with this TimelineObject."""
        return _fusion.TimelineObject__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.TimelineObject__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.TimelineObject__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TimelineObject__get_isValid(self)
TimelineObject_swigregister = _fusion.TimelineObject_swigregister
TimelineObject_swigregister(TimelineObject)

def TimelineObject_classType() -> "char const *" :
  return _fusion.TimelineObject_classType()
TimelineObject_classType = _fusion.TimelineObject_classType

TimelineObject.__swig_getmethods__["isSuppressed"] = TimelineObject._get_isSuppressed
TimelineObject.__swig_setmethods__["isSuppressed"] = TimelineObject._set_isSuppressed
TimelineObject.isSuppressed = property(TimelineObject._get_isSuppressed, TimelineObject._set_isSuppressed, doc="Gets and sets if this object is suppressed.")

TimelineObject.__swig_getmethods__["parentGroup"] = TimelineObject._get_parentGroup
TimelineObject.parentGroup = property(TimelineObject._get_parentGroup, doc="Returns the parent group, if this object is part of a group.\nReturns null if this object is not part of a group.")

TimelineObject.__swig_getmethods__["index"] = TimelineObject._get_index
TimelineObject.index = property(TimelineObject._get_index, doc="Returns the position of this item within the timeline where\nthe first item has an index of 0.\nThis property can return -1 in the two cases where this object\nis not currently represented in the timeline. The two cases are:\n1. When this is a TimelineGroup object and the group is expanded.\n2. When this object is part of a group and the group is collapsed.")

TimelineObject.__swig_getmethods__["isRolledBack"] = TimelineObject._get_isRolledBack
TimelineObject.isRolledBack = property(TimelineObject._get_isRolledBack, doc="Indicates if this item is currently not being computed\nbecause it has been rolled back.\nIf this is a timelineGroup object and the group is expanded\nthe value of this property should be ignored.")

TimelineObject.__swig_getmethods__["entity"] = TimelineObject._get_entity
TimelineObject.entity = property(TimelineObject._get_entity, doc="Returns the entity associated with this timeline object.\nEdit operations can be performed by getting the object\nrepresenting the associated entity and using the methods\nand properties on that entity to make changes.\nReturns null if this is a TimelineGroup object")

TimelineObject.__swig_getmethods__["isGroup"] = TimelineObject._get_isGroup
TimelineObject.isGroup = property(TimelineObject._get_isGroup, doc="Indicates if this TimelineObject represents a group. If True you can\noperate on this object as a TimelineGroup object.")

TimelineObject.__swig_getmethods__["name"] = TimelineObject._get_name
TimelineObject.__swig_setmethods__["name"] = TimelineObject._set_name
TimelineObject.name = property(TimelineObject._get_name, TimelineObject._set_name, doc="Gets and sets the name of this timeline object. This name is shared by the object\nthe timeline object represents. For example, if the TimelineObject represents a Sketch\nand you change the name using the TimelineObject, the name of the sketch in the browser\nis also changed. The reverse is also true. Setting the name of an object; sketch, feature\nconstruction geometry, etc, will also change the name of the associated node in the timeline.")

TimelineObject.__swig_getmethods__["healthState"] = TimelineObject._get_healthState
TimelineObject.healthState = property(TimelineObject._get_healthState, doc="Returns the current health state of the object associated with this TimelineObject.")

TimelineObject.__swig_getmethods__["errorOrWarningMessage"] = TimelineObject._get_errorOrWarningMessage
TimelineObject.errorOrWarningMessage = property(TimelineObject._get_errorOrWarningMessage, doc="Returns the error or warning message in the case where the healthState property returns either\nWarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.")

TimelineObject.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TimelineObject) else None
TimelineObject.cast = lambda arg: arg if isinstance(arg, TimelineObject) else None

class TorusFeatures(Base):
    """Collection that provides access to all of the existing torus features in a design."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TorusFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TorusFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TorusFeatures *" : return _fusion.TorusFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TorusFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TorusFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.TorusFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::TorusFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.TorusFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TorusFeatures_classType
    if _newclass:classType = staticmethod(_fusion.TorusFeatures_classType)
    __swig_destroy__ = _fusion.delete_TorusFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::TorusFeature >" :
        """
        Function that returns the specified torus feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.TorusFeatures_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::TorusFeature >" :
        """
        Function that returns the specified torus feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.TorusFeatures_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of torus features in the collection."""
        return _fusion.TorusFeatures__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.TorusFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TorusFeatures__get_isValid(self)
TorusFeatures_swigregister = _fusion.TorusFeatures_swigregister
TorusFeatures_swigregister(TorusFeatures)

def TorusFeatures_classType() -> "char const *" :
  return _fusion.TorusFeatures_classType()
TorusFeatures_classType = _fusion.TorusFeatures_classType

TorusFeatures.__swig_getmethods__["count"] = TorusFeatures._get_count
TorusFeatures.count = property(TorusFeatures._get_count, doc="The number of torus features in the collection.")

TorusFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TorusFeatures) else None
TorusFeatures.cast = lambda arg: arg if isinstance(arg, TorusFeatures) else None

class TriangleMesh(Base):
    """
    The TriangleMesh object represents all of the data defining
    a triangular mesh.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TriangleMesh, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TriangleMesh, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TriangleMesh *" : return _fusion.TriangleMesh___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TriangleMesh___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TriangleMesh___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TriangleMesh_classType
    if _newclass:classType = staticmethod(_fusion.TriangleMesh_classType)
    __swig_destroy__ = _fusion.delete_TriangleMesh
    __del__ = lambda self : None;
    def _get_nodeCount(self) -> "int" :
        """Returns the total number of nodes in the mesh."""
        return _fusion.TriangleMesh__get_nodeCount(self)

    def _get_nodeCoordinatesAsDouble(self) -> "std::vector< double,std::allocator< double > >" :
        """
        Returns the node coordinates as an array of doubles where
        they are the x, y, z components of each coordinate.
        """
        return _fusion.TriangleMesh__get_nodeCoordinatesAsDouble(self)

    def _get_nodeCoordinatesAsFloat(self) -> "std::vector< float,std::allocator< float > >" :
        """
        Returns the node coordinates as an array of floats where
        they are the x, y, z components of each coordinate.
        """
        return _fusion.TriangleMesh__get_nodeCoordinatesAsFloat(self)

    def _get_nodeCoordinates(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point3D >,std::allocator< adsk::core::Ptr< adsk::core::Point3D > > >" :
        """Returns the node coordinates as an array of Point3D objects."""
        return _fusion.TriangleMesh__get_nodeCoordinates(self)

    def _get_triangleCount(self) -> "int" :
        """Returns the number of triangles in the mesh."""
        return _fusion.TriangleMesh__get_triangleCount(self)

    def _get_normalVectorsAsDouble(self) -> "std::vector< double,std::allocator< double > >" :
        """
        Returns the normal vectors of the mesh where there is a normal
        vector at each node. The normals are returned as an array
        of doubles where they are the x, y, z components of each vector.
        """
        return _fusion.TriangleMesh__get_normalVectorsAsDouble(self)

    def _get_normalVectorsAsFloat(self) -> "std::vector< float,std::allocator< float > >" :
        """
        Returns the normal vectors of the mesh where there is a normal
        vector at each node. The normals are returned as an array
        of floats where they are the x, y, z components of each vector.
        """
        return _fusion.TriangleMesh__get_normalVectorsAsFloat(self)

    def _get_normalVectors(self) -> "std::vector< adsk::core::Ptr< adsk::core::Vector3D >,std::allocator< adsk::core::Ptr< adsk::core::Vector3D > > >" :
        """
        Returns the normal vectors of the mesh where there is a normal
        vector at each node. The normals are returned as an array
        of Vector3D objects.
        """
        return _fusion.TriangleMesh__get_normalVectors(self)

    def _get_nodeIndices(self) -> "std::vector< int,std::allocator< int > >" :
        """
        Returns an array of indices that define which nodes are used
        for each triangle. This is used to look-up the coordinates in the
        NodeCoordinates array to get the three coordinates of each triangle.
        """
        return _fusion.TriangleMesh__get_nodeIndices(self)

    def _get_hasTexture(self) -> "bool" :
        """
        Indicates if the associated face has an image based texture. This can only
        return true when this TriangleMesh object was obtained from a BRepFace object.
        If false, the TextureCoordinates and TextureMap properties should be ignored.
        A texture is returned by a face when an appearance has been applied
        that has an associated image based texture.
        """
        return _fusion.TriangleMesh__get_hasTexture(self)

    def _get_textureCoordinatesAsDouble(self) -> "std::vector< double,std::allocator< double > >" :
        """
        Returns the texture coordinates used when mapping a texture to
        this face. The coordinates are returned as an array of
        doubles where they are the u and v components of each
        coordinate as defined in parametric space. There is a texture
        coordinate for each vertex in the face mesh.
        """
        return _fusion.TriangleMesh__get_textureCoordinatesAsDouble(self)

    def _get_textureCoordinatesAsFloat(self) -> "std::vector< float,std::allocator< float > >" :
        """
        Returns the texture coordinates used when mapping a texture to
        this face. The coordinates are returned as an array of
        floats where they are the u and v components of each
        coordinate as defined in parametric space. There is a texture
        coordinate for each vertex in the face mesh.
        """
        return _fusion.TriangleMesh__get_textureCoordinatesAsFloat(self)

    def _get_textureCoordinates(self) -> "std::vector< adsk::core::Ptr< adsk::core::Point2D >,std::allocator< adsk::core::Ptr< adsk::core::Point2D > > >" :
        """
        Returns the texture coordinates used when mapping a texture to
        this face. The coordinates are returned as an array of
        Point2D objects where the x and y properties of the point are
        u and v coordinates as defined in parametric space. There is 
        a texture coordinate for each vertex in the face mesh.
        """
        return _fusion.TriangleMesh__get_textureCoordinates(self)

    def _get_textureImage(self) -> "adsk::core::Ptr< adsk::fusion::TextureImage >" :
        """Returns the texture image associated with the texture."""
        return _fusion.TriangleMesh__get_textureImage(self)

    def _get_surfaceTolerance(self) -> "double" :
        """
        Returns the surface tolerance that was used to generate this mesh.
        This is most useful when using display meshes that have already
        been calculated.
        """
        return _fusion.TriangleMesh__get_surfaceTolerance(self)

    def _get_objectType(self) -> "char const *" : return _fusion.TriangleMesh__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TriangleMesh__get_isValid(self)
TriangleMesh_swigregister = _fusion.TriangleMesh_swigregister
TriangleMesh_swigregister(TriangleMesh)

def TriangleMesh_classType() -> "char const *" :
  return _fusion.TriangleMesh_classType()
TriangleMesh_classType = _fusion.TriangleMesh_classType

TriangleMesh.__swig_getmethods__["nodeCount"] = TriangleMesh._get_nodeCount
TriangleMesh.nodeCount = property(TriangleMesh._get_nodeCount, doc="Returns the total number of nodes in the mesh.")

TriangleMesh.__swig_getmethods__["nodeCoordinatesAsDouble"] = TriangleMesh._get_nodeCoordinatesAsDouble
TriangleMesh.nodeCoordinatesAsDouble = property(TriangleMesh._get_nodeCoordinatesAsDouble, doc="Returns the node coordinates as an array of doubles where\nthey are the x, y, z components of each coordinate.")

TriangleMesh.__swig_getmethods__["nodeCoordinatesAsFloat"] = TriangleMesh._get_nodeCoordinatesAsFloat
TriangleMesh.nodeCoordinatesAsFloat = property(TriangleMesh._get_nodeCoordinatesAsFloat, doc="Returns the node coordinates as an array of floats where\nthey are the x, y, z components of each coordinate.")

TriangleMesh.__swig_getmethods__["nodeCoordinates"] = TriangleMesh._get_nodeCoordinates
TriangleMesh.nodeCoordinates = property(TriangleMesh._get_nodeCoordinates, doc="Returns the node coordinates as an array of Point3D objects.")

TriangleMesh.__swig_getmethods__["triangleCount"] = TriangleMesh._get_triangleCount
TriangleMesh.triangleCount = property(TriangleMesh._get_triangleCount, doc="Returns the number of triangles in the mesh.")

TriangleMesh.__swig_getmethods__["normalVectorsAsDouble"] = TriangleMesh._get_normalVectorsAsDouble
TriangleMesh.normalVectorsAsDouble = property(TriangleMesh._get_normalVectorsAsDouble, doc="Returns the normal vectors of the mesh where there is a normal\nvector at each node. The normals are returned as an array\nof doubles where they are the x, y, z components of each vector.")

TriangleMesh.__swig_getmethods__["normalVectorsAsFloat"] = TriangleMesh._get_normalVectorsAsFloat
TriangleMesh.normalVectorsAsFloat = property(TriangleMesh._get_normalVectorsAsFloat, doc="Returns the normal vectors of the mesh where there is a normal\nvector at each node. The normals are returned as an array\nof floats where they are the x, y, z components of each vector.")

TriangleMesh.__swig_getmethods__["normalVectors"] = TriangleMesh._get_normalVectors
TriangleMesh.normalVectors = property(TriangleMesh._get_normalVectors, doc="Returns the normal vectors of the mesh where there is a normal\nvector at each node. The normals are returned as an array\nof Vector3D objects.")

TriangleMesh.__swig_getmethods__["nodeIndices"] = TriangleMesh._get_nodeIndices
TriangleMesh.nodeIndices = property(TriangleMesh._get_nodeIndices, doc="Returns an array of indices that define which nodes are used\nfor each triangle. This is used to look-up the coordinates in the\nNodeCoordinates array to get the three coordinates of each triangle.")

TriangleMesh.__swig_getmethods__["hasTexture"] = TriangleMesh._get_hasTexture
TriangleMesh.hasTexture = property(TriangleMesh._get_hasTexture, doc="Indicates if the associated face has an image based texture. This can only\nreturn true when this TriangleMesh object was obtained from a BRepFace object.\nIf false, the TextureCoordinates and TextureMap properties should be ignored.\nA texture is returned by a face when an appearance has been applied\nthat has an associated image based texture.")

TriangleMesh.__swig_getmethods__["textureCoordinatesAsDouble"] = TriangleMesh._get_textureCoordinatesAsDouble
TriangleMesh.textureCoordinatesAsDouble = property(TriangleMesh._get_textureCoordinatesAsDouble, doc="Returns the texture coordinates used when mapping a texture to\nthis face. The coordinates are returned as an array of\ndoubles where they are the u and v components of each\ncoordinate as defined in parametric space. There is a texture\ncoordinate for each vertex in the face mesh.")

TriangleMesh.__swig_getmethods__["textureCoordinatesAsFloat"] = TriangleMesh._get_textureCoordinatesAsFloat
TriangleMesh.textureCoordinatesAsFloat = property(TriangleMesh._get_textureCoordinatesAsFloat, doc="Returns the texture coordinates used when mapping a texture to\nthis face. The coordinates are returned as an array of\nfloats where they are the u and v components of each\ncoordinate as defined in parametric space. There is a texture\ncoordinate for each vertex in the face mesh.")

TriangleMesh.__swig_getmethods__["textureCoordinates"] = TriangleMesh._get_textureCoordinates
TriangleMesh.textureCoordinates = property(TriangleMesh._get_textureCoordinates, doc="Returns the texture coordinates used when mapping a texture to\nthis face. The coordinates are returned as an array of\nPoint2D objects where the x and y properties of the point are\nu and v coordinates as defined in parametric space. There is\na texture coordinate for each vertex in the face mesh.")

TriangleMesh.__swig_getmethods__["textureImage"] = TriangleMesh._get_textureImage
TriangleMesh.textureImage = property(TriangleMesh._get_textureImage, doc="Returns the texture image associated with the texture.")

TriangleMesh.__swig_getmethods__["surfaceTolerance"] = TriangleMesh._get_surfaceTolerance
TriangleMesh.surfaceTolerance = property(TriangleMesh._get_surfaceTolerance, doc="Returns the surface tolerance that was used to generate this mesh.\nThis is most useful when using display meshes that have already\nbeen calculated.")

TriangleMesh.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TriangleMesh) else None
TriangleMesh.cast = lambda arg: arg if isinstance(arg, TriangleMesh) else None

class TriangleMeshCalculator(Base):
    """Used to calculate new meshes for a B-Rep or T-Spline using defined criteria."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TriangleMeshCalculator, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TriangleMeshCalculator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TriangleMeshCalculator *" : return _fusion.TriangleMeshCalculator___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TriangleMeshCalculator___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TriangleMeshCalculator___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TriangleMeshCalculator_classType
    if _newclass:classType = staticmethod(_fusion.TriangleMeshCalculator_classType)
    __swig_destroy__ = _fusion.delete_TriangleMeshCalculator
    __del__ = lambda self : None;
    def setQuality(self, *args) -> "bool" :
        """
        This is a simplified way to set the various settings that control the resulting mesh. When used it automatically 
        adjusts all of the property values appropriately. It does this for the given geometry by computing its bounding 
        box diameter. Then the surface tolerance is calculated as shown below where the meshLOD is the 'Level of Detail' and
        is described in more detail below. The diameter is the bounding box diameter.
        double nodeApproximateSize = std::pow(2.0, meshLOD); 
        double fracTol = 1.0 / nodeApproximateSize; 
        surfaceTolerance = fracTol * diameter; 
        triangleMeshQuality : The mesh quality is specified by using an item from the enum list where the following items result
        in a corresponding mesh LOD that's used in the equation above.
        LowQualityTriangleMesh: 8 
        NormalQualityTriangleMesh: 11
        HighQualityTriangleMesh: 13 
        VeryHighQualityTriangleMesh: 15 
        Returns true if setting the quality was successful.
        """
        return _fusion.TriangleMeshCalculator_setQuality(self, *args)

    def _get_surfaceTolerance(self) -> "double" :
        """
        Specifies the maximum distance that the mesh can deviate from the smooth surface. 
        The value is in centimeters. Smaller values can result in a much greater number 
        of facets being returned and will require more processing time to calculate.
        """
        return _fusion.TriangleMeshCalculator__get_surfaceTolerance(self)

    def _set_surfaceTolerance(self, *args) -> "bool" :
        """
        Specifies the maximum distance that the mesh can deviate from the smooth surface. 
        The value is in centimeters. Smaller values can result in a much greater number 
        of facets being returned and will require more processing time to calculate.
        """
        return _fusion.TriangleMeshCalculator__set_surfaceTolerance(self, *args)

    def _get_maxSideLength(self) -> "double" :
        """
        Specifies the maximum side of any triangle in the mesh. A value of 0 (the default) 
        indicates that no maximum length is specified. The value is specified in centimeters.
        """
        return _fusion.TriangleMeshCalculator__get_maxSideLength(self)

    def _set_maxSideLength(self, *args) -> "bool" :
        """
        Specifies the maximum side of any triangle in the mesh. A value of 0 (the default) 
        indicates that no maximum length is specified. The value is specified in centimeters.
        """
        return _fusion.TriangleMeshCalculator__set_maxSideLength(self, *args)

    def _get_maxAspectRatio(self) -> "double" :
        """
        Specifies the maximum length to height ratio that a triangle can have. 
        This helps to avoid long skinny triangles. A value of 0 (the default) 
        indicates that no maximum aspect ratio is specified.
        """
        return _fusion.TriangleMeshCalculator__get_maxAspectRatio(self)

    def _set_maxAspectRatio(self, *args) -> "bool" :
        """
        Specifies the maximum length to height ratio that a triangle can have. 
        This helps to avoid long skinny triangles. A value of 0 (the default) 
        indicates that no maximum aspect ratio is specified.
        """
        return _fusion.TriangleMeshCalculator__set_maxAspectRatio(self, *args)

    def _get_maxNormalDeviation(self) -> "double" :
        """
        Specifies the maximum deviation between adjacent vertex normals. 
        This value is the maximum angle allowed between normals and is 
        specified in radians. A value of 0 (the default) indicates that no normal deviation is specified.
        """
        return _fusion.TriangleMeshCalculator__get_maxNormalDeviation(self)

    def _set_maxNormalDeviation(self, *args) -> "bool" :
        """
        Specifies the maximum deviation between adjacent vertex normals. 
        This value is the maximum angle allowed between normals and is 
        specified in radians. A value of 0 (the default) indicates that no normal deviation is specified.
        """
        return _fusion.TriangleMeshCalculator__set_maxNormalDeviation(self, *args)

    def calculate(self) -> "adsk::core::Ptr< adsk::fusion::TriangleMesh >" :
        """
        Calculates a new triangle mesh based on the current settings. 
        Returns the new TriangleMesh object or null in the case where the calculation failed.
        """
        return _fusion.TriangleMeshCalculator_calculate(self)

    def _get_parentMeshManager(self) -> "adsk::core::Ptr< adsk::fusion::MeshManager >" :
        """Returns the parent MeshManager object."""
        return _fusion.TriangleMeshCalculator__get_parentMeshManager(self)

    def _get_objectType(self) -> "char const *" : return _fusion.TriangleMeshCalculator__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TriangleMeshCalculator__get_isValid(self)
TriangleMeshCalculator_swigregister = _fusion.TriangleMeshCalculator_swigregister
TriangleMeshCalculator_swigregister(TriangleMeshCalculator)

def TriangleMeshCalculator_classType() -> "char const *" :
  return _fusion.TriangleMeshCalculator_classType()
TriangleMeshCalculator_classType = _fusion.TriangleMeshCalculator_classType

TriangleMeshCalculator.__swig_getmethods__["surfaceTolerance"] = TriangleMeshCalculator._get_surfaceTolerance
TriangleMeshCalculator.__swig_setmethods__["surfaceTolerance"] = TriangleMeshCalculator._set_surfaceTolerance
TriangleMeshCalculator.surfaceTolerance = property(TriangleMeshCalculator._get_surfaceTolerance, TriangleMeshCalculator._set_surfaceTolerance, doc="Specifies the maximum distance that the mesh can deviate from the smooth surface.\nThe value is in centimeters. Smaller values can result in a much greater number\nof facets being returned and will require more processing time to calculate.")

TriangleMeshCalculator.__swig_getmethods__["maxSideLength"] = TriangleMeshCalculator._get_maxSideLength
TriangleMeshCalculator.__swig_setmethods__["maxSideLength"] = TriangleMeshCalculator._set_maxSideLength
TriangleMeshCalculator.maxSideLength = property(TriangleMeshCalculator._get_maxSideLength, TriangleMeshCalculator._set_maxSideLength, doc="Specifies the maximum side of any triangle in the mesh. A value of 0 (the default)\nindicates that no maximum length is specified. The value is specified in centimeters.")

TriangleMeshCalculator.__swig_getmethods__["maxAspectRatio"] = TriangleMeshCalculator._get_maxAspectRatio
TriangleMeshCalculator.__swig_setmethods__["maxAspectRatio"] = TriangleMeshCalculator._set_maxAspectRatio
TriangleMeshCalculator.maxAspectRatio = property(TriangleMeshCalculator._get_maxAspectRatio, TriangleMeshCalculator._set_maxAspectRatio, doc="Specifies the maximum length to height ratio that a triangle can have.\nThis helps to avoid long skinny triangles. A value of 0 (the default)\nindicates that no maximum aspect ratio is specified.")

TriangleMeshCalculator.__swig_getmethods__["maxNormalDeviation"] = TriangleMeshCalculator._get_maxNormalDeviation
TriangleMeshCalculator.__swig_setmethods__["maxNormalDeviation"] = TriangleMeshCalculator._set_maxNormalDeviation
TriangleMeshCalculator.maxNormalDeviation = property(TriangleMeshCalculator._get_maxNormalDeviation, TriangleMeshCalculator._set_maxNormalDeviation, doc="Specifies the maximum deviation between adjacent vertex normals.\nThis value is the maximum angle allowed between normals and is\nspecified in radians. A value of 0 (the default) indicates that no normal deviation is specified.")

TriangleMeshCalculator.__swig_getmethods__["parentMeshManager"] = TriangleMeshCalculator._get_parentMeshManager
TriangleMeshCalculator.parentMeshManager = property(TriangleMeshCalculator._get_parentMeshManager, doc="Returns the parent MeshManager object.")

TriangleMeshCalculator.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TriangleMeshCalculator) else None
TriangleMeshCalculator.cast = lambda arg: arg if isinstance(arg, TriangleMeshCalculator) else None

class TriangleMeshList(Base):
    """Provides access to a set of triangle meshes."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TriangleMeshList, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TriangleMeshList, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TriangleMeshList *" : return _fusion.TriangleMeshList___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TriangleMeshList___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TriangleMeshList___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.TriangleMeshList___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::TriangleMesh >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.TriangleMeshList___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TriangleMeshList_classType
    if _newclass:classType = staticmethod(_fusion.TriangleMeshList_classType)
    __swig_destroy__ = _fusion.delete_TriangleMeshList
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::TriangleMesh >" :
        """
        Returns the specified triangle meshes. 
        index : The index of the mesh to return where the first item has an index of 0. 
        Returns the specified mesh or null in the case of invalid index.
        """
        return _fusion.TriangleMeshList_item(self, *args)

    def _get_bestMesh(self) -> "adsk::core::Ptr< adsk::fusion::TriangleMesh >" :
        """
        Returns the mesh with the tightest surface tolerance. This can return null
        in the case the list is empty, ie. Count is 0.
        """
        return _fusion.TriangleMeshList__get_bestMesh(self)

    def _get_count(self) -> "size_t" :
        """Returns the number of meshes in the collection."""
        return _fusion.TriangleMeshList__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.TriangleMeshList__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TriangleMeshList__get_isValid(self)
TriangleMeshList_swigregister = _fusion.TriangleMeshList_swigregister
TriangleMeshList_swigregister(TriangleMeshList)

def TriangleMeshList_classType() -> "char const *" :
  return _fusion.TriangleMeshList_classType()
TriangleMeshList_classType = _fusion.TriangleMeshList_classType

TriangleMeshList.__swig_getmethods__["bestMesh"] = TriangleMeshList._get_bestMesh
TriangleMeshList.bestMesh = property(TriangleMeshList._get_bestMesh, doc="Returns the mesh with the tightest surface tolerance. This can return null\nin the case the list is empty, ie. Count is 0.")

TriangleMeshList.__swig_getmethods__["count"] = TriangleMeshList._get_count
TriangleMeshList.count = property(TriangleMeshList._get_count, doc="Returns the number of meshes in the collection.")

TriangleMeshList.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TriangleMeshList) else None
TriangleMeshList.cast = lambda arg: arg if isinstance(arg, TriangleMeshList) else None

class TrimFeatureInput(Base):
    """This class defines the methods and properties that pertain to the definition of a TrimFeatureInput."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TrimFeatureInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TrimFeatureInput, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TrimFeatureInput *" : return _fusion.TrimFeatureInput___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TrimFeatureInput___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TrimFeatureInput___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TrimFeatureInput_classType
    if _newclass:classType = staticmethod(_fusion.TrimFeatureInput_classType)
    __swig_destroy__ = _fusion.delete_TrimFeatureInput
    __del__ = lambda self : None;
    def _get_bRepCells(self) -> "adsk::core::Ptr< adsk::fusion::BRepCells >" :
        """
        Returns the collection of the valid cells that have been calculated based on the trim tool.
        Use this collection to specify which cells to trim away.
        """
        return _fusion.TrimFeatureInput__get_bRepCells(self)

    def _get_trimTool(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets and sets the entity (a patch body, B-Rep face, construction plane or sketch curve) that intersects the trim tool"""
        return _fusion.TrimFeatureInput__get_trimTool(self)

    def _set_trimTool(self, *args) -> "bool" :
        """Gets and sets the entity (a patch body, B-Rep face, construction plane or sketch curve) that intersects the trim tool"""
        return _fusion.TrimFeatureInput__set_trimTool(self, *args)

    def _get_targetBaseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.TrimFeatureInput__get_targetBaseFeature(self)

    def _set_targetBaseFeature(self, *args) -> "bool" :
        """
        When creating a feature that is owned by a base feature, set this property to the 
        base feature you want to associate the new feature with. By default, this is null,
        meaning it will not be associated with a base feature.
        Because of a current limitation, if you want to create a feature associated with a base
        feature, you must set this property AND call the startEdit method of the base feature,
        create the feature, and then call the finishEdit method of the base feature. The base
        feature must be in an 'edit' state to be able to add any additional items to it.
        """
        return _fusion.TrimFeatureInput__set_targetBaseFeature(self, *args)

    def cancel(self) -> "bool" :
        """
        To determine the possible boundaries and allow you to choose which cells to keep, the trim 
        feature does a partial compute when the input object is created. To do this it starts a trim
        feature transaction and completes the transaction when you call the add method. If you don't 
        call the add method it leaves Fusion 360 in a bad state and there will be undo problems and it 
        will possibly crash. If you have created a TrimFeatureInput object and don't want to finish
        the feature creation, you need to call the cancel method on the TrimFeatureInput object to 
        safely abort the current trim feature transaction.
        """
        return _fusion.TrimFeatureInput_cancel(self)

    def _get_objectType(self) -> "char const *" : return _fusion.TrimFeatureInput__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TrimFeatureInput__get_isValid(self)
TrimFeatureInput_swigregister = _fusion.TrimFeatureInput_swigregister
TrimFeatureInput_swigregister(TrimFeatureInput)

def TrimFeatureInput_classType() -> "char const *" :
  return _fusion.TrimFeatureInput_classType()
TrimFeatureInput_classType = _fusion.TrimFeatureInput_classType

TrimFeatureInput.__swig_getmethods__["bRepCells"] = TrimFeatureInput._get_bRepCells
TrimFeatureInput.bRepCells = property(TrimFeatureInput._get_bRepCells, doc="Returns the collection of the valid cells that have been calculated based on the trim tool.\nUse this collection to specify which cells to trim away.")

TrimFeatureInput.__swig_getmethods__["trimTool"] = TrimFeatureInput._get_trimTool
TrimFeatureInput.__swig_setmethods__["trimTool"] = TrimFeatureInput._set_trimTool
TrimFeatureInput.trimTool = property(TrimFeatureInput._get_trimTool, TrimFeatureInput._set_trimTool, doc="Gets and sets the entity (a patch body, B-Rep face, construction plane or sketch curve) that intersects the trim tool")

TrimFeatureInput.__swig_getmethods__["targetBaseFeature"] = TrimFeatureInput._get_targetBaseFeature
TrimFeatureInput.__swig_setmethods__["targetBaseFeature"] = TrimFeatureInput._set_targetBaseFeature
TrimFeatureInput.targetBaseFeature = property(TrimFeatureInput._get_targetBaseFeature, TrimFeatureInput._set_targetBaseFeature, doc="When creating a feature that is owned by a base feature, set this property to the\nbase feature you want to associate the new feature with. By default, this is null,\nmeaning it will not be associated with a base feature.\nBecause of a current limitation, if you want to create a feature associated with a base\nfeature, you must set this property AND call the startEdit method of the base feature,\ncreate the feature, and then call the finishEdit method of the base feature. The base\nfeature must be in an 'edit' state to be able to add any additional items to it.")

TrimFeatureInput.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TrimFeatureInput) else None
TrimFeatureInput.cast = lambda arg: arg if isinstance(arg, TrimFeatureInput) else None

class TrimFeatures(Base):
    """
    Collection that provides access to all of the existing trim features in a component
    and supports the ability to create new trim features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TrimFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TrimFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TrimFeatures *" : return _fusion.TrimFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TrimFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TrimFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.TrimFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::TrimFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.TrimFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TrimFeatures_classType
    if _newclass:classType = staticmethod(_fusion.TrimFeatures_classType)
    __swig_destroy__ = _fusion.delete_TrimFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::TrimFeature >" :
        """
        Function that returns the specified trim feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.TrimFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of trim features in the collection."""
        return _fusion.TrimFeatures__get_count(self)

    def createInput(self, *args) -> "adsk::core::Ptr< adsk::fusion::TrimFeatureInput >" :
        """
        Creates a TrimFeatureInput object. Use properties and methods on this object
        to define the trim feature you want to create and then use the Add method, passing in 
        the TrimFeatureInput object.
        To determine the possible boundaries and allow you to choose which cells to keep, the trim
        feature does a partial compute when the input object is created. To do this it starts a trim
        feature transaction and completes the transaction when you call the add method. If you don't call
        the add method to finish the transaction it leaves Fusion 360 in a bad state and there will be undo
        problems and possibly a crash. If you have created a TrimFeatureInput object and don't want to 
        finish the feature creation, you need to call the cancel method on the TrimFeatureInput object to 
        safely abort the current boundary fill transaction. 
        trimTool : A patch body, B-Rep face, construction plane or sketch curve that intersects the surface or surfaces to be trimmed 
        Returns the newly created TrimFeatureInput object or null if the creation failed.
        """
        return _fusion.TrimFeatures_createInput(self, *args)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::TrimFeature >" :
        """
        Creates a new trim feature. 
        input : A TrimFeatureInput object that defines the desired trim feature. Use the createInput 
        method to create a new TrimFeatureInput object and then use methods on it 
        (the TrimFeatureInput object) to define the trim feature. 
        Returns the newly created TrimFeature object or null if the creation failed.
        """
        return _fusion.TrimFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::TrimFeature >" :
        """
        Function that returns the specified trim feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.TrimFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.TrimFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TrimFeatures__get_isValid(self)
TrimFeatures_swigregister = _fusion.TrimFeatures_swigregister
TrimFeatures_swigregister(TrimFeatures)

def TrimFeatures_classType() -> "char const *" :
  return _fusion.TrimFeatures_classType()
TrimFeatures_classType = _fusion.TrimFeatures_classType

TrimFeatures.__swig_getmethods__["count"] = TrimFeatures._get_count
TrimFeatures.count = property(TrimFeatures._get_count, doc="The number of trim features in the collection.")

TrimFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TrimFeatures) else None
TrimFeatures.cast = lambda arg: arg if isinstance(arg, TrimFeatures) else None

class TSplineBodies(Base):
    """A collection of TSpline bodies."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TSplineBodies, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TSplineBodies, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TSplineBodies *" : return _fusion.TSplineBodies___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TSplineBodies___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TSplineBodies___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.TSplineBodies___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::TSplineBody >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.TSplineBodies___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TSplineBodies_classType
    if _newclass:classType = staticmethod(_fusion.TSplineBodies_classType)
    __swig_destroy__ = _fusion.delete_TSplineBodies
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::TSplineBody >" :
        """
        Function that returns the specified T-Spline body using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.TSplineBodies_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of bodies in the collection."""
        return _fusion.TSplineBodies__get_count(self)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::TSplineBody >" :
        """
        Returns a TSplineBody by specifying the name of the body as seen in the browser. 
        name : The name of the body, as seen in the browser. This is case sensitive. 
        Returns the specified item or null if a body with that name was not found.
        """
        return _fusion.TSplineBodies_itemByName(self, *args)

    def addByTSMFile(self, *args) -> "adsk::core::Ptr< adsk::fusion::TSplineBody >" :
        """
        Creates a new TSplineBody by reading in a TSM file from disk. 
        tsmFilename : The full filename of the TSM file on disk. 
        Returns the newly created TSplineBody if successful or null in the case of failure.
        """
        return _fusion.TSplineBodies_addByTSMFile(self, *args)

    def addByTSMDescription(self, *args) -> "adsk::core::Ptr< adsk::fusion::TSplineBody >" :
        """
        Creates a new TSplineBody using the T-Spline description provided by the input
        string which contains TSM formatted text. 
        tsmDescription : A string that contains a T-Spline description in TSM form. 
        Returns the newly created TSplineBody if successful or null in the case of failure.
        """
        return _fusion.TSplineBodies_addByTSMDescription(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.TSplineBodies__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TSplineBodies__get_isValid(self)
TSplineBodies_swigregister = _fusion.TSplineBodies_swigregister
TSplineBodies_swigregister(TSplineBodies)

def TSplineBodies_classType() -> "char const *" :
  return _fusion.TSplineBodies_classType()
TSplineBodies_classType = _fusion.TSplineBodies_classType

TSplineBodies.__swig_getmethods__["count"] = TSplineBodies._get_count
TSplineBodies.count = property(TSplineBodies._get_count, doc="The number of bodies in the collection.")

TSplineBodies.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TSplineBodies) else None
TSplineBodies.cast = lambda arg: arg if isinstance(arg, TSplineBodies) else None

class TSplineBody(Base):
    """A TSpline body."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TSplineBody, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TSplineBody, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TSplineBody *" : return _fusion.TSplineBody___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TSplineBody___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TSplineBody___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TSplineBody_classType
    if _newclass:classType = staticmethod(_fusion.TSplineBody_classType)
    __swig_destroy__ = _fusion.delete_TSplineBody
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """
        Gets and sets the name of the body. If setting this property, there is the side-effect
        that the B-Rep body created from this T-Spline body is also renamed.
        """
        return _fusion.TSplineBody__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """
        Gets and sets the name of the body. If setting this property, there is the side-effect
        that the B-Rep body created from this T-Spline body is also renamed.
        """
        return _fusion.TSplineBody__set_name(self, *args)

    def getTSMDescription(self) -> "std::string" :
        """
        Returns the T-Spline body as a string in the form of a TSM description. 
        Returns the string formatted using the TSM format.
        """
        return _fusion.TSplineBody_getTSMDescription(self)

    def saveAsTSMFile(self, *args) -> "bool" :
        """
        Saves the body as a TSM file. 
        filename : The full filename of the file to save the body to. If the file already exists,
        it will be overwritten. 
        Returns true if the file was successfully created.
        """
        return _fusion.TSplineBody_saveAsTSMFile(self, *args)

    def _get_parentFormFeature(self) -> "adsk::core::Ptr< adsk::fusion::FormFeature >" :
        """Returns the owning form feature."""
        return _fusion.TSplineBody__get_parentFormFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.TSplineBody__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TSplineBody__get_isValid(self)
TSplineBody_swigregister = _fusion.TSplineBody_swigregister
TSplineBody_swigregister(TSplineBody)

def TSplineBody_classType() -> "char const *" :
  return _fusion.TSplineBody_classType()
TSplineBody_classType = _fusion.TSplineBody_classType

TSplineBody.__swig_getmethods__["name"] = TSplineBody._get_name
TSplineBody.__swig_setmethods__["name"] = TSplineBody._set_name
TSplineBody.name = property(TSplineBody._get_name, TSplineBody._set_name, doc="Gets and sets the name of the body. If setting this property, there is the side-effect\nthat the B-Rep body created from this T-Spline body is also renamed.")

TSplineBody.__swig_getmethods__["parentFormFeature"] = TSplineBody._get_parentFormFeature
TSplineBody.parentFormFeature = property(TSplineBody._get_parentFormFeature, doc="Returns the owning form feature.")

TSplineBody.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TSplineBody) else None
TSplineBody.cast = lambda arg: arg if isinstance(arg, TSplineBody) else None

class UnstitchFeatures(Base):
    """
    Collection that provides access to all of the existing Unstitch features in a component
    and supports the ability to create new Unstitch features.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UnstitchFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UnstitchFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::UnstitchFeatures *" : return _fusion.UnstitchFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.UnstitchFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.UnstitchFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.UnstitchFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::UnstitchFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.UnstitchFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.UnstitchFeatures_classType
    if _newclass:classType = staticmethod(_fusion.UnstitchFeatures_classType)
    __swig_destroy__ = _fusion.delete_UnstitchFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::UnstitchFeature >" :
        """
        Function that returns the specified Unstitch feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.UnstitchFeatures_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of Unstitch features in the collection."""
        return _fusion.UnstitchFeatures__get_count(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::UnstitchFeature >" :
        """
        Creates a new Unstitch feature. 
        faces : The faces and/or bodies to Unstitch. Individual faces can be unstitched from solid and/or patch bodies. The faces being unstitched
        need not all come from the same body. 
        isChainSelection : A boolean value for setting whether or not faces that are connected and adjacent to 
        the input faces will be included in the selection. The default value is true. 
        Returns the newly created UnstitchFeature object or null if the creation failed.
        """
        return _fusion.UnstitchFeatures_add(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::UnstitchFeature >" :
        """
        Function that returns the specified unstitch feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.UnstitchFeatures_itemByName(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.UnstitchFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.UnstitchFeatures__get_isValid(self)
UnstitchFeatures_swigregister = _fusion.UnstitchFeatures_swigregister
UnstitchFeatures_swigregister(UnstitchFeatures)

def UnstitchFeatures_classType() -> "char const *" :
  return _fusion.UnstitchFeatures_classType()
UnstitchFeatures_classType = _fusion.UnstitchFeatures_classType

UnstitchFeatures.__swig_getmethods__["count"] = UnstitchFeatures._get_count
UnstitchFeatures.count = property(UnstitchFeatures._get_count, doc="The number of Unstitch features in the collection.")

UnstitchFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, UnstitchFeatures) else None
UnstitchFeatures.cast = lambda arg: arg if isinstance(arg, UnstitchFeatures) else None

class UserParameters(Base):
    """
    Provides access to the User Parameters within a design and provides 
    methods to create new user parameters.
    """
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UserParameters, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UserParameters, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::UserParameters *" : return _fusion.UserParameters___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.UserParameters___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.UserParameters___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.UserParameters___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::UserParameter >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.UserParameters___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.UserParameters_classType
    if _newclass:classType = staticmethod(_fusion.UserParameters_classType)
    __swig_destroy__ = _fusion.delete_UserParameters
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::UserParameter >" :
        """
        Function that returns the specified User Parameter using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection 
        has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.UserParameters_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::UserParameter >" :
        """
        Function that returns the specified User Parameter using the name of the parameter 
        as it is displayed in the parameters dialog. 
        name : The name of the User Parameter as it is displayed in the parameters dialog 
        Returns the specified item or null if an invalid name was specified.
        """
        return _fusion.UserParameters_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of parameters in the collection."""
        return _fusion.UserParameters__get_count(self)

    def _get_design(self) -> "adsk::core::Ptr< adsk::fusion::Design >" :
        """Returns the design that owns the user parameters collection."""
        return _fusion.UserParameters__get_design(self)

    def add(self, *args) -> "adsk::core::Ptr< adsk::fusion::UserParameter >" :
        """
        Adds a new user parameter to the collection. 
        name : The name of the parameter. This is the name shown in the parameters dialog 
        value : ValueInput object that specifies the offset distance. If the ValueInput was created using
        a real, the value will be interpreted using the internal unit for the unit type specified by
        the 'units' argument. For example, if the ValueInput was created using the real value 5 and
        the input to a 'units' argument is any valid length unit the value will be interpreted at 5
        centimeters. If the 'units' argument is a valid angle unit then the value will be interpreted
        as 5 radians.
        If the ValueInput was created using a string, the string is used as-is for the expression of
        the parameter. This means it must evaluate to the same unit type as that specified by the
        'units' argument and if no type is specified it will use the current default units specified
        for the current document. For example, if the ValueInput was created with the string '5 in',
        then the 'units' argument must define any valid length so they are compatible. If the 'units'
        argument is 'cm' a parameter with the unit type of centimeter will be created and it will have
        the expression '5 in'.
        When using a ValueInput created using a string, it's the same as creating a ValueInput in the
        user-interface. You can specify any valid expression, i.e. '5', '5 in', '5 in / 2', '5 + Length', etc.
        and you can choose from many different types of units. The only requirement is that the units
        must match in type. For example, they must both be lengths, or they must both be angles, etc. 
        units : The units to use for the value of the parameter. 
        Units specified must match the units specified (if any) in the ValueInput object.
        To create a parameter with no units you can specify either an empty string. 
        comment : The comment to display in the parameters dialog. Specify an empty string ('') for no comment 
        Returns the newly created UserParameter or null if the creation failed.
        """
        return _fusion.UserParameters_add(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.UserParameters__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.UserParameters__get_isValid(self)
UserParameters_swigregister = _fusion.UserParameters_swigregister
UserParameters_swigregister(UserParameters)

def UserParameters_classType() -> "char const *" :
  return _fusion.UserParameters_classType()
UserParameters_classType = _fusion.UserParameters_classType

UserParameters.__swig_getmethods__["count"] = UserParameters._get_count
UserParameters.count = property(UserParameters._get_count, doc="Returns the number of parameters in the collection.")

UserParameters.__swig_getmethods__["design"] = UserParameters._get_design
UserParameters.design = property(UserParameters._get_design, doc="Returns the design that owns the user parameters collection.")

UserParameters.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, UserParameters) else None
UserParameters.cast = lambda arg: arg if isinstance(arg, UserParameters) else None

class WebFeatures(Base):
    """Collection that provides access to all of the existing web features in a design."""
    __swig_setmethods__ = {}
    for _s in [Base]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WebFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [Base]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WebFeatures, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::WebFeatures *" : return _fusion.WebFeatures___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.WebFeatures___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.WebFeatures___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.WebFeatures___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::WebFeature >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.WebFeatures___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.WebFeatures_classType
    if _newclass:classType = staticmethod(_fusion.WebFeatures_classType)
    __swig_destroy__ = _fusion.delete_WebFeatures
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::WebFeature >" :
        """
        Function that returns the specified web feature using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.WebFeatures_item(self, *args)

    def itemByName(self, *args) -> "adsk::core::Ptr< adsk::fusion::WebFeature >" :
        """
        Function that returns the specified web feature using the name of the feature. 
        name : The name of the feature within the collection to return. This is the name seen in the timeline. 
        Returns the specified item or null if the specified name was not found.
        """
        return _fusion.WebFeatures_itemByName(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of web features in the collection."""
        return _fusion.WebFeatures__get_count(self)

    def _get_objectType(self) -> "char const *" : return _fusion.WebFeatures__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.WebFeatures__get_isValid(self)
WebFeatures_swigregister = _fusion.WebFeatures_swigregister
WebFeatures_swigregister(WebFeatures)

def WebFeatures_classType() -> "char const *" :
  return _fusion.WebFeatures_classType()
WebFeatures_classType = _fusion.WebFeatures_classType

WebFeatures.__swig_getmethods__["count"] = WebFeatures._get_count
WebFeatures.count = property(WebFeatures._get_count, doc="The number of web features in the collection.")

WebFeatures.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, WebFeatures) else None
WebFeatures.cast = lambda arg: arg if isinstance(arg, WebFeatures) else None

class AllExtentDefinition(ExtentDefinition):
    """
    Defines the inputs for a AllExtentDefinition object. 
    This defines a feature extent where the direction can be positive, negative, or symmetric. 
    Setting the direction to Symmetric specifies that the extrusion is through-all, 
    and goes in both directions.
    """
    __swig_setmethods__ = {}
    for _s in [ExtentDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AllExtentDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ExtentDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AllExtentDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::AllExtentDefinition *" : return _fusion.AllExtentDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.AllExtentDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.AllExtentDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.AllExtentDefinition_classType
    if _newclass:classType = staticmethod(_fusion.AllExtentDefinition_classType)
    __swig_destroy__ = _fusion.delete_AllExtentDefinition
    __del__ = lambda self : None;
    def _get_direction(self) -> "adsk::fusion::ExtentDirections" :
        """Gets and sets the direction of the extent."""
        return _fusion.AllExtentDefinition__get_direction(self)

    def _set_direction(self, *args) -> "bool" :
        """Gets and sets the direction of the extent."""
        return _fusion.AllExtentDefinition__set_direction(self, *args)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        """
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.AllExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.AllExtentDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.AllExtentDefinition__get_isValid(self)
AllExtentDefinition_swigregister = _fusion.AllExtentDefinition_swigregister
AllExtentDefinition_swigregister(AllExtentDefinition)

def AllExtentDefinition_classType() -> "char const *" :
  return _fusion.AllExtentDefinition_classType()
AllExtentDefinition_classType = _fusion.AllExtentDefinition_classType

AllExtentDefinition.__swig_getmethods__["direction"] = AllExtentDefinition._get_direction
AllExtentDefinition.__swig_setmethods__["direction"] = AllExtentDefinition._set_direction
AllExtentDefinition.direction = property(AllExtentDefinition._get_direction, AllExtentDefinition._set_direction, doc="Gets and sets the direction of the extent.")

AllExtentDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, AllExtentDefinition) else None
AllExtentDefinition.cast = lambda arg: arg if isinstance(arg, AllExtentDefinition) else None

class AngleExtentDefinition(ExtentDefinition):
    """
    Defines the inputs for a AngleExtentDefinition object.
    This feature extent is defined by an angle as well as whether the extent is symmetric or only in one direction.
    If the extent is not symmetric, a positive or negative angle can be used to control the direction.
    """
    __swig_setmethods__ = {}
    for _s in [ExtentDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AngleExtentDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ExtentDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AngleExtentDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::AngleExtentDefinition *" : return _fusion.AngleExtentDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.AngleExtentDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.AngleExtentDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.AngleExtentDefinition_classType
    if _newclass:classType = staticmethod(_fusion.AngleExtentDefinition_classType)
    __swig_destroy__ = _fusion.delete_AngleExtentDefinition
    __del__ = lambda self : None;
    def _get_isSymmetric(self) -> "bool" :
        """
        Gets and sets if the angle extent is in one direction or symmetric.
        For a hole this property will always return false and setting it is ignored.
        """
        return _fusion.AngleExtentDefinition__get_isSymmetric(self)

    def _set_isSymmetric(self, *args) -> "bool" :
        """
        Gets and sets if the angle extent is in one direction or symmetric.
        For a hole this property will always return false and setting it is ignored.
        """
        return _fusion.AngleExtentDefinition__set_isSymmetric(self, *args)

    def _get_angle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the ModelParameter that defines the angle. The value of the angle can be edited
        by using the properties on the ModelParameter object to edit the parameter.
        """
        return _fusion.AngleExtentDefinition__get_angle(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        """
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.AngleExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.AngleExtentDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.AngleExtentDefinition__get_isValid(self)
AngleExtentDefinition_swigregister = _fusion.AngleExtentDefinition_swigregister
AngleExtentDefinition_swigregister(AngleExtentDefinition)

def AngleExtentDefinition_classType() -> "char const *" :
  return _fusion.AngleExtentDefinition_classType()
AngleExtentDefinition_classType = _fusion.AngleExtentDefinition_classType

AngleExtentDefinition.__swig_getmethods__["isSymmetric"] = AngleExtentDefinition._get_isSymmetric
AngleExtentDefinition.__swig_setmethods__["isSymmetric"] = AngleExtentDefinition._set_isSymmetric
AngleExtentDefinition.isSymmetric = property(AngleExtentDefinition._get_isSymmetric, AngleExtentDefinition._set_isSymmetric, doc="Gets and sets if the angle extent is in one direction or symmetric.\nFor a hole this property will always return false and setting it is ignored.")

AngleExtentDefinition.__swig_getmethods__["angle"] = AngleExtentDefinition._get_angle
AngleExtentDefinition.angle = property(AngleExtentDefinition._get_angle, doc="Gets the ModelParameter that defines the angle. The value of the angle can be edited\nby using the properties on the ModelParameter object to edit the parameter.")

AngleExtentDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, AngleExtentDefinition) else None
AngleExtentDefinition.cast = lambda arg: arg if isinstance(arg, AngleExtentDefinition) else None

class AtCenterHolePositionDefinition(HolePositionDefinition):
    """
    Provides positioning information for a hole that is positioned at the center of a 
    circular or elliptical edge.
    """
    __swig_setmethods__ = {}
    for _s in [HolePositionDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AtCenterHolePositionDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [HolePositionDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AtCenterHolePositionDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::AtCenterHolePositionDefinition *" : return _fusion.AtCenterHolePositionDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.AtCenterHolePositionDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.AtCenterHolePositionDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.AtCenterHolePositionDefinition_classType
    if _newclass:classType = staticmethod(_fusion.AtCenterHolePositionDefinition_classType)
    __swig_destroy__ = _fusion.delete_AtCenterHolePositionDefinition
    __del__ = lambda self : None;
    def _get_planarEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the plane that defines the orientation and start of the hole."""
        return _fusion.AtCenterHolePositionDefinition__get_planarEntity(self)

    def _get_centerEdge(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdge >" :
        """Returns the circular or elliptical edge the hole is centered at."""
        return _fusion.AtCenterHolePositionDefinition__get_centerEdge(self)

    def _get_objectType(self) -> "char const *" : return _fusion.AtCenterHolePositionDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.AtCenterHolePositionDefinition__get_isValid(self)
AtCenterHolePositionDefinition_swigregister = _fusion.AtCenterHolePositionDefinition_swigregister
AtCenterHolePositionDefinition_swigregister(AtCenterHolePositionDefinition)

def AtCenterHolePositionDefinition_classType() -> "char const *" :
  return _fusion.AtCenterHolePositionDefinition_classType()
AtCenterHolePositionDefinition_classType = _fusion.AtCenterHolePositionDefinition_classType

AtCenterHolePositionDefinition.__swig_getmethods__["planarEntity"] = AtCenterHolePositionDefinition._get_planarEntity
AtCenterHolePositionDefinition.planarEntity = property(AtCenterHolePositionDefinition._get_planarEntity, doc="Returns the plane that defines the orientation and start of the hole.")

AtCenterHolePositionDefinition.__swig_getmethods__["centerEdge"] = AtCenterHolePositionDefinition._get_centerEdge
AtCenterHolePositionDefinition.centerEdge = property(AtCenterHolePositionDefinition._get_centerEdge, doc="Returns the circular or elliptical edge the hole is centered at.")

AtCenterHolePositionDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, AtCenterHolePositionDefinition) else None
AtCenterHolePositionDefinition.cast = lambda arg: arg if isinstance(arg, AtCenterHolePositionDefinition) else None

class BallJointMotion(JointMotion):
    """Represents the set of information specific to a ball joint."""
    __swig_setmethods__ = {}
    for _s in [JointMotion]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BallJointMotion, name, value)
    __swig_getmethods__ = {}
    for _s in [JointMotion]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BallJointMotion, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BallJointMotion *" : return _fusion.BallJointMotion___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BallJointMotion___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BallJointMotion___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BallJointMotion_classType
    if _newclass:classType = staticmethod(_fusion.BallJointMotion_classType)
    __swig_destroy__ = _fusion.delete_BallJointMotion
    __del__ = lambda self : None;
    def _get_pitchDirection(self) -> "adsk::fusion::JointDirections" :
        """
        Gets and sets the direction that the pitch is measured from.
        This can only be set to ZAxisJointDirection and can return ZAxisJointDirection
        or CustomJointDirection. If this returns CustomJointDirection then the 
        customNormalDirectionEntity will return an entity that defines the direction. 
        If there is a custom direction defined and this property is set to ZAxisJointDirection,
        the custom direction will be removed and customNormalDirectionEntity will return null.
        """
        return _fusion.BallJointMotion__get_pitchDirection(self)

    def _set_pitchDirection(self, *args) -> "bool" :
        """
        Gets and sets the direction that the pitch is measured from.
        This can only be set to ZAxisJointDirection and can return ZAxisJointDirection
        or CustomJointDirection. If this returns CustomJointDirection then the 
        customNormalDirectionEntity will return an entity that defines the direction. 
        If there is a custom direction defined and this property is set to ZAxisJointDirection,
        the custom direction will be removed and customNormalDirectionEntity will return null.
        """
        return _fusion.BallJointMotion__set_pitchDirection(self, *args)

    def _get_customPitchDirectionEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        This property defines a custom pitch direction and can be set using various types 
        of entities that can infer a direction. For example, a linear edge, sketch line, 
        planar face, and cylindrical face.This property is only valid in the case where the 
        pitchDirection property returns CustomJointDirection. Setting this property will 
        automatically set the pitchDirection property to CustomJointDirection.
        """
        return _fusion.BallJointMotion__get_customPitchDirectionEntity(self)

    def _set_customPitchDirectionEntity(self, *args) -> "bool" :
        """
        This property defines a custom pitch direction and can be set using various types 
        of entities that can infer a direction. For example, a linear edge, sketch line, 
        planar face, and cylindrical face.This property is only valid in the case where the 
        pitchDirection property returns CustomJointDirection. Setting this property will 
        automatically set the pitchDirection property to CustomJointDirection.
        """
        return _fusion.BallJointMotion__set_customPitchDirectionEntity(self, *args)

    def _get_pitchDirectionVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Returns the direction that the pitch angle is measured from. This property will return null in the case
        where the BallJointMotion object was obtained from a JointInput object.
        """
        return _fusion.BallJointMotion__get_pitchDirectionVector(self)

    def _get_yawDirection(self) -> "adsk::fusion::JointDirections" :
        """
        Gets and sets the direction that the pitch is measured from.
        This can only be set to XAxisJointDirection and can return XAxisJointDirection
        or CustomJointDirection. If this returns CustomJointDirection then the 
        customYawDirectionEntity will return an entity that defines the direction. 
        If there is a custom direction defined and this property is set to XAxisJointDirection,
        the custom direction will be removed and customYawDirectionEntity will return null.
        """
        return _fusion.BallJointMotion__get_yawDirection(self)

    def _set_yawDirection(self, *args) -> "bool" :
        """
        Gets and sets the direction that the pitch is measured from.
        This can only be set to XAxisJointDirection and can return XAxisJointDirection
        or CustomJointDirection. If this returns CustomJointDirection then the 
        customYawDirectionEntity will return an entity that defines the direction. 
        If there is a custom direction defined and this property is set to XAxisJointDirection,
        the custom direction will be removed and customYawDirectionEntity will return null.
        """
        return _fusion.BallJointMotion__set_yawDirection(self, *args)

    def _get_customYawDirectionEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        This property defines a custom yaw direction and can be set using various types 
        of entities that can infer a direction. For example, a linear edge, sketch line, 
        planar face, and cylindrical face.This property is only valid in the case where the 
        yawDirection property returns CustomJointDirection. Setting this property will 
        automatically set the yawDirection property to CustomJointDirection.
        """
        return _fusion.BallJointMotion__get_customYawDirectionEntity(self)

    def _set_customYawDirectionEntity(self, *args) -> "bool" :
        """
        This property defines a custom yaw direction and can be set using various types 
        of entities that can infer a direction. For example, a linear edge, sketch line, 
        planar face, and cylindrical face.This property is only valid in the case where the 
        yawDirection property returns CustomJointDirection. Setting this property will 
        automatically set the yawDirection property to CustomJointDirection.
        """
        return _fusion.BallJointMotion__set_customYawDirectionEntity(self, *args)

    def _get_yawDirectionVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Returns the direction that the yaw angle is measured from. This property will return null in the case
        where the BallJointMotion object was obtained from a JointInput object.
        """
        return _fusion.BallJointMotion__get_yawDirectionVector(self)

    def _get_rollDirectionVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Returns the direction that the roll angle is measured from. This property will return null in the case
        where the BallJointMotion object was obtained from a JointInput object.
        """
        return _fusion.BallJointMotion__get_rollDirectionVector(self)

    def _get_pitchValue(self) -> "double" :
        """
        Gets and sets the pitch value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.BallJointMotion__get_pitchValue(self)

    def _set_pitchValue(self, *args) -> "bool" :
        """
        Gets and sets the pitch value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.BallJointMotion__set_pitchValue(self, *args)

    def _get_pitchLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >" :
        """
        Returns a JointLimits object that defines the limits of rotation for the pitch.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.BallJointMotion__get_pitchLimits(self)

    def _get_yawValue(self) -> "double" :
        """
        Gets and sets the yaw value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.BallJointMotion__get_yawValue(self)

    def _set_yawValue(self, *args) -> "bool" :
        """
        Gets and sets the yaw value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.BallJointMotion__set_yawValue(self, *args)

    def _get_yawLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >" :
        """
        Returns a JointLimits object that defines the limits of rotation for the yaw.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.BallJointMotion__get_yawLimits(self)

    def _get_rollValue(self) -> "double" :
        """
        Gets and sets the roll value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.BallJointMotion__get_rollValue(self)

    def _set_rollValue(self, *args) -> "bool" :
        """
        Gets and sets the roll value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.BallJointMotion__set_rollValue(self, *args)

    def _get_rollLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >" :
        """
        Returns a JointLimits object that defines the limits of rotation for the roll.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.BallJointMotion__get_rollLimits(self)

    def _get_jointType(self) -> "adsk::fusion::JointTypes" :
        """Returns an enum value indicating the type of joint this joint represents."""
        return _fusion.BallJointMotion__get_jointType(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BallJointMotion__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BallJointMotion__get_isValid(self)
BallJointMotion_swigregister = _fusion.BallJointMotion_swigregister
BallJointMotion_swigregister(BallJointMotion)

def BallJointMotion_classType() -> "char const *" :
  return _fusion.BallJointMotion_classType()
BallJointMotion_classType = _fusion.BallJointMotion_classType

BallJointMotion.__swig_getmethods__["pitchDirection"] = BallJointMotion._get_pitchDirection
BallJointMotion.__swig_setmethods__["pitchDirection"] = BallJointMotion._set_pitchDirection
BallJointMotion.pitchDirection = property(BallJointMotion._get_pitchDirection, BallJointMotion._set_pitchDirection, doc="Gets and sets the direction that the pitch is measured from.\nThis can only be set to ZAxisJointDirection and can return ZAxisJointDirection\nor CustomJointDirection. If this returns CustomJointDirection then the\ncustomNormalDirectionEntity will return an entity that defines the direction.\nIf there is a custom direction defined and this property is set to ZAxisJointDirection,\nthe custom direction will be removed and customNormalDirectionEntity will return null.")

BallJointMotion.__swig_getmethods__["customPitchDirectionEntity"] = BallJointMotion._get_customPitchDirectionEntity
BallJointMotion.__swig_setmethods__["customPitchDirectionEntity"] = BallJointMotion._set_customPitchDirectionEntity
BallJointMotion.customPitchDirectionEntity = property(BallJointMotion._get_customPitchDirectionEntity, BallJointMotion._set_customPitchDirectionEntity, doc="This property defines a custom pitch direction and can be set using various types\nof entities that can infer a direction. For example, a linear edge, sketch line,\nplanar face, and cylindrical face.This property is only valid in the case where the\npitchDirection property returns CustomJointDirection. Setting this property will\nautomatically set the pitchDirection property to CustomJointDirection.")

BallJointMotion.__swig_getmethods__["pitchDirectionVector"] = BallJointMotion._get_pitchDirectionVector
BallJointMotion.pitchDirectionVector = property(BallJointMotion._get_pitchDirectionVector, doc="Returns the direction that the pitch angle is measured from. This property will return null in the case\nwhere the BallJointMotion object was obtained from a JointInput object.")

BallJointMotion.__swig_getmethods__["yawDirection"] = BallJointMotion._get_yawDirection
BallJointMotion.__swig_setmethods__["yawDirection"] = BallJointMotion._set_yawDirection
BallJointMotion.yawDirection = property(BallJointMotion._get_yawDirection, BallJointMotion._set_yawDirection, doc="Gets and sets the direction that the pitch is measured from.\nThis can only be set to XAxisJointDirection and can return XAxisJointDirection\nor CustomJointDirection. If this returns CustomJointDirection then the\ncustomYawDirectionEntity will return an entity that defines the direction.\nIf there is a custom direction defined and this property is set to XAxisJointDirection,\nthe custom direction will be removed and customYawDirectionEntity will return null.")

BallJointMotion.__swig_getmethods__["customYawDirectionEntity"] = BallJointMotion._get_customYawDirectionEntity
BallJointMotion.__swig_setmethods__["customYawDirectionEntity"] = BallJointMotion._set_customYawDirectionEntity
BallJointMotion.customYawDirectionEntity = property(BallJointMotion._get_customYawDirectionEntity, BallJointMotion._set_customYawDirectionEntity, doc="This property defines a custom yaw direction and can be set using various types\nof entities that can infer a direction. For example, a linear edge, sketch line,\nplanar face, and cylindrical face.This property is only valid in the case where the\nyawDirection property returns CustomJointDirection. Setting this property will\nautomatically set the yawDirection property to CustomJointDirection.")

BallJointMotion.__swig_getmethods__["yawDirectionVector"] = BallJointMotion._get_yawDirectionVector
BallJointMotion.yawDirectionVector = property(BallJointMotion._get_yawDirectionVector, doc="Returns the direction that the yaw angle is measured from. This property will return null in the case\nwhere the BallJointMotion object was obtained from a JointInput object.")

BallJointMotion.__swig_getmethods__["rollDirectionVector"] = BallJointMotion._get_rollDirectionVector
BallJointMotion.rollDirectionVector = property(BallJointMotion._get_rollDirectionVector, doc="Returns the direction that the roll angle is measured from. This property will return null in the case\nwhere the BallJointMotion object was obtained from a JointInput object.")

BallJointMotion.__swig_getmethods__["pitchValue"] = BallJointMotion._get_pitchValue
BallJointMotion.__swig_setmethods__["pitchValue"] = BallJointMotion._set_pitchValue
BallJointMotion.pitchValue = property(BallJointMotion._get_pitchValue, BallJointMotion._set_pitchValue, doc="Gets and sets the pitch value. This is in radians. Setting this value is\nthe equivalent of using the Drive Joints command.")

BallJointMotion.__swig_getmethods__["pitchLimits"] = BallJointMotion._get_pitchLimits
BallJointMotion.pitchLimits = property(BallJointMotion._get_pitchLimits, doc="Returns a JointLimits object that defines the limits of rotation for the pitch.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")

BallJointMotion.__swig_getmethods__["yawValue"] = BallJointMotion._get_yawValue
BallJointMotion.__swig_setmethods__["yawValue"] = BallJointMotion._set_yawValue
BallJointMotion.yawValue = property(BallJointMotion._get_yawValue, BallJointMotion._set_yawValue, doc="Gets and sets the yaw value. This is in radians. Setting this value is\nthe equivalent of using the Drive Joints command.")

BallJointMotion.__swig_getmethods__["yawLimits"] = BallJointMotion._get_yawLimits
BallJointMotion.yawLimits = property(BallJointMotion._get_yawLimits, doc="Returns a JointLimits object that defines the limits of rotation for the yaw.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")

BallJointMotion.__swig_getmethods__["rollValue"] = BallJointMotion._get_rollValue
BallJointMotion.__swig_setmethods__["rollValue"] = BallJointMotion._set_rollValue
BallJointMotion.rollValue = property(BallJointMotion._get_rollValue, BallJointMotion._set_rollValue, doc="Gets and sets the roll value. This is in radians. Setting this value is\nthe equivalent of using the Drive Joints command.")

BallJointMotion.__swig_getmethods__["rollLimits"] = BallJointMotion._get_rollLimits
BallJointMotion.rollLimits = property(BallJointMotion._get_rollLimits, doc="Returns a JointLimits object that defines the limits of rotation for the roll.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")

BallJointMotion.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BallJointMotion) else None
BallJointMotion.cast = lambda arg: arg if isinstance(arg, BallJointMotion) else None

class BaseFeature(Feature):
    """The BaseFeature class represents a direct edit feature within a parametric design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BaseFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BaseFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BaseFeature *" : return _fusion.BaseFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BaseFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BaseFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BaseFeature_classType
    if _newclass:classType = staticmethod(_fusion.BaseFeature_classType)
    __swig_destroy__ = _fusion.delete_BaseFeature
    __del__ = lambda self : None;
    def _get_constructionPlanes(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPlane >,std::allocator< adsk::core::Ptr< adsk::fusion::ConstructionPlane > > >" :
        """Returns an array of the construction planes associated with this base feature."""
        return _fusion.BaseFeature__get_constructionPlanes(self)

    def _get_constructionAxes(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionAxis >,std::allocator< adsk::core::Ptr< adsk::fusion::ConstructionAxis > > >" :
        """Returns an array of the construction axes associated with this base feature."""
        return _fusion.BaseFeature__get_constructionAxes(self)

    def _get_constructionPoints(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::ConstructionPoint >,std::allocator< adsk::core::Ptr< adsk::fusion::ConstructionPoint > > >" :
        """Returns an array of the construction points associated with this base feature."""
        return _fusion.BaseFeature__get_constructionPoints(self)

    def _get_sketches(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Sketch >,std::allocator< adsk::core::Ptr< adsk::fusion::Sketch > > >" :
        """Returns an array of the sketches associated with this base feature."""
        return _fusion.BaseFeature__get_sketches(self)

    def _get_meshBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::MeshBody >,std::allocator< adsk::core::Ptr< adsk::fusion::MeshBody > > >" :
        """Returns an array of the mesh bodies associated with this base feature."""
        return _fusion.BaseFeature__get_meshBodies(self)

    def startEdit(self) -> "bool" :
        """
        Set the user-interface so that the base body is in edit mode. 
        Returns true if successful.
        """
        return _fusion.BaseFeature_startEdit(self)

    def finishEdit(self) -> "bool" :
        """
        Exits from edit mode in the user-interface. If this base feature in not
        in edit mode, then nothing happens. 
        Returns true if successful.
        """
        return _fusion.BaseFeature_finishEdit(self)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.BaseFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.BaseFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.BaseFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.BaseFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.BaseFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.BaseFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.BaseFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.BaseFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.BaseFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.BaseFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.BaseFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.BaseFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.BaseFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.BaseFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.BaseFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.BaseFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.BaseFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BaseFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BaseFeature__get_isValid(self)
BaseFeature_swigregister = _fusion.BaseFeature_swigregister
BaseFeature_swigregister(BaseFeature)

def BaseFeature_classType() -> "char const *" :
  return _fusion.BaseFeature_classType()
BaseFeature_classType = _fusion.BaseFeature_classType

BaseFeature.__swig_getmethods__["constructionPlanes"] = BaseFeature._get_constructionPlanes
BaseFeature.constructionPlanes = property(BaseFeature._get_constructionPlanes, doc="Returns an array of the construction planes associated with this base feature.")

BaseFeature.__swig_getmethods__["constructionAxes"] = BaseFeature._get_constructionAxes
BaseFeature.constructionAxes = property(BaseFeature._get_constructionAxes, doc="Returns an array of the construction axes associated with this base feature.")

BaseFeature.__swig_getmethods__["constructionPoints"] = BaseFeature._get_constructionPoints
BaseFeature.constructionPoints = property(BaseFeature._get_constructionPoints, doc="Returns an array of the construction points associated with this base feature.")

BaseFeature.__swig_getmethods__["sketches"] = BaseFeature._get_sketches
BaseFeature.sketches = property(BaseFeature._get_sketches, doc="Returns an array of the sketches associated with this base feature.")

BaseFeature.__swig_getmethods__["meshBodies"] = BaseFeature._get_meshBodies
BaseFeature.meshBodies = property(BaseFeature._get_meshBodies, doc="Returns an array of the mesh bodies associated with this base feature.")

BaseFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BaseFeature) else None
BaseFeature.cast = lambda arg: arg if isinstance(arg, BaseFeature) else None

class BoundaryFillFeature(Feature):
    """Object that represents an existing boundary fill feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoundaryFillFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BoundaryFillFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BoundaryFillFeature *" : return _fusion.BoundaryFillFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BoundaryFillFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BoundaryFillFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BoundaryFillFeature_classType
    if _newclass:classType = staticmethod(_fusion.BoundaryFillFeature_classType)
    __swig_destroy__ = _fusion.delete_BoundaryFillFeature
    __del__ = lambda self : None;
    def _get_tools(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        A collection of construction planes and open or closed BRepBody objects that define the 
        set of boundaries that have been used in the calculation of available closed boundaries.
        Setting this property will clear all currently selected tools.
        """
        return _fusion.BoundaryFillFeature__get_tools(self)

    def _set_tools(self, *args) -> "bool" :
        """
        A collection of construction planes and open or closed BRepBody objects that define the 
        set of boundaries that have been used in the calculation of available closed boundaries.
        Setting this property will clear all currently selected tools.
        """
        return _fusion.BoundaryFillFeature__set_tools(self, *args)

    def _get_bRepCells(self) -> "adsk::core::Ptr< adsk::fusion::BRepCells >" :
        """
        Gets the set of closed boundaries that have been calculated based on the current set of
        tools. To get this collection the model must be in the state it was when the feature
        was initially computed, which means the timeline marker must be positioned to immediately
        before this feature. 
        After changing any selected cells you must call the applyCellChanges method to update
        the feature with the changes.
        """
        return _fusion.BoundaryFillFeature__get_bRepCells(self)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """Gets and sets the type of operation performed by the boundary fill feature."""
        return _fusion.BoundaryFillFeature__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """Gets and sets the type of operation performed by the boundary fill feature."""
        return _fusion.BoundaryFillFeature__set_operation(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::BoundaryFillFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.BoundaryFillFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::BoundaryFillFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.BoundaryFillFeature_createForAssemblyContext(self, *args)

    def applyCellChanges(self) -> "bool" :
        """
        After making any changes to the set of selected cells you must call this method to 
        indicate all changes have been made and to apply those changes to the feature. 
        Returns true if the apply was successful.
        """
        return _fusion.BoundaryFillFeature_applyCellChanges(self)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.BoundaryFillFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.BoundaryFillFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.BoundaryFillFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.BoundaryFillFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.BoundaryFillFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.BoundaryFillFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.BoundaryFillFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.BoundaryFillFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.BoundaryFillFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.BoundaryFillFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.BoundaryFillFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.BoundaryFillFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.BoundaryFillFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.BoundaryFillFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.BoundaryFillFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.BoundaryFillFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.BoundaryFillFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BoundaryFillFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BoundaryFillFeature__get_isValid(self)
BoundaryFillFeature_swigregister = _fusion.BoundaryFillFeature_swigregister
BoundaryFillFeature_swigregister(BoundaryFillFeature)

def BoundaryFillFeature_classType() -> "char const *" :
  return _fusion.BoundaryFillFeature_classType()
BoundaryFillFeature_classType = _fusion.BoundaryFillFeature_classType

BoundaryFillFeature.__swig_getmethods__["tools"] = BoundaryFillFeature._get_tools
BoundaryFillFeature.__swig_setmethods__["tools"] = BoundaryFillFeature._set_tools
BoundaryFillFeature.tools = property(BoundaryFillFeature._get_tools, BoundaryFillFeature._set_tools, doc="A collection of construction planes and open or closed BRepBody objects that define the\nset of boundaries that have been used in the calculation of available closed boundaries.\nSetting this property will clear all currently selected tools.")

BoundaryFillFeature.__swig_getmethods__["bRepCells"] = BoundaryFillFeature._get_bRepCells
BoundaryFillFeature.bRepCells = property(BoundaryFillFeature._get_bRepCells, doc="Gets the set of closed boundaries that have been calculated based on the current set of\ntools. To get this collection the model must be in the state it was when the feature\nwas initially computed, which means the timeline marker must be positioned to immediately\nbefore this feature.\nAfter changing any selected cells you must call the applyCellChanges method to update\nthe feature with the changes.")

BoundaryFillFeature.__swig_getmethods__["operation"] = BoundaryFillFeature._get_operation
BoundaryFillFeature.__swig_setmethods__["operation"] = BoundaryFillFeature._set_operation
BoundaryFillFeature.operation = property(BoundaryFillFeature._get_operation, BoundaryFillFeature._set_operation, doc="Gets and sets the type of operation performed by the boundary fill feature.")

BoundaryFillFeature.__swig_getmethods__["nativeObject"] = BoundaryFillFeature._get_nativeObject
BoundaryFillFeature.nativeObject = property(BoundaryFillFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

BoundaryFillFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BoundaryFillFeature) else None
BoundaryFillFeature.cast = lambda arg: arg if isinstance(arg, BoundaryFillFeature) else None

class BoxFeature(Feature):
    """Object that represents an existing box feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoxFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BoxFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::BoxFeature *" : return _fusion.BoxFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.BoxFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.BoxFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.BoxFeature_classType
    if _newclass:classType = staticmethod(_fusion.BoxFeature_classType)
    __swig_destroy__ = _fusion.delete_BoxFeature
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.BoxFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.BoxFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.BoxFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.BoxFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.BoxFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.BoxFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.BoxFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.BoxFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.BoxFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.BoxFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.BoxFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.BoxFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.BoxFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.BoxFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.BoxFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.BoxFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.BoxFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.BoxFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.BoxFeature__get_isValid(self)
BoxFeature_swigregister = _fusion.BoxFeature_swigregister
BoxFeature_swigregister(BoxFeature)

def BoxFeature_classType() -> "char const *" :
  return _fusion.BoxFeature_classType()
BoxFeature_classType = _fusion.BoxFeature_classType

BoxFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, BoxFeature) else None
BoxFeature.cast = lambda arg: arg if isinstance(arg, BoxFeature) else None

class ChamferFeature(Feature):
    """Object that represents an existing chamfer feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChamferFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ChamferFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ChamferFeature *" : return _fusion.ChamferFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ChamferFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ChamferFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ChamferFeature_classType
    if _newclass:classType = staticmethod(_fusion.ChamferFeature_classType)
    __swig_destroy__ = _fusion.delete_ChamferFeature
    __del__ = lambda self : None;
    def _get_edges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the edges being chamfered. In order to access (get) the input edges
        of a chamfer, you must roll the timeline back to just before the chamfer feature
        whose edges you want to access. When setting the edges, if the IsTangentChain property is true then
        all edges that are tangent to the input edges will be include in the chamfer.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ChamferFeature__get_edges(self)

    def _set_edges(self, *args) -> "bool" :
        """
        Gets and sets the edges being chamfered. In order to access (get) the input edges
        of a chamfer, you must roll the timeline back to just before the chamfer feature
        whose edges you want to access. When setting the edges, if the IsTangentChain property is true then
        all edges that are tangent to the input edges will be include in the chamfer.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ChamferFeature__set_edges(self, *args)

    def _get_isTangentChain(self) -> "bool" :
        """
        Gets and sets whether or not edges that are tangentially connected to 
        the input edges (if any) will also be chamfered.
        """
        return _fusion.ChamferFeature__get_isTangentChain(self)

    def _set_isTangentChain(self, *args) -> "bool" :
        """
        Gets and sets whether or not edges that are tangentially connected to 
        the input edges (if any) will also be chamfered.
        """
        return _fusion.ChamferFeature__set_isTangentChain(self, *args)

    def _get_chamferType(self) -> "adsk::fusion::ChamferTypes" :
        """
        Gets an enum indicating how the chamfer was defined. The valid return values are 
        EqualDistanceType, TwoDistancesType and DistanceAndAngleType. 
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ChamferFeature__get_chamferType(self)

    def _get_chamferTypeDefinition(self) -> "adsk::core::Ptr< adsk::fusion::ChamferTypeDefinition >" :
        """
        Gets the definition object that is defining the type of chamfer. Modifying the
        definition object will cause the chamfer to recompute. Various types of definition objects can
        be returned depending on how the chamfer is defined. The ChamferType property can
        be used to determine which type of definition will be returned.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ChamferFeature__get_chamferTypeDefinition(self)

    def setEqualDistance(self, *args) -> "bool" :
        """
        Changes the type of chamfer to be an equal distance chamfer. 
        distance : A ValueInput object that defines the distance of the chamfer. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '2 in'). If no units are specified
        it is interpreted using the current default units for length. 
        Returns true if the feature is successfully changed
        """
        return _fusion.ChamferFeature_setEqualDistance(self, *args)

    def setTwoDistances(self, *args) -> "bool" :
        """
        Changes the type of chamfer to be a two distances chamfer. 
        distanceOne : A ValueInput object that defines the distanceOne of the chamfer. This distance 
        is along the face which is on the left of the selected edge.
        If the ValueInput uses a real then it is interpreted as centimeters.
        If it is a string then the units can be defined as part of the string (i.e. '2 in').
        If no units are specified it is interpreted using the current default units for length. 
        distanceTwo : A ValueInput object that defines the distanceTwo of the chamfer. This distance 
        is along the face which is on the right of the selected edge.
        If the ValueInput uses a real then it is interpreted as centimeters.
        If it is a string then the units can be defined as part of the string (i.e. '2 in').
        If no units are specified it is interpreted using the current default units for length. 
        Returns true if the feature is successfully changed
        """
        return _fusion.ChamferFeature_setTwoDistances(self, *args)

    def setDistanceAndAngle(self, *args) -> "bool" :
        """
        Changes the type of chamfer to be a distance and angle chamfer. 
        distance : A ValueInput object that defines the distance of the chamfer. This distance 
        is along the face which is on the right of the selected edge.
        If the ValueInput uses a real then it is interpreted as centimeters.
        If it is a string then the units can be defined as part of the string (i.e. '2 in').
        If no units are specified it is interpreted using the current default units for length. 
        angle : A valueInput object that defines the angle. The direction will be towards to the face 
        which is on the left of the selected edge. This can be a string or a value.
        If it's a string it is interpreted using the current document units and can include
        equations. For example all of the following are valid as long as they result in
        angle units; '45', '45 deg', 'a1 / 2'. If a value is input it is interpreted
        as radians. 
        It cannot be negative. 
        Returns true if the feature is successfully changed
        """
        return _fusion.ChamferFeature_setDistanceAndAngle(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ChamferFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ChamferFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ChamferFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ChamferFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ChamferFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.ChamferFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ChamferFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ChamferFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.ChamferFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.ChamferFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.ChamferFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.ChamferFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ChamferFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.ChamferFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.ChamferFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.ChamferFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ChamferFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.ChamferFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ChamferFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ChamferFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ChamferFeature__get_isValid(self)
ChamferFeature_swigregister = _fusion.ChamferFeature_swigregister
ChamferFeature_swigregister(ChamferFeature)

def ChamferFeature_classType() -> "char const *" :
  return _fusion.ChamferFeature_classType()
ChamferFeature_classType = _fusion.ChamferFeature_classType

ChamferFeature.__swig_getmethods__["edges"] = ChamferFeature._get_edges
ChamferFeature.__swig_setmethods__["edges"] = ChamferFeature._set_edges
ChamferFeature.edges = property(ChamferFeature._get_edges, ChamferFeature._set_edges, doc="Gets and sets the edges being chamfered. In order to access (get) the input edges\nof a chamfer, you must roll the timeline back to just before the chamfer feature\nwhose edges you want to access. When setting the edges, if the IsTangentChain property is true then\nall edges that are tangent to the input edges will be include in the chamfer.\nThis property returns nothing in the case where the feature is non-parametric.")

ChamferFeature.__swig_getmethods__["isTangentChain"] = ChamferFeature._get_isTangentChain
ChamferFeature.__swig_setmethods__["isTangentChain"] = ChamferFeature._set_isTangentChain
ChamferFeature.isTangentChain = property(ChamferFeature._get_isTangentChain, ChamferFeature._set_isTangentChain, doc="Gets and sets whether or not edges that are tangentially connected to\nthe input edges (if any) will also be chamfered.")

ChamferFeature.__swig_getmethods__["chamferType"] = ChamferFeature._get_chamferType
ChamferFeature.chamferType = property(ChamferFeature._get_chamferType, doc="Gets an enum indicating how the chamfer was defined. The valid return values are\nEqualDistanceType, TwoDistancesType and DistanceAndAngleType.\nThis property returns nothing in the case where the feature is non-parametric.")

ChamferFeature.__swig_getmethods__["chamferTypeDefinition"] = ChamferFeature._get_chamferTypeDefinition
ChamferFeature.chamferTypeDefinition = property(ChamferFeature._get_chamferTypeDefinition, doc="Gets the definition object that is defining the type of chamfer. Modifying the\ndefinition object will cause the chamfer to recompute. Various types of definition objects can\nbe returned depending on how the chamfer is defined. The ChamferType property can\nbe used to determine which type of definition will be returned.\nThis property returns nothing in the case where the feature is non-parametric.")

ChamferFeature.__swig_getmethods__["nativeObject"] = ChamferFeature._get_nativeObject
ChamferFeature.nativeObject = property(ChamferFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

ChamferFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ChamferFeature) else None
ChamferFeature.cast = lambda arg: arg if isinstance(arg, ChamferFeature) else None

class ChordLengthFilletEdgeSet(FilletEdgeSet):
    """Provides access to the edges and the parameter associated with a chord length fillet."""
    __swig_setmethods__ = {}
    for _s in [FilletEdgeSet]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChordLengthFilletEdgeSet, name, value)
    __swig_getmethods__ = {}
    for _s in [FilletEdgeSet]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ChordLengthFilletEdgeSet, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ChordLengthFilletEdgeSet *" : return _fusion.ChordLengthFilletEdgeSet___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ChordLengthFilletEdgeSet___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ChordLengthFilletEdgeSet___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ChordLengthFilletEdgeSet_classType
    if _newclass:classType = staticmethod(_fusion.ChordLengthFilletEdgeSet_classType)
    __swig_destroy__ = _fusion.delete_ChordLengthFilletEdgeSet
    __del__ = lambda self : None;
    def _get_edges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the edges that will be filleted. In order to access (get) the input edges
        of a fillet, you must roll the timeline back to just before the fillet feature
        whose edges you want to access.
        """
        return _fusion.ChordLengthFilletEdgeSet__get_edges(self)

    def _set_edges(self, *args) -> "bool" :
        """
        Gets and sets the edges that will be filleted. In order to access (get) the input edges
        of a fillet, you must roll the timeline back to just before the fillet feature
        whose edges you want to access.
        """
        return _fusion.ChordLengthFilletEdgeSet__set_edges(self, *args)

    def _get_chordLength(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the model parameter that controls the chord length of the fillet. You can edit
        the chord length by using the properties on the returned ModelParameter object.
        """
        return _fusion.ChordLengthFilletEdgeSet__get_chordLength(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ChordLengthFilletEdgeSet__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ChordLengthFilletEdgeSet__get_isValid(self)
ChordLengthFilletEdgeSet_swigregister = _fusion.ChordLengthFilletEdgeSet_swigregister
ChordLengthFilletEdgeSet_swigregister(ChordLengthFilletEdgeSet)

def ChordLengthFilletEdgeSet_classType() -> "char const *" :
  return _fusion.ChordLengthFilletEdgeSet_classType()
ChordLengthFilletEdgeSet_classType = _fusion.ChordLengthFilletEdgeSet_classType

ChordLengthFilletEdgeSet.__swig_getmethods__["edges"] = ChordLengthFilletEdgeSet._get_edges
ChordLengthFilletEdgeSet.__swig_setmethods__["edges"] = ChordLengthFilletEdgeSet._set_edges
ChordLengthFilletEdgeSet.edges = property(ChordLengthFilletEdgeSet._get_edges, ChordLengthFilletEdgeSet._set_edges, doc="Gets and sets the edges that will be filleted. In order to access (get) the input edges\nof a fillet, you must roll the timeline back to just before the fillet feature\nwhose edges you want to access.")

ChordLengthFilletEdgeSet.__swig_getmethods__["chordLength"] = ChordLengthFilletEdgeSet._get_chordLength
ChordLengthFilletEdgeSet.chordLength = property(ChordLengthFilletEdgeSet._get_chordLength, doc="Returns the model parameter that controls the chord length of the fillet. You can edit\nthe chord length by using the properties on the returned ModelParameter object.")

ChordLengthFilletEdgeSet.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ChordLengthFilletEdgeSet) else None
ChordLengthFilletEdgeSet.cast = lambda arg: arg if isinstance(arg, ChordLengthFilletEdgeSet) else None

class CircularPatternConstraint(GeometricConstraint):
    """A circular pattern constraint in a sketch."""
    __swig_setmethods__ = {}
    for _s in [GeometricConstraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CircularPatternConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricConstraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CircularPatternConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CircularPatternConstraint *" : return _fusion.CircularPatternConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CircularPatternConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CircularPatternConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CircularPatternConstraint_classType
    if _newclass:classType = staticmethod(_fusion.CircularPatternConstraint_classType)
    __swig_destroy__ = _fusion.delete_CircularPatternConstraint
    __del__ = lambda self : None;
    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.CircularPatternConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.CircularPatternConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.CircularPatternConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CircularPatternConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.CircularPatternConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.CircularPatternConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CircularPatternConstraint__get_isValid(self)
CircularPatternConstraint_swigregister = _fusion.CircularPatternConstraint_swigregister
CircularPatternConstraint_swigregister(CircularPatternConstraint)

def CircularPatternConstraint_classType() -> "char const *" :
  return _fusion.CircularPatternConstraint_classType()
CircularPatternConstraint_classType = _fusion.CircularPatternConstraint_classType

CircularPatternConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CircularPatternConstraint) else None
CircularPatternConstraint.cast = lambda arg: arg if isinstance(arg, CircularPatternConstraint) else None

class CircularPatternFeature(Feature):
    """Object that represents an existing circular pattern feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CircularPatternFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CircularPatternFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CircularPatternFeature *" : return _fusion.CircularPatternFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CircularPatternFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CircularPatternFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CircularPatternFeature_classType
    if _newclass:classType = staticmethod(_fusion.CircularPatternFeature_classType)
    __swig_destroy__ = _fusion.delete_CircularPatternFeature
    __del__ = lambda self : None;
    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        """
        return _fusion.CircularPatternFeature__get_inputEntities(self)

    def _set_inputEntities(self, *args) -> "bool" :
        """
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        """
        return _fusion.CircularPatternFeature__set_inputEntities(self, *args)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the axis of circular pattern. This can be a sketch line, linear edge,
        construction axis, an edge/sketch curve that defines an axis (circle, etc.) or a face that defines an axis (cylinder, cone, torus, etc.).
        """
        return _fusion.CircularPatternFeature__get_axis(self)

    def _set_axis(self, *args) -> "bool" :
        """
        Gets and sets the axis of circular pattern. This can be a sketch line, linear edge,
        construction axis, an edge/sketch curve that defines an axis (circle, etc.) or a face that defines an axis (cylinder, cone, torus, etc.).
        """
        return _fusion.CircularPatternFeature__set_axis(self, *args)

    def _get_totalAngle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter controlling the total angle.
        To edit the angle use properties on the parameter to edit its value.
        This property returns null in the case where the feature is non-parametric.
        A negative value can be used to change the direction of the pattern.
        """
        return _fusion.CircularPatternFeature__get_totalAngle(self)

    def _get_isSymmetric(self) -> "bool" :
        """Gets and sets if the angle extent is in one direction or symmetric."""
        return _fusion.CircularPatternFeature__get_isSymmetric(self)

    def _set_isSymmetric(self, *args) -> "bool" :
        """Gets and sets if the angle extent is in one direction or symmetric."""
        return _fusion.CircularPatternFeature__set_isSymmetric(self, *args)

    def _get_quantity(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter controlling the number of pattern elements, including any suppressed elements.
        To edit the quantity use properties on the parameter to edit its value.
        This property returns null in the case where the feature is non-parametric.
        """
        return _fusion.CircularPatternFeature__get_quantity(self)

    def _get_suppressedElementsIds(self) -> "std::vector< size_t,std::allocator< size_t > >" :
        """Gets and sets the id's of the elements to suppress."""
        return _fusion.CircularPatternFeature__get_suppressedElementsIds(self)

    def _set_suppressedElementsIds(self, *args) -> "bool" :
        """Gets and sets the id's of the elements to suppress."""
        return _fusion.CircularPatternFeature__set_suppressedElementsIds(self, *args)

    def _get_patternElements(self) -> "adsk::core::Ptr< adsk::fusion::PatternElements >" :
        """Gets the PatternElements collection that contains the elements created by this pattern."""
        return _fusion.CircularPatternFeature__get_patternElements(self)

    def _get_resultFeatures(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Returns the features that were created as a result of this pattern.
        This is only valid for a direct edit model and this returns null 
        in the case where the feature is parametric.
        """
        return _fusion.CircularPatternFeature__get_resultFeatures(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::CircularPatternFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.CircularPatternFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::CircularPatternFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.CircularPatternFeature_createForAssemblyContext(self, *args)

    def _get_patternEntityType(self) -> "adsk::fusion::PatternEntityTypes" :
        """
        Returns the type of entities the pattern consists of. This can be used to help
        determine the type of results that will be found in the pattern elements.
        """
        return _fusion.CircularPatternFeature__get_patternEntityType(self)

    def _get_patternComputeOption(self) -> "adsk::fusion::PatternComputeOptions" :
        """
        Gets and sets the compute option for this pattern feature.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        """
        return _fusion.CircularPatternFeature__get_patternComputeOption(self)

    def _set_patternComputeOption(self, *args) -> "bool" :
        """
        Gets and sets the compute option for this pattern feature.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        """
        return _fusion.CircularPatternFeature__set_patternComputeOption(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CircularPatternFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CircularPatternFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.CircularPatternFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.CircularPatternFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CircularPatternFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CircularPatternFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.CircularPatternFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.CircularPatternFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.CircularPatternFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.CircularPatternFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CircularPatternFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.CircularPatternFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.CircularPatternFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.CircularPatternFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.CircularPatternFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.CircularPatternFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.CircularPatternFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.CircularPatternFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CircularPatternFeature__get_isValid(self)
CircularPatternFeature_swigregister = _fusion.CircularPatternFeature_swigregister
CircularPatternFeature_swigregister(CircularPatternFeature)

def CircularPatternFeature_classType() -> "char const *" :
  return _fusion.CircularPatternFeature_classType()
CircularPatternFeature_classType = _fusion.CircularPatternFeature_classType

CircularPatternFeature.__swig_getmethods__["inputEntities"] = CircularPatternFeature._get_inputEntities
CircularPatternFeature.__swig_setmethods__["inputEntities"] = CircularPatternFeature._set_inputEntities
CircularPatternFeature.inputEntities = property(CircularPatternFeature._get_inputEntities, CircularPatternFeature._set_inputEntities, doc="Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.\nAll of the entities must be of a single type. For example, it can't contain features and occurrences\nbut only features or occurrences.")

CircularPatternFeature.__swig_getmethods__["axis"] = CircularPatternFeature._get_axis
CircularPatternFeature.__swig_setmethods__["axis"] = CircularPatternFeature._set_axis
CircularPatternFeature.axis = property(CircularPatternFeature._get_axis, CircularPatternFeature._set_axis, doc="Gets and sets the axis of circular pattern. This can be a sketch line, linear edge,\nconstruction axis, an edge/sketch curve that defines an axis (circle, etc.) or a face that defines an axis (cylinder, cone, torus, etc.).")

CircularPatternFeature.__swig_getmethods__["totalAngle"] = CircularPatternFeature._get_totalAngle
CircularPatternFeature.totalAngle = property(CircularPatternFeature._get_totalAngle, doc="Returns the parameter controlling the total angle.\nTo edit the angle use properties on the parameter to edit its value.\nThis property returns null in the case where the feature is non-parametric.\nA negative value can be used to change the direction of the pattern.")

CircularPatternFeature.__swig_getmethods__["isSymmetric"] = CircularPatternFeature._get_isSymmetric
CircularPatternFeature.__swig_setmethods__["isSymmetric"] = CircularPatternFeature._set_isSymmetric
CircularPatternFeature.isSymmetric = property(CircularPatternFeature._get_isSymmetric, CircularPatternFeature._set_isSymmetric, doc="Gets and sets if the angle extent is in one direction or symmetric.")

CircularPatternFeature.__swig_getmethods__["quantity"] = CircularPatternFeature._get_quantity
CircularPatternFeature.quantity = property(CircularPatternFeature._get_quantity, doc="Returns the parameter controlling the number of pattern elements, including any suppressed elements.\nTo edit the quantity use properties on the parameter to edit its value.\nThis property returns null in the case where the feature is non-parametric.")

CircularPatternFeature.__swig_getmethods__["suppressedElementsIds"] = CircularPatternFeature._get_suppressedElementsIds
CircularPatternFeature.__swig_setmethods__["suppressedElementsIds"] = CircularPatternFeature._set_suppressedElementsIds
CircularPatternFeature.suppressedElementsIds = property(CircularPatternFeature._get_suppressedElementsIds, CircularPatternFeature._set_suppressedElementsIds, doc="Gets and sets the id's of the elements to suppress.")

CircularPatternFeature.__swig_getmethods__["patternElements"] = CircularPatternFeature._get_patternElements
CircularPatternFeature.patternElements = property(CircularPatternFeature._get_patternElements, doc="Gets the PatternElements collection that contains the elements created by this pattern.")

CircularPatternFeature.__swig_getmethods__["resultFeatures"] = CircularPatternFeature._get_resultFeatures
CircularPatternFeature.resultFeatures = property(CircularPatternFeature._get_resultFeatures, doc="Returns the features that were created as a result of this pattern.\nThis is only valid for a direct edit model and this returns null\nin the case where the feature is parametric.")

CircularPatternFeature.__swig_getmethods__["nativeObject"] = CircularPatternFeature._get_nativeObject
CircularPatternFeature.nativeObject = property(CircularPatternFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

CircularPatternFeature.__swig_getmethods__["patternEntityType"] = CircularPatternFeature._get_patternEntityType
CircularPatternFeature.patternEntityType = property(CircularPatternFeature._get_patternEntityType, doc="Returns the type of entities the pattern consists of. This can be used to help\ndetermine the type of results that will be found in the pattern elements.")

CircularPatternFeature.__swig_getmethods__["patternComputeOption"] = CircularPatternFeature._get_patternComputeOption
CircularPatternFeature.__swig_setmethods__["patternComputeOption"] = CircularPatternFeature._set_patternComputeOption
CircularPatternFeature.patternComputeOption = property(CircularPatternFeature._get_patternComputeOption, CircularPatternFeature._set_patternComputeOption, doc="Gets and sets the compute option for this pattern feature.\nThis property only applies when patterning features and is ignored in the direct modeling environment.")

CircularPatternFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CircularPatternFeature) else None
CircularPatternFeature.cast = lambda arg: arg if isinstance(arg, CircularPatternFeature) else None

class CoilFeature(Feature):
    """Object that represents an existing coil primitive feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoilFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoilFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CoilFeature *" : return _fusion.CoilFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CoilFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CoilFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CoilFeature_classType
    if _newclass:classType = staticmethod(_fusion.CoilFeature_classType)
    __swig_destroy__ = _fusion.delete_CoilFeature
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CoilFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CoilFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.CoilFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.CoilFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CoilFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CoilFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.CoilFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.CoilFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.CoilFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.CoilFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CoilFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.CoilFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.CoilFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.CoilFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.CoilFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.CoilFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.CoilFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.CoilFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CoilFeature__get_isValid(self)
CoilFeature_swigregister = _fusion.CoilFeature_swigregister
CoilFeature_swigregister(CoilFeature)

def CoilFeature_classType() -> "char const *" :
  return _fusion.CoilFeature_classType()
CoilFeature_classType = _fusion.CoilFeature_classType

CoilFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CoilFeature) else None
CoilFeature.cast = lambda arg: arg if isinstance(arg, CoilFeature) else None

class CoincidentConstraint(GeometricConstraint):
    """A coincident constraint in a sketch."""
    __swig_setmethods__ = {}
    for _s in [GeometricConstraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoincidentConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricConstraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoincidentConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CoincidentConstraint *" : return _fusion.CoincidentConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CoincidentConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CoincidentConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CoincidentConstraint_classType
    if _newclass:classType = staticmethod(_fusion.CoincidentConstraint_classType)
    __swig_destroy__ = _fusion.delete_CoincidentConstraint
    __del__ = lambda self : None;
    def _get_point(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """Returns the sketch point that is constrained."""
        return _fusion.CoincidentConstraint__get_point(self)

    def _get_entity(self) -> "adsk::core::Ptr< adsk::fusion::SketchEntity >" :
        """The sketch curve or point the point is constrained to."""
        return _fusion.CoincidentConstraint__get_entity(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::CoincidentConstraint >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.CoincidentConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::CoincidentConstraint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.CoincidentConstraint_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.CoincidentConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.CoincidentConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.CoincidentConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CoincidentConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.CoincidentConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.CoincidentConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CoincidentConstraint__get_isValid(self)
CoincidentConstraint_swigregister = _fusion.CoincidentConstraint_swigregister
CoincidentConstraint_swigregister(CoincidentConstraint)

def CoincidentConstraint_classType() -> "char const *" :
  return _fusion.CoincidentConstraint_classType()
CoincidentConstraint_classType = _fusion.CoincidentConstraint_classType

CoincidentConstraint.__swig_getmethods__["point"] = CoincidentConstraint._get_point
CoincidentConstraint.point = property(CoincidentConstraint._get_point, doc="Returns the sketch point that is constrained.")

CoincidentConstraint.__swig_getmethods__["entity"] = CoincidentConstraint._get_entity
CoincidentConstraint.entity = property(CoincidentConstraint._get_entity, doc="The sketch curve or point the point is constrained to.")

CoincidentConstraint.__swig_getmethods__["nativeObject"] = CoincidentConstraint._get_nativeObject
CoincidentConstraint.nativeObject = property(CoincidentConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

CoincidentConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CoincidentConstraint) else None
CoincidentConstraint.cast = lambda arg: arg if isinstance(arg, CoincidentConstraint) else None

class CollinearConstraint(GeometricConstraint):
    """A collinear constraint in a sketch."""
    __swig_setmethods__ = {}
    for _s in [GeometricConstraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollinearConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricConstraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollinearConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CollinearConstraint *" : return _fusion.CollinearConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CollinearConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CollinearConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CollinearConstraint_classType
    if _newclass:classType = staticmethod(_fusion.CollinearConstraint_classType)
    __swig_destroy__ = _fusion.delete_CollinearConstraint
    __del__ = lambda self : None;
    def _get_lineOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """Returns the first line."""
        return _fusion.CollinearConstraint__get_lineOne(self)

    def _get_lineTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """Returns the second line."""
        return _fusion.CollinearConstraint__get_lineTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::CollinearConstraint >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.CollinearConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::CollinearConstraint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.CollinearConstraint_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.CollinearConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.CollinearConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.CollinearConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CollinearConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.CollinearConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.CollinearConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CollinearConstraint__get_isValid(self)
CollinearConstraint_swigregister = _fusion.CollinearConstraint_swigregister
CollinearConstraint_swigregister(CollinearConstraint)

def CollinearConstraint_classType() -> "char const *" :
  return _fusion.CollinearConstraint_classType()
CollinearConstraint_classType = _fusion.CollinearConstraint_classType

CollinearConstraint.__swig_getmethods__["lineOne"] = CollinearConstraint._get_lineOne
CollinearConstraint.lineOne = property(CollinearConstraint._get_lineOne, doc="Returns the first line.")

CollinearConstraint.__swig_getmethods__["lineTwo"] = CollinearConstraint._get_lineTwo
CollinearConstraint.lineTwo = property(CollinearConstraint._get_lineTwo, doc="Returns the second line.")

CollinearConstraint.__swig_getmethods__["nativeObject"] = CollinearConstraint._get_nativeObject
CollinearConstraint.nativeObject = property(CollinearConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

CollinearConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CollinearConstraint) else None
CollinearConstraint.cast = lambda arg: arg if isinstance(arg, CollinearConstraint) else None

class CombineFeature(Feature):
    """
    Object that represents an existing Combine feature in a design. 
    In non-parametric environment this object does not exist.
    """
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CombineFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CombineFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CombineFeature *" : return _fusion.CombineFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CombineFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CombineFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CombineFeature_classType
    if _newclass:classType = staticmethod(_fusion.CombineFeature_classType)
    __swig_destroy__ = _fusion.delete_CombineFeature
    __del__ = lambda self : None;
    def _get_targetBody(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """Gets and sets the BRep Body object that represents the blank body."""
        return _fusion.CombineFeature__get_targetBody(self)

    def _set_targetBody(self, *args) -> "bool" :
        """Gets and sets the BRep Body object that represents the blank body."""
        return _fusion.CombineFeature__set_targetBody(self, *args)

    def _get_toolBodies(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """Gets and sets the BRep Body objects that represent the tool bodies."""
        return _fusion.CombineFeature__get_toolBodies(self)

    def _set_toolBodies(self, *args) -> "bool" :
        """Gets and sets the BRep Body objects that represent the tool bodies."""
        return _fusion.CombineFeature__set_toolBodies(self, *args)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """
        Gets and sets the type of operation performed by the combine.
        The valid values are JoinFeatureOperation, CutFeatureOperation and IntersectFeatureOperation.
        """
        return _fusion.CombineFeature__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """
        Gets and sets the type of operation performed by the combine.
        The valid values are JoinFeatureOperation, CutFeatureOperation and IntersectFeatureOperation.
        """
        return _fusion.CombineFeature__set_operation(self, *args)

    def _get_isNewComponent(self) -> "bool" :
        """Gets a boolean value for whether or not a new component was created when this feature was created."""
        return _fusion.CombineFeature__get_isNewComponent(self)

    def _get_isKeepToolBodies(self) -> "bool" :
        """Gets and sets a boolean value for whether or not the tool bodies are retrained after the combine results."""
        return _fusion.CombineFeature__get_isKeepToolBodies(self)

    def _set_isKeepToolBodies(self, *args) -> "bool" :
        """Gets and sets a boolean value for whether or not the tool bodies are retrained after the combine results."""
        return _fusion.CombineFeature__set_isKeepToolBodies(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::CombineFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.CombineFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::CombineFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.CombineFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CombineFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CombineFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.CombineFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.CombineFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CombineFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CombineFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.CombineFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.CombineFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.CombineFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.CombineFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CombineFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.CombineFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.CombineFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.CombineFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.CombineFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.CombineFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.CombineFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.CombineFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CombineFeature__get_isValid(self)
CombineFeature_swigregister = _fusion.CombineFeature_swigregister
CombineFeature_swigregister(CombineFeature)

def CombineFeature_classType() -> "char const *" :
  return _fusion.CombineFeature_classType()
CombineFeature_classType = _fusion.CombineFeature_classType

CombineFeature.__swig_getmethods__["targetBody"] = CombineFeature._get_targetBody
CombineFeature.__swig_setmethods__["targetBody"] = CombineFeature._set_targetBody
CombineFeature.targetBody = property(CombineFeature._get_targetBody, CombineFeature._set_targetBody, doc="Gets and sets the BRep Body object that represents the blank body.")

CombineFeature.__swig_getmethods__["toolBodies"] = CombineFeature._get_toolBodies
CombineFeature.__swig_setmethods__["toolBodies"] = CombineFeature._set_toolBodies
CombineFeature.toolBodies = property(CombineFeature._get_toolBodies, CombineFeature._set_toolBodies, doc="Gets and sets the BRep Body objects that represent the tool bodies.")

CombineFeature.__swig_getmethods__["operation"] = CombineFeature._get_operation
CombineFeature.__swig_setmethods__["operation"] = CombineFeature._set_operation
CombineFeature.operation = property(CombineFeature._get_operation, CombineFeature._set_operation, doc="Gets and sets the type of operation performed by the combine.\nThe valid values are JoinFeatureOperation, CutFeatureOperation and IntersectFeatureOperation.")

CombineFeature.__swig_getmethods__["isNewComponent"] = CombineFeature._get_isNewComponent
CombineFeature.isNewComponent = property(CombineFeature._get_isNewComponent, doc="Gets a boolean value for whether or not a new component was created when this feature was created.")

CombineFeature.__swig_getmethods__["isKeepToolBodies"] = CombineFeature._get_isKeepToolBodies
CombineFeature.__swig_setmethods__["isKeepToolBodies"] = CombineFeature._set_isKeepToolBodies
CombineFeature.isKeepToolBodies = property(CombineFeature._get_isKeepToolBodies, CombineFeature._set_isKeepToolBodies, doc="Gets and sets a boolean value for whether or not the tool bodies are retrained after the combine results.")

CombineFeature.__swig_getmethods__["nativeObject"] = CombineFeature._get_nativeObject
CombineFeature.nativeObject = property(CombineFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

CombineFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CombineFeature) else None
CombineFeature.cast = lambda arg: arg if isinstance(arg, CombineFeature) else None

class Component(BaseComponent):
    """
    Represents a component in the data model.
    A component represents a set of geometry, features, and parameters that make up an item in the design.
    A component can be referenced multiple times into a design with a Occurrence object.
    """
    __swig_setmethods__ = {}
    for _s in [BaseComponent]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Component, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseComponent]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Component, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::Component *" : return _fusion.Component___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.Component___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.Component___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.Component_classType
    if _newclass:classType = staticmethod(_fusion.Component_classType)
    __swig_destroy__ = _fusion.delete_Component
    __del__ = lambda self : None;
    def _get_sketches(self) -> "adsk::core::Ptr< adsk::fusion::Sketches >" :
        """
        Returns the sketches collection associated with this component.
        This provides access to the existing sketches and supports
        the creation of new sketches.
        """
        return _fusion.Component__get_sketches(self)

    def _get_features(self) -> "adsk::core::Ptr< adsk::fusion::Features >" :
        """
        Returns the collection that provides access to all of the features
        associated with this component.
        """
        return _fusion.Component__get_features(self)

    def _get_meshBodies(self) -> "adsk::core::Ptr< adsk::fusion::MeshBodies >" :
        """Returns the mesh bodies collection associated with this component."""
        return _fusion.Component__get_meshBodies(self)

    def _get_modelParameters(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameters >" :
        """Returns the collection of model parameters in the Component."""
        return _fusion.Component__get_modelParameters(self)

    def _get_isOriginFolderLightBulbOn(self) -> "bool" :
        """
        Gets and sets if the light bulb of the origin folder as seen in the browser is on or off.
        This controls the visibility of the origin construction geometry.
        """
        return _fusion.Component__get_isOriginFolderLightBulbOn(self)

    def _set_isOriginFolderLightBulbOn(self, *args) -> "bool" :
        """
        Gets and sets if the light bulb of the origin folder as seen in the browser is on or off.
        This controls the visibility of the origin construction geometry.
        """
        return _fusion.Component__set_isOriginFolderLightBulbOn(self, *args)

    def _get_isConstructionFolderLightBulbOn(self) -> "bool" :
        """
        Gets and sets if the light bulb of the construction folder as seen in the browser is on or off.
        This controls the visibility of the (non-origin) construction geometry 
        (i.e. planes, points, axes).
        """
        return _fusion.Component__get_isConstructionFolderLightBulbOn(self)

    def _set_isConstructionFolderLightBulbOn(self, *args) -> "bool" :
        """
        Gets and sets if the light bulb of the construction folder as seen in the browser is on or off.
        This controls the visibility of the (non-origin) construction geometry 
        (i.e. planes, points, axes).
        """
        return _fusion.Component__set_isConstructionFolderLightBulbOn(self, *args)

    def _get_isSketchFolderLightBulbOn(self) -> "bool" :
        """
        Gets and sets if the light bulb of the sketch folder as seen in the browser is on or off.
        This controls the visibility of the sketches in this component.
        """
        return _fusion.Component__get_isSketchFolderLightBulbOn(self)

    def _set_isSketchFolderLightBulbOn(self, *args) -> "bool" :
        """
        Gets and sets if the light bulb of the sketch folder as seen in the browser is on or off.
        This controls the visibility of the sketches in this component.
        """
        return _fusion.Component__set_isSketchFolderLightBulbOn(self, *args)

    def _get_xYConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        """Returns the XY origin construction plane."""
        return _fusion.Component__get_xYConstructionPlane(self)

    def _get_xZConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        """Returns the XZ origin construction plane."""
        return _fusion.Component__get_xZConstructionPlane(self)

    def _get_yZConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        """Returns the YZ origin construction plane."""
        return _fusion.Component__get_yZConstructionPlane(self)

    def _get_xConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >" :
        """Returns the X origin construction axis."""
        return _fusion.Component__get_xConstructionAxis(self)

    def _get_yConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >" :
        """Returns the Y origin construction axis."""
        return _fusion.Component__get_yConstructionAxis(self)

    def _get_zConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >" :
        """Returns the Z origin construction axis."""
        return _fusion.Component__get_zConstructionAxis(self)

    def _get_originConstructionPoint(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >" :
        """Returns the origin construction point."""
        return _fusion.Component__get_originConstructionPoint(self)

    def _get_partNumber(self) -> "std::string" :
        """
        Gets and sets the part number associated with this component. Setting this
        to an empty string will reset it to be the same as the component name.
        """
        return _fusion.Component__get_partNumber(self)

    def _set_partNumber(self, *args) -> "bool" :
        """
        Gets and sets the part number associated with this component. Setting this
        to an empty string will reset it to be the same as the component name.
        """
        return _fusion.Component__set_partNumber(self, *args)

    def _get_description(self) -> "std::string" :
        """Gets and sets the description associated with this component."""
        return _fusion.Component__get_description(self)

    def _set_description(self, *args) -> "bool" :
        """Gets and sets the description associated with this component."""
        return _fusion.Component__set_description(self, *args)

    def createOpenProfile(self, *args) -> "adsk::core::Ptr< adsk::fusion::Profile >" :
        """
        Creates an open profile based on the input curve(s). 
        curves : A SketchCurve or an ObjectCollection containing multiple sketch entities. If a single sketch curve
        is input the chainCurves argument is checked to determine if connected curves (they do not need to be tangent)
        should be automatically found. If multiple curves are provided the chainCurves argument is always
        treated as false so you must provide all of the curves in the object collection that you want included in the profile.
        The provided curves must all connect together in a single path.
        The input curves do not need to be in the same sketch, but they do need to geometrically connect for
        a valid profile to be created. 
        chainCurves : If true, this finds any curves within the same sketch that connect to the single input curve and automatically includes them in the profile. If 
        false, only the curves provided will be used to define the profile. This argument is ignored and treated as false if multiple curves are input. 
        Returns the new Profile object or null in the case of a failure.
        """
        return _fusion.Component_createOpenProfile(self, *args)

    def createBRepEdgeProfile(self, *args) -> "adsk::core::Ptr< adsk::fusion::Profile >" :
        """
        Creates a profile based on the outside open edges of a BRepFace. 
        edges : A single BRepEdge object or an ObjectCollection containing multiple BRepEdge objects, or a BRepLoop object. If a single edge
        is input, the chainEdges argument is checked to determine if connected edges (they do not need to be tangent)
        should be automatically found. If multiple edges are provided the chainEdges argument is always
        treated as false so you must provide all of the edges in the object collection that you want included in the profile. 
        and the edges must all connect together in a single path. if a BRepLoop object is provided, all of the edges in the loop
        are included in the profile and the chainEdges argument is ignored. 
        chainEdges : If true, this finds any edges that connect to the single input edge and automatically includes them in the profile. If 
        false, only the edges provided will be used to define the profile. This argument is ignored and treated as false if multipled edges 
        or a BRepLoop is input. 
        Returns the new Profile object or null in the case of a failure.
        """
        return _fusion.Component_createBRepEdgeProfile(self, *args)

    def _get_joints(self) -> "adsk::core::Ptr< adsk::fusion::Joints >" :
        """Returns the collection of joints associated with this component."""
        return _fusion.Component__get_joints(self)

    def _get_jointOrgins(self) -> "adsk::core::Ptr< adsk::fusion::JointOrigins >" :
        """
        This property was incorrectly spelled and has been replaced with the JointOrigins property.
        However, this needs to remain in the implementation to continue to support programs that
        already used it, but it will be hidden in the documentation.
        """
        return _fusion.Component__get_jointOrgins(self)

    def _get_asBuiltJoints(self) -> "adsk::core::Ptr< adsk::fusion::AsBuiltJoints >" :
        """Returns the collection of as-built joints associated with this component."""
        return _fusion.Component__get_asBuiltJoints(self)

    def _get_rigidGroups(self) -> "adsk::core::Ptr< adsk::fusion::RigidGroups >" :
        """Returns the collection of rigid groups associated with this component."""
        return _fusion.Component__get_rigidGroups(self)

    def _get_material(self) -> "adsk::core::Ptr< adsk::core::Material >" :
        """Gets and sets the physical material assigned to this component."""
        return _fusion.Component__get_material(self)

    def _set_material(self, *args) -> "bool" :
        """Gets and sets the physical material assigned to this component."""
        return _fusion.Component__set_material(self, *args)

    def _get_physicalProperties(self) -> "adsk::core::Ptr< adsk::fusion::PhysicalProperties >" :
        """
        Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc 
        of this component. Property values will be calulated using the 'LowCalculationAccuracy' setting when using this property
        to get the PhysicalProperties object. To specify a higher calculation tolerance, use the getPhysicalProperties method instead.
        """
        return _fusion.Component__get_physicalProperties(self)

    def saveCopyAs(self, *args) -> "adsk::core::Ptr< adsk::core::DataFileFuture >" :
        """
        Performs a Save Copy As on this component. This saves the specified component as a new document 
        in the specified location. 
        name : The name to use for the new document. If this is an empty string, Fusion 360 will use the 
        name of the component being saved. 
        dataFolder : The data folder to save the new document to. 
        description : The description string of the document. This can be an empty string. 
        tag : The tag string of the document. This can be an empty string. 
        Returns a DataFileFuture object that can be used to track the progress of the upload and get the
        resulting DataFile once it's available on A360.
        """
        return _fusion.Component_saveCopyAs(self, *args)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of this component. This is always in world space of the component."""
        return _fusion.Component__get_boundingBox(self)

    def _get_isJointsFolderLightBulbOn(self) -> "bool" :
        """
        Gets and sets if the light bulb of the joints folder as seen in the browser is on or off.
        This controls the visibility of the joints in this occurrence. The light bulb for the 
        folder is component specific and will turn off the joints for all occurrences referencing 
        the component.
        """
        return _fusion.Component__get_isJointsFolderLightBulbOn(self)

    def _set_isJointsFolderLightBulbOn(self, *args) -> "bool" :
        """
        Gets and sets if the light bulb of the joints folder as seen in the browser is on or off.
        This controls the visibility of the joints in this occurrence. The light bulb for the 
        folder is component specific and will turn off the joints for all occurrences referencing 
        the component.
        """
        return _fusion.Component__set_isJointsFolderLightBulbOn(self, *args)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.Component__get_attributes(self)

    def _get_isBodiesFolderLightBulbOn(self) -> "bool" :
        """
        Gets and sets if the light bulb of the bodies folder as seen in the browser is on or off.
        This controls the visibility of the solid/surface bodies and the mesh bodies in this component.
        """
        return _fusion.Component__get_isBodiesFolderLightBulbOn(self)

    def _set_isBodiesFolderLightBulbOn(self, *args) -> "bool" :
        """
        Gets and sets if the light bulb of the bodies folder as seen in the browser is on or off.
        This controls the visibility of the solid/surface bodies and the mesh bodies in this component.
        """
        return _fusion.Component__set_isBodiesFolderLightBulbOn(self, *args)

    def getPhysicalProperties(self, *args) -> "adsk::core::Ptr< adsk::fusion::PhysicalProperties >" :
        """
        Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc 
        of this component. 
        accuracy : Specifies the desired level of computational accuracy of the property calculations.
        The default value of 'LowCalculationAccuracy' returns results within a +/- 1% error margin.
        """
        return _fusion.Component_getPhysicalProperties(self, *args)

    def transformOccurrences(self, *args) -> "bool" :
        """
        Transforms a set of occurrences in one step. This provides better performance than transforming them one at a time.
        This method is only valid when called on the root component because Fusion 360 flattens the entire assembly structure
        when manipulating the assembly so all transforms are relative to the root component. 
        occurrences : An array of Occurrence objects that you want to transform. These must all be in the context of the root component which
        means proxies must be used for occurrences that are in sub-components. 
        transforms : An array of Matrix3D objects that defines the transform to apply to each occurrence. This array must be the same size
        as the array provided for the occurrences argument and the transform will be applied to the occurrence at the same index
        in the occurrences array. 
        ignoreJoints : Specifies if the joints are to be ignored and the occurrences are to be positioned based on then specified transform or if
        the joints should be used and the occurrence is transformed the best it can while still honoring the joints. 
        Returns true if the transform was successful.
        """
        return _fusion.Component_transformOccurrences(self, *args)

    def _get_allJoints(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::Joint >,std::allocator< adsk::core::Ptr< adsk::fusion::Joint > > >" :
        """
        Returns all joints in this component and any sub components. The joints returned are all in the context
        of this component so any joints in sub components will be proxies. This is primarily useful when used
        from the root component because Fusion 360 flattens the assembly structure, including joints, when manipulating
        an assembly.
        """
        return _fusion.Component__get_allJoints(self)

    def _get_allAsBuiltJoints(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::AsBuiltJoint >,std::allocator< adsk::core::Ptr< adsk::fusion::AsBuiltJoint > > >" :
        """
        Returns all joint origins in this component and any sub components. The joint origins returned are all in the context
        of this component so any joint origins in sub components will be proxies. This is primarily useful when used
        from the root component because Fusion 360 flattens the assembly structure, including joint origins, when manipulating
        an assembly.
        """
        return _fusion.Component__get_allAsBuiltJoints(self)

    def _get_allJointOrigins(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::JointOrigin >,std::allocator< adsk::core::Ptr< adsk::fusion::JointOrigin > > >" :
        """
        Returns all as-built joints in this component and any sub components. The as-built joints returned are all in the context
        of this component so any as-built joints in sub components will be proxies. This is primarily useful when used
        from the root component because Fusion 360 flattens the assembly structure, including as-built joints, when manipulating
        an assembly.
        """
        return _fusion.Component__get_allJointOrigins(self)

    def _get_allRigidGroups(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::RigidGroup >,std::allocator< adsk::core::Ptr< adsk::fusion::RigidGroup > > >" :
        """
        Returns all rigid groups in this component and any sub components. The rigid groups returned are all in the context
        of this component so any rigid groups in sub components will be proxies. This is primarily useful when used
        from the root component because Fusion 360 flattens the assembly structure, including rigid groups, when manipulating
        an assembly.
        """
        return _fusion.Component__get_allRigidGroups(self)

    def _get_opacity(self) -> "double" :
        """
        Gets and sets the opacity override assigned to this component. A value of 1.0 specifies
        that is it completely opaque and a value of 0.0 specifies that is it completely transparent.
        This is only applicable for a non-root local component.
        This value is not necessarily related to what the user sees because the opacity is inherited.
        For example, if you have TopComponent and it has a component in it called SubComponent and you 
        set the opacity of TopComponent to be 0.5, SubComponent will also be shown as slightly transparent
        even though the opacity property for it will return 1.0. Because a component can be referenced as
        an occurrence in other components and they can have different opacity settings, it's possible that
        different instances of the same component can display using different opacity levels. To get the
        opacity that it is being displayed with use the Occurrence.visibleOpacity property.
        """
        return _fusion.Component__get_opacity(self)

    def _set_opacity(self, *args) -> "bool" :
        """
        Gets and sets the opacity override assigned to this component. A value of 1.0 specifies
        that is it completely opaque and a value of 0.0 specifies that is it completely transparent.
        This is only applicable for a non-root local component.
        This value is not necessarily related to what the user sees because the opacity is inherited.
        For example, if you have TopComponent and it has a component in it called SubComponent and you 
        set the opacity of TopComponent to be 0.5, SubComponent will also be shown as slightly transparent
        even though the opacity property for it will return 1.0. Because a component can be referenced as
        an occurrence in other components and they can have different opacity settings, it's possible that
        different instances of the same component can display using different opacity levels. To get the
        opacity that it is being displayed with use the Occurrence.visibleOpacity property.
        """
        return _fusion.Component__set_opacity(self, *args)

    def _get_jointOrigins(self) -> "adsk::core::Ptr< adsk::fusion::JointOrigins >" :
        """Returns the collection of joint origins associated with this component."""
        return _fusion.Component__get_jointOrigins(self)

    def _get_customGraphicsGroups(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsGroups >" :
        """Returns the customGraphicsGroups object in this component."""
        return _fusion.Component__get_customGraphicsGroups(self)

    def _get_revisionId(self) -> "std::string" :
        """
        Returns the current revision ID of the component. This ID changes any time the component is modified in any way. By getting
        and saving the ID when you create any data that is dependent on the component, you can then compare the saved
        ID with the current ID to determine if the component has changed to know if you should update your data.
        """
        return _fusion.Component__get_revisionId(self)

    def _get_name(self) -> "std::string" :
        """
        Property that gets and sets the name of this component. This is the name
        shown in the browser for each occurrence referencing this component.
        """
        return _fusion.Component__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """
        Property that gets and sets the name of this component. This is the name
        shown in the browser for each occurrence referencing this component.
        """
        return _fusion.Component__set_name(self, *args)

    def _get_occurrences(self) -> "adsk::core::Ptr< adsk::fusion::Occurrences >" :
        """
        Property that returns the Occurrences collection associated with this component.
        This provides access to the occurrences at the top-level of this component and provides
        the functionality to add new occurrences.
        """
        return _fusion.Component__get_occurrences(self)

    def occurrencesByComponent(self, *args) -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >" :
        """
        Returns all occurrences at the top-level of this component that reference the specified component.
        The returned list is read-only. 
        component : The component that is being referenced by the occurrences that will be returned. 
        The occurrences referenced by the specified component.
        """
        return _fusion.Component_occurrencesByComponent(self, *args)

    def _get_allOccurrences(self) -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >" :
        """
        Returns all of the occurrences in the assembly regardless of their level within the assembly structure.
        The returned list is read-only.
        """
        return _fusion.Component__get_allOccurrences(self)

    def allOccurrencesByComponent(self, *args) -> "adsk::core::Ptr< adsk::fusion::OccurrenceList >" :
        """
        Returns all occurrences, at any level of the assembly, that reference the specified component.
        The returned list is read-only. 
        component : The component that is being referenced by the occurrences that will be returned. 
        The occurrences referenced by the specified component.
        """
        return _fusion.Component_allOccurrencesByComponent(self, *args)

    def _get_constructionPlanes(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlanes >" :
        """
        Returns the construction planes collection associated with this component.
        This provides access to the existing construction planes and supports
        the creation of new construction planes.
        """
        return _fusion.Component__get_constructionPlanes(self)

    def _get_constructionAxes(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxes >" :
        """
        Returns the construction axes collection associated with this component.
        This provides access to the existing construction axes and supports
        the creation of new construction axes.
        """
        return _fusion.Component__get_constructionAxes(self)

    def _get_constructionPoints(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoints >" :
        """
        Returns the construction points collection associated with this component.
        This provides access to the existing construction points and supports
        the creation of new construction points.
        """
        return _fusion.Component__get_constructionPoints(self)

    def _get_bRepBodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """Returns the B-Rep bodies collection associated with this component."""
        return _fusion.Component__get_bRepBodies(self)

    def _get_parentDesign(self) -> "adsk::core::Ptr< adsk::fusion::Design >" :
        """Returns the parent product this component is owned by."""
        return _fusion.Component__get_parentDesign(self)

    def findBRepUsingRay(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Finds all the B-Rep entities that are intersected by the specified ray. This can return BRepFace, BrepEdge,
        and BRepVertex objects. 
        originPoint : Input point that defines the origin of the ray. The search for entities begins at this point. 
        rayDirection : Input vector that defines the direction of the ray. The ray is infinite so the length of the vector is ignored. 
        entityType : The type of B-Rep entity wanted. You can also take advantage of B-Rep topology to infer other intersections. For example,
        If you get a BRepEdge it implies that the faces the edge connects were also intersected. If a BRepVertex is returned it 
        implies the edges that the vertex connects were intersected and the faces that the edges connect were intersected. 
        proximityTolerance : Optional argument that specifies the tolerance for the search. All entities within this distance from the ray and of the specified type will be returned. If not specified a default small tolerance is used. 
        visibleEntitiesOnly : Optional argument that indicates whether or not invisible entities should be included in the search. Defaults to True indicating that invisible entities will be ignored. 
        hitPoints : An ObjectCollection of Point3D objects that represent the coordinates where the ray hit the found entity. There will be the same number of hit points as returned entities
        and they will be in the collections in the same order. In other words, hit point 1 corresponds with found entity 1, hit point 2 corresponds with found entity 2, and so on.
        Because of the proximity tolerance the hitPoint may not actually lie on the entity but will be within the proximity tolerance to it.
        It's an optional out argument, returns the hit points if an existing ObjectCollection is input. You can create a new ObjectCollection by using
        the static create method on the ObjectCollection class. 
        Returns an ObjectCollection containing the entities found. The returned collection can be empty indicating nothing was found. The points are returned
        in an order where they are arranged based on their distance from the origin point where the closest point is first. If an entity is hit more than
        once, the entity is returned once for the first intersection.
        """
        return _fusion.Component_findBRepUsingRay(self, *args)

    def findBRepUsingPoint(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Finds all the entities of the specified type at the specified location. 
        point : Input coordinate that specifies the component space point at which to find the entities. 
        entityType : The type of B-Rep entity wanted. You can also take advantage of B-Rep topology to infer other that other entities were found. For example,
        If you get a BRepEdge it implies that the faces the edge connects were also found. If a BRepVertex is returned it 
        implies the edges that the vertex connects were found and the faces that the edges connect were found. 
        proximityTolerance : Specifies the tolerance for the search. All entities within this distance from the search point that match the filter will be returned. If not specified a default tolerance is used. 
        visibleEntitiesOnly : indicates whether or not invisible objects should be included in the search. Defaults to True indicating that invisible objects will be ignored. 
        Returns an ObjectCollection containing the entities found. The returned collection can be empty indicating nothing was found.
        """
        return _fusion.Component_findBRepUsingPoint(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.Component__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.Component__get_isValid(self)
Component_swigregister = _fusion.Component_swigregister
Component_swigregister(Component)

def Component_classType() -> "char const *" :
  return _fusion.Component_classType()
Component_classType = _fusion.Component_classType

Component.__swig_getmethods__["sketches"] = Component._get_sketches
Component.sketches = property(Component._get_sketches, doc="Returns the sketches collection associated with this component.\nThis provides access to the existing sketches and supports\nthe creation of new sketches.")

Component.__swig_getmethods__["features"] = Component._get_features
Component.features = property(Component._get_features, doc="Returns the collection that provides access to all of the features\nassociated with this component.")

Component.__swig_getmethods__["meshBodies"] = Component._get_meshBodies
Component.meshBodies = property(Component._get_meshBodies, doc="Returns the mesh bodies collection associated with this component.")

Component.__swig_getmethods__["modelParameters"] = Component._get_modelParameters
Component.modelParameters = property(Component._get_modelParameters, doc="Returns the collection of model parameters in the Component.")

Component.__swig_getmethods__["isOriginFolderLightBulbOn"] = Component._get_isOriginFolderLightBulbOn
Component.__swig_setmethods__["isOriginFolderLightBulbOn"] = Component._set_isOriginFolderLightBulbOn
Component.isOriginFolderLightBulbOn = property(Component._get_isOriginFolderLightBulbOn, Component._set_isOriginFolderLightBulbOn, doc="Gets and sets if the light bulb of the origin folder as seen in the browser is on or off.\nThis controls the visibility of the origin construction geometry.")

Component.__swig_getmethods__["isConstructionFolderLightBulbOn"] = Component._get_isConstructionFolderLightBulbOn
Component.__swig_setmethods__["isConstructionFolderLightBulbOn"] = Component._set_isConstructionFolderLightBulbOn
Component.isConstructionFolderLightBulbOn = property(Component._get_isConstructionFolderLightBulbOn, Component._set_isConstructionFolderLightBulbOn, doc="Gets and sets if the light bulb of the construction folder as seen in the browser is on or off.\nThis controls the visibility of the (non-origin) construction geometry\n(i.e. planes, points, axes).")

Component.__swig_getmethods__["isSketchFolderLightBulbOn"] = Component._get_isSketchFolderLightBulbOn
Component.__swig_setmethods__["isSketchFolderLightBulbOn"] = Component._set_isSketchFolderLightBulbOn
Component.isSketchFolderLightBulbOn = property(Component._get_isSketchFolderLightBulbOn, Component._set_isSketchFolderLightBulbOn, doc="Gets and sets if the light bulb of the sketch folder as seen in the browser is on or off.\nThis controls the visibility of the sketches in this component.")

Component.__swig_getmethods__["xYConstructionPlane"] = Component._get_xYConstructionPlane
Component.xYConstructionPlane = property(Component._get_xYConstructionPlane, doc="Returns the XY origin construction plane.")

Component.__swig_getmethods__["xZConstructionPlane"] = Component._get_xZConstructionPlane
Component.xZConstructionPlane = property(Component._get_xZConstructionPlane, doc="Returns the XZ origin construction plane.")

Component.__swig_getmethods__["yZConstructionPlane"] = Component._get_yZConstructionPlane
Component.yZConstructionPlane = property(Component._get_yZConstructionPlane, doc="Returns the YZ origin construction plane.")

Component.__swig_getmethods__["xConstructionAxis"] = Component._get_xConstructionAxis
Component.xConstructionAxis = property(Component._get_xConstructionAxis, doc="Returns the X origin construction axis.")

Component.__swig_getmethods__["yConstructionAxis"] = Component._get_yConstructionAxis
Component.yConstructionAxis = property(Component._get_yConstructionAxis, doc="Returns the Y origin construction axis.")

Component.__swig_getmethods__["zConstructionAxis"] = Component._get_zConstructionAxis
Component.zConstructionAxis = property(Component._get_zConstructionAxis, doc="Returns the Z origin construction axis.")

Component.__swig_getmethods__["originConstructionPoint"] = Component._get_originConstructionPoint
Component.originConstructionPoint = property(Component._get_originConstructionPoint, doc="Returns the origin construction point.")

Component.__swig_getmethods__["partNumber"] = Component._get_partNumber
Component.__swig_setmethods__["partNumber"] = Component._set_partNumber
Component.partNumber = property(Component._get_partNumber, Component._set_partNumber, doc="Gets and sets the part number associated with this component. Setting this\nto an empty string will reset it to be the same as the component name.")

Component.__swig_getmethods__["description"] = Component._get_description
Component.__swig_setmethods__["description"] = Component._set_description
Component.description = property(Component._get_description, Component._set_description, doc="Gets and sets the description associated with this component.")

Component.__swig_getmethods__["joints"] = Component._get_joints
Component.joints = property(Component._get_joints, doc="Returns the collection of joints associated with this component.")

Component.__swig_getmethods__["jointOrgins"] = Component._get_jointOrgins
Component.jointOrgins = property(Component._get_jointOrgins, doc="This property was incorrectly spelled and has been replaced with the JointOrigins property.\nHowever, this needs to remain in the implementation to continue to support programs that\nalready used it, but it will be hidden in the documentation.")

Component.__swig_getmethods__["asBuiltJoints"] = Component._get_asBuiltJoints
Component.asBuiltJoints = property(Component._get_asBuiltJoints, doc="Returns the collection of as-built joints associated with this component.")

Component.__swig_getmethods__["rigidGroups"] = Component._get_rigidGroups
Component.rigidGroups = property(Component._get_rigidGroups, doc="Returns the collection of rigid groups associated with this component.")

Component.__swig_getmethods__["material"] = Component._get_material
Component.__swig_setmethods__["material"] = Component._set_material
Component.material = property(Component._get_material, Component._set_material, doc="Gets and sets the physical material assigned to this component.")

Component.__swig_getmethods__["physicalProperties"] = Component._get_physicalProperties
Component.physicalProperties = property(Component._get_physicalProperties, doc="Returns the PhysicalProperties object that has properties for getting the area, density, mass, volume, moments, etc\nof this component. Property values will be calulated using the 'LowCalculationAccuracy' setting when using this property\nto get the PhysicalProperties object. To specify a higher calculation tolerance, use the getPhysicalProperties method instead.")

Component.__swig_getmethods__["boundingBox"] = Component._get_boundingBox
Component.boundingBox = property(Component._get_boundingBox, doc="Returns the bounding box of this component. This is always in world space of the component.")

Component.__swig_getmethods__["isJointsFolderLightBulbOn"] = Component._get_isJointsFolderLightBulbOn
Component.__swig_setmethods__["isJointsFolderLightBulbOn"] = Component._set_isJointsFolderLightBulbOn
Component.isJointsFolderLightBulbOn = property(Component._get_isJointsFolderLightBulbOn, Component._set_isJointsFolderLightBulbOn, doc="Gets and sets if the light bulb of the joints folder as seen in the browser is on or off.\nThis controls the visibility of the joints in this occurrence. The light bulb for the\nfolder is component specific and will turn off the joints for all occurrences referencing\nthe component.")

Component.__swig_getmethods__["attributes"] = Component._get_attributes
Component.attributes = property(Component._get_attributes, doc="Returns the collection of attributes associated with this face.")

Component.__swig_getmethods__["isBodiesFolderLightBulbOn"] = Component._get_isBodiesFolderLightBulbOn
Component.__swig_setmethods__["isBodiesFolderLightBulbOn"] = Component._set_isBodiesFolderLightBulbOn
Component.isBodiesFolderLightBulbOn = property(Component._get_isBodiesFolderLightBulbOn, Component._set_isBodiesFolderLightBulbOn, doc="Gets and sets if the light bulb of the bodies folder as seen in the browser is on or off.\nThis controls the visibility of the solid/surface bodies and the mesh bodies in this component.")

Component.__swig_getmethods__["allJoints"] = Component._get_allJoints
Component.allJoints = property(Component._get_allJoints, doc="Returns all joints in this component and any sub components. The joints returned are all in the context\nof this component so any joints in sub components will be proxies. This is primarily useful when used\nfrom the root component because Fusion 360 flattens the assembly structure, including joints, when manipulating\nan assembly.")

Component.__swig_getmethods__["allAsBuiltJoints"] = Component._get_allAsBuiltJoints
Component.allAsBuiltJoints = property(Component._get_allAsBuiltJoints, doc="Returns all joint origins in this component and any sub components. The joint origins returned are all in the context\nof this component so any joint origins in sub components will be proxies. This is primarily useful when used\nfrom the root component because Fusion 360 flattens the assembly structure, including joint origins, when manipulating\nan assembly.")

Component.__swig_getmethods__["allJointOrigins"] = Component._get_allJointOrigins
Component.allJointOrigins = property(Component._get_allJointOrigins, doc="Returns all as-built joints in this component and any sub components. The as-built joints returned are all in the context\nof this component so any as-built joints in sub components will be proxies. This is primarily useful when used\nfrom the root component because Fusion 360 flattens the assembly structure, including as-built joints, when manipulating\nan assembly.")

Component.__swig_getmethods__["allRigidGroups"] = Component._get_allRigidGroups
Component.allRigidGroups = property(Component._get_allRigidGroups, doc="Returns all rigid groups in this component and any sub components. The rigid groups returned are all in the context\nof this component so any rigid groups in sub components will be proxies. This is primarily useful when used\nfrom the root component because Fusion 360 flattens the assembly structure, including rigid groups, when manipulating\nan assembly.")

Component.__swig_getmethods__["opacity"] = Component._get_opacity
Component.__swig_setmethods__["opacity"] = Component._set_opacity
Component.opacity = property(Component._get_opacity, Component._set_opacity, doc="Gets and sets the opacity override assigned to this component. A value of 1.0 specifies\nthat is it completely opaque and a value of 0.0 specifies that is it completely transparent.\nThis is only applicable for a non-root local component.\nThis value is not necessarily related to what the user sees because the opacity is inherited.\nFor example, if you have TopComponent and it has a component in it called SubComponent and you\nset the opacity of TopComponent to be 0.5, SubComponent will also be shown as slightly transparent\neven though the opacity property for it will return 1.0. Because a component can be referenced as\nan occurrence in other components and they can have different opacity settings, it's possible that\ndifferent instances of the same component can display using different opacity levels. To get the\nopacity that it is being displayed with use the Occurrence.visibleOpacity property.")

Component.__swig_getmethods__["jointOrigins"] = Component._get_jointOrigins
Component.jointOrigins = property(Component._get_jointOrigins, doc="Returns the collection of joint origins associated with this component.")

Component.__swig_getmethods__["customGraphicsGroups"] = Component._get_customGraphicsGroups
Component.customGraphicsGroups = property(Component._get_customGraphicsGroups, doc="Returns the customGraphicsGroups object in this component.")

Component.__swig_getmethods__["revisionId"] = Component._get_revisionId
Component.revisionId = property(Component._get_revisionId, doc="Returns the current revision ID of the component. This ID changes any time the component is modified in any way. By getting\nand saving the ID when you create any data that is dependent on the component, you can then compare the saved\nID with the current ID to determine if the component has changed to know if you should update your data.")

Component.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, Component) else None
Component.cast = lambda arg: arg if isinstance(arg, Component) else None

class ConcentricConstraint(GeometricConstraint):
    """A concentric constraint in a sketch."""
    __swig_setmethods__ = {}
    for _s in [GeometricConstraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConcentricConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricConstraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConcentricConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConcentricConstraint *" : return _fusion.ConcentricConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConcentricConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConcentricConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConcentricConstraint_classType
    if _newclass:classType = staticmethod(_fusion.ConcentricConstraint_classType)
    __swig_destroy__ = _fusion.delete_ConcentricConstraint
    __del__ = lambda self : None;
    def _get_entityOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >" :
        """Returns the first curve."""
        return _fusion.ConcentricConstraint__get_entityOne(self)

    def _get_entityTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >" :
        """Returns the second curve."""
        return _fusion.ConcentricConstraint__get_entityTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ConcentricConstraint >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ConcentricConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::ConcentricConstraint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ConcentricConstraint_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.ConcentricConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.ConcentricConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.ConcentricConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ConcentricConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.ConcentricConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConcentricConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConcentricConstraint__get_isValid(self)
ConcentricConstraint_swigregister = _fusion.ConcentricConstraint_swigregister
ConcentricConstraint_swigregister(ConcentricConstraint)

def ConcentricConstraint_classType() -> "char const *" :
  return _fusion.ConcentricConstraint_classType()
ConcentricConstraint_classType = _fusion.ConcentricConstraint_classType

ConcentricConstraint.__swig_getmethods__["entityOne"] = ConcentricConstraint._get_entityOne
ConcentricConstraint.entityOne = property(ConcentricConstraint._get_entityOne, doc="Returns the first curve.")

ConcentricConstraint.__swig_getmethods__["entityTwo"] = ConcentricConstraint._get_entityTwo
ConcentricConstraint.entityTwo = property(ConcentricConstraint._get_entityTwo, doc="Returns the second curve.")

ConcentricConstraint.__swig_getmethods__["nativeObject"] = ConcentricConstraint._get_nativeObject
ConcentricConstraint.nativeObject = property(ConcentricConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

ConcentricConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConcentricConstraint) else None
ConcentricConstraint.cast = lambda arg: arg if isinstance(arg, ConcentricConstraint) else None

class ConstantRadiusFilletEdgeSet(FilletEdgeSet):
    """Provides access to the edges and the parameter associated with a constant radius fillet."""
    __swig_setmethods__ = {}
    for _s in [FilletEdgeSet]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstantRadiusFilletEdgeSet, name, value)
    __swig_getmethods__ = {}
    for _s in [FilletEdgeSet]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstantRadiusFilletEdgeSet, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstantRadiusFilletEdgeSet *" : return _fusion.ConstantRadiusFilletEdgeSet___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstantRadiusFilletEdgeSet___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstantRadiusFilletEdgeSet___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstantRadiusFilletEdgeSet_classType
    if _newclass:classType = staticmethod(_fusion.ConstantRadiusFilletEdgeSet_classType)
    __swig_destroy__ = _fusion.delete_ConstantRadiusFilletEdgeSet
    __del__ = lambda self : None;
    def _get_edges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the edges that will be filleted. In order to access (get) the input edges
        of a fillet, you must roll the timeline back to just before the fillet feature
        whose edges you want to access.
        """
        return _fusion.ConstantRadiusFilletEdgeSet__get_edges(self)

    def _set_edges(self, *args) -> "bool" :
        """
        Gets and sets the edges that will be filleted. In order to access (get) the input edges
        of a fillet, you must roll the timeline back to just before the fillet feature
        whose edges you want to access.
        """
        return _fusion.ConstantRadiusFilletEdgeSet__set_edges(self, *args)

    def _get_radius(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the model parameter that controls the radius of the fillet. You can edit
        the radius by using the properties on the returned ModelParameter object.
        """
        return _fusion.ConstantRadiusFilletEdgeSet__get_radius(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstantRadiusFilletEdgeSet__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstantRadiusFilletEdgeSet__get_isValid(self)
ConstantRadiusFilletEdgeSet_swigregister = _fusion.ConstantRadiusFilletEdgeSet_swigregister
ConstantRadiusFilletEdgeSet_swigregister(ConstantRadiusFilletEdgeSet)

def ConstantRadiusFilletEdgeSet_classType() -> "char const *" :
  return _fusion.ConstantRadiusFilletEdgeSet_classType()
ConstantRadiusFilletEdgeSet_classType = _fusion.ConstantRadiusFilletEdgeSet_classType

ConstantRadiusFilletEdgeSet.__swig_getmethods__["edges"] = ConstantRadiusFilletEdgeSet._get_edges
ConstantRadiusFilletEdgeSet.__swig_setmethods__["edges"] = ConstantRadiusFilletEdgeSet._set_edges
ConstantRadiusFilletEdgeSet.edges = property(ConstantRadiusFilletEdgeSet._get_edges, ConstantRadiusFilletEdgeSet._set_edges, doc="Gets and sets the edges that will be filleted. In order to access (get) the input edges\nof a fillet, you must roll the timeline back to just before the fillet feature\nwhose edges you want to access.")

ConstantRadiusFilletEdgeSet.__swig_getmethods__["radius"] = ConstantRadiusFilletEdgeSet._get_radius
ConstantRadiusFilletEdgeSet.radius = property(ConstantRadiusFilletEdgeSet._get_radius, doc="Returns the model parameter that controls the radius of the fillet. You can edit\nthe radius by using the properties on the returned ModelParameter object.")

ConstantRadiusFilletEdgeSet.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstantRadiusFilletEdgeSet) else None
ConstantRadiusFilletEdgeSet.cast = lambda arg: arg if isinstance(arg, ConstantRadiusFilletEdgeSet) else None

class ConstructionAxisByLineDefinition(ConstructionAxisDefinition):
    """
    The definition for a non-parametric construction axis. In a non-parametric design
    all construction planes will return this type of definition regardless of how they
    were initially created.
    """
    __swig_setmethods__ = {}
    for _s in [ConstructionAxisDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionAxisByLineDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionAxisDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionAxisByLineDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionAxisByLineDefinition *" : return _fusion.ConstructionAxisByLineDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionAxisByLineDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionAxisByLineDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionAxisByLineDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionAxisByLineDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionAxisByLineDefinition
    __del__ = lambda self : None;
    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::InfiniteLine3D >" :
        """Gets and sets the infinite line that defines the position and direction of the axis"""
        return _fusion.ConstructionAxisByLineDefinition__get_axis(self)

    def _set_axis(self, *args) -> "bool" :
        """Gets and sets the infinite line that defines the position and direction of the axis"""
        return _fusion.ConstructionAxisByLineDefinition__set_axis(self, *args)

    def _get_parentConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >" :
        """Returns the ConstructionAxis object"""
        return _fusion.ConstructionAxisByLineDefinition__get_parentConstructionAxis(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionAxisByLineDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionAxisByLineDefinition__get_isValid(self)
ConstructionAxisByLineDefinition_swigregister = _fusion.ConstructionAxisByLineDefinition_swigregister
ConstructionAxisByLineDefinition_swigregister(ConstructionAxisByLineDefinition)

def ConstructionAxisByLineDefinition_classType() -> "char const *" :
  return _fusion.ConstructionAxisByLineDefinition_classType()
ConstructionAxisByLineDefinition_classType = _fusion.ConstructionAxisByLineDefinition_classType

ConstructionAxisByLineDefinition.__swig_getmethods__["axis"] = ConstructionAxisByLineDefinition._get_axis
ConstructionAxisByLineDefinition.__swig_setmethods__["axis"] = ConstructionAxisByLineDefinition._set_axis
ConstructionAxisByLineDefinition.axis = property(ConstructionAxisByLineDefinition._get_axis, ConstructionAxisByLineDefinition._set_axis, doc="Gets and sets the infinite line that defines the position and direction of the axis")

ConstructionAxisByLineDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionAxisByLineDefinition) else None
ConstructionAxisByLineDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionAxisByLineDefinition) else None

class ConstructionAxisCircularFaceDefinition(ConstructionAxisDefinition):
    """The definition for a parametric construction axis created using the SetbyCircularFace method"""
    __swig_setmethods__ = {}
    for _s in [ConstructionAxisDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionAxisCircularFaceDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionAxisDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionAxisCircularFaceDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionAxisCircularFaceDefinition *" : return _fusion.ConstructionAxisCircularFaceDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionAxisCircularFaceDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionAxisCircularFaceDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionAxisCircularFaceDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionAxisCircularFaceDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionAxisCircularFaceDefinition
    __del__ = lambda self : None;
    def _get_circularFace(self) -> "adsk::core::Ptr< adsk::fusion::BRepFace >" :
        """
        Gets and sets the cylinder, cone, or torus this work axis 
        is parametrically dependent on.
        """
        return _fusion.ConstructionAxisCircularFaceDefinition__get_circularFace(self)

    def _set_circularFace(self, *args) -> "bool" :
        """
        Gets and sets the cylinder, cone, or torus this work axis 
        is parametrically dependent on.
        """
        return _fusion.ConstructionAxisCircularFaceDefinition__set_circularFace(self, *args)

    def _get_parentConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >" :
        """Returns the ConstructionAxis object"""
        return _fusion.ConstructionAxisCircularFaceDefinition__get_parentConstructionAxis(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionAxisCircularFaceDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionAxisCircularFaceDefinition__get_isValid(self)
ConstructionAxisCircularFaceDefinition_swigregister = _fusion.ConstructionAxisCircularFaceDefinition_swigregister
ConstructionAxisCircularFaceDefinition_swigregister(ConstructionAxisCircularFaceDefinition)

def ConstructionAxisCircularFaceDefinition_classType() -> "char const *" :
  return _fusion.ConstructionAxisCircularFaceDefinition_classType()
ConstructionAxisCircularFaceDefinition_classType = _fusion.ConstructionAxisCircularFaceDefinition_classType

ConstructionAxisCircularFaceDefinition.__swig_getmethods__["circularFace"] = ConstructionAxisCircularFaceDefinition._get_circularFace
ConstructionAxisCircularFaceDefinition.__swig_setmethods__["circularFace"] = ConstructionAxisCircularFaceDefinition._set_circularFace
ConstructionAxisCircularFaceDefinition.circularFace = property(ConstructionAxisCircularFaceDefinition._get_circularFace, ConstructionAxisCircularFaceDefinition._set_circularFace, doc="Gets and sets the cylinder, cone, or torus this work axis\nis parametrically dependent on.")

ConstructionAxisCircularFaceDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionAxisCircularFaceDefinition) else None
ConstructionAxisCircularFaceDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionAxisCircularFaceDefinition) else None

class ConstructionAxisEdgeDefinition(ConstructionAxisDefinition):
    """The definition for a parametric construction axis created using the SetbyEdge method"""
    __swig_setmethods__ = {}
    for _s in [ConstructionAxisDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionAxisEdgeDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionAxisDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionAxisEdgeDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionAxisEdgeDefinition *" : return _fusion.ConstructionAxisEdgeDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionAxisEdgeDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionAxisEdgeDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionAxisEdgeDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionAxisEdgeDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionAxisEdgeDefinition
    __del__ = lambda self : None;
    def _get_edgeEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the linear edge, construction line, or sketch line that defines 
        the construction axis.
        """
        return _fusion.ConstructionAxisEdgeDefinition__get_edgeEntity(self)

    def _set_edgeEntity(self, *args) -> "bool" :
        """
        Gets and sets the linear edge, construction line, or sketch line that defines 
        the construction axis.
        """
        return _fusion.ConstructionAxisEdgeDefinition__set_edgeEntity(self, *args)

    def _get_parentConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >" :
        """Returns the ConstructionAxis object"""
        return _fusion.ConstructionAxisEdgeDefinition__get_parentConstructionAxis(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionAxisEdgeDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionAxisEdgeDefinition__get_isValid(self)
ConstructionAxisEdgeDefinition_swigregister = _fusion.ConstructionAxisEdgeDefinition_swigregister
ConstructionAxisEdgeDefinition_swigregister(ConstructionAxisEdgeDefinition)

def ConstructionAxisEdgeDefinition_classType() -> "char const *" :
  return _fusion.ConstructionAxisEdgeDefinition_classType()
ConstructionAxisEdgeDefinition_classType = _fusion.ConstructionAxisEdgeDefinition_classType

ConstructionAxisEdgeDefinition.__swig_getmethods__["edgeEntity"] = ConstructionAxisEdgeDefinition._get_edgeEntity
ConstructionAxisEdgeDefinition.__swig_setmethods__["edgeEntity"] = ConstructionAxisEdgeDefinition._set_edgeEntity
ConstructionAxisEdgeDefinition.edgeEntity = property(ConstructionAxisEdgeDefinition._get_edgeEntity, ConstructionAxisEdgeDefinition._set_edgeEntity, doc="Gets and sets the linear edge, construction line, or sketch line that defines\nthe construction axis.")

ConstructionAxisEdgeDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionAxisEdgeDefinition) else None
ConstructionAxisEdgeDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionAxisEdgeDefinition) else None

class ConstructionAxisNormalToFaceAtPointDefinition(ConstructionAxisDefinition):
    """
    The definition for a parametric construction axis created using the 
    SetByNormalToFaceAtPoint method
    """
    __swig_setmethods__ = {}
    for _s in [ConstructionAxisDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionAxisNormalToFaceAtPointDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionAxisDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionAxisNormalToFaceAtPointDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionAxisNormalToFaceAtPointDefinition *" : return _fusion.ConstructionAxisNormalToFaceAtPointDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionAxisNormalToFaceAtPointDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionAxisNormalToFaceAtPointDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionAxisNormalToFaceAtPointDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionAxisNormalToFaceAtPointDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionAxisNormalToFaceAtPointDefinition
    __del__ = lambda self : None;
    def _get_face(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets the face the axis is normal to"""
        return _fusion.ConstructionAxisNormalToFaceAtPointDefinition__get_face(self)

    def _get_pointEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets the point that positions the axis"""
        return _fusion.ConstructionAxisNormalToFaceAtPointDefinition__get_pointEntity(self)

    def redefine(self, *args) -> "bool" :
        """
        Redefines the input geometry of the construction axis. 
        face : The face the axis is normal to 
        pointEntity : The point that positions the axis 
        Returns true if the redefinition of the construction axis is successful.
        """
        return _fusion.ConstructionAxisNormalToFaceAtPointDefinition_redefine(self, *args)

    def _get_parentConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >" :
        """Returns the ConstructionAxis object"""
        return _fusion.ConstructionAxisNormalToFaceAtPointDefinition__get_parentConstructionAxis(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionAxisNormalToFaceAtPointDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionAxisNormalToFaceAtPointDefinition__get_isValid(self)
ConstructionAxisNormalToFaceAtPointDefinition_swigregister = _fusion.ConstructionAxisNormalToFaceAtPointDefinition_swigregister
ConstructionAxisNormalToFaceAtPointDefinition_swigregister(ConstructionAxisNormalToFaceAtPointDefinition)

def ConstructionAxisNormalToFaceAtPointDefinition_classType() -> "char const *" :
  return _fusion.ConstructionAxisNormalToFaceAtPointDefinition_classType()
ConstructionAxisNormalToFaceAtPointDefinition_classType = _fusion.ConstructionAxisNormalToFaceAtPointDefinition_classType

ConstructionAxisNormalToFaceAtPointDefinition.__swig_getmethods__["face"] = ConstructionAxisNormalToFaceAtPointDefinition._get_face
ConstructionAxisNormalToFaceAtPointDefinition.face = property(ConstructionAxisNormalToFaceAtPointDefinition._get_face, doc="Gets the face the axis is normal to")

ConstructionAxisNormalToFaceAtPointDefinition.__swig_getmethods__["pointEntity"] = ConstructionAxisNormalToFaceAtPointDefinition._get_pointEntity
ConstructionAxisNormalToFaceAtPointDefinition.pointEntity = property(ConstructionAxisNormalToFaceAtPointDefinition._get_pointEntity, doc="Gets the point that positions the axis")

ConstructionAxisNormalToFaceAtPointDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionAxisNormalToFaceAtPointDefinition) else None
ConstructionAxisNormalToFaceAtPointDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionAxisNormalToFaceAtPointDefinition) else None

class ConstructionAxisPerpendicularAtPointDefinition(ConstructionAxisDefinition):
    """
    The definition for a parametric construction axis created using the 
    SetByPerpendicularAtPoint method
    """
    __swig_setmethods__ = {}
    for _s in [ConstructionAxisDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionAxisPerpendicularAtPointDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionAxisDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionAxisPerpendicularAtPointDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionAxisPerpendicularAtPointDefinition *" : return _fusion.ConstructionAxisPerpendicularAtPointDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionAxisPerpendicularAtPointDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionAxisPerpendicularAtPointDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionAxisPerpendicularAtPointDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionAxisPerpendicularAtPointDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionAxisPerpendicularAtPointDefinition
    __del__ = lambda self : None;
    def _get_face(self) -> "adsk::core::Ptr< adsk::fusion::BRepFace >" :
        """Returns the face the construction axis is perpendicular to."""
        return _fusion.ConstructionAxisPerpendicularAtPointDefinition__get_face(self)

    def _get_point(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the point (construction or sketch point) that positions the axis."""
        return _fusion.ConstructionAxisPerpendicularAtPointDefinition__get_point(self)

    def redefine(self, *args) -> "bool" :
        """
        Redefines the input geometry of the construction axis. 
        face : The face (BRepFace object) to create the axis perpendicular to. 
        pointEntity : The point (sketch point, vertex, construction point) used to position the axis. 
        Returns true if the redefinition of the axis is successful.
        """
        return _fusion.ConstructionAxisPerpendicularAtPointDefinition_redefine(self, *args)

    def _get_parentConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >" :
        """Returns the ConstructionAxis object"""
        return _fusion.ConstructionAxisPerpendicularAtPointDefinition__get_parentConstructionAxis(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionAxisPerpendicularAtPointDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionAxisPerpendicularAtPointDefinition__get_isValid(self)
ConstructionAxisPerpendicularAtPointDefinition_swigregister = _fusion.ConstructionAxisPerpendicularAtPointDefinition_swigregister
ConstructionAxisPerpendicularAtPointDefinition_swigregister(ConstructionAxisPerpendicularAtPointDefinition)

def ConstructionAxisPerpendicularAtPointDefinition_classType() -> "char const *" :
  return _fusion.ConstructionAxisPerpendicularAtPointDefinition_classType()
ConstructionAxisPerpendicularAtPointDefinition_classType = _fusion.ConstructionAxisPerpendicularAtPointDefinition_classType

ConstructionAxisPerpendicularAtPointDefinition.__swig_getmethods__["face"] = ConstructionAxisPerpendicularAtPointDefinition._get_face
ConstructionAxisPerpendicularAtPointDefinition.face = property(ConstructionAxisPerpendicularAtPointDefinition._get_face, doc="Returns the face the construction axis is perpendicular to.")

ConstructionAxisPerpendicularAtPointDefinition.__swig_getmethods__["point"] = ConstructionAxisPerpendicularAtPointDefinition._get_point
ConstructionAxisPerpendicularAtPointDefinition.point = property(ConstructionAxisPerpendicularAtPointDefinition._get_point, doc="Returns the point (construction or sketch point) that positions the axis.")

ConstructionAxisPerpendicularAtPointDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionAxisPerpendicularAtPointDefinition) else None
ConstructionAxisPerpendicularAtPointDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionAxisPerpendicularAtPointDefinition) else None

class ConstructionAxisTwoPlaneDefinition(ConstructionAxisDefinition):
    """The definition for a parametric construction axis created using the SetByTwoPlanes method"""
    __swig_setmethods__ = {}
    for _s in [ConstructionAxisDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionAxisTwoPlaneDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionAxisDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionAxisTwoPlaneDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionAxisTwoPlaneDefinition *" : return _fusion.ConstructionAxisTwoPlaneDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionAxisTwoPlaneDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionAxisTwoPlaneDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionAxisTwoPlaneDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionAxisTwoPlaneDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionAxisTwoPlaneDefinition
    __del__ = lambda self : None;
    def _get_planarEntityOne(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets the first planar face or construction plane"""
        return _fusion.ConstructionAxisTwoPlaneDefinition__get_planarEntityOne(self)

    def _get_planarEntityTwo(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets the second planar face or construction plane"""
        return _fusion.ConstructionAxisTwoPlaneDefinition__get_planarEntityTwo(self)

    def redefine(self, *args) -> "bool" :
        """
        Redefines the input geometry of the construction axis. 
        planarEntityOne : The first planar face or construction plane 
        planarEntityTwo : The second planar face or construction plane 
        Returns true if the redefinition of the axis is successful.
        """
        return _fusion.ConstructionAxisTwoPlaneDefinition_redefine(self, *args)

    def _get_parentConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >" :
        """Returns the ConstructionAxis object"""
        return _fusion.ConstructionAxisTwoPlaneDefinition__get_parentConstructionAxis(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionAxisTwoPlaneDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionAxisTwoPlaneDefinition__get_isValid(self)
ConstructionAxisTwoPlaneDefinition_swigregister = _fusion.ConstructionAxisTwoPlaneDefinition_swigregister
ConstructionAxisTwoPlaneDefinition_swigregister(ConstructionAxisTwoPlaneDefinition)

def ConstructionAxisTwoPlaneDefinition_classType() -> "char const *" :
  return _fusion.ConstructionAxisTwoPlaneDefinition_classType()
ConstructionAxisTwoPlaneDefinition_classType = _fusion.ConstructionAxisTwoPlaneDefinition_classType

ConstructionAxisTwoPlaneDefinition.__swig_getmethods__["planarEntityOne"] = ConstructionAxisTwoPlaneDefinition._get_planarEntityOne
ConstructionAxisTwoPlaneDefinition.planarEntityOne = property(ConstructionAxisTwoPlaneDefinition._get_planarEntityOne, doc="Gets the first planar face or construction plane")

ConstructionAxisTwoPlaneDefinition.__swig_getmethods__["planarEntityTwo"] = ConstructionAxisTwoPlaneDefinition._get_planarEntityTwo
ConstructionAxisTwoPlaneDefinition.planarEntityTwo = property(ConstructionAxisTwoPlaneDefinition._get_planarEntityTwo, doc="Gets the second planar face or construction plane")

ConstructionAxisTwoPlaneDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionAxisTwoPlaneDefinition) else None
ConstructionAxisTwoPlaneDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionAxisTwoPlaneDefinition) else None

class ConstructionAxisTwoPointDefinition(ConstructionAxisDefinition):
    """The definition for a parametric construction axis created using the SetbyTwoPoints method"""
    __swig_setmethods__ = {}
    for _s in [ConstructionAxisDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionAxisTwoPointDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionAxisDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionAxisTwoPointDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionAxisTwoPointDefinition *" : return _fusion.ConstructionAxisTwoPointDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionAxisTwoPointDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionAxisTwoPointDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionAxisTwoPointDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionAxisTwoPointDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionAxisTwoPointDefinition
    __del__ = lambda self : None;
    def _get_pointEntityOne(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets the first point."""
        return _fusion.ConstructionAxisTwoPointDefinition__get_pointEntityOne(self)

    def _get_pointEntityTwo(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets the second point."""
        return _fusion.ConstructionAxisTwoPointDefinition__get_pointEntityTwo(self)

    def redefine(self, *args) -> "bool" :
        """
        Redefines the input geometry of the construction axis. 
        pointEntityOne : The first point 
        pointEntityTwo : The second point 
        Returns true if the redefinition of the construction axis is successful.
        """
        return _fusion.ConstructionAxisTwoPointDefinition_redefine(self, *args)

    def _get_parentConstructionAxis(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionAxis >" :
        """Returns the ConstructionAxis object"""
        return _fusion.ConstructionAxisTwoPointDefinition__get_parentConstructionAxis(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionAxisTwoPointDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionAxisTwoPointDefinition__get_isValid(self)
ConstructionAxisTwoPointDefinition_swigregister = _fusion.ConstructionAxisTwoPointDefinition_swigregister
ConstructionAxisTwoPointDefinition_swigregister(ConstructionAxisTwoPointDefinition)

def ConstructionAxisTwoPointDefinition_classType() -> "char const *" :
  return _fusion.ConstructionAxisTwoPointDefinition_classType()
ConstructionAxisTwoPointDefinition_classType = _fusion.ConstructionAxisTwoPointDefinition_classType

ConstructionAxisTwoPointDefinition.__swig_getmethods__["pointEntityOne"] = ConstructionAxisTwoPointDefinition._get_pointEntityOne
ConstructionAxisTwoPointDefinition.pointEntityOne = property(ConstructionAxisTwoPointDefinition._get_pointEntityOne, doc="Gets the first point.")

ConstructionAxisTwoPointDefinition.__swig_getmethods__["pointEntityTwo"] = ConstructionAxisTwoPointDefinition._get_pointEntityTwo
ConstructionAxisTwoPointDefinition.pointEntityTwo = property(ConstructionAxisTwoPointDefinition._get_pointEntityTwo, doc="Gets the second point.")

ConstructionAxisTwoPointDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionAxisTwoPointDefinition) else None
ConstructionAxisTwoPointDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionAxisTwoPointDefinition) else None

class ConstructionPlaneAtAngleDefinition(ConstructionPlaneDefinition):
    """ConstructionPlaneAtAngleDefinition defines a ConstructionPlane by..."""
    __swig_setmethods__ = {}
    for _s in [ConstructionPlaneDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPlaneAtAngleDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionPlaneDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPlaneAtAngleDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPlaneAtAngleDefinition *" : return _fusion.ConstructionPlaneAtAngleDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPlaneAtAngleDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPlaneAtAngleDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPlaneAtAngleDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPlaneAtAngleDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPlaneAtAngleDefinition
    __del__ = lambda self : None;
    def _get_angle(self) -> "adsk::core::Ptr< adsk::fusion::Parameter >" :
        """
        Returns a Value object that for a transient definition provides the current
        assigned value. For a definition associated with a construction plane, this
        provides access to the associated parameter controlling the angle.
        """
        return _fusion.ConstructionPlaneAtAngleDefinition__get_angle(self)

    def _get_linearEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the linear edge, construction line, or sketch line that defines 
        the axis of rotation for the construction plane.
        """
        return _fusion.ConstructionPlaneAtAngleDefinition__get_linearEntity(self)

    def _get_planarEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the planar face or construction plane the angle for this 
        construction plane is measured from and is parametrically dependent on.
        """
        return _fusion.ConstructionPlaneAtAngleDefinition__get_planarEntity(self)

    def redefine(self, *args) -> "bool" :
        """
        Redefines the input geometry of the construction plane. 
        angle : A ValueInput object that defines the angle at which to create the construction plane 
        linearEntity : The linear edge, construction line, or sketch line that defines the axis of rotation to
        measure the angle about 
        planarEntity : A plane, planar face or construction plane the angle of the construction plane is
        measured from 
        Returns true if the redefinition of the plane is successful.
        """
        return _fusion.ConstructionPlaneAtAngleDefinition_redefine(self, *args)

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        """Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneAtAngleDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPlaneAtAngleDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPlaneAtAngleDefinition__get_isValid(self)
ConstructionPlaneAtAngleDefinition_swigregister = _fusion.ConstructionPlaneAtAngleDefinition_swigregister
ConstructionPlaneAtAngleDefinition_swigregister(ConstructionPlaneAtAngleDefinition)

def ConstructionPlaneAtAngleDefinition_classType() -> "char const *" :
  return _fusion.ConstructionPlaneAtAngleDefinition_classType()
ConstructionPlaneAtAngleDefinition_classType = _fusion.ConstructionPlaneAtAngleDefinition_classType

ConstructionPlaneAtAngleDefinition.__swig_getmethods__["angle"] = ConstructionPlaneAtAngleDefinition._get_angle
ConstructionPlaneAtAngleDefinition.angle = property(ConstructionPlaneAtAngleDefinition._get_angle, doc="Returns a Value object that for a transient definition provides the current\nassigned value. For a definition associated with a construction plane, this\nprovides access to the associated parameter controlling the angle.")

ConstructionPlaneAtAngleDefinition.__swig_getmethods__["linearEntity"] = ConstructionPlaneAtAngleDefinition._get_linearEntity
ConstructionPlaneAtAngleDefinition.linearEntity = property(ConstructionPlaneAtAngleDefinition._get_linearEntity, doc="Gets the linear edge, construction line, or sketch line that defines\nthe axis of rotation for the construction plane.")

ConstructionPlaneAtAngleDefinition.__swig_getmethods__["planarEntity"] = ConstructionPlaneAtAngleDefinition._get_planarEntity
ConstructionPlaneAtAngleDefinition.planarEntity = property(ConstructionPlaneAtAngleDefinition._get_planarEntity, doc="Gets the planar face or construction plane the angle for this\nconstruction plane is measured from and is parametrically dependent on.")

ConstructionPlaneAtAngleDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPlaneAtAngleDefinition) else None
ConstructionPlaneAtAngleDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneAtAngleDefinition) else None

class ConstructionPlaneByPlaneDefinition(ConstructionPlaneDefinition):
    """
    The definition for a non-parametric construction plane. All constructions planes will 
    return this type of definition regardless of method used to initially create them.
    """
    __swig_setmethods__ = {}
    for _s in [ConstructionPlaneDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPlaneByPlaneDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionPlaneDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPlaneByPlaneDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPlaneByPlaneDefinition *" : return _fusion.ConstructionPlaneByPlaneDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPlaneByPlaneDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPlaneByPlaneDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPlaneByPlaneDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPlaneByPlaneDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPlaneByPlaneDefinition
    __del__ = lambda self : None;
    def _get_plane(self) -> "adsk::core::Ptr< adsk::core::Plane >" :
        """Gets and sets the position of the construction plane."""
        return _fusion.ConstructionPlaneByPlaneDefinition__get_plane(self)

    def _set_plane(self, *args) -> "bool" :
        """Gets and sets the position of the construction plane."""
        return _fusion.ConstructionPlaneByPlaneDefinition__set_plane(self, *args)

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        """Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneByPlaneDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPlaneByPlaneDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPlaneByPlaneDefinition__get_isValid(self)
ConstructionPlaneByPlaneDefinition_swigregister = _fusion.ConstructionPlaneByPlaneDefinition_swigregister
ConstructionPlaneByPlaneDefinition_swigregister(ConstructionPlaneByPlaneDefinition)

def ConstructionPlaneByPlaneDefinition_classType() -> "char const *" :
  return _fusion.ConstructionPlaneByPlaneDefinition_classType()
ConstructionPlaneByPlaneDefinition_classType = _fusion.ConstructionPlaneByPlaneDefinition_classType

ConstructionPlaneByPlaneDefinition.__swig_getmethods__["plane"] = ConstructionPlaneByPlaneDefinition._get_plane
ConstructionPlaneByPlaneDefinition.__swig_setmethods__["plane"] = ConstructionPlaneByPlaneDefinition._set_plane
ConstructionPlaneByPlaneDefinition.plane = property(ConstructionPlaneByPlaneDefinition._get_plane, ConstructionPlaneByPlaneDefinition._set_plane, doc="Gets and sets the position of the construction plane.")

ConstructionPlaneByPlaneDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPlaneByPlaneDefinition) else None
ConstructionPlaneByPlaneDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneByPlaneDefinition) else None

class ConstructionPlaneDistanceOnPathDefinition(ConstructionPlaneDefinition):
    """
    ConstructionDistanceOnPathDefinition defines a ConstructionPlane normal to an edge or
    sketch profile at a specified position along the path defined by the edge or sketch profile.
    """
    __swig_setmethods__ = {}
    for _s in [ConstructionPlaneDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPlaneDistanceOnPathDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionPlaneDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPlaneDistanceOnPathDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPlaneDistanceOnPathDefinition *" : return _fusion.ConstructionPlaneDistanceOnPathDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPlaneDistanceOnPathDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPlaneDistanceOnPathDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPlaneDistanceOnPathDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPlaneDistanceOnPathDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPlaneDistanceOnPathDefinition
    __del__ = lambda self : None;
    def _get_pathEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets the sketch curve, edge, or a profile object."""
        return _fusion.ConstructionPlaneDistanceOnPathDefinition__get_pathEntity(self)

    def redefine(self, *args) -> "bool" :
        """
        Redefines the input defining the construction plane. 
        pathEntity : The sketch curve, edge, or a profile object 
        distance : The ValueInput object that defines the distance along the path 
        Returns true if the redefinition of the plane is successful.
        """
        return _fusion.ConstructionPlaneDistanceOnPathDefinition_redefine(self, *args)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::fusion::Parameter >" :
        """Gets the distance along the path."""
        return _fusion.ConstructionPlaneDistanceOnPathDefinition__get_distance(self)

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        """Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneDistanceOnPathDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPlaneDistanceOnPathDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPlaneDistanceOnPathDefinition__get_isValid(self)
ConstructionPlaneDistanceOnPathDefinition_swigregister = _fusion.ConstructionPlaneDistanceOnPathDefinition_swigregister
ConstructionPlaneDistanceOnPathDefinition_swigregister(ConstructionPlaneDistanceOnPathDefinition)

def ConstructionPlaneDistanceOnPathDefinition_classType() -> "char const *" :
  return _fusion.ConstructionPlaneDistanceOnPathDefinition_classType()
ConstructionPlaneDistanceOnPathDefinition_classType = _fusion.ConstructionPlaneDistanceOnPathDefinition_classType

ConstructionPlaneDistanceOnPathDefinition.__swig_getmethods__["pathEntity"] = ConstructionPlaneDistanceOnPathDefinition._get_pathEntity
ConstructionPlaneDistanceOnPathDefinition.pathEntity = property(ConstructionPlaneDistanceOnPathDefinition._get_pathEntity, doc="Gets the sketch curve, edge, or a profile object.")

ConstructionPlaneDistanceOnPathDefinition.__swig_getmethods__["distance"] = ConstructionPlaneDistanceOnPathDefinition._get_distance
ConstructionPlaneDistanceOnPathDefinition.distance = property(ConstructionPlaneDistanceOnPathDefinition._get_distance, doc="Gets the distance along the path.")

ConstructionPlaneDistanceOnPathDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPlaneDistanceOnPathDefinition) else None
ConstructionPlaneDistanceOnPathDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneDistanceOnPathDefinition) else None

class ConstructionPlaneMidplaneDefinition(ConstructionPlaneDefinition):
    """ConstructionPlaneMidplaneDefinition defines a ConstructionPlane by..."""
    __swig_setmethods__ = {}
    for _s in [ConstructionPlaneDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPlaneMidplaneDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionPlaneDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPlaneMidplaneDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPlaneMidplaneDefinition *" : return _fusion.ConstructionPlaneMidplaneDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPlaneMidplaneDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPlaneMidplaneDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPlaneMidplaneDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPlaneMidplaneDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPlaneMidplaneDefinition
    __del__ = lambda self : None;
    def _get_planarEntityOne(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets the first planar face or construction plane that defines this ConstructionPlane."""
        return _fusion.ConstructionPlaneMidplaneDefinition__get_planarEntityOne(self)

    def _get_planarEntityTwo(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets the second planar face or construction plane that defines this ConstructionPlane."""
        return _fusion.ConstructionPlaneMidplaneDefinition__get_planarEntityTwo(self)

    def redefine(self, *args) -> "bool" :
        """
        Redefines the input geometry of the construction plane. 
        planarEntityOne : The first planar face or construction plane that defines this ConstructionPlane. 
        planarEntityTwo : The second planar face or construction plane that defines this ConstructionPlane. 
        Returns true if the redefinition of the plane is successful.
        """
        return _fusion.ConstructionPlaneMidplaneDefinition_redefine(self, *args)

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        """Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneMidplaneDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPlaneMidplaneDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPlaneMidplaneDefinition__get_isValid(self)
ConstructionPlaneMidplaneDefinition_swigregister = _fusion.ConstructionPlaneMidplaneDefinition_swigregister
ConstructionPlaneMidplaneDefinition_swigregister(ConstructionPlaneMidplaneDefinition)

def ConstructionPlaneMidplaneDefinition_classType() -> "char const *" :
  return _fusion.ConstructionPlaneMidplaneDefinition_classType()
ConstructionPlaneMidplaneDefinition_classType = _fusion.ConstructionPlaneMidplaneDefinition_classType

ConstructionPlaneMidplaneDefinition.__swig_getmethods__["planarEntityOne"] = ConstructionPlaneMidplaneDefinition._get_planarEntityOne
ConstructionPlaneMidplaneDefinition.planarEntityOne = property(ConstructionPlaneMidplaneDefinition._get_planarEntityOne, doc="Gets the first planar face or construction plane that defines this ConstructionPlane.")

ConstructionPlaneMidplaneDefinition.__swig_getmethods__["planarEntityTwo"] = ConstructionPlaneMidplaneDefinition._get_planarEntityTwo
ConstructionPlaneMidplaneDefinition.planarEntityTwo = property(ConstructionPlaneMidplaneDefinition._get_planarEntityTwo, doc="Gets the second planar face or construction plane that defines this ConstructionPlane.")

ConstructionPlaneMidplaneDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPlaneMidplaneDefinition) else None
ConstructionPlaneMidplaneDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneMidplaneDefinition) else None

class ConstructionPlaneOffsetDefinition(ConstructionPlaneDefinition):
    """ConstructionPlaneOffsetDefinition defines a ConstructionPlane by..."""
    __swig_setmethods__ = {}
    for _s in [ConstructionPlaneDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPlaneOffsetDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionPlaneDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPlaneOffsetDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPlaneOffsetDefinition *" : return _fusion.ConstructionPlaneOffsetDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPlaneOffsetDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPlaneOffsetDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPlaneOffsetDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPlaneOffsetDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPlaneOffsetDefinition
    __del__ = lambda self : None;
    def _get_offset(self) -> "adsk::core::Ptr< adsk::fusion::Parameter >" :
        """
        Returns a Value object that for a transient definition that provides the current
        assigned value and for a definition associated with a construction plane
        Provides access to the associated parameter controlling the offset.
        """
        return _fusion.ConstructionPlaneOffsetDefinition__get_offset(self)

    def _get_planarEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the planar face or construction plane this construction plane
        is parametrically dependent on.
        """
        return _fusion.ConstructionPlaneOffsetDefinition__get_planarEntity(self)

    def redefine(self, *args) -> "bool" :
        """
        Redefines the input geometry of the construction plane. 
        offset : ValueInput object that specifies the offset distance 
        planarEntity : A plane, planar face or construction plane from which to measure the offset from 
        Returns true is the operation is successful
        """
        return _fusion.ConstructionPlaneOffsetDefinition_redefine(self, *args)

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        """Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneOffsetDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPlaneOffsetDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPlaneOffsetDefinition__get_isValid(self)
ConstructionPlaneOffsetDefinition_swigregister = _fusion.ConstructionPlaneOffsetDefinition_swigregister
ConstructionPlaneOffsetDefinition_swigregister(ConstructionPlaneOffsetDefinition)

def ConstructionPlaneOffsetDefinition_classType() -> "char const *" :
  return _fusion.ConstructionPlaneOffsetDefinition_classType()
ConstructionPlaneOffsetDefinition_classType = _fusion.ConstructionPlaneOffsetDefinition_classType

ConstructionPlaneOffsetDefinition.__swig_getmethods__["offset"] = ConstructionPlaneOffsetDefinition._get_offset
ConstructionPlaneOffsetDefinition.offset = property(ConstructionPlaneOffsetDefinition._get_offset, doc="Returns a Value object that for a transient definition that provides the current\nassigned value and for a definition associated with a construction plane\nProvides access to the associated parameter controlling the offset.")

ConstructionPlaneOffsetDefinition.__swig_getmethods__["planarEntity"] = ConstructionPlaneOffsetDefinition._get_planarEntity
ConstructionPlaneOffsetDefinition.planarEntity = property(ConstructionPlaneOffsetDefinition._get_planarEntity, doc="Gets the planar face or construction plane this construction plane\nis parametrically dependent on.")

ConstructionPlaneOffsetDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPlaneOffsetDefinition) else None
ConstructionPlaneOffsetDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneOffsetDefinition) else None

class ConstructionPlaneTangentAtPointDefinition(ConstructionPlaneDefinition):
    """
    ConstructionPlaneTangentAtPointDefinition defines a ConstructionPlane tangent to a 
    face and aligned to a point.
    """
    __swig_setmethods__ = {}
    for _s in [ConstructionPlaneDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPlaneTangentAtPointDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionPlaneDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPlaneTangentAtPointDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPlaneTangentAtPointDefinition *" : return _fusion.ConstructionPlaneTangentAtPointDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPlaneTangentAtPointDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPlaneTangentAtPointDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPlaneTangentAtPointDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPlaneTangentAtPointDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPlaneTangentAtPointDefinition
    __del__ = lambda self : None;
    def _get_tangentFace(self) -> "adsk::core::Ptr< adsk::fusion::BRepFace >" :
        """Gets the tangent face."""
        return _fusion.ConstructionPlaneTangentAtPointDefinition__get_tangentFace(self)

    def _get_pointEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets the point (sketch point, vertex, construction point) used to align the plane."""
        return _fusion.ConstructionPlaneTangentAtPointDefinition__get_pointEntity(self)

    def redefine(self, *args) -> "bool" :
        """
        Redefines the input geometry of the construction plane. 
        tangentFace : The face to create the plane tangent to 
        pointEntity : The point (sketch point, vertex, construction point) used to align the plane. 
        Returns true if the redefinition of the plane is successful.
        """
        return _fusion.ConstructionPlaneTangentAtPointDefinition_redefine(self, *args)

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        """Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneTangentAtPointDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPlaneTangentAtPointDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPlaneTangentAtPointDefinition__get_isValid(self)
ConstructionPlaneTangentAtPointDefinition_swigregister = _fusion.ConstructionPlaneTangentAtPointDefinition_swigregister
ConstructionPlaneTangentAtPointDefinition_swigregister(ConstructionPlaneTangentAtPointDefinition)

def ConstructionPlaneTangentAtPointDefinition_classType() -> "char const *" :
  return _fusion.ConstructionPlaneTangentAtPointDefinition_classType()
ConstructionPlaneTangentAtPointDefinition_classType = _fusion.ConstructionPlaneTangentAtPointDefinition_classType

ConstructionPlaneTangentAtPointDefinition.__swig_getmethods__["tangentFace"] = ConstructionPlaneTangentAtPointDefinition._get_tangentFace
ConstructionPlaneTangentAtPointDefinition.tangentFace = property(ConstructionPlaneTangentAtPointDefinition._get_tangentFace, doc="Gets the tangent face.")

ConstructionPlaneTangentAtPointDefinition.__swig_getmethods__["pointEntity"] = ConstructionPlaneTangentAtPointDefinition._get_pointEntity
ConstructionPlaneTangentAtPointDefinition.pointEntity = property(ConstructionPlaneTangentAtPointDefinition._get_pointEntity, doc="Gets the point (sketch point, vertex, construction point) used to align the plane.")

ConstructionPlaneTangentAtPointDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPlaneTangentAtPointDefinition) else None
ConstructionPlaneTangentAtPointDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneTangentAtPointDefinition) else None

class ConstructionPlaneTangentDefinition(ConstructionPlaneDefinition):
    """
    ConstructionPlaneTangentDefinition defines a ConstructionPlane tangent to a cylindrical or conical
    face at a point.
    """
    __swig_setmethods__ = {}
    for _s in [ConstructionPlaneDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPlaneTangentDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionPlaneDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPlaneTangentDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPlaneTangentDefinition *" : return _fusion.ConstructionPlaneTangentDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPlaneTangentDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPlaneTangentDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPlaneTangentDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPlaneTangentDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPlaneTangentDefinition
    __del__ = lambda self : None;
    def _get_angle(self) -> "adsk::core::Ptr< adsk::fusion::Parameter >" :
        """
        Returns a Value object that for a transient definition provides the current
        assigned value. For a definition associated with a construction plane, it
        provides access to the associated parameter controlling the angle.
        """
        return _fusion.ConstructionPlaneTangentDefinition__get_angle(self)

    def _get_tangentFace(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the cylindrical or conical face that the construction plane
        is tangent to.
        """
        return _fusion.ConstructionPlaneTangentDefinition__get_tangentFace(self)

    def _get_planarEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the planar face or construction plane the angle for this 
        construction plane is measured from and is parametrically dependent on.
        """
        return _fusion.ConstructionPlaneTangentDefinition__get_planarEntity(self)

    def redefine(self, *args) -> "bool" :
        """
        Redefines the input geometry of the construction plane. 
        angle : A Value object that defines the angle of the construction plane 
        tangentFace : The cylindrical or conical face that the construction plane is tangent to. 
        planarEntity : The planar face or construction plane the angle for this 
        construction plane is measured from 
        Returns true if the redefinition of the plane is successful.
        """
        return _fusion.ConstructionPlaneTangentDefinition_redefine(self, *args)

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        """Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneTangentDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPlaneTangentDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPlaneTangentDefinition__get_isValid(self)
ConstructionPlaneTangentDefinition_swigregister = _fusion.ConstructionPlaneTangentDefinition_swigregister
ConstructionPlaneTangentDefinition_swigregister(ConstructionPlaneTangentDefinition)

def ConstructionPlaneTangentDefinition_classType() -> "char const *" :
  return _fusion.ConstructionPlaneTangentDefinition_classType()
ConstructionPlaneTangentDefinition_classType = _fusion.ConstructionPlaneTangentDefinition_classType

ConstructionPlaneTangentDefinition.__swig_getmethods__["angle"] = ConstructionPlaneTangentDefinition._get_angle
ConstructionPlaneTangentDefinition.angle = property(ConstructionPlaneTangentDefinition._get_angle, doc="Returns a Value object that for a transient definition provides the current\nassigned value. For a definition associated with a construction plane, it\nprovides access to the associated parameter controlling the angle.")

ConstructionPlaneTangentDefinition.__swig_getmethods__["tangentFace"] = ConstructionPlaneTangentDefinition._get_tangentFace
ConstructionPlaneTangentDefinition.tangentFace = property(ConstructionPlaneTangentDefinition._get_tangentFace, doc="Gets the cylindrical or conical face that the construction plane\nis tangent to.")

ConstructionPlaneTangentDefinition.__swig_getmethods__["planarEntity"] = ConstructionPlaneTangentDefinition._get_planarEntity
ConstructionPlaneTangentDefinition.planarEntity = property(ConstructionPlaneTangentDefinition._get_planarEntity, doc="Gets the planar face or construction plane the angle for this\nconstruction plane is measured from and is parametrically dependent on.")

ConstructionPlaneTangentDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPlaneTangentDefinition) else None
ConstructionPlaneTangentDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneTangentDefinition) else None

class ConstructionPlaneThreePointsDefinition(ConstructionPlaneDefinition):
    """
    ConstructionPlaneThreePointDefinition defines a ConstructionPlane by 3 point entities 
    (e.g. (sketch points, vectrices or construction points) that form a triangle (i.e.
    no two points the same and they aren't collinear).
    """
    __swig_setmethods__ = {}
    for _s in [ConstructionPlaneDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPlaneThreePointsDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionPlaneDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPlaneThreePointsDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPlaneThreePointsDefinition *" : return _fusion.ConstructionPlaneThreePointsDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPlaneThreePointsDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPlaneThreePointsDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPlaneThreePointsDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPlaneThreePointsDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPlaneThreePointsDefinition
    __del__ = lambda self : None;
    def _get_pointEntityOne(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets the first construction point, sketch point or vertex."""
        return _fusion.ConstructionPlaneThreePointsDefinition__get_pointEntityOne(self)

    def _get_pointEntityTwo(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets the second construction point, sketch point or vertex."""
        return _fusion.ConstructionPlaneThreePointsDefinition__get_pointEntityTwo(self)

    def _get_pointEntityThree(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets the third construction point, sketch point or vertex."""
        return _fusion.ConstructionPlaneThreePointsDefinition__get_pointEntityThree(self)

    def redefine(self, *args) -> "bool" :
        """
        Redefines the input geometry of the construction plane. 
        pointEntityOne : Gets the first construction point, sketch point or vertex. 
        pointEntityTwo : Gets the second construction point, sketch point or vertex. 
        pointEntityThree : Gets the third construction point, sketch point or vertex. 
        Returns true if the redefinition of the plane is successful.
        """
        return _fusion.ConstructionPlaneThreePointsDefinition_redefine(self, *args)

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        """Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneThreePointsDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPlaneThreePointsDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPlaneThreePointsDefinition__get_isValid(self)
ConstructionPlaneThreePointsDefinition_swigregister = _fusion.ConstructionPlaneThreePointsDefinition_swigregister
ConstructionPlaneThreePointsDefinition_swigregister(ConstructionPlaneThreePointsDefinition)

def ConstructionPlaneThreePointsDefinition_classType() -> "char const *" :
  return _fusion.ConstructionPlaneThreePointsDefinition_classType()
ConstructionPlaneThreePointsDefinition_classType = _fusion.ConstructionPlaneThreePointsDefinition_classType

ConstructionPlaneThreePointsDefinition.__swig_getmethods__["pointEntityOne"] = ConstructionPlaneThreePointsDefinition._get_pointEntityOne
ConstructionPlaneThreePointsDefinition.pointEntityOne = property(ConstructionPlaneThreePointsDefinition._get_pointEntityOne, doc="Gets the first construction point, sketch point or vertex.")

ConstructionPlaneThreePointsDefinition.__swig_getmethods__["pointEntityTwo"] = ConstructionPlaneThreePointsDefinition._get_pointEntityTwo
ConstructionPlaneThreePointsDefinition.pointEntityTwo = property(ConstructionPlaneThreePointsDefinition._get_pointEntityTwo, doc="Gets the second construction point, sketch point or vertex.")

ConstructionPlaneThreePointsDefinition.__swig_getmethods__["pointEntityThree"] = ConstructionPlaneThreePointsDefinition._get_pointEntityThree
ConstructionPlaneThreePointsDefinition.pointEntityThree = property(ConstructionPlaneThreePointsDefinition._get_pointEntityThree, doc="Gets the third construction point, sketch point or vertex.")

ConstructionPlaneThreePointsDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPlaneThreePointsDefinition) else None
ConstructionPlaneThreePointsDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneThreePointsDefinition) else None

class ConstructionPlaneTwoEdgesDefinition(ConstructionPlaneDefinition):
    """
    ConstructionPlaneTwoEdgesDefinition defines a ConstructionPlane by two co-planar
    linear entities like edges, sketch lines or construction axis.
    """
    __swig_setmethods__ = {}
    for _s in [ConstructionPlaneDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPlaneTwoEdgesDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionPlaneDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPlaneTwoEdgesDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPlaneTwoEdgesDefinition *" : return _fusion.ConstructionPlaneTwoEdgesDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPlaneTwoEdgesDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPlaneTwoEdgesDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPlaneTwoEdgesDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPlaneTwoEdgesDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPlaneTwoEdgesDefinition
    __del__ = lambda self : None;
    def _get_linearEntityOne(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the first linear edge, construction line, or sketch line that defines 
        the construction plane.
        """
        return _fusion.ConstructionPlaneTwoEdgesDefinition__get_linearEntityOne(self)

    def _get_linearEntityTwo(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the second linear edge, construction line, or sketch line that defines 
        the construction plane.
        """
        return _fusion.ConstructionPlaneTwoEdgesDefinition__get_linearEntityTwo(self)

    def redefine(self, *args) -> "bool" :
        """
        Redefines the input geometry of the construction plane. 
        linearEntityOne : The first linear edge, construction line, or sketch line that defines 
        the construction plane. 
        linearEntityTwo : The second linear edge, construction line, or sketch line that defines 
        the construction plane.
        """
        return _fusion.ConstructionPlaneTwoEdgesDefinition_redefine(self, *args)

    def _get_parentConstructionPlane(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPlane >" :
        """Returns the ConstructionPlane object"""
        return _fusion.ConstructionPlaneTwoEdgesDefinition__get_parentConstructionPlane(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPlaneTwoEdgesDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPlaneTwoEdgesDefinition__get_isValid(self)
ConstructionPlaneTwoEdgesDefinition_swigregister = _fusion.ConstructionPlaneTwoEdgesDefinition_swigregister
ConstructionPlaneTwoEdgesDefinition_swigregister(ConstructionPlaneTwoEdgesDefinition)

def ConstructionPlaneTwoEdgesDefinition_classType() -> "char const *" :
  return _fusion.ConstructionPlaneTwoEdgesDefinition_classType()
ConstructionPlaneTwoEdgesDefinition_classType = _fusion.ConstructionPlaneTwoEdgesDefinition_classType

ConstructionPlaneTwoEdgesDefinition.__swig_getmethods__["linearEntityOne"] = ConstructionPlaneTwoEdgesDefinition._get_linearEntityOne
ConstructionPlaneTwoEdgesDefinition.linearEntityOne = property(ConstructionPlaneTwoEdgesDefinition._get_linearEntityOne, doc="Gets the first linear edge, construction line, or sketch line that defines\nthe construction plane.")

ConstructionPlaneTwoEdgesDefinition.__swig_getmethods__["linearEntityTwo"] = ConstructionPlaneTwoEdgesDefinition._get_linearEntityTwo
ConstructionPlaneTwoEdgesDefinition.linearEntityTwo = property(ConstructionPlaneTwoEdgesDefinition._get_linearEntityTwo, doc="Gets the second linear edge, construction line, or sketch line that defines\nthe construction plane.")

ConstructionPlaneTwoEdgesDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPlaneTwoEdgesDefinition) else None
ConstructionPlaneTwoEdgesDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPlaneTwoEdgesDefinition) else None

class ConstructionPointCenterDefinition(ConstructionPointDefinition):
    """The definition for a parametric construction point created using the SetbyCenter method"""
    __swig_setmethods__ = {}
    for _s in [ConstructionPointDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPointCenterDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionPointDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPointCenterDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPointCenterDefinition *" : return _fusion.ConstructionPointCenterDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPointCenterDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPointCenterDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPointCenterDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPointCenterDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPointCenterDefinition
    __del__ = lambda self : None;
    def _get_circularEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the spherical face (sphere or torus), circular edge or sketch arc/circle
        whose center defines the location for the construction point.
        """
        return _fusion.ConstructionPointCenterDefinition__get_circularEntity(self)

    def _set_circularEntity(self, *args) -> "bool" :
        """
        Gets and sets the spherical face (sphere or torus), circular edge or sketch arc/circle
        whose center defines the location for the construction point.
        """
        return _fusion.ConstructionPointCenterDefinition__set_circularEntity(self, *args)

    def _get_parentConstructionPoint(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >" :
        """Returns the ConstructionPoint object"""
        return _fusion.ConstructionPointCenterDefinition__get_parentConstructionPoint(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPointCenterDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPointCenterDefinition__get_isValid(self)
ConstructionPointCenterDefinition_swigregister = _fusion.ConstructionPointCenterDefinition_swigregister
ConstructionPointCenterDefinition_swigregister(ConstructionPointCenterDefinition)

def ConstructionPointCenterDefinition_classType() -> "char const *" :
  return _fusion.ConstructionPointCenterDefinition_classType()
ConstructionPointCenterDefinition_classType = _fusion.ConstructionPointCenterDefinition_classType

ConstructionPointCenterDefinition.__swig_getmethods__["circularEntity"] = ConstructionPointCenterDefinition._get_circularEntity
ConstructionPointCenterDefinition.__swig_setmethods__["circularEntity"] = ConstructionPointCenterDefinition._set_circularEntity
ConstructionPointCenterDefinition.circularEntity = property(ConstructionPointCenterDefinition._get_circularEntity, ConstructionPointCenterDefinition._set_circularEntity, doc="Gets and sets the spherical face (sphere or torus), circular edge or sketch arc/circle\nwhose center defines the location for the construction point.")

ConstructionPointCenterDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPointCenterDefinition) else None
ConstructionPointCenterDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPointCenterDefinition) else None

class ConstructionPointEdgePlaneDefinition(ConstructionPointDefinition):
    """The definition for a parametric construction point created using the SetbyEdgePlane method"""
    __swig_setmethods__ = {}
    for _s in [ConstructionPointDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPointEdgePlaneDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionPointDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPointEdgePlaneDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPointEdgePlaneDefinition *" : return _fusion.ConstructionPointEdgePlaneDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPointEdgePlaneDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPointEdgePlaneDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPointEdgePlaneDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPointEdgePlaneDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPointEdgePlaneDefinition
    __del__ = lambda self : None;
    def _get_edge(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """A linear B-Rep edge, construction axis or sketch line."""
        return _fusion.ConstructionPointEdgePlaneDefinition__get_edge(self)

    def _get_plane(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """A plane, planar B-Rep face or construction plane."""
        return _fusion.ConstructionPointEdgePlaneDefinition__get_plane(self)

    def redefine(self, *args) -> "bool" :
        """
        Redefines the input geometry of the construction point. 
        edge : A linear B-Rep edge, construction axis or sketch line. 
        plane : A plane, planar B-Rep face or construction plane. 
        Returns true if the redefinition of the Construction Point is successful.
        """
        return _fusion.ConstructionPointEdgePlaneDefinition_redefine(self, *args)

    def _get_parentConstructionPoint(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >" :
        """Returns the ConstructionPoint object"""
        return _fusion.ConstructionPointEdgePlaneDefinition__get_parentConstructionPoint(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPointEdgePlaneDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPointEdgePlaneDefinition__get_isValid(self)
ConstructionPointEdgePlaneDefinition_swigregister = _fusion.ConstructionPointEdgePlaneDefinition_swigregister
ConstructionPointEdgePlaneDefinition_swigregister(ConstructionPointEdgePlaneDefinition)

def ConstructionPointEdgePlaneDefinition_classType() -> "char const *" :
  return _fusion.ConstructionPointEdgePlaneDefinition_classType()
ConstructionPointEdgePlaneDefinition_classType = _fusion.ConstructionPointEdgePlaneDefinition_classType

ConstructionPointEdgePlaneDefinition.__swig_getmethods__["edge"] = ConstructionPointEdgePlaneDefinition._get_edge
ConstructionPointEdgePlaneDefinition.edge = property(ConstructionPointEdgePlaneDefinition._get_edge, doc="A linear B-Rep edge, construction axis or sketch line.")

ConstructionPointEdgePlaneDefinition.__swig_getmethods__["plane"] = ConstructionPointEdgePlaneDefinition._get_plane
ConstructionPointEdgePlaneDefinition.plane = property(ConstructionPointEdgePlaneDefinition._get_plane, doc="A plane, planar B-Rep face or construction plane.")

ConstructionPointEdgePlaneDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPointEdgePlaneDefinition) else None
ConstructionPointEdgePlaneDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPointEdgePlaneDefinition) else None

class ConstructionPointPointDefinition(ConstructionPointDefinition):
    """
    The definition for a parametric construction point created using the SetbyPoint method
    All non-parametric constructions points will return this type of definition regardless 
    of the method used to initially create them.
    """
    __swig_setmethods__ = {}
    for _s in [ConstructionPointDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPointPointDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionPointDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPointPointDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPointPointDefinition *" : return _fusion.ConstructionPointPointDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPointPointDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPointPointDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPointPointDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPointPointDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPointPointDefinition
    __del__ = lambda self : None;
    def _get_pointEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the position of the point using a construction point, sketch point or
        vertex.
        Non-parametric points will always return a Point3D object
        """
        return _fusion.ConstructionPointPointDefinition__get_pointEntity(self)

    def _set_pointEntity(self, *args) -> "bool" :
        """
        Gets and sets the position of the point using a construction point, sketch point or
        vertex.
        Non-parametric points will always return a Point3D object
        """
        return _fusion.ConstructionPointPointDefinition__set_pointEntity(self, *args)

    def _get_parentConstructionPoint(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >" :
        """Returns the ConstructionPoint object"""
        return _fusion.ConstructionPointPointDefinition__get_parentConstructionPoint(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPointPointDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPointPointDefinition__get_isValid(self)
ConstructionPointPointDefinition_swigregister = _fusion.ConstructionPointPointDefinition_swigregister
ConstructionPointPointDefinition_swigregister(ConstructionPointPointDefinition)

def ConstructionPointPointDefinition_classType() -> "char const *" :
  return _fusion.ConstructionPointPointDefinition_classType()
ConstructionPointPointDefinition_classType = _fusion.ConstructionPointPointDefinition_classType

ConstructionPointPointDefinition.__swig_getmethods__["pointEntity"] = ConstructionPointPointDefinition._get_pointEntity
ConstructionPointPointDefinition.__swig_setmethods__["pointEntity"] = ConstructionPointPointDefinition._set_pointEntity
ConstructionPointPointDefinition.pointEntity = property(ConstructionPointPointDefinition._get_pointEntity, ConstructionPointPointDefinition._set_pointEntity, doc="Gets and sets the position of the point using a construction point, sketch point or\nvertex.\nNon-parametric points will always return a Point3D object")

ConstructionPointPointDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPointPointDefinition) else None
ConstructionPointPointDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPointPointDefinition) else None

class ConstructionPointThreePlanesDefinition(ConstructionPointDefinition):
    """The definition for a parametric construction point created using the SetbyThreePlanes method"""
    __swig_setmethods__ = {}
    for _s in [ConstructionPointDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPointThreePlanesDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionPointDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPointThreePlanesDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPointThreePlanesDefinition *" : return _fusion.ConstructionPointThreePlanesDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPointThreePlanesDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPointThreePlanesDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPointThreePlanesDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPointThreePlanesDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPointThreePlanesDefinition
    __del__ = lambda self : None;
    def _get_planeOne(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """The first plane or planar face"""
        return _fusion.ConstructionPointThreePlanesDefinition__get_planeOne(self)

    def _get_planeTwo(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """The second plane or planar face"""
        return _fusion.ConstructionPointThreePlanesDefinition__get_planeTwo(self)

    def _get_planeThree(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """The third plane or planar face"""
        return _fusion.ConstructionPointThreePlanesDefinition__get_planeThree(self)

    def redefine(self, *args) -> "bool" :
        """
        Redefines the input geometry of the construction point. 
        planeOne : The first plane or planar face to intersect 
        planeTwo : The second plane or planar face to intersect 
        planeThree : The third plane or planar face to intersect 
        Returns true if the redefinition of the Construction Point is successful.
        """
        return _fusion.ConstructionPointThreePlanesDefinition_redefine(self, *args)

    def _get_parentConstructionPoint(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >" :
        """Returns the ConstructionPoint object"""
        return _fusion.ConstructionPointThreePlanesDefinition__get_parentConstructionPoint(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPointThreePlanesDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPointThreePlanesDefinition__get_isValid(self)
ConstructionPointThreePlanesDefinition_swigregister = _fusion.ConstructionPointThreePlanesDefinition_swigregister
ConstructionPointThreePlanesDefinition_swigregister(ConstructionPointThreePlanesDefinition)

def ConstructionPointThreePlanesDefinition_classType() -> "char const *" :
  return _fusion.ConstructionPointThreePlanesDefinition_classType()
ConstructionPointThreePlanesDefinition_classType = _fusion.ConstructionPointThreePlanesDefinition_classType

ConstructionPointThreePlanesDefinition.__swig_getmethods__["planeOne"] = ConstructionPointThreePlanesDefinition._get_planeOne
ConstructionPointThreePlanesDefinition.planeOne = property(ConstructionPointThreePlanesDefinition._get_planeOne, doc="The first plane or planar face")

ConstructionPointThreePlanesDefinition.__swig_getmethods__["planeTwo"] = ConstructionPointThreePlanesDefinition._get_planeTwo
ConstructionPointThreePlanesDefinition.planeTwo = property(ConstructionPointThreePlanesDefinition._get_planeTwo, doc="The second plane or planar face")

ConstructionPointThreePlanesDefinition.__swig_getmethods__["planeThree"] = ConstructionPointThreePlanesDefinition._get_planeThree
ConstructionPointThreePlanesDefinition.planeThree = property(ConstructionPointThreePlanesDefinition._get_planeThree, doc="The third plane or planar face")

ConstructionPointThreePlanesDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPointThreePlanesDefinition) else None
ConstructionPointThreePlanesDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPointThreePlanesDefinition) else None

class ConstructionPointTwoEdgesDefinition(ConstructionPointDefinition):
    """The definition for a parametric construction point created using the SetbyTwoEdges method"""
    __swig_setmethods__ = {}
    for _s in [ConstructionPointDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstructionPointTwoEdgesDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ConstructionPointDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstructionPointTwoEdgesDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ConstructionPointTwoEdgesDefinition *" : return _fusion.ConstructionPointTwoEdgesDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ConstructionPointTwoEdgesDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ConstructionPointTwoEdgesDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ConstructionPointTwoEdgesDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ConstructionPointTwoEdgesDefinition_classType)
    __swig_destroy__ = _fusion.delete_ConstructionPointTwoEdgesDefinition
    __del__ = lambda self : None;
    def _get_edgeOne(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns a B-Rep edge or sketch line"""
        return _fusion.ConstructionPointTwoEdgesDefinition__get_edgeOne(self)

    def _get_edgeTwo(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns a B-Rep edge or sketch line"""
        return _fusion.ConstructionPointTwoEdgesDefinition__get_edgeTwo(self)

    def redefine(self, *args) -> "bool" :
        """
        Redefines the input geometry of the construction point. 
        edgeOne : The first B-Rep edge or sketch line 
        edgeTwo : The second B-Rep edge or sketch line 
        Returns true if the redefinition of the Construction Point is successful.
        """
        return _fusion.ConstructionPointTwoEdgesDefinition_redefine(self, *args)

    def _get_parentConstructionPoint(self) -> "adsk::core::Ptr< adsk::fusion::ConstructionPoint >" :
        """Returns the ConstructionPoint object"""
        return _fusion.ConstructionPointTwoEdgesDefinition__get_parentConstructionPoint(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ConstructionPointTwoEdgesDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ConstructionPointTwoEdgesDefinition__get_isValid(self)
ConstructionPointTwoEdgesDefinition_swigregister = _fusion.ConstructionPointTwoEdgesDefinition_swigregister
ConstructionPointTwoEdgesDefinition_swigregister(ConstructionPointTwoEdgesDefinition)

def ConstructionPointTwoEdgesDefinition_classType() -> "char const *" :
  return _fusion.ConstructionPointTwoEdgesDefinition_classType()
ConstructionPointTwoEdgesDefinition_classType = _fusion.ConstructionPointTwoEdgesDefinition_classType

ConstructionPointTwoEdgesDefinition.__swig_getmethods__["edgeOne"] = ConstructionPointTwoEdgesDefinition._get_edgeOne
ConstructionPointTwoEdgesDefinition.edgeOne = property(ConstructionPointTwoEdgesDefinition._get_edgeOne, doc="Returns a B-Rep edge or sketch line")

ConstructionPointTwoEdgesDefinition.__swig_getmethods__["edgeTwo"] = ConstructionPointTwoEdgesDefinition._get_edgeTwo
ConstructionPointTwoEdgesDefinition.edgeTwo = property(ConstructionPointTwoEdgesDefinition._get_edgeTwo, doc="Returns a B-Rep edge or sketch line")

ConstructionPointTwoEdgesDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ConstructionPointTwoEdgesDefinition) else None
ConstructionPointTwoEdgesDefinition.cast = lambda arg: arg if isinstance(arg, ConstructionPointTwoEdgesDefinition) else None

class CopyPasteBody(Feature):
    """Object that represents an existing Copy/Paste Body feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CopyPasteBody, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CopyPasteBody, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CopyPasteBody *" : return _fusion.CopyPasteBody___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CopyPasteBody___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CopyPasteBody___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CopyPasteBody_classType
    if _newclass:classType = staticmethod(_fusion.CopyPasteBody_classType)
    __swig_destroy__ = _fusion.delete_CopyPasteBody
    __del__ = lambda self : None;
    def _get_sourceBody(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Returns the bodies that were copied to create the result bodies of this feature. An ObjectCollection
        is returned that will contain the original bodies. It's possible that the collection can be empty
        or contain less than the number of bodies originally copied. This happens in the case where a body 
        has been deleted or consumed by some other operation. If you roll the timeline to a point immediately 
        before or after the feature was created you can access the bodies.
        """
        return _fusion.CopyPasteBody__get_sourceBody(self)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CopyPasteBody__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CopyPasteBody__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.CopyPasteBody_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.CopyPasteBody_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CopyPasteBody__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CopyPasteBody__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.CopyPasteBody__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.CopyPasteBody__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.CopyPasteBody__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.CopyPasteBody__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CopyPasteBody__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.CopyPasteBody__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.CopyPasteBody__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.CopyPasteBody__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.CopyPasteBody__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.CopyPasteBody__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.CopyPasteBody__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.CopyPasteBody__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CopyPasteBody__get_isValid(self)
CopyPasteBody_swigregister = _fusion.CopyPasteBody_swigregister
CopyPasteBody_swigregister(CopyPasteBody)

def CopyPasteBody_classType() -> "char const *" :
  return _fusion.CopyPasteBody_classType()
CopyPasteBody_classType = _fusion.CopyPasteBody_classType

CopyPasteBody.__swig_getmethods__["sourceBody"] = CopyPasteBody._get_sourceBody
CopyPasteBody.sourceBody = property(CopyPasteBody._get_sourceBody, doc="Returns the bodies that were copied to create the result bodies of this feature. An ObjectCollection\nis returned that will contain the original bodies. It's possible that the collection can be empty\nor contain less than the number of bodies originally copied. This happens in the case where a body\nhas been deleted or consumed by some other operation. If you roll the timeline to a point immediately\nbefore or after the feature was created you can access the bodies.")

CopyPasteBody.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CopyPasteBody) else None
CopyPasteBody.cast = lambda arg: arg if isinstance(arg, CopyPasteBody) else None

class CustomGraphicsAppearanceColorEffect(CustomGraphicsColorEffect):
    """
    One of the types of color effects that can be applied to a custom graphics entity. With this 
    type of effect, the graphics entity will display using a Fusion appearance.
    """
    __swig_setmethods__ = {}
    for _s in [CustomGraphicsColorEffect]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsAppearanceColorEffect, name, value)
    __swig_getmethods__ = {}
    for _s in [CustomGraphicsColorEffect]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsAppearanceColorEffect, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsAppearanceColorEffect *" : return _fusion.CustomGraphicsAppearanceColorEffect___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsAppearanceColorEffect___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsAppearanceColorEffect___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsAppearanceColorEffect_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsAppearanceColorEffect_classType)
    __swig_getmethods__["create"] = lambda x: _fusion.CustomGraphicsAppearanceColorEffect_create
    if _newclass:create = staticmethod(_fusion.CustomGraphicsAppearanceColorEffect_create)
    __swig_destroy__ = _fusion.delete_CustomGraphicsAppearanceColorEffect
    __del__ = lambda self : None;
    def _get_appearance(self) -> "adsk::core::Ptr< adsk::core::Appearance >" :
        """
        Gets and sets the appearance to use. The appearance assigned must be available in the 
        design where the graphics will be drawn.
        """
        return _fusion.CustomGraphicsAppearanceColorEffect__get_appearance(self)

    def _set_appearance(self, *args) -> "bool" :
        """
        Gets and sets the appearance to use. The appearance assigned must be available in the 
        design where the graphics will be drawn.
        """
        return _fusion.CustomGraphicsAppearanceColorEffect__set_appearance(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsAppearanceColorEffect__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsAppearanceColorEffect__get_isValid(self)
CustomGraphicsAppearanceColorEffect_swigregister = _fusion.CustomGraphicsAppearanceColorEffect_swigregister
CustomGraphicsAppearanceColorEffect_swigregister(CustomGraphicsAppearanceColorEffect)

def CustomGraphicsAppearanceColorEffect_classType() -> "char const *" :
  return _fusion.CustomGraphicsAppearanceColorEffect_classType()
CustomGraphicsAppearanceColorEffect_classType = _fusion.CustomGraphicsAppearanceColorEffect_classType

def CustomGraphicsAppearanceColorEffect_create(*args) -> "adsk::core::Ptr< adsk::core::Appearance > const &" :
  return _fusion.CustomGraphicsAppearanceColorEffect_create(*args)
CustomGraphicsAppearanceColorEffect_create = _fusion.CustomGraphicsAppearanceColorEffect_create

CustomGraphicsAppearanceColorEffect.__swig_getmethods__["appearance"] = CustomGraphicsAppearanceColorEffect._get_appearance
CustomGraphicsAppearanceColorEffect.__swig_setmethods__["appearance"] = CustomGraphicsAppearanceColorEffect._set_appearance
CustomGraphicsAppearanceColorEffect.appearance = property(CustomGraphicsAppearanceColorEffect._get_appearance, CustomGraphicsAppearanceColorEffect._set_appearance, doc="Gets and sets the appearance to use. The appearance assigned must be available in the\ndesign where the graphics will be drawn.")

CustomGraphicsAppearanceColorEffect.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsAppearanceColorEffect) else None
CustomGraphicsAppearanceColorEffect.cast = lambda arg: arg if isinstance(arg, CustomGraphicsAppearanceColorEffect) else None

class CustomGraphicsBasicMaterialColorEffect(CustomGraphicsColorEffect):
    """
    One of the types of color effects that can be applied to a custom graphics entity. With this type
    of effect, basic phong shading and lighting techniques are used so give the entity a 3-dimensional
    appearance.
    """
    __swig_setmethods__ = {}
    for _s in [CustomGraphicsColorEffect]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsBasicMaterialColorEffect, name, value)
    __swig_getmethods__ = {}
    for _s in [CustomGraphicsColorEffect]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsBasicMaterialColorEffect, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsBasicMaterialColorEffect *" : return _fusion.CustomGraphicsBasicMaterialColorEffect___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsBasicMaterialColorEffect___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsBasicMaterialColorEffect___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsBasicMaterialColorEffect_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsBasicMaterialColorEffect_classType)
    __swig_getmethods__["create"] = lambda x: _fusion.CustomGraphicsBasicMaterialColorEffect_create
    if _newclass:create = staticmethod(_fusion.CustomGraphicsBasicMaterialColorEffect_create)
    __swig_destroy__ = _fusion.delete_CustomGraphicsBasicMaterialColorEffect
    __del__ = lambda self : None;
    def _get_emissiveColor(self) -> "adsk::core::Ptr< adsk::core::Color >" :
        """
        Gets and sets the emissiveColor associated with this CustomGraphicsBasicMaterialColorEffect object.
        The emissive color is the primary color of the entity
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__get_emissiveColor(self)

    def _set_emissiveColor(self, *args) -> "bool" :
        """
        Gets and sets the emissiveColor associated with this CustomGraphicsBasicMaterialColorEffect object.
        The emissive color is the primary color of the entity
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__set_emissiveColor(self, *args)

    def _get_ambientColor(self) -> "adsk::core::Ptr< adsk::core::Color >" :
        """
        Gets and sets the ambientColor associated with this CustomGraphicsBasicMaterialColorEffect object.
        The ambient color is the color of the light anywhere there's not a specific light source.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__get_ambientColor(self)

    def _set_ambientColor(self, *args) -> "bool" :
        """
        Gets and sets the ambientColor associated with this CustomGraphicsBasicMaterialColorEffect object.
        The ambient color is the color of the light anywhere there's not a specific light source.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__set_ambientColor(self, *args)

    def _get_diffuseColor(self) -> "adsk::core::Ptr< adsk::core::Color >" :
        """
        Gets and sets the diffuseColor associated with this CustomGraphicsBasicMaterialColorEffect object.
        The diffuse color is the color of reflected light as it scatters off of a rough surface.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__get_diffuseColor(self)

    def _set_diffuseColor(self, *args) -> "bool" :
        """
        Gets and sets the diffuseColor associated with this CustomGraphicsBasicMaterialColorEffect object.
        The diffuse color is the color of reflected light as it scatters off of a rough surface.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__set_diffuseColor(self, *args)

    def _get_specularColor(self) -> "adsk::core::Ptr< adsk::core::Color >" :
        """
        Gets and sets the specularColor associated with this CustomGraphicsBasicMaterialColorEffect object.
        The specular color is the color of reflected light (highlights) as it is reflected off of a shiny surface. This is 
        commonly white or a lighter shade of the emissive color.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__get_specularColor(self)

    def _set_specularColor(self, *args) -> "bool" :
        """
        Gets and sets the specularColor associated with this CustomGraphicsBasicMaterialColorEffect object.
        The specular color is the color of reflected light (highlights) as it is reflected off of a shiny surface. This is 
        commonly white or a lighter shade of the emissive color.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__set_specularColor(self, *args)

    def _get_glossiness(self) -> "double" :
        """
        Gets and sets the glossiness associated with this CustomGraphicsBasicMaterialColorEffect object.
        The glossiness determines the size of highlights, and thus the apparent shininess of the material.
        A value of 0.0 will result in very large hightlights like you would see with a rough surface.
        A maximum valaue of 128.0 will result in very small highlight as from a smooth surface.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__get_glossiness(self)

    def _set_glossiness(self, *args) -> "bool" :
        """
        Gets and sets the glossiness associated with this CustomGraphicsBasicMaterialColorEffect object.
        The glossiness determines the size of highlights, and thus the apparent shininess of the material.
        A value of 0.0 will result in very large hightlights like you would see with a rough surface.
        A maximum valaue of 128.0 will result in very small highlight as from a smooth surface.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__set_glossiness(self, *args)

    def _get_opacity(self) -> "double" :
        """
        Gets and sets the opacity associated with this CustomGraphicsBasicMaterialColorEffect object. 
        A value of 1.0 is completely opaque and 0.0 is completely transparent.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__get_opacity(self)

    def _set_opacity(self, *args) -> "bool" :
        """
        Gets and sets the opacity associated with this CustomGraphicsBasicMaterialColorEffect object. 
        A value of 1.0 is completely opaque and 0.0 is completely transparent.
        """
        return _fusion.CustomGraphicsBasicMaterialColorEffect__set_opacity(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsBasicMaterialColorEffect__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsBasicMaterialColorEffect__get_isValid(self)
CustomGraphicsBasicMaterialColorEffect_swigregister = _fusion.CustomGraphicsBasicMaterialColorEffect_swigregister
CustomGraphicsBasicMaterialColorEffect_swigregister(CustomGraphicsBasicMaterialColorEffect)

def CustomGraphicsBasicMaterialColorEffect_classType() -> "char const *" :
  return _fusion.CustomGraphicsBasicMaterialColorEffect_classType()
CustomGraphicsBasicMaterialColorEffect_classType = _fusion.CustomGraphicsBasicMaterialColorEffect_classType

def CustomGraphicsBasicMaterialColorEffect_create(*args) -> "adsk::core::Ptr< adsk::core::Color > const &" :
  return _fusion.CustomGraphicsBasicMaterialColorEffect_create(*args)
CustomGraphicsBasicMaterialColorEffect_create = _fusion.CustomGraphicsBasicMaterialColorEffect_create

CustomGraphicsBasicMaterialColorEffect.__swig_getmethods__["emissiveColor"] = CustomGraphicsBasicMaterialColorEffect._get_emissiveColor
CustomGraphicsBasicMaterialColorEffect.__swig_setmethods__["emissiveColor"] = CustomGraphicsBasicMaterialColorEffect._set_emissiveColor
CustomGraphicsBasicMaterialColorEffect.emissiveColor = property(CustomGraphicsBasicMaterialColorEffect._get_emissiveColor, CustomGraphicsBasicMaterialColorEffect._set_emissiveColor, doc="Gets and sets the emissiveColor associated with this CustomGraphicsBasicMaterialColorEffect object.\nThe emissive color is the primary color of the entity")

CustomGraphicsBasicMaterialColorEffect.__swig_getmethods__["ambientColor"] = CustomGraphicsBasicMaterialColorEffect._get_ambientColor
CustomGraphicsBasicMaterialColorEffect.__swig_setmethods__["ambientColor"] = CustomGraphicsBasicMaterialColorEffect._set_ambientColor
CustomGraphicsBasicMaterialColorEffect.ambientColor = property(CustomGraphicsBasicMaterialColorEffect._get_ambientColor, CustomGraphicsBasicMaterialColorEffect._set_ambientColor, doc="Gets and sets the ambientColor associated with this CustomGraphicsBasicMaterialColorEffect object.\nThe ambient color is the color of the light anywhere there's not a specific light source.")

CustomGraphicsBasicMaterialColorEffect.__swig_getmethods__["diffuseColor"] = CustomGraphicsBasicMaterialColorEffect._get_diffuseColor
CustomGraphicsBasicMaterialColorEffect.__swig_setmethods__["diffuseColor"] = CustomGraphicsBasicMaterialColorEffect._set_diffuseColor
CustomGraphicsBasicMaterialColorEffect.diffuseColor = property(CustomGraphicsBasicMaterialColorEffect._get_diffuseColor, CustomGraphicsBasicMaterialColorEffect._set_diffuseColor, doc="Gets and sets the diffuseColor associated with this CustomGraphicsBasicMaterialColorEffect object.\nThe diffuse color is the color of reflected light as it scatters off of a rough surface.")

CustomGraphicsBasicMaterialColorEffect.__swig_getmethods__["specularColor"] = CustomGraphicsBasicMaterialColorEffect._get_specularColor
CustomGraphicsBasicMaterialColorEffect.__swig_setmethods__["specularColor"] = CustomGraphicsBasicMaterialColorEffect._set_specularColor
CustomGraphicsBasicMaterialColorEffect.specularColor = property(CustomGraphicsBasicMaterialColorEffect._get_specularColor, CustomGraphicsBasicMaterialColorEffect._set_specularColor, doc="Gets and sets the specularColor associated with this CustomGraphicsBasicMaterialColorEffect object.\nThe specular color is the color of reflected light (highlights) as it is reflected off of a shiny surface. This is\ncommonly white or a lighter shade of the emissive color.")

CustomGraphicsBasicMaterialColorEffect.__swig_getmethods__["glossiness"] = CustomGraphicsBasicMaterialColorEffect._get_glossiness
CustomGraphicsBasicMaterialColorEffect.__swig_setmethods__["glossiness"] = CustomGraphicsBasicMaterialColorEffect._set_glossiness
CustomGraphicsBasicMaterialColorEffect.glossiness = property(CustomGraphicsBasicMaterialColorEffect._get_glossiness, CustomGraphicsBasicMaterialColorEffect._set_glossiness, doc="Gets and sets the glossiness associated with this CustomGraphicsBasicMaterialColorEffect object.\nThe glossiness determines the size of highlights, and thus the apparent shininess of the material.\nA value of 0.0 will result in very large hightlights like you would see with a rough surface.\nA maximum valaue of 128.0 will result in very small highlight as from a smooth surface.")

CustomGraphicsBasicMaterialColorEffect.__swig_getmethods__["opacity"] = CustomGraphicsBasicMaterialColorEffect._get_opacity
CustomGraphicsBasicMaterialColorEffect.__swig_setmethods__["opacity"] = CustomGraphicsBasicMaterialColorEffect._set_opacity
CustomGraphicsBasicMaterialColorEffect.opacity = property(CustomGraphicsBasicMaterialColorEffect._get_opacity, CustomGraphicsBasicMaterialColorEffect._set_opacity, doc="Gets and sets the opacity associated with this CustomGraphicsBasicMaterialColorEffect object.\nA value of 1.0 is completely opaque and 0.0 is completely transparent.")

CustomGraphicsBasicMaterialColorEffect.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsBasicMaterialColorEffect) else None
CustomGraphicsBasicMaterialColorEffect.cast = lambda arg: arg if isinstance(arg, CustomGraphicsBasicMaterialColorEffect) else None

class CustomGraphicsBRepBody(CustomGraphicsEntity):
    """This represents custom graphics that are based on a BRepBody."""
    __swig_setmethods__ = {}
    for _s in [CustomGraphicsEntity]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsBRepBody, name, value)
    __swig_getmethods__ = {}
    for _s in [CustomGraphicsEntity]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsBRepBody, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsBRepBody *" : return _fusion.CustomGraphicsBRepBody___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsBRepBody___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsBRepBody___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsBRepBody_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsBRepBody_classType)
    __swig_destroy__ = _fusion.delete_CustomGraphicsBRepBody
    __del__ = lambda self : None;
    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBRepFaces >" :
        """Returns the collection of CustomGraphicsBRepFace objects in the CustomGraphicsBRepBody."""
        return _fusion.CustomGraphicsBRepBody__get_faces(self)

    def _get_edges(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBRepEdges >" :
        """Returns the collection of CustomGraphicsBRepEdge objects in the CustomGraphicsBRepBody."""
        return _fusion.CustomGraphicsBRepBody__get_edges(self)

    def _get_vertices(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBRepVertices >" :
        """Returns the collection of CustomGraphicsBRepVertex objects in the CustomGraphicsBRepBody."""
        return _fusion.CustomGraphicsBRepBody__get_vertices(self)

    def _get_bRepBody(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """Returns a transient BRepBody that is being displayed as custom graphics."""
        return _fusion.CustomGraphicsBRepBody__get_bRepBody(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the custom graphics group. 
        Returns true if the deletion was successful.
        """
        return _fusion.CustomGraphicsBRepBody_deleteMe(self)

    def _get_isVisible(self) -> "bool" :
        """
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsBRepBody__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsBRepBody__set_isVisible(self, *args)

    def _get_isSelectable(self) -> "bool" :
        """
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsBRepBody__get_isSelectable(self)

    def _set_isSelectable(self, *args) -> "bool" :
        """
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsBRepBody__set_isSelectable(self, *args)

    def setOpacity(self, *args) -> "bool" :
        """
        Sets the opacity of the graphics entity. By default, when a new entity is it is
        completely opaque and does not override the opacity defined by the material. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if setting the opacity information was successful.
        """
        return _fusion.CustomGraphicsBRepBody_setOpacity(self, *args)

    def getOpacity(self) -> "bool" :
        """
        Gets the opacity of the graphics entity. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if getting the opacity information was successful.
        """
        return _fusion.CustomGraphicsBRepBody_getOpacity(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >" :
        """
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsBRepBody__get_transform(self)

    def _set_transform(self, *args) -> "bool" :
        """
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsBRepBody__set_transform(self, *args)

    def _get_depthPriority(self) -> "int" :
        """
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsBRepBody__get_depthPriority(self)

    def _set_depthPriority(self, *args) -> "bool" :
        """
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsBRepBody__set_depthPriority(self, *args)

    def _get_cullMode(self) -> "adsk::fusion::CustomGraphicsCullModes" :
        """
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsBRepBody__get_cullMode(self)

    def _set_cullMode(self, *args) -> "bool" :
        """
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsBRepBody__set_cullMode(self, *args)

    def _get_color(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsColorEffect >" :
        """
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsBRepBody__get_color(self)

    def _set_color(self, *args) -> "bool" :
        """
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsBRepBody__set_color(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the parent Component for a top-level group or the CustomGraphicsGroup object for 
        graphics entities and child groups.
        """
        return _fusion.CustomGraphicsBRepBody__get_parent(self)

    def _get_id(self) -> "std::string" :
        """
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsBRepBody__get_id(self)

    def _set_id(self, *args) -> "bool" :
        """
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsBRepBody__set_id(self, *args)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """
        Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.
        Depending on whether the graphics are drawn in model space or screen space this will return
        the bounding box in either centimeters (model) or pixels (screen). In the case where it
        returns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.
        """
        return _fusion.CustomGraphicsBRepBody__get_boundingBox(self)

    def _get_billBoarding(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBillBoard >" :
        """
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsBRepBody__get_billBoarding(self)

    def _set_billBoarding(self, *args) -> "bool" :
        """
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsBRepBody__set_billBoarding(self, *args)

    def _get_viewPlacement(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewPlacement >" :
        """
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsBRepBody__get_viewPlacement(self)

    def _set_viewPlacement(self, *args) -> "bool" :
        """
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsBRepBody__set_viewPlacement(self, *args)

    def _get_viewScale(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewScale >" :
        """
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsBRepBody__get_viewScale(self)

    def _set_viewScale(self, *args) -> "bool" :
        """
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsBRepBody__set_viewScale(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsBRepBody__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsBRepBody__get_isValid(self)
CustomGraphicsBRepBody_swigregister = _fusion.CustomGraphicsBRepBody_swigregister
CustomGraphicsBRepBody_swigregister(CustomGraphicsBRepBody)

def CustomGraphicsBRepBody_classType() -> "char const *" :
  return _fusion.CustomGraphicsBRepBody_classType()
CustomGraphicsBRepBody_classType = _fusion.CustomGraphicsBRepBody_classType

CustomGraphicsBRepBody.__swig_getmethods__["faces"] = CustomGraphicsBRepBody._get_faces
CustomGraphicsBRepBody.faces = property(CustomGraphicsBRepBody._get_faces, doc="Returns the collection of CustomGraphicsBRepFace objects in the CustomGraphicsBRepBody.")

CustomGraphicsBRepBody.__swig_getmethods__["edges"] = CustomGraphicsBRepBody._get_edges
CustomGraphicsBRepBody.edges = property(CustomGraphicsBRepBody._get_edges, doc="Returns the collection of CustomGraphicsBRepEdge objects in the CustomGraphicsBRepBody.")

CustomGraphicsBRepBody.__swig_getmethods__["vertices"] = CustomGraphicsBRepBody._get_vertices
CustomGraphicsBRepBody.vertices = property(CustomGraphicsBRepBody._get_vertices, doc="Returns the collection of CustomGraphicsBRepVertex objects in the CustomGraphicsBRepBody.")

CustomGraphicsBRepBody.__swig_getmethods__["bRepBody"] = CustomGraphicsBRepBody._get_bRepBody
CustomGraphicsBRepBody.bRepBody = property(CustomGraphicsBRepBody._get_bRepBody, doc="Returns a transient BRepBody that is being displayed as custom graphics.")

CustomGraphicsBRepBody.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsBRepBody) else None
CustomGraphicsBRepBody.cast = lambda arg: arg if isinstance(arg, CustomGraphicsBRepBody) else None

class CustomGraphicsCurve(CustomGraphicsEntity):
    """
    This represents custom graphics that are based on any object derived from Curve3D (except InfiniteLine3D).
    This is useful when drawing curved geometry where the alternative is to stroke the smooth curve and draw
    it as a series of lines. Using this you can directly use the curve and Fusion 360 will automatically take care
    of creating the correct display for the current level of detail.
    """
    __swig_setmethods__ = {}
    for _s in [CustomGraphicsEntity]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsCurve, name, value)
    __swig_getmethods__ = {}
    for _s in [CustomGraphicsEntity]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsCurve, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsCurve *" : return _fusion.CustomGraphicsCurve___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsCurve___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsCurve___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsCurve_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsCurve_classType)
    __swig_destroy__ = _fusion.delete_CustomGraphicsCurve
    __del__ = lambda self : None;
    def _get_curve(self) -> "adsk::core::Ptr< adsk::core::Curve3D >" :
        """
        Gets and sets the curve associated with this graphics entity. Any of the curve types derived from Curve3D
        is valid except for InfiniteLine3D.
        """
        return _fusion.CustomGraphicsCurve__get_curve(self)

    def _set_curve(self, *args) -> "bool" :
        """
        Gets and sets the curve associated with this graphics entity. Any of the curve types derived from Curve3D
        is valid except for InfiniteLine3D.
        """
        return _fusion.CustomGraphicsCurve__set_curve(self, *args)

    def _get_weight(self) -> "double" :
        """Defines the thickness of the curve in pixels."""
        return _fusion.CustomGraphicsCurve__get_weight(self)

    def _set_weight(self, *args) -> "bool" :
        """Defines the thickness of the curve in pixels."""
        return _fusion.CustomGraphicsCurve__set_weight(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the custom graphics group. 
        Returns true if the deletion was successful.
        """
        return _fusion.CustomGraphicsCurve_deleteMe(self)

    def _get_isVisible(self) -> "bool" :
        """
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsCurve__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsCurve__set_isVisible(self, *args)

    def _get_isSelectable(self) -> "bool" :
        """
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsCurve__get_isSelectable(self)

    def _set_isSelectable(self, *args) -> "bool" :
        """
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsCurve__set_isSelectable(self, *args)

    def setOpacity(self, *args) -> "bool" :
        """
        Sets the opacity of the graphics entity. By default, when a new entity is it is
        completely opaque and does not override the opacity defined by the material. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if setting the opacity information was successful.
        """
        return _fusion.CustomGraphicsCurve_setOpacity(self, *args)

    def getOpacity(self) -> "bool" :
        """
        Gets the opacity of the graphics entity. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if getting the opacity information was successful.
        """
        return _fusion.CustomGraphicsCurve_getOpacity(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >" :
        """
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsCurve__get_transform(self)

    def _set_transform(self, *args) -> "bool" :
        """
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsCurve__set_transform(self, *args)

    def _get_depthPriority(self) -> "int" :
        """
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsCurve__get_depthPriority(self)

    def _set_depthPriority(self, *args) -> "bool" :
        """
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsCurve__set_depthPriority(self, *args)

    def _get_cullMode(self) -> "adsk::fusion::CustomGraphicsCullModes" :
        """
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsCurve__get_cullMode(self)

    def _set_cullMode(self, *args) -> "bool" :
        """
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsCurve__set_cullMode(self, *args)

    def _get_color(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsColorEffect >" :
        """
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsCurve__get_color(self)

    def _set_color(self, *args) -> "bool" :
        """
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsCurve__set_color(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the parent Component for a top-level group or the CustomGraphicsGroup object for 
        graphics entities and child groups.
        """
        return _fusion.CustomGraphicsCurve__get_parent(self)

    def _get_id(self) -> "std::string" :
        """
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsCurve__get_id(self)

    def _set_id(self, *args) -> "bool" :
        """
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsCurve__set_id(self, *args)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """
        Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.
        Depending on whether the graphics are drawn in model space or screen space this will return
        the bounding box in either centimeters (model) or pixels (screen). In the case where it
        returns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.
        """
        return _fusion.CustomGraphicsCurve__get_boundingBox(self)

    def _get_billBoarding(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBillBoard >" :
        """
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsCurve__get_billBoarding(self)

    def _set_billBoarding(self, *args) -> "bool" :
        """
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsCurve__set_billBoarding(self, *args)

    def _get_viewPlacement(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewPlacement >" :
        """
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsCurve__get_viewPlacement(self)

    def _set_viewPlacement(self, *args) -> "bool" :
        """
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsCurve__set_viewPlacement(self, *args)

    def _get_viewScale(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewScale >" :
        """
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsCurve__get_viewScale(self)

    def _set_viewScale(self, *args) -> "bool" :
        """
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsCurve__set_viewScale(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsCurve__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsCurve__get_isValid(self)
CustomGraphicsCurve_swigregister = _fusion.CustomGraphicsCurve_swigregister
CustomGraphicsCurve_swigregister(CustomGraphicsCurve)

def CustomGraphicsCurve_classType() -> "char const *" :
  return _fusion.CustomGraphicsCurve_classType()
CustomGraphicsCurve_classType = _fusion.CustomGraphicsCurve_classType

CustomGraphicsCurve.__swig_getmethods__["curve"] = CustomGraphicsCurve._get_curve
CustomGraphicsCurve.__swig_setmethods__["curve"] = CustomGraphicsCurve._set_curve
CustomGraphicsCurve.curve = property(CustomGraphicsCurve._get_curve, CustomGraphicsCurve._set_curve, doc="Gets and sets the curve associated with this graphics entity. Any of the curve types derived from Curve3D\nis valid except for InfiniteLine3D.")

CustomGraphicsCurve.__swig_getmethods__["weight"] = CustomGraphicsCurve._get_weight
CustomGraphicsCurve.__swig_setmethods__["weight"] = CustomGraphicsCurve._set_weight
CustomGraphicsCurve.weight = property(CustomGraphicsCurve._get_weight, CustomGraphicsCurve._set_weight, doc="Defines the thickness of the curve in pixels.")

CustomGraphicsCurve.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsCurve) else None
CustomGraphicsCurve.cast = lambda arg: arg if isinstance(arg, CustomGraphicsCurve) else None

class CustomGraphicsGroup(CustomGraphicsEntity):
    """Represents of group of custom graphics entities. A group can also own other graphics groups."""
    __swig_setmethods__ = {}
    for _s in [CustomGraphicsEntity]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsGroup, name, value)
    __swig_getmethods__ = {}
    for _s in [CustomGraphicsEntity]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsGroup, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsGroup *" : return _fusion.CustomGraphicsGroup___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsGroup___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsGroup___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.CustomGraphicsGroup___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsEntity >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.CustomGraphicsGroup___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsGroup_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsGroup_classType)
    __swig_destroy__ = _fusion.delete_CustomGraphicsGroup
    __del__ = lambda self : None;
    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsEntity >" :
        """
        Function that returns the specified custom graphics entity within this group. This also includes
        any child graphics groups. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.CustomGraphicsGroup_item(self, *args)

    def _get_count(self) -> "size_t" :
        """Returns the number of graphics entities within the group."""
        return _fusion.CustomGraphicsGroup__get_count(self)

    def addGroup(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsGroup >" :
        """
        Creates a new, empty CustomGraphicsGroup that is owned by this CustomGraphicsGroup. 
        Returns the new CustomGraphicsGroup object or null in the case of a failure.
        """
        return _fusion.CustomGraphicsGroup_addGroup(self)

    def addMesh(self, *args) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsMesh >" :
        """
        Adds a new CustomGraphicsMesh entity to this group. 
        coordinates : The CustomGraphicsCoordinates object that defines the coordinates of the vertices of the mesh.
        A CustomGrahpicsCoordinates object can be created using the static create method of the CustomGraphicsCoordinates class. 
        coordinateIndexList : An array of integers that represent indices into the coordinates to define the vertices of the triangles. If an empty
        array is provided, then it's assumed that the first three coordinates defines the first triangle, the next three define
        the second triangle, and so on. 
        normalVectors : An array of doubles that represent the x, y, z components of the normals at each coordinate. There should be a normal defined
        for each coordinate. If an empty array is provided for the normal vectors, Fusion 360 will automatically calculate normal vectors
        that are 90 degrees to the face of the triangle, making it appear flat. 
        normalIndexList : An array of integers that represent indices into the normal vectors to define the which vector corresponds to which vertex. This
        should be the same size as the vertex index list. If an empty array is input and normal vectors are provided, it is assumed that
        the normals match up one-to-one to each coordinate. 
        Returns the new CustomGraphicsMesh object or null in the case of a failure.
        """
        return _fusion.CustomGraphicsGroup_addMesh(self, *args)

    def addLines(self, *args) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsLines >" :
        """
        Adds a new CustomGraphicsLines entity to this group. 
        coordinates : The CustomGraphicsCoordinates object that defines the coordinates of the vertices of the lines.
        A CustomGraphicsCoordinates object can be created using the static create method of the CustomGraphicsCoordinates class. 
        indexList : An array of integers that represent indices into the coordinates to define the order the coordinates are used to draw the lines.
        If an empty array is provided, the coordinates are used in the order they're provided in the provided CustomGraphicsCoordinates object. 
        isLineStrip : A boolean indicating if a series of individual lines or a connected set of lines (a line strip) is to be drawn. If individual lines
        are drawn, (this argument is false), each pair of coordinates defines a single line. If a line strip is drawn, (this argument is true), 
        the first pair of coordinates define the first line and the third coordinate defines a line that connects to the second coordinate. 
        The fourth coordinate creates a line connecting to the third coordinate, and so on. 
        lineStripLengths : If isLineStrip is true, this argument is used to define the number of coordinates to use in each line strip. It is an array of integers 
        that defines the number of coordinates for each line strip. For example, if the array [4,10] is input, 4 coordinates are connected for
        the first line strip and 10 are used to create a second line strip. If an empty array is provided, a single line strip is created. If
        isLineStrip is False, this argument is ignored. 
        Returns the new CustomGraphicsLines object or null in the case of a failure.
        """
        return _fusion.CustomGraphicsGroup_addLines(self, *args)

    def addCurve(self, *args) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsCurve >" :
        """
        Adds a new CustomGraphicsCurve entity to this group. A CustomGraphicsCurve is a wireframe graphic 
        that is based on any object derived from Curve3D (except InfiniteLine3D). This is useful when 
        drawing curved geometry where the alternative is to stroke the smooth curve and draw it as a series 
        of lines. Using this you can directly use the curve and Fusion 360 will automatically take care of creating 
        the correct display for the current level of detail. 
        curve : The curve that defines the shape of the graphics entity. Any of the curve types derived from Curve3D
        are valid except for InfiniteLine3D. 
        Returns the newly created CustomGraphicsCurve object or null in the case of failure.
        """
        return _fusion.CustomGraphicsGroup_addCurve(self, *args)

    def addPointSet(self, *args) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsPointSet >" :
        """
        Adds a new CustomGraphicsPointSet entity to this group. This will be displayed as one or more points where
        all of the points will display using the same image. 
        coordinates : The CustomGraphicsCoordinates object that defines the coordinates where the points will be displayed.
        A CustomGraphicsCoordinates object can be created using the static create method of the CustomGraphicsCoordinates class. 
        indexList : An array of integers that represent indices into the coordinates to define which coordinates to use when drawing points.
        If an empty array is provided, a point is drawn for every coordinate. 
        pointType : Specifies the type of point to display. Currently there are two choices; UserDefinedCustomGraphicsPointType and 
        PointCloudCustomGraphicsPointType. When set to PointCloudCustomGraphicsPointType, each point displays as a single pixel and is 
        the most efficient point display type for displaying sets that contain very large quantities of points. When
        set to UserDefinedCustomGraphicsPointType, you specify the image to display as the point. This can be any png image and is
        centered on the point. 
        pointImage : If the pointType is PointCloudCustomGraphicsPointType this argument is ignored and can be an empty string. This argument
        must be specified if the pointType is UserDefinedCustomGraphicsPointType. This is the path to the png image file that will be
        displayed as the point. It can be either a full path to the file or a relative path that is respect to the .py, dll, or dylib
        file being run. There is no restriction on the size of the image, but generally very small images would be used for points. 
        Returns the newly created CustomGraphicsPointSet object or null in the case of failure.
        """
        return _fusion.CustomGraphicsGroup_addPointSet(self, *args)

    def addText(self, *args) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsText >" :
        """
        Adds a new CustomGraphicsText entity to this group. This will be displayed as a single line of text.
        It is placed so that the upper-left corner is at the point defined and the text will be parallel
        to the X-Y plane of the world coordinate system and in the X direction. To change it's position relative
        to the input point you can change the horizontal and vertical justification on the returnsed CustomGrahicsText
        object. You can also reorient the text by changing the transform of the returned CustomGraphicsText object. 
        formattedText : The text string to be displayed. Overall formatting can be defined using properties on the returned
        CustomGraphicsText object. Formatting overrides can be defined within the string using formatting codes. 
        font : The name of the font to use when displaying the text. 
        size : The size of the text in centimeters. 
        transform : Transformation matrix that specifies the position and orientation of the text in model space. 
        Returns the newly created CustomGraphicsText object or null in the case of failure.
        """
        return _fusion.CustomGraphicsGroup_addText(self, *args)

    def addBRepBody(self, *args) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBRepBody >" :
        """
        Adds a new CustomGraphicsBRepBody object to this group. This displays a real or transient BRepBody
        object as custom graphics. No relationship exists back to the original input body so if it is
        changed, the custom graphics will not change.
        The body associated with the CustomGraphicsBRep body is a copy of the original input body. Equivalent
        Faces, Edges, and vertices can be found by using the indexes in the collection. For example if you have
        a face of the original body and find that it is at index 24 in the BRepFaces collection of that body,
        the equivalent face in the custom graphics body will also be at index 24. This works as long as the original
        body is not modified in any way. 
        body : The real or transient BRepBody object to draw using custom graphics. 
        Returns the newly created CustomGraphicsBRepBody object or null in the case of failure.
        """
        return _fusion.CustomGraphicsGroup_addBRepBody(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the custom graphics group. 
        Returns true if the deletion was successful.
        """
        return _fusion.CustomGraphicsGroup_deleteMe(self)

    def _get_isVisible(self) -> "bool" :
        """
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsGroup__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsGroup__set_isVisible(self, *args)

    def _get_isSelectable(self) -> "bool" :
        """
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsGroup__get_isSelectable(self)

    def _set_isSelectable(self, *args) -> "bool" :
        """
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsGroup__set_isSelectable(self, *args)

    def setOpacity(self, *args) -> "bool" :
        """
        Sets the opacity of the graphics entity. By default, when a new entity is it is
        completely opaque and does not override the opacity defined by the material. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if setting the opacity information was successful.
        """
        return _fusion.CustomGraphicsGroup_setOpacity(self, *args)

    def getOpacity(self) -> "bool" :
        """
        Gets the opacity of the graphics entity. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if getting the opacity information was successful.
        """
        return _fusion.CustomGraphicsGroup_getOpacity(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >" :
        """
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsGroup__get_transform(self)

    def _set_transform(self, *args) -> "bool" :
        """
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsGroup__set_transform(self, *args)

    def _get_depthPriority(self) -> "int" :
        """
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsGroup__get_depthPriority(self)

    def _set_depthPriority(self, *args) -> "bool" :
        """
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsGroup__set_depthPriority(self, *args)

    def _get_cullMode(self) -> "adsk::fusion::CustomGraphicsCullModes" :
        """
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsGroup__get_cullMode(self)

    def _set_cullMode(self, *args) -> "bool" :
        """
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsGroup__set_cullMode(self, *args)

    def _get_color(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsColorEffect >" :
        """
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsGroup__get_color(self)

    def _set_color(self, *args) -> "bool" :
        """
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsGroup__set_color(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the parent Component for a top-level group or the CustomGraphicsGroup object for 
        graphics entities and child groups.
        """
        return _fusion.CustomGraphicsGroup__get_parent(self)

    def _get_id(self) -> "std::string" :
        """
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsGroup__get_id(self)

    def _set_id(self, *args) -> "bool" :
        """
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsGroup__set_id(self, *args)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """
        Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.
        Depending on whether the graphics are drawn in model space or screen space this will return
        the bounding box in either centimeters (model) or pixels (screen). In the case where it
        returns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.
        """
        return _fusion.CustomGraphicsGroup__get_boundingBox(self)

    def _get_billBoarding(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBillBoard >" :
        """
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsGroup__get_billBoarding(self)

    def _set_billBoarding(self, *args) -> "bool" :
        """
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsGroup__set_billBoarding(self, *args)

    def _get_viewPlacement(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewPlacement >" :
        """
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsGroup__get_viewPlacement(self)

    def _set_viewPlacement(self, *args) -> "bool" :
        """
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsGroup__set_viewPlacement(self, *args)

    def _get_viewScale(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewScale >" :
        """
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsGroup__get_viewScale(self)

    def _set_viewScale(self, *args) -> "bool" :
        """
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsGroup__set_viewScale(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsGroup__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsGroup__get_isValid(self)
CustomGraphicsGroup_swigregister = _fusion.CustomGraphicsGroup_swigregister
CustomGraphicsGroup_swigregister(CustomGraphicsGroup)

def CustomGraphicsGroup_classType() -> "char const *" :
  return _fusion.CustomGraphicsGroup_classType()
CustomGraphicsGroup_classType = _fusion.CustomGraphicsGroup_classType

CustomGraphicsGroup.__swig_getmethods__["count"] = CustomGraphicsGroup._get_count
CustomGraphicsGroup.count = property(CustomGraphicsGroup._get_count, doc="Returns the number of graphics entities within the group.")

CustomGraphicsGroup.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsGroup) else None
CustomGraphicsGroup.cast = lambda arg: arg if isinstance(arg, CustomGraphicsGroup) else None

class CustomGraphicsLines(CustomGraphicsEntity):
    """Represents lines drawn in the graphics window."""
    __swig_setmethods__ = {}
    for _s in [CustomGraphicsEntity]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsLines, name, value)
    __swig_getmethods__ = {}
    for _s in [CustomGraphicsEntity]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsLines, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsLines *" : return _fusion.CustomGraphicsLines___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsLines___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsLines___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsLines_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsLines_classType)
    __swig_destroy__ = _fusion.delete_CustomGraphicsLines
    __del__ = lambda self : None;
    def _get_coordinates(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsCoordinates >" :
        """
        Gets and sets the CustomGraphicsCoordinates object that defines the coordinates of the vertices of the lines.
        A CustomGraphicsCoordinates object can be created using the static create method of the CustomGraphicsCoordinates class.
        """
        return _fusion.CustomGraphicsLines__get_coordinates(self)

    def _set_coordinates(self, *args) -> "bool" :
        """
        Gets and sets the CustomGraphicsCoordinates object that defines the coordinates of the vertices of the lines.
        A CustomGraphicsCoordinates object can be created using the static create method of the CustomGraphicsCoordinates class.
        """
        return _fusion.CustomGraphicsLines__set_coordinates(self, *args)

    def _get_indexList(self) -> "std::vector< int,std::allocator< int > >" :
        """
        Gets and sets an array of integers that represent indices into the coordinates to define the order the coordinates are used to draw the lines.
        An empty array indicates that no index list is used and coordinates are used in the order they're provided in the provided CustomGraphicsCoordinates object.
        """
        return _fusion.CustomGraphicsLines__get_indexList(self)

    def _set_indexList(self, *args) -> "bool" :
        """
        Gets and sets an array of integers that represent indices into the coordinates to define the order the coordinates are used to draw the lines.
        An empty array indicates that no index list is used and coordinates are used in the order they're provided in the provided CustomGraphicsCoordinates object.
        """
        return _fusion.CustomGraphicsLines__set_indexList(self, *args)

    def _get_isLineStrip(self) -> "bool" :
        """
        Defines if the coordinates are used to define a series of individual lines or a connected set of lines (line strip). If individual lines
        are drawn (this property is false), each pair of coordinates define a single line. If a line strip is drawn (this property is true), 
        the first pair of coordinates define the first line and the third coordinate defines a line that connects to the second coordinate. 
        The fourth coordinate creates a line connecting to the third coordinate, and so on.
        """
        return _fusion.CustomGraphicsLines__get_isLineStrip(self)

    def _set_isLineStrip(self, *args) -> "bool" :
        """
        Defines if the coordinates are used to define a series of individual lines or a connected set of lines (line strip). If individual lines
        are drawn (this property is false), each pair of coordinates define a single line. If a line strip is drawn (this property is true), 
        the first pair of coordinates define the first line and the third coordinate defines a line that connects to the second coordinate. 
        The fourth coordinate creates a line connecting to the third coordinate, and so on.
        """
        return _fusion.CustomGraphicsLines__set_isLineStrip(self, *args)

    def _get_lineStripLengths(self) -> "std::vector< int,std::allocator< int > >" :
        """
        If isLineStrip is true, this property defines the number of coordinates to use in the line strips. It is an array of integers 
        that defines the number of coordinates for each line strip. An empty array indicates that a single line strip is to be drawn.
        """
        return _fusion.CustomGraphicsLines__get_lineStripLengths(self)

    def _set_lineStripLengths(self, *args) -> "bool" :
        """
        If isLineStrip is true, this property defines the number of coordinates to use in the line strips. It is an array of integers 
        that defines the number of coordinates for each line strip. An empty array indicates that a single line strip is to be drawn.
        """
        return _fusion.CustomGraphicsLines__set_lineStripLengths(self, *args)

    def _get_weight(self) -> "double" :
        """Defines the thickness of the line in pixels."""
        return _fusion.CustomGraphicsLines__get_weight(self)

    def _set_weight(self, *args) -> "bool" :
        """Defines the thickness of the line in pixels."""
        return _fusion.CustomGraphicsLines__set_weight(self, *args)

    def _get_lineStyleScale(self) -> "double" :
        """
        Defines the scale as it relates to how the line style is applied. The effect is to 
        shrink or expand the line style as it is applied to the line. This does not affect the line width.
        """
        return _fusion.CustomGraphicsLines__get_lineStyleScale(self)

    def _set_lineStyleScale(self, *args) -> "bool" :
        """
        Defines the scale as it relates to how the line style is applied. The effect is to 
        shrink or expand the line style as it is applied to the line. This does not affect the line width.
        """
        return _fusion.CustomGraphicsLines__set_lineStyleScale(self, *args)

    def _get_isScreenSpaceLineStyle(self) -> "bool" :
        """
        Specifies if the line style is computed based on the screen or model space. The default is
        based on the screen which means the style is drawn the same regardless of how you zoom in
        or out of the view. That is the length of lines and spaces are based on pixels. If it
        is drawn relative to model space then the lines and spaces are defined in centimeters and
        will zooming in and out will change the apparent spacing.
        """
        return _fusion.CustomGraphicsLines__get_isScreenSpaceLineStyle(self)

    def _set_isScreenSpaceLineStyle(self, *args) -> "bool" :
        """
        Specifies if the line style is computed based on the screen or model space. The default is
        based on the screen which means the style is drawn the same regardless of how you zoom in
        or out of the view. That is the length of lines and spaces are based on pixels. If it
        is drawn relative to model space then the lines and spaces are defined in centimeters and
        will zooming in and out will change the apparent spacing.
        """
        return _fusion.CustomGraphicsLines__set_isScreenSpaceLineStyle(self, *args)

    def _get_lineStylePattern(self) -> "adsk::fusion::LineStylePatterns" :
        """The line style to apply to the line. The default is to draw a continuous line."""
        return _fusion.CustomGraphicsLines__get_lineStylePattern(self)

    def _set_lineStylePattern(self, *args) -> "bool" :
        """The line style to apply to the line. The default is to draw a continuous line."""
        return _fusion.CustomGraphicsLines__set_lineStylePattern(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the custom graphics group. 
        Returns true if the deletion was successful.
        """
        return _fusion.CustomGraphicsLines_deleteMe(self)

    def _get_isVisible(self) -> "bool" :
        """
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsLines__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsLines__set_isVisible(self, *args)

    def _get_isSelectable(self) -> "bool" :
        """
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsLines__get_isSelectable(self)

    def _set_isSelectable(self, *args) -> "bool" :
        """
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsLines__set_isSelectable(self, *args)

    def setOpacity(self, *args) -> "bool" :
        """
        Sets the opacity of the graphics entity. By default, when a new entity is it is
        completely opaque and does not override the opacity defined by the material. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if setting the opacity information was successful.
        """
        return _fusion.CustomGraphicsLines_setOpacity(self, *args)

    def getOpacity(self) -> "bool" :
        """
        Gets the opacity of the graphics entity. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if getting the opacity information was successful.
        """
        return _fusion.CustomGraphicsLines_getOpacity(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >" :
        """
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsLines__get_transform(self)

    def _set_transform(self, *args) -> "bool" :
        """
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsLines__set_transform(self, *args)

    def _get_depthPriority(self) -> "int" :
        """
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsLines__get_depthPriority(self)

    def _set_depthPriority(self, *args) -> "bool" :
        """
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsLines__set_depthPriority(self, *args)

    def _get_cullMode(self) -> "adsk::fusion::CustomGraphicsCullModes" :
        """
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsLines__get_cullMode(self)

    def _set_cullMode(self, *args) -> "bool" :
        """
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsLines__set_cullMode(self, *args)

    def _get_color(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsColorEffect >" :
        """
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsLines__get_color(self)

    def _set_color(self, *args) -> "bool" :
        """
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsLines__set_color(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the parent Component for a top-level group or the CustomGraphicsGroup object for 
        graphics entities and child groups.
        """
        return _fusion.CustomGraphicsLines__get_parent(self)

    def _get_id(self) -> "std::string" :
        """
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsLines__get_id(self)

    def _set_id(self, *args) -> "bool" :
        """
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsLines__set_id(self, *args)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """
        Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.
        Depending on whether the graphics are drawn in model space or screen space this will return
        the bounding box in either centimeters (model) or pixels (screen). In the case where it
        returns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.
        """
        return _fusion.CustomGraphicsLines__get_boundingBox(self)

    def _get_billBoarding(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBillBoard >" :
        """
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsLines__get_billBoarding(self)

    def _set_billBoarding(self, *args) -> "bool" :
        """
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsLines__set_billBoarding(self, *args)

    def _get_viewPlacement(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewPlacement >" :
        """
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsLines__get_viewPlacement(self)

    def _set_viewPlacement(self, *args) -> "bool" :
        """
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsLines__set_viewPlacement(self, *args)

    def _get_viewScale(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewScale >" :
        """
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsLines__get_viewScale(self)

    def _set_viewScale(self, *args) -> "bool" :
        """
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsLines__set_viewScale(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsLines__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsLines__get_isValid(self)
CustomGraphicsLines_swigregister = _fusion.CustomGraphicsLines_swigregister
CustomGraphicsLines_swigregister(CustomGraphicsLines)

def CustomGraphicsLines_classType() -> "char const *" :
  return _fusion.CustomGraphicsLines_classType()
CustomGraphicsLines_classType = _fusion.CustomGraphicsLines_classType

CustomGraphicsLines.__swig_getmethods__["coordinates"] = CustomGraphicsLines._get_coordinates
CustomGraphicsLines.__swig_setmethods__["coordinates"] = CustomGraphicsLines._set_coordinates
CustomGraphicsLines.coordinates = property(CustomGraphicsLines._get_coordinates, CustomGraphicsLines._set_coordinates, doc="Gets and sets the CustomGraphicsCoordinates object that defines the coordinates of the vertices of the lines.\nA CustomGraphicsCoordinates object can be created using the static create method of the CustomGraphicsCoordinates class.")

CustomGraphicsLines.__swig_getmethods__["indexList"] = CustomGraphicsLines._get_indexList
CustomGraphicsLines.__swig_setmethods__["indexList"] = CustomGraphicsLines._set_indexList
CustomGraphicsLines.indexList = property(CustomGraphicsLines._get_indexList, CustomGraphicsLines._set_indexList, doc="Gets and sets an array of integers that represent indices into the coordinates to define the order the coordinates are used to draw the lines.\nAn empty array indicates that no index list is used and coordinates are used in the order they're provided in the provided CustomGraphicsCoordinates object.")

CustomGraphicsLines.__swig_getmethods__["isLineStrip"] = CustomGraphicsLines._get_isLineStrip
CustomGraphicsLines.__swig_setmethods__["isLineStrip"] = CustomGraphicsLines._set_isLineStrip
CustomGraphicsLines.isLineStrip = property(CustomGraphicsLines._get_isLineStrip, CustomGraphicsLines._set_isLineStrip, doc="Defines if the coordinates are used to define a series of individual lines or a connected set of lines (line strip). If individual lines\nare drawn (this property is false), each pair of coordinates define a single line. If a line strip is drawn (this property is true),\nthe first pair of coordinates define the first line and the third coordinate defines a line that connects to the second coordinate.\nThe fourth coordinate creates a line connecting to the third coordinate, and so on.")

CustomGraphicsLines.__swig_getmethods__["lineStripLengths"] = CustomGraphicsLines._get_lineStripLengths
CustomGraphicsLines.__swig_setmethods__["lineStripLengths"] = CustomGraphicsLines._set_lineStripLengths
CustomGraphicsLines.lineStripLengths = property(CustomGraphicsLines._get_lineStripLengths, CustomGraphicsLines._set_lineStripLengths, doc="If isLineStrip is true, this property defines the number of coordinates to use in the line strips. It is an array of integers\nthat defines the number of coordinates for each line strip. An empty array indicates that a single line strip is to be drawn.")

CustomGraphicsLines.__swig_getmethods__["weight"] = CustomGraphicsLines._get_weight
CustomGraphicsLines.__swig_setmethods__["weight"] = CustomGraphicsLines._set_weight
CustomGraphicsLines.weight = property(CustomGraphicsLines._get_weight, CustomGraphicsLines._set_weight, doc="Defines the thickness of the line in pixels.")

CustomGraphicsLines.__swig_getmethods__["lineStyleScale"] = CustomGraphicsLines._get_lineStyleScale
CustomGraphicsLines.__swig_setmethods__["lineStyleScale"] = CustomGraphicsLines._set_lineStyleScale
CustomGraphicsLines.lineStyleScale = property(CustomGraphicsLines._get_lineStyleScale, CustomGraphicsLines._set_lineStyleScale, doc="Defines the scale as it relates to how the line style is applied. The effect is to\nshrink or expand the line style as it is applied to the line. This does not affect the line width.")

CustomGraphicsLines.__swig_getmethods__["isScreenSpaceLineStyle"] = CustomGraphicsLines._get_isScreenSpaceLineStyle
CustomGraphicsLines.__swig_setmethods__["isScreenSpaceLineStyle"] = CustomGraphicsLines._set_isScreenSpaceLineStyle
CustomGraphicsLines.isScreenSpaceLineStyle = property(CustomGraphicsLines._get_isScreenSpaceLineStyle, CustomGraphicsLines._set_isScreenSpaceLineStyle, doc="Specifies if the line style is computed based on the screen or model space. The default is\nbased on the screen which means the style is drawn the same regardless of how you zoom in\nor out of the view. That is the length of lines and spaces are based on pixels. If it\nis drawn relative to model space then the lines and spaces are defined in centimeters and\nwill zooming in and out will change the apparent spacing.")

CustomGraphicsLines.__swig_getmethods__["lineStylePattern"] = CustomGraphicsLines._get_lineStylePattern
CustomGraphicsLines.__swig_setmethods__["lineStylePattern"] = CustomGraphicsLines._set_lineStylePattern
CustomGraphicsLines.lineStylePattern = property(CustomGraphicsLines._get_lineStylePattern, CustomGraphicsLines._set_lineStylePattern, doc="The line style to apply to the line. The default is to draw a continuous line.")

CustomGraphicsLines.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsLines) else None
CustomGraphicsLines.cast = lambda arg: arg if isinstance(arg, CustomGraphicsLines) else None

class CustomGraphicsMesh(CustomGraphicsEntity):
    """Represents a custom triangle mesh drawn in the graphics window."""
    __swig_setmethods__ = {}
    for _s in [CustomGraphicsEntity]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsMesh, name, value)
    __swig_getmethods__ = {}
    for _s in [CustomGraphicsEntity]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsMesh, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsMesh *" : return _fusion.CustomGraphicsMesh___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsMesh___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsMesh___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsMesh_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsMesh_classType)
    __swig_destroy__ = _fusion.delete_CustomGraphicsMesh
    __del__ = lambda self : None;
    def _get_coordinates(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsCoordinates >" :
        """Gets and sets the coordinates associated with this CustomGraphicsMesh."""
        return _fusion.CustomGraphicsMesh__get_coordinates(self)

    def _set_coordinates(self, *args) -> "bool" :
        """Gets and sets the coordinates associated with this CustomGraphicsMesh."""
        return _fusion.CustomGraphicsMesh__set_coordinates(self, *args)

    def _get_normalVectors(self) -> "std::vector< double,std::allocator< double > >" :
        """
        Gets and sets the normal vectors of the mesh where there is a normal
        vector at each node. The normals are defined as an array
        of floats where they are the x, y, z components of each vector.
        """
        return _fusion.CustomGraphicsMesh__get_normalVectors(self)

    def _set_normalVectors(self, *args) -> "bool" :
        """
        Gets and sets the normal vectors of the mesh where there is a normal
        vector at each node. The normals are defined as an array
        of floats where they are the x, y, z components of each vector.
        """
        return _fusion.CustomGraphicsMesh__set_normalVectors(self, *args)

    def _get_vertexIndexList(self) -> "std::vector< int,std::allocator< int > >" :
        """
        Gets and sets an array of indices that define which coordinate in the
        coordinate list is used for each vertex in the mesh. Each set of three
        indices defines a triagle. For example: 
        Indices 0, 1, and 2 define the coordinates to use for the first triangle and
        indices 3, 4, and 5 define the coordinates for the second triangle, and so on.
        """
        return _fusion.CustomGraphicsMesh__get_vertexIndexList(self)

    def _set_vertexIndexList(self, *args) -> "bool" :
        """
        Gets and sets an array of indices that define which coordinate in the
        coordinate list is used for each vertex in the mesh. Each set of three
        indices defines a triagle. For example: 
        Indices 0, 1, and 2 define the coordinates to use for the first triangle and
        indices 3, 4, and 5 define the coordinates for the second triangle, and so on.
        """
        return _fusion.CustomGraphicsMesh__set_vertexIndexList(self, *args)

    def _get_normalIndexList(self) -> "std::vector< int,std::allocator< int > >" :
        """
        Gets and sets an array of indices that define which normal is associated
        with each vertex in the mesh. This is used to look-up the normal in the
        normalVectors array.
        """
        return _fusion.CustomGraphicsMesh__get_normalIndexList(self)

    def _set_normalIndexList(self, *args) -> "bool" :
        """
        Gets and sets an array of indices that define which normal is associated
        with each vertex in the mesh. This is used to look-up the normal in the
        normalVectors array.
        """
        return _fusion.CustomGraphicsMesh__set_normalIndexList(self, *args)

    def _get_textureCoordinates(self) -> "std::vector< double,std::allocator< double > >" :
        """
        Gets and sets the texture coordinates as an array of floats where
        they are the u,v components at each node. They are defined as an
        array of doubles where they are the u, v coordinates of each node.
        Defining texture coordinates for a mesh is optional.
        """
        return _fusion.CustomGraphicsMesh__get_textureCoordinates(self)

    def _set_textureCoordinates(self, *args) -> "bool" :
        """
        Gets and sets the texture coordinates as an array of floats where
        they are the u,v components at each node. They are defined as an
        array of doubles where they are the u, v coordinates of each node.
        Defining texture coordinates for a mesh is optional.
        """
        return _fusion.CustomGraphicsMesh__set_textureCoordinates(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the custom graphics group. 
        Returns true if the deletion was successful.
        """
        return _fusion.CustomGraphicsMesh_deleteMe(self)

    def _get_isVisible(self) -> "bool" :
        """
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsMesh__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsMesh__set_isVisible(self, *args)

    def _get_isSelectable(self) -> "bool" :
        """
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsMesh__get_isSelectable(self)

    def _set_isSelectable(self, *args) -> "bool" :
        """
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsMesh__set_isSelectable(self, *args)

    def setOpacity(self, *args) -> "bool" :
        """
        Sets the opacity of the graphics entity. By default, when a new entity is it is
        completely opaque and does not override the opacity defined by the material. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if setting the opacity information was successful.
        """
        return _fusion.CustomGraphicsMesh_setOpacity(self, *args)

    def getOpacity(self) -> "bool" :
        """
        Gets the opacity of the graphics entity. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if getting the opacity information was successful.
        """
        return _fusion.CustomGraphicsMesh_getOpacity(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >" :
        """
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsMesh__get_transform(self)

    def _set_transform(self, *args) -> "bool" :
        """
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsMesh__set_transform(self, *args)

    def _get_depthPriority(self) -> "int" :
        """
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsMesh__get_depthPriority(self)

    def _set_depthPriority(self, *args) -> "bool" :
        """
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsMesh__set_depthPriority(self, *args)

    def _get_cullMode(self) -> "adsk::fusion::CustomGraphicsCullModes" :
        """
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsMesh__get_cullMode(self)

    def _set_cullMode(self, *args) -> "bool" :
        """
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsMesh__set_cullMode(self, *args)

    def _get_color(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsColorEffect >" :
        """
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsMesh__get_color(self)

    def _set_color(self, *args) -> "bool" :
        """
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsMesh__set_color(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the parent Component for a top-level group or the CustomGraphicsGroup object for 
        graphics entities and child groups.
        """
        return _fusion.CustomGraphicsMesh__get_parent(self)

    def _get_id(self) -> "std::string" :
        """
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsMesh__get_id(self)

    def _set_id(self, *args) -> "bool" :
        """
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsMesh__set_id(self, *args)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """
        Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.
        Depending on whether the graphics are drawn in model space or screen space this will return
        the bounding box in either centimeters (model) or pixels (screen). In the case where it
        returns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.
        """
        return _fusion.CustomGraphicsMesh__get_boundingBox(self)

    def _get_billBoarding(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBillBoard >" :
        """
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsMesh__get_billBoarding(self)

    def _set_billBoarding(self, *args) -> "bool" :
        """
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsMesh__set_billBoarding(self, *args)

    def _get_viewPlacement(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewPlacement >" :
        """
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsMesh__get_viewPlacement(self)

    def _set_viewPlacement(self, *args) -> "bool" :
        """
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsMesh__set_viewPlacement(self, *args)

    def _get_viewScale(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewScale >" :
        """
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsMesh__get_viewScale(self)

    def _set_viewScale(self, *args) -> "bool" :
        """
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsMesh__set_viewScale(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsMesh__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsMesh__get_isValid(self)
CustomGraphicsMesh_swigregister = _fusion.CustomGraphicsMesh_swigregister
CustomGraphicsMesh_swigregister(CustomGraphicsMesh)

def CustomGraphicsMesh_classType() -> "char const *" :
  return _fusion.CustomGraphicsMesh_classType()
CustomGraphicsMesh_classType = _fusion.CustomGraphicsMesh_classType

CustomGraphicsMesh.__swig_getmethods__["coordinates"] = CustomGraphicsMesh._get_coordinates
CustomGraphicsMesh.__swig_setmethods__["coordinates"] = CustomGraphicsMesh._set_coordinates
CustomGraphicsMesh.coordinates = property(CustomGraphicsMesh._get_coordinates, CustomGraphicsMesh._set_coordinates, doc="Gets and sets the coordinates associated with this CustomGraphicsMesh.")

CustomGraphicsMesh.__swig_getmethods__["normalVectors"] = CustomGraphicsMesh._get_normalVectors
CustomGraphicsMesh.__swig_setmethods__["normalVectors"] = CustomGraphicsMesh._set_normalVectors
CustomGraphicsMesh.normalVectors = property(CustomGraphicsMesh._get_normalVectors, CustomGraphicsMesh._set_normalVectors, doc="Gets and sets the normal vectors of the mesh where there is a normal\nvector at each node. The normals are defined as an array\nof floats where they are the x, y, z components of each vector.")

CustomGraphicsMesh.__swig_getmethods__["vertexIndexList"] = CustomGraphicsMesh._get_vertexIndexList
CustomGraphicsMesh.__swig_setmethods__["vertexIndexList"] = CustomGraphicsMesh._set_vertexIndexList
CustomGraphicsMesh.vertexIndexList = property(CustomGraphicsMesh._get_vertexIndexList, CustomGraphicsMesh._set_vertexIndexList, doc="Gets and sets an array of indices that define which coordinate in the\ncoordinate list is used for each vertex in the mesh. Each set of three\nindices defines a triagle. For example:\nIndices 0, 1, and 2 define the coordinates to use for the first triangle and\nindices 3, 4, and 5 define the coordinates for the second triangle, and so on.")

CustomGraphicsMesh.__swig_getmethods__["normalIndexList"] = CustomGraphicsMesh._get_normalIndexList
CustomGraphicsMesh.__swig_setmethods__["normalIndexList"] = CustomGraphicsMesh._set_normalIndexList
CustomGraphicsMesh.normalIndexList = property(CustomGraphicsMesh._get_normalIndexList, CustomGraphicsMesh._set_normalIndexList, doc="Gets and sets an array of indices that define which normal is associated\nwith each vertex in the mesh. This is used to look-up the normal in the\nnormalVectors array.")

CustomGraphicsMesh.__swig_getmethods__["textureCoordinates"] = CustomGraphicsMesh._get_textureCoordinates
CustomGraphicsMesh.__swig_setmethods__["textureCoordinates"] = CustomGraphicsMesh._set_textureCoordinates
CustomGraphicsMesh.textureCoordinates = property(CustomGraphicsMesh._get_textureCoordinates, CustomGraphicsMesh._set_textureCoordinates, doc="Gets and sets the texture coordinates as an array of floats where\nthey are the u,v components at each node. They are defined as an\narray of doubles where they are the u, v coordinates of each node.\nDefining texture coordinates for a mesh is optional.")

CustomGraphicsMesh.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsMesh) else None
CustomGraphicsMesh.cast = lambda arg: arg if isinstance(arg, CustomGraphicsMesh) else None

class CustomGraphicsPointSet(CustomGraphicsEntity):
    """Represents a set of one or more custom graphics points all of the same style."""
    __swig_setmethods__ = {}
    for _s in [CustomGraphicsEntity]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsPointSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CustomGraphicsEntity]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsPointSet, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsPointSet *" : return _fusion.CustomGraphicsPointSet___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsPointSet___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsPointSet___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsPointSet_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsPointSet_classType)
    __swig_destroy__ = _fusion.delete_CustomGraphicsPointSet
    __del__ = lambda self : None;
    def _get_coordinates(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsCoordinates >" :
        """
        Gets and sets the coordinates used to define the position of the custom graphics points.
        If no indexList is specified, every coordinate will be drawn using a custom graphics point,
        """
        return _fusion.CustomGraphicsPointSet__get_coordinates(self)

    def _set_coordinates(self, *args) -> "bool" :
        """
        Gets and sets the coordinates used to define the position of the custom graphics points.
        If no indexList is specified, every coordinate will be drawn using a custom graphics point,
        """
        return _fusion.CustomGraphicsPointSet__set_coordinates(self, *args)

    def _get_indexList(self) -> "std::vector< int,std::allocator< int > >" :
        """
        An list of indices that specify which coordinates from the coordinate list to draw points for.
        If this is an empty array, then all of the coordinates are used.
        """
        return _fusion.CustomGraphicsPointSet__get_indexList(self)

    def _set_indexList(self, *args) -> "bool" :
        """
        An list of indices that specify which coordinates from the coordinate list to draw points for.
        If this is an empty array, then all of the coordinates are used.
        """
        return _fusion.CustomGraphicsPointSet__set_indexList(self, *args)

    def _get_pointImage(self) -> "std::string" :
        """
        Gets and sets the image that will be used to display the point if the point type
        is a custom image. The image will always be be billboarded. The file should be 
        a png image and can use transparency. The filename can be a full path or a 
        relative path that is relative to your runtime file. Setting this will automatically
        set the pointType to UserDefinedCustomGraphicsPointType. This property can also
        return an empty string in the case where a user defined image point is not being used.
        """
        return _fusion.CustomGraphicsPointSet__get_pointImage(self)

    def _set_pointImage(self, *args) -> "bool" :
        """
        Gets and sets the image that will be used to display the point if the point type
        is a custom image. The image will always be be billboarded. The file should be 
        a png image and can use transparency. The filename can be a full path or a 
        relative path that is relative to your runtime file. Setting this will automatically
        set the pointType to UserDefinedCustomGraphicsPointType. This property can also
        return an empty string in the case where a user defined image point is not being used.
        """
        return _fusion.CustomGraphicsPointSet__set_pointImage(self, *args)

    def _get_pointType(self) -> "adsk::fusion::CustomGraphicsPointTypes" :
        """
        Specifies which of the pre-defined point images to use. Attempting to set this property
        to UserDefinedCustomGraphicsPointType will fail. To change to a user defined point type
        you must set use the pointImage property to specify the image to use and this will have
        the side-effect of changing the value of this property to UserDefinedCustomGraphicsPointType.
        """
        return _fusion.CustomGraphicsPointSet__get_pointType(self)

    def _set_pointType(self, *args) -> "bool" :
        """
        Specifies which of the pre-defined point images to use. Attempting to set this property
        to UserDefinedCustomGraphicsPointType will fail. To change to a user defined point type
        you must set use the pointImage property to specify the image to use and this will have
        the side-effect of changing the value of this property to UserDefinedCustomGraphicsPointType.
        """
        return _fusion.CustomGraphicsPointSet__set_pointType(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the custom graphics group. 
        Returns true if the deletion was successful.
        """
        return _fusion.CustomGraphicsPointSet_deleteMe(self)

    def _get_isVisible(self) -> "bool" :
        """
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsPointSet__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsPointSet__set_isVisible(self, *args)

    def _get_isSelectable(self) -> "bool" :
        """
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsPointSet__get_isSelectable(self)

    def _set_isSelectable(self, *args) -> "bool" :
        """
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsPointSet__set_isSelectable(self, *args)

    def setOpacity(self, *args) -> "bool" :
        """
        Sets the opacity of the graphics entity. By default, when a new entity is it is
        completely opaque and does not override the opacity defined by the material. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if setting the opacity information was successful.
        """
        return _fusion.CustomGraphicsPointSet_setOpacity(self, *args)

    def getOpacity(self) -> "bool" :
        """
        Gets the opacity of the graphics entity. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if getting the opacity information was successful.
        """
        return _fusion.CustomGraphicsPointSet_getOpacity(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >" :
        """
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsPointSet__get_transform(self)

    def _set_transform(self, *args) -> "bool" :
        """
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsPointSet__set_transform(self, *args)

    def _get_depthPriority(self) -> "int" :
        """
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsPointSet__get_depthPriority(self)

    def _set_depthPriority(self, *args) -> "bool" :
        """
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsPointSet__set_depthPriority(self, *args)

    def _get_cullMode(self) -> "adsk::fusion::CustomGraphicsCullModes" :
        """
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsPointSet__get_cullMode(self)

    def _set_cullMode(self, *args) -> "bool" :
        """
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsPointSet__set_cullMode(self, *args)

    def _get_color(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsColorEffect >" :
        """
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsPointSet__get_color(self)

    def _set_color(self, *args) -> "bool" :
        """
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsPointSet__set_color(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the parent Component for a top-level group or the CustomGraphicsGroup object for 
        graphics entities and child groups.
        """
        return _fusion.CustomGraphicsPointSet__get_parent(self)

    def _get_id(self) -> "std::string" :
        """
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsPointSet__get_id(self)

    def _set_id(self, *args) -> "bool" :
        """
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsPointSet__set_id(self, *args)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """
        Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.
        Depending on whether the graphics are drawn in model space or screen space this will return
        the bounding box in either centimeters (model) or pixels (screen). In the case where it
        returns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.
        """
        return _fusion.CustomGraphicsPointSet__get_boundingBox(self)

    def _get_billBoarding(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBillBoard >" :
        """
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsPointSet__get_billBoarding(self)

    def _set_billBoarding(self, *args) -> "bool" :
        """
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsPointSet__set_billBoarding(self, *args)

    def _get_viewPlacement(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewPlacement >" :
        """
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsPointSet__get_viewPlacement(self)

    def _set_viewPlacement(self, *args) -> "bool" :
        """
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsPointSet__set_viewPlacement(self, *args)

    def _get_viewScale(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewScale >" :
        """
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsPointSet__get_viewScale(self)

    def _set_viewScale(self, *args) -> "bool" :
        """
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsPointSet__set_viewScale(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsPointSet__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsPointSet__get_isValid(self)
CustomGraphicsPointSet_swigregister = _fusion.CustomGraphicsPointSet_swigregister
CustomGraphicsPointSet_swigregister(CustomGraphicsPointSet)

def CustomGraphicsPointSet_classType() -> "char const *" :
  return _fusion.CustomGraphicsPointSet_classType()
CustomGraphicsPointSet_classType = _fusion.CustomGraphicsPointSet_classType

CustomGraphicsPointSet.__swig_getmethods__["coordinates"] = CustomGraphicsPointSet._get_coordinates
CustomGraphicsPointSet.__swig_setmethods__["coordinates"] = CustomGraphicsPointSet._set_coordinates
CustomGraphicsPointSet.coordinates = property(CustomGraphicsPointSet._get_coordinates, CustomGraphicsPointSet._set_coordinates, doc="Gets and sets the coordinates used to define the position of the custom graphics points.\nIf no indexList is specified, every coordinate will be drawn using a custom graphics point,")

CustomGraphicsPointSet.__swig_getmethods__["indexList"] = CustomGraphicsPointSet._get_indexList
CustomGraphicsPointSet.__swig_setmethods__["indexList"] = CustomGraphicsPointSet._set_indexList
CustomGraphicsPointSet.indexList = property(CustomGraphicsPointSet._get_indexList, CustomGraphicsPointSet._set_indexList, doc="An list of indices that specify which coordinates from the coordinate list to draw points for.\nIf this is an empty array, then all of the coordinates are used.")

CustomGraphicsPointSet.__swig_getmethods__["pointImage"] = CustomGraphicsPointSet._get_pointImage
CustomGraphicsPointSet.__swig_setmethods__["pointImage"] = CustomGraphicsPointSet._set_pointImage
CustomGraphicsPointSet.pointImage = property(CustomGraphicsPointSet._get_pointImage, CustomGraphicsPointSet._set_pointImage, doc="Gets and sets the image that will be used to display the point if the point type\nis a custom image. The image will always be be billboarded. The file should be\na png image and can use transparency. The filename can be a full path or a\nrelative path that is relative to your runtime file. Setting this will automatically\nset the pointType to UserDefinedCustomGraphicsPointType. This property can also\nreturn an empty string in the case where a user defined image point is not being used.")

CustomGraphicsPointSet.__swig_getmethods__["pointType"] = CustomGraphicsPointSet._get_pointType
CustomGraphicsPointSet.__swig_setmethods__["pointType"] = CustomGraphicsPointSet._set_pointType
CustomGraphicsPointSet.pointType = property(CustomGraphicsPointSet._get_pointType, CustomGraphicsPointSet._set_pointType, doc="Specifies which of the pre-defined point images to use. Attempting to set this property\nto UserDefinedCustomGraphicsPointType will fail. To change to a user defined point type\nyou must set use the pointImage property to specify the image to use and this will have\nthe side-effect of changing the value of this property to UserDefinedCustomGraphicsPointType.")

CustomGraphicsPointSet.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsPointSet) else None
CustomGraphicsPointSet.cast = lambda arg: arg if isinstance(arg, CustomGraphicsPointSet) else None

class CustomGraphicsSolidColorEffect(CustomGraphicsColorEffect):
    """
    One of the types of color effects that can be applied to a custom graphics entity. With this 
    type of effect, the graphics entity will display as the single color without any lighting 
    effects. For example, a sphere will display as a solid filled circle without any shading 
    indicating it is actually spherical.
    """
    __swig_setmethods__ = {}
    for _s in [CustomGraphicsColorEffect]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsSolidColorEffect, name, value)
    __swig_getmethods__ = {}
    for _s in [CustomGraphicsColorEffect]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsSolidColorEffect, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsSolidColorEffect *" : return _fusion.CustomGraphicsSolidColorEffect___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsSolidColorEffect___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsSolidColorEffect___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsSolidColorEffect_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsSolidColorEffect_classType)
    __swig_getmethods__["create"] = lambda x: _fusion.CustomGraphicsSolidColorEffect_create
    if _newclass:create = staticmethod(_fusion.CustomGraphicsSolidColorEffect_create)
    __swig_destroy__ = _fusion.delete_CustomGraphicsSolidColorEffect
    __del__ = lambda self : None;
    def _get_color(self) -> "adsk::core::Ptr< adsk::core::Color >" :
        """
        The color to use for the solid color display. The opacity component of the color is ignored 
        because the opacity of custom graphics is controlled seperately using an opacity attribute.
        """
        return _fusion.CustomGraphicsSolidColorEffect__get_color(self)

    def _set_color(self, *args) -> "bool" :
        """
        The color to use for the solid color display. The opacity component of the color is ignored 
        because the opacity of custom graphics is controlled seperately using an opacity attribute.
        """
        return _fusion.CustomGraphicsSolidColorEffect__set_color(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsSolidColorEffect__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsSolidColorEffect__get_isValid(self)
CustomGraphicsSolidColorEffect_swigregister = _fusion.CustomGraphicsSolidColorEffect_swigregister
CustomGraphicsSolidColorEffect_swigregister(CustomGraphicsSolidColorEffect)

def CustomGraphicsSolidColorEffect_classType() -> "char const *" :
  return _fusion.CustomGraphicsSolidColorEffect_classType()
CustomGraphicsSolidColorEffect_classType = _fusion.CustomGraphicsSolidColorEffect_classType

def CustomGraphicsSolidColorEffect_create(*args) -> "adsk::core::Ptr< adsk::core::Color > const &" :
  return _fusion.CustomGraphicsSolidColorEffect_create(*args)
CustomGraphicsSolidColorEffect_create = _fusion.CustomGraphicsSolidColorEffect_create

CustomGraphicsSolidColorEffect.__swig_getmethods__["color"] = CustomGraphicsSolidColorEffect._get_color
CustomGraphicsSolidColorEffect.__swig_setmethods__["color"] = CustomGraphicsSolidColorEffect._set_color
CustomGraphicsSolidColorEffect.color = property(CustomGraphicsSolidColorEffect._get_color, CustomGraphicsSolidColorEffect._set_color, doc="The color to use for the solid color display. The opacity component of the color is ignored\nbecause the opacity of custom graphics is controlled seperately using an opacity attribute.")

CustomGraphicsSolidColorEffect.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsSolidColorEffect) else None
CustomGraphicsSolidColorEffect.cast = lambda arg: arg if isinstance(arg, CustomGraphicsSolidColorEffect) else None

class CustomGraphicsText(CustomGraphicsEntity):
    """
    Represents text drawn in the graphics window. The default position of the text is at (0,0,0) and 
    orientation is the text lying on the x-y plane. To reposition and reorient the text you can use
    the transformation property.
    """
    __swig_setmethods__ = {}
    for _s in [CustomGraphicsEntity]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsText, name, value)
    __swig_getmethods__ = {}
    for _s in [CustomGraphicsEntity]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsText, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsText *" : return _fusion.CustomGraphicsText___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsText___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsText___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsText_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsText_classType)
    __swig_destroy__ = _fusion.delete_CustomGraphicsText
    __del__ = lambda self : None;
    def _get_formattedText(self) -> "std::string" :
        """
        Gets and sets the formatted text definition. This is the full string, including the 
        formatting information, that's used to define the displayed text.
        """
        return _fusion.CustomGraphicsText__get_formattedText(self)

    def _set_formattedText(self, *args) -> "bool" :
        """
        Gets and sets the formatted text definition. This is the full string, including the 
        formatting information, that's used to define the displayed text.
        """
        return _fusion.CustomGraphicsText__set_formattedText(self, *args)

    def _get_font(self) -> "std::string" :
        """
        Gets and sets the font used to display the text. This is the default font and applies to
        all of text unless there is a font override defined within the text.
        """
        return _fusion.CustomGraphicsText__get_font(self)

    def _set_font(self, *args) -> "bool" :
        """
        Gets and sets the font used to display the text. This is the default font and applies to
        all of text unless there is a font override defined within the text.
        """
        return _fusion.CustomGraphicsText__set_font(self, *args)

    def _get_isItalic(self) -> "bool" :
        """
        Specifies that the text displays using an italic style. This is the default italic style and applies to
        all of text unless there is a style override defined within the text.
        """
        return _fusion.CustomGraphicsText__get_isItalic(self)

    def _set_isItalic(self, *args) -> "bool" :
        """
        Specifies that the text displays using an italic style. This is the default italic style and applies to
        all of text unless there is a style override defined within the text.
        """
        return _fusion.CustomGraphicsText__set_isItalic(self, *args)

    def _get_isBold(self) -> "bool" :
        """
        Specifies that the text displays using a bold style. This is the default bold style and applies to
        all of text unless there is a style override defined within the text.
        """
        return _fusion.CustomGraphicsText__get_isBold(self)

    def _set_isBold(self, *args) -> "bool" :
        """
        Specifies that the text displays using a bold style. This is the default bold style and applies to
        all of text unless there is a style override defined within the text.
        """
        return _fusion.CustomGraphicsText__set_isBold(self, *args)

    def _get_isUnderline(self) -> "bool" :
        """
        Specifies that the text displays using an underline style. This is the default underline style and applies to
        all of text unless there is a style override defined within the text.
        """
        return _fusion.CustomGraphicsText__get_isUnderline(self)

    def _set_isUnderline(self, *args) -> "bool" :
        """
        Specifies that the text displays using an underline style. This is the default underline style and applies to
        all of text unless there is a style override defined within the text.
        """
        return _fusion.CustomGraphicsText__set_isUnderline(self, *args)

    def _get_isStrikeThrough(self) -> "bool" :
        """
        Specifies that the text displays using a strike through style. This is the default strike through style and applies to
        all of text unless there is a style override defined within the text.
        """
        return _fusion.CustomGraphicsText__get_isStrikeThrough(self)

    def _set_isStrikeThrough(self, *args) -> "bool" :
        """
        Specifies that the text displays using a strike through style. This is the default strike through style and applies to
        all of text unless there is a style override defined within the text.
        """
        return _fusion.CustomGraphicsText__set_isStrikeThrough(self, *args)

    def _get_size(self) -> "double" :
        """
        Gets and sets the size of the text in centimeters. This is the default size and applies to
        all of text unless there is a size override defined within the text.
        """
        return _fusion.CustomGraphicsText__get_size(self)

    def _set_size(self, *args) -> "bool" :
        """
        Gets and sets the size of the text in centimeters. This is the default size and applies to
        all of text unless there is a size override defined within the text.
        """
        return _fusion.CustomGraphicsText__set_size(self, *args)

    def _get_width(self) -> "double" :
        """
        The actual width of the text in centimeters. This is useful when you want to position several
        GraphicsText objects together.
        """
        return _fusion.CustomGraphicsText__get_width(self)

    def _get_height(self) -> "double" :
        """
        The actual height of the text in centimeters. This is useful when you want to position several
        GraphicsText objects together.
        """
        return _fusion.CustomGraphicsText__get_height(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the custom graphics group. 
        Returns true if the deletion was successful.
        """
        return _fusion.CustomGraphicsText_deleteMe(self)

    def _get_isVisible(self) -> "bool" :
        """
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsText__get_isVisible(self)

    def _set_isVisible(self, *args) -> "bool" :
        """
        Gets and sets if the graphics entity is visible in the graphics window. By
        default, when a new entity is created it is visible.
        """
        return _fusion.CustomGraphicsText__set_isVisible(self, *args)

    def _get_isSelectable(self) -> "bool" :
        """
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsText__get_isSelectable(self)

    def _set_isSelectable(self, *args) -> "bool" :
        """
        Gets and sets if the graphics entity is selectable within the graphics window. By
        default, when a new entity is created it is selectable.
        """
        return _fusion.CustomGraphicsText__set_isSelectable(self, *args)

    def setOpacity(self, *args) -> "bool" :
        """
        Sets the opacity of the graphics entity. By default, when a new entity is it is
        completely opaque and does not override the opacity defined by the material. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if setting the opacity information was successful.
        """
        return _fusion.CustomGraphicsText_setOpacity(self, *args)

    def getOpacity(self) -> "bool" :
        """
        Gets the opacity of the graphics entity. 
        opacity : The opacity value where 1.0 is completely opaque and 0.0 is completely transparent. 
        isOverride : Indicates if this entities opacity will override the opacity defined by the material.
        If true, it will override the material opacity and if false the opacity values will
        accumulate. 
        Returns true if getting the opacity information was successful.
        """
        return _fusion.CustomGraphicsText_getOpacity(self)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >" :
        """
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsText__get_transform(self)

    def _set_transform(self, *args) -> "bool" :
        """
        Gets and sets the transform associated with the graphics entity. When a new graphics
        entity is created its default transform is an identity matrix which results in the graphics entity
        being displayed in model space using the original coordinate data used to define the entity.
        """
        return _fusion.CustomGraphicsText__set_transform(self, *args)

    def _get_depthPriority(self) -> "int" :
        """
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsText__get_depthPriority(self)

    def _set_depthPriority(self, *args) -> "bool" :
        """
        Gets and sets the depth priority associated with the graphics entity. The depth priority defines 
        how one graphics entity will be drawn with respect to another entity. This is useful when there
        are entities that lie in the same space so it's ambiguous which should be drawn on the other. For
        example, if you draw a curve on a planar mesh and want the curve to be completely visible. You can
        set the depth priority of the curve to be greater than the mesh so it will be drawn after the mesh
        and will remain visible.
        When a new graphics entity is created it's default depth priority is 0.
        """
        return _fusion.CustomGraphicsText__set_depthPriority(self, *args)

    def _get_cullMode(self) -> "adsk::fusion::CustomGraphicsCullModes" :
        """
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsText__get_cullMode(self)

    def _set_cullMode(self, *args) -> "bool" :
        """
        Gets and sets the culling model to use when rendering the entity. Culling is used when the entity contains
        a mesh or B-Rep faces and defines which sides of the mesh or face are rendered. This is primarily used
        for a watertight mesh or solid B-Rep so that the 'inside' of the faces is not rendered since it's never
        visible to the user.
        When a new graphics entity is created its default cull mode is CustomGraphicsCullBack which will optimize
        the rendering of 'solid' meshes so the inside is not rendered.
        """
        return _fusion.CustomGraphicsText__set_cullMode(self, *args)

    def _get_color(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsColorEffect >" :
        """
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsText__get_color(self)

    def _set_color(self, *args) -> "bool" :
        """
        Gets and sets the current color definition for this entity. The color of custom graphics can
        be defined in many ways; solid color, simple material, and appearance.
        """
        return _fusion.CustomGraphicsText__set_color(self, *args)

    def _get_parent(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the parent Component for a top-level group or the CustomGraphicsGroup object for 
        graphics entities and child groups.
        """
        return _fusion.CustomGraphicsText__get_parent(self)

    def _get_id(self) -> "std::string" :
        """
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsText__get_id(self)

    def _set_id(self, *args) -> "bool" :
        """
        An id you can specify for the entity. By default, all new graphics entities do not have an id and
        this property will return an empty string. But in cases where entities will be selected, assigning 
        an id can make understanding what was selected much easier.
        """
        return _fusion.CustomGraphicsText__set_id(self, *args)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """
        Returns a box oriented parallel to the world x-y-x axes that contains the graphics entity.
        Depending on whether the graphics are drawn in model space or screen space this will return
        the bounding box in either centimeters (model) or pixels (screen). In the case where it
        returns the bounding box in pixel space, the Z coordinates of the box will be 0 and can be ignored.
        """
        return _fusion.CustomGraphicsText__get_boundingBox(self)

    def _get_billBoarding(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsBillBoard >" :
        """
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsText__get_billBoarding(self)

    def _set_billBoarding(self, *args) -> "bool" :
        """
        Gets and sets the billboarding behavior of this custom graphics entity. To define billboarding
        you can set this property using a CustomGraphicsBillBoard objects that you statically create using
        the create method of the CustomGraphicsBillBoard class. To remove billboarding from this entity
        you can set this property to null.
        Billboarding is used to specify that the orientation of custom graphics is defined relative to the 
        screen instead of model space. This is commonly used for legends and symbols that you want to 
        always face the user, even as the camera is rotated.
        """
        return _fusion.CustomGraphicsText__set_billBoarding(self, *args)

    def _get_viewPlacement(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewPlacement >" :
        """
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsText__get_viewPlacement(self)

    def _set_viewPlacement(self, *args) -> "bool" :
        """
        Gets and sets the graphics view placement being applied to this graphics entity. A
        CustomGraphicsViewPlacement object can be created using the static create method of the 
        class. When assigned to a graphics entity the position of the graphics is defined
        relative to the view in 2D view space (pixels) rather than in 3D model space (centimeters).
        """
        return _fusion.CustomGraphicsText__set_viewPlacement(self, *args)

    def _get_viewScale(self) -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsViewScale >" :
        """
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsText__get_viewScale(self)

    def _set_viewScale(self, *args) -> "bool" :
        """
        Gets and sets the graphics view scale being applied to this graphics entity. A
        CustomGraphicsViewScale object can be created using the static create method of the 
        class. When assigned to a graphics entity the size of the graphics entity is defined
        in view space (pixels) instead of model space (centimeters).
        """
        return _fusion.CustomGraphicsText__set_viewScale(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsText__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsText__get_isValid(self)
CustomGraphicsText_swigregister = _fusion.CustomGraphicsText_swigregister
CustomGraphicsText_swigregister(CustomGraphicsText)

def CustomGraphicsText_classType() -> "char const *" :
  return _fusion.CustomGraphicsText_classType()
CustomGraphicsText_classType = _fusion.CustomGraphicsText_classType

CustomGraphicsText.__swig_getmethods__["formattedText"] = CustomGraphicsText._get_formattedText
CustomGraphicsText.__swig_setmethods__["formattedText"] = CustomGraphicsText._set_formattedText
CustomGraphicsText.formattedText = property(CustomGraphicsText._get_formattedText, CustomGraphicsText._set_formattedText, doc="Gets and sets the formatted text definition. This is the full string, including the\nformatting information, that's used to define the displayed text.")

CustomGraphicsText.__swig_getmethods__["font"] = CustomGraphicsText._get_font
CustomGraphicsText.__swig_setmethods__["font"] = CustomGraphicsText._set_font
CustomGraphicsText.font = property(CustomGraphicsText._get_font, CustomGraphicsText._set_font, doc="Gets and sets the font used to display the text. This is the default font and applies to\nall of text unless there is a font override defined within the text.")

CustomGraphicsText.__swig_getmethods__["isItalic"] = CustomGraphicsText._get_isItalic
CustomGraphicsText.__swig_setmethods__["isItalic"] = CustomGraphicsText._set_isItalic
CustomGraphicsText.isItalic = property(CustomGraphicsText._get_isItalic, CustomGraphicsText._set_isItalic, doc="Specifies that the text displays using an italic style. This is the default italic style and applies to\nall of text unless there is a style override defined within the text.")

CustomGraphicsText.__swig_getmethods__["isBold"] = CustomGraphicsText._get_isBold
CustomGraphicsText.__swig_setmethods__["isBold"] = CustomGraphicsText._set_isBold
CustomGraphicsText.isBold = property(CustomGraphicsText._get_isBold, CustomGraphicsText._set_isBold, doc="Specifies that the text displays using a bold style. This is the default bold style and applies to\nall of text unless there is a style override defined within the text.")

CustomGraphicsText.__swig_getmethods__["isUnderline"] = CustomGraphicsText._get_isUnderline
CustomGraphicsText.__swig_setmethods__["isUnderline"] = CustomGraphicsText._set_isUnderline
CustomGraphicsText.isUnderline = property(CustomGraphicsText._get_isUnderline, CustomGraphicsText._set_isUnderline, doc="Specifies that the text displays using an underline style. This is the default underline style and applies to\nall of text unless there is a style override defined within the text.")

CustomGraphicsText.__swig_getmethods__["isStrikeThrough"] = CustomGraphicsText._get_isStrikeThrough
CustomGraphicsText.__swig_setmethods__["isStrikeThrough"] = CustomGraphicsText._set_isStrikeThrough
CustomGraphicsText.isStrikeThrough = property(CustomGraphicsText._get_isStrikeThrough, CustomGraphicsText._set_isStrikeThrough, doc="Specifies that the text displays using a strike through style. This is the default strike through style and applies to\nall of text unless there is a style override defined within the text.")

CustomGraphicsText.__swig_getmethods__["size"] = CustomGraphicsText._get_size
CustomGraphicsText.__swig_setmethods__["size"] = CustomGraphicsText._set_size
CustomGraphicsText.size = property(CustomGraphicsText._get_size, CustomGraphicsText._set_size, doc="Gets and sets the size of the text in centimeters. This is the default size and applies to\nall of text unless there is a size override defined within the text.")

CustomGraphicsText.__swig_getmethods__["width"] = CustomGraphicsText._get_width
CustomGraphicsText.width = property(CustomGraphicsText._get_width, doc="The actual width of the text in centimeters. This is useful when you want to position several\nGraphicsText objects together.")

CustomGraphicsText.__swig_getmethods__["height"] = CustomGraphicsText._get_height
CustomGraphicsText.height = property(CustomGraphicsText._get_height, doc="The actual height of the text in centimeters. This is useful when you want to position several\nGraphicsText objects together.")

CustomGraphicsText.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsText) else None
CustomGraphicsText.cast = lambda arg: arg if isinstance(arg, CustomGraphicsText) else None

class CustomGraphicsVertexColorEffect(CustomGraphicsColorEffect):
    """
    One of the types of color effects that can be applied to a custom graphics entity. With this 
    type of effect, the graphics entity will display using the colors associated with the vertices
    of the mesh in the CustomGraphicsCoordinates object.
    """
    __swig_setmethods__ = {}
    for _s in [CustomGraphicsColorEffect]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomGraphicsVertexColorEffect, name, value)
    __swig_getmethods__ = {}
    for _s in [CustomGraphicsColorEffect]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomGraphicsVertexColorEffect, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CustomGraphicsVertexColorEffect *" : return _fusion.CustomGraphicsVertexColorEffect___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CustomGraphicsVertexColorEffect___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CustomGraphicsVertexColorEffect___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CustomGraphicsVertexColorEffect_classType
    if _newclass:classType = staticmethod(_fusion.CustomGraphicsVertexColorEffect_classType)
    __swig_getmethods__["create"] = lambda x: _fusion.CustomGraphicsVertexColorEffect_create
    if _newclass:create = staticmethod(_fusion.CustomGraphicsVertexColorEffect_create)
    __swig_destroy__ = _fusion.delete_CustomGraphicsVertexColorEffect
    __del__ = lambda self : None;
    def _get_objectType(self) -> "char const *" : return _fusion.CustomGraphicsVertexColorEffect__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CustomGraphicsVertexColorEffect__get_isValid(self)
CustomGraphicsVertexColorEffect_swigregister = _fusion.CustomGraphicsVertexColorEffect_swigregister
CustomGraphicsVertexColorEffect_swigregister(CustomGraphicsVertexColorEffect)

def CustomGraphicsVertexColorEffect_classType() -> "char const *" :
  return _fusion.CustomGraphicsVertexColorEffect_classType()
CustomGraphicsVertexColorEffect_classType = _fusion.CustomGraphicsVertexColorEffect_classType

def CustomGraphicsVertexColorEffect_create() -> "adsk::core::Ptr< adsk::fusion::CustomGraphicsVertexColorEffect >" :
  return _fusion.CustomGraphicsVertexColorEffect_create()
CustomGraphicsVertexColorEffect_create = _fusion.CustomGraphicsVertexColorEffect_create

CustomGraphicsVertexColorEffect.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CustomGraphicsVertexColorEffect) else None
CustomGraphicsVertexColorEffect.cast = lambda arg: arg if isinstance(arg, CustomGraphicsVertexColorEffect) else None

class CutPasteBody(Feature):
    """Object that represents an existing Cut/Paste Body feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CutPasteBody, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CutPasteBody, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CutPasteBody *" : return _fusion.CutPasteBody___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CutPasteBody___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CutPasteBody___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CutPasteBody_classType
    if _newclass:classType = staticmethod(_fusion.CutPasteBody_classType)
    __swig_destroy__ = _fusion.delete_CutPasteBody
    __del__ = lambda self : None;
    def _get_sourceBody(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Returns the bodies that were cut to create the result bodies of this feature. An ObjectCollection
        is returned that will contain the original bodies. It's possible that the collection can be empty
        or contain less than the number of bodies originally copied. This happens in the case where a body 
        has been deleted or consumed by some other operation. If you roll the timeline to a point immediately 
        before or after the feature was created you can access the bodies.
        Returns the bodies that were cut to create the result bodies of this feature. An ObjectCollection
        is returned that will contain the original bodies. Because the body is removed as a result of this 
        operation the cut bodies will never be available after the feature has been created. If you roll 
        the timeline to a point immediately before the feature was created you can access the bodies.
        """
        return _fusion.CutPasteBody__get_sourceBody(self)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CutPasteBody__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CutPasteBody__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.CutPasteBody_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.CutPasteBody_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CutPasteBody__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CutPasteBody__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.CutPasteBody__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.CutPasteBody__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.CutPasteBody__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.CutPasteBody__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CutPasteBody__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.CutPasteBody__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.CutPasteBody__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.CutPasteBody__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.CutPasteBody__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.CutPasteBody__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.CutPasteBody__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.CutPasteBody__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CutPasteBody__get_isValid(self)
CutPasteBody_swigregister = _fusion.CutPasteBody_swigregister
CutPasteBody_swigregister(CutPasteBody)

def CutPasteBody_classType() -> "char const *" :
  return _fusion.CutPasteBody_classType()
CutPasteBody_classType = _fusion.CutPasteBody_classType

CutPasteBody.__swig_getmethods__["sourceBody"] = CutPasteBody._get_sourceBody
CutPasteBody.sourceBody = property(CutPasteBody._get_sourceBody, doc="Returns the bodies that were cut to create the result bodies of this feature. An ObjectCollection\nis returned that will contain the original bodies. It's possible that the collection can be empty\nor contain less than the number of bodies originally copied. This happens in the case where a body\nhas been deleted or consumed by some other operation. If you roll the timeline to a point immediately\nbefore or after the feature was created you can access the bodies.\nReturns the bodies that were cut to create the result bodies of this feature. An ObjectCollection\nis returned that will contain the original bodies. Because the body is removed as a result of this\noperation the cut bodies will never be available after the feature has been created. If you roll\nthe timeline to a point immediately before the feature was created you can access the bodies.")

CutPasteBody.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CutPasteBody) else None
CutPasteBody.cast = lambda arg: arg if isinstance(arg, CutPasteBody) else None

class CylinderFeature(Feature):
    """Object that represents an existing cylinder feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CylinderFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CylinderFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CylinderFeature *" : return _fusion.CylinderFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CylinderFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CylinderFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CylinderFeature_classType
    if _newclass:classType = staticmethod(_fusion.CylinderFeature_classType)
    __swig_destroy__ = _fusion.delete_CylinderFeature
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CylinderFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.CylinderFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.CylinderFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.CylinderFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CylinderFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.CylinderFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.CylinderFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.CylinderFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.CylinderFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.CylinderFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.CylinderFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.CylinderFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.CylinderFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.CylinderFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.CylinderFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.CylinderFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.CylinderFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.CylinderFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CylinderFeature__get_isValid(self)
CylinderFeature_swigregister = _fusion.CylinderFeature_swigregister
CylinderFeature_swigregister(CylinderFeature)

def CylinderFeature_classType() -> "char const *" :
  return _fusion.CylinderFeature_classType()
CylinderFeature_classType = _fusion.CylinderFeature_classType

CylinderFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CylinderFeature) else None
CylinderFeature.cast = lambda arg: arg if isinstance(arg, CylinderFeature) else None

class CylindricalJointMotion(JointMotion):
    """Represents the set of information specific to a cylindrical joint."""
    __swig_setmethods__ = {}
    for _s in [JointMotion]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CylindricalJointMotion, name, value)
    __swig_getmethods__ = {}
    for _s in [JointMotion]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CylindricalJointMotion, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::CylindricalJointMotion *" : return _fusion.CylindricalJointMotion___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.CylindricalJointMotion___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.CylindricalJointMotion___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.CylindricalJointMotion_classType
    if _newclass:classType = staticmethod(_fusion.CylindricalJointMotion_classType)
    __swig_destroy__ = _fusion.delete_CylindricalJointMotion
    __del__ = lambda self : None;
    def _get_rotationAxis(self) -> "adsk::fusion::JointDirections" :
        """
        Gets and sets the direction of the axis of rotation. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customRotationAxisEntity will return an entity
        that defines the axis. If there is a custom rotation axis defined and this
        property is set to one of the three standard axes, the custom rotation will
        be removed and customRotationAxisEntity will return null.
        """
        return _fusion.CylindricalJointMotion__get_rotationAxis(self)

    def _set_rotationAxis(self, *args) -> "bool" :
        """
        Gets and sets the direction of the axis of rotation. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customRotationAxisEntity will return an entity
        that defines the axis. If there is a custom rotation axis defined and this
        property is set to one of the three standard axes, the custom rotation will
        be removed and customRotationAxisEntity will return null.
        """
        return _fusion.CylindricalJointMotion__set_rotationAxis(self, *args)

    def _get_rotationAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Returns the direction of the rotation axis. This property will return null in the case
        where the CylindricalJointMotion object was obtained from a JointInput object.
        """
        return _fusion.CylindricalJointMotion__get_rotationAxisVector(self)

    def _get_customRotationAxisEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        This property can be set using various types of entities that can infer an
        axis. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the rotationAxis property returns
        CustomJointDirection. Setting this property will automatically set
        the rotationAxis property to CustomJointDirection.
        """
        return _fusion.CylindricalJointMotion__get_customRotationAxisEntity(self)

    def _set_customRotationAxisEntity(self, *args) -> "bool" :
        """
        This property can be set using various types of entities that can infer an
        axis. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the rotationAxis property returns
        CustomJointDirection. Setting this property will automatically set
        the rotationAxis property to CustomJointDirection.
        """
        return _fusion.CylindricalJointMotion__set_customRotationAxisEntity(self, *args)

    def _get_rotationValue(self) -> "double" :
        """
        Gets and sets the rotation value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.CylindricalJointMotion__get_rotationValue(self)

    def _set_rotationValue(self, *args) -> "bool" :
        """
        Gets and sets the rotation value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.CylindricalJointMotion__set_rotationValue(self, *args)

    def _get_rotationLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >" :
        """
        Returns a JointLimits object that defines the rotation limits for this joint.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.CylindricalJointMotion__get_rotationLimits(self)

    def _get_slideValue(self) -> "double" :
        """
        Gets and sets the slide value. This is in centimeters. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.CylindricalJointMotion__get_slideValue(self)

    def _set_slideValue(self, *args) -> "bool" :
        """
        Gets and sets the slide value. This is in centimeters. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.CylindricalJointMotion__set_slideValue(self, *args)

    def _get_slideLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >" :
        """
        Returns a JointLimits object that defines the slide limits for this joint.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.CylindricalJointMotion__get_slideLimits(self)

    def _get_jointType(self) -> "adsk::fusion::JointTypes" :
        """Returns an enum value indicating the type of joint this joint represents."""
        return _fusion.CylindricalJointMotion__get_jointType(self)

    def _get_objectType(self) -> "char const *" : return _fusion.CylindricalJointMotion__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.CylindricalJointMotion__get_isValid(self)
CylindricalJointMotion_swigregister = _fusion.CylindricalJointMotion_swigregister
CylindricalJointMotion_swigregister(CylindricalJointMotion)

def CylindricalJointMotion_classType() -> "char const *" :
  return _fusion.CylindricalJointMotion_classType()
CylindricalJointMotion_classType = _fusion.CylindricalJointMotion_classType

CylindricalJointMotion.__swig_getmethods__["rotationAxis"] = CylindricalJointMotion._get_rotationAxis
CylindricalJointMotion.__swig_setmethods__["rotationAxis"] = CylindricalJointMotion._set_rotationAxis
CylindricalJointMotion.rotationAxis = property(CylindricalJointMotion._get_rotationAxis, CylindricalJointMotion._set_rotationAxis, doc="Gets and sets the direction of the axis of rotation. This can be set to\nXAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can\nreturn those three directions and CustomJointDirection. If this returns\nCustomJointDirection then the customRotationAxisEntity will return an entity\nthat defines the axis. If there is a custom rotation axis defined and this\nproperty is set to one of the three standard axes, the custom rotation will\nbe removed and customRotationAxisEntity will return null.")

CylindricalJointMotion.__swig_getmethods__["rotationAxisVector"] = CylindricalJointMotion._get_rotationAxisVector
CylindricalJointMotion.rotationAxisVector = property(CylindricalJointMotion._get_rotationAxisVector, doc="Returns the direction of the rotation axis. This property will return null in the case\nwhere the CylindricalJointMotion object was obtained from a JointInput object.")

CylindricalJointMotion.__swig_getmethods__["customRotationAxisEntity"] = CylindricalJointMotion._get_customRotationAxisEntity
CylindricalJointMotion.__swig_setmethods__["customRotationAxisEntity"] = CylindricalJointMotion._set_customRotationAxisEntity
CylindricalJointMotion.customRotationAxisEntity = property(CylindricalJointMotion._get_customRotationAxisEntity, CylindricalJointMotion._set_customRotationAxisEntity, doc="This property can be set using various types of entities that can infer an\naxis. For example, a linear edge, sketch line, planar face, and cylindrical face.\nThis property is only valid in the case where the rotationAxis property returns\nCustomJointDirection. Setting this property will automatically set\nthe rotationAxis property to CustomJointDirection.")

CylindricalJointMotion.__swig_getmethods__["rotationValue"] = CylindricalJointMotion._get_rotationValue
CylindricalJointMotion.__swig_setmethods__["rotationValue"] = CylindricalJointMotion._set_rotationValue
CylindricalJointMotion.rotationValue = property(CylindricalJointMotion._get_rotationValue, CylindricalJointMotion._set_rotationValue, doc="Gets and sets the rotation value. This is in radians. Setting this value is\nthe equivalent of using the Drive Joints command.")

CylindricalJointMotion.__swig_getmethods__["rotationLimits"] = CylindricalJointMotion._get_rotationLimits
CylindricalJointMotion.rotationLimits = property(CylindricalJointMotion._get_rotationLimits, doc="Returns a JointLimits object that defines the rotation limits for this joint.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")

CylindricalJointMotion.__swig_getmethods__["slideValue"] = CylindricalJointMotion._get_slideValue
CylindricalJointMotion.__swig_setmethods__["slideValue"] = CylindricalJointMotion._set_slideValue
CylindricalJointMotion.slideValue = property(CylindricalJointMotion._get_slideValue, CylindricalJointMotion._set_slideValue, doc="Gets and sets the slide value. This is in centimeters. Setting this value is\nthe equivalent of using the Drive Joints command.")

CylindricalJointMotion.__swig_getmethods__["slideLimits"] = CylindricalJointMotion._get_slideLimits
CylindricalJointMotion.slideLimits = property(CylindricalJointMotion._get_slideLimits, doc="Returns a JointLimits object that defines the slide limits for this joint.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")

CylindricalJointMotion.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, CylindricalJointMotion) else None
CylindricalJointMotion.cast = lambda arg: arg if isinstance(arg, CylindricalJointMotion) else None

class DeleteFaceFeature(Feature):
    """
    Object that represents an existing DeleteFaceFeature object in a design.
    The SurfaceDeleteFaceFeature and DeleteFaceFeature differ in that the SurfaceDeleteFaceFeature
    can delete any face without any restrictions. If the body is a solid, it will become a surface
    when the first face is deleted. The specified face is deleted without any other changes being
    made to the body. The DeleteFaceFeature deletes the specified face and also modifies the other faces
    in the body to heal or fill in the area of the deleted face. This means that a solid body will
    remain solid.
    """
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DeleteFaceFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DeleteFaceFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::DeleteFaceFeature *" : return _fusion.DeleteFaceFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.DeleteFaceFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.DeleteFaceFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.DeleteFaceFeature_classType
    if _newclass:classType = staticmethod(_fusion.DeleteFaceFeature_classType)
    __swig_destroy__ = _fusion.delete_DeleteFaceFeature
    __del__ = lambda self : None;
    def _get_deletedFaces(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepFace > > >" :
        """
        Gets and sets the set of faces that are deleted by this feature. To 
        be able to use this property to both get and set the faces, you need to 
        first roll the timeline to immediately before this feature. This can be
        accomplished using the following code where thisFeature is a reference
        to a DeleteFaceFeature:
        thisFeature.timelineObject.rollTo(True)
        Setting this property can fail if Fusion 360 is unable to heal the body after
        deleting the specified faces.
        """
        return _fusion.DeleteFaceFeature__get_deletedFaces(self)

    def _set_deletedFaces(self, *args) -> "bool" :
        """
        Gets and sets the set of faces that are deleted by this feature. To 
        be able to use this property to both get and set the faces, you need to 
        first roll the timeline to immediately before this feature. This can be
        accomplished using the following code where thisFeature is a reference
        to a DeleteFaceFeature:
        thisFeature.timelineObject.rollTo(True)
        Setting this property can fail if Fusion 360 is unable to heal the body after
        deleting the specified faces.
        """
        return _fusion.DeleteFaceFeature__set_deletedFaces(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::DeleteFaceFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.DeleteFaceFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::DeleteFaceFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.DeleteFaceFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.DeleteFaceFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.DeleteFaceFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.DeleteFaceFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.DeleteFaceFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.DeleteFaceFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.DeleteFaceFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.DeleteFaceFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.DeleteFaceFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.DeleteFaceFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.DeleteFaceFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.DeleteFaceFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.DeleteFaceFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.DeleteFaceFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.DeleteFaceFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.DeleteFaceFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.DeleteFaceFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.DeleteFaceFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.DeleteFaceFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.DeleteFaceFeature__get_isValid(self)
DeleteFaceFeature_swigregister = _fusion.DeleteFaceFeature_swigregister
DeleteFaceFeature_swigregister(DeleteFaceFeature)

def DeleteFaceFeature_classType() -> "char const *" :
  return _fusion.DeleteFaceFeature_classType()
DeleteFaceFeature_classType = _fusion.DeleteFaceFeature_classType

DeleteFaceFeature.__swig_getmethods__["deletedFaces"] = DeleteFaceFeature._get_deletedFaces
DeleteFaceFeature.__swig_setmethods__["deletedFaces"] = DeleteFaceFeature._set_deletedFaces
DeleteFaceFeature.deletedFaces = property(DeleteFaceFeature._get_deletedFaces, DeleteFaceFeature._set_deletedFaces, doc="Gets and sets the set of faces that are deleted by this feature. To\nbe able to use this property to both get and set the faces, you need to\nfirst roll the timeline to immediately before this feature. This can be\naccomplished using the following code where thisFeature is a reference\nto a DeleteFaceFeature:\nthisFeature.timelineObject.rollTo(True)\nSetting this property can fail if Fusion 360 is unable to heal the body after\ndeleting the specified faces.")

DeleteFaceFeature.__swig_getmethods__["nativeObject"] = DeleteFaceFeature._get_nativeObject
DeleteFaceFeature.nativeObject = property(DeleteFaceFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

DeleteFaceFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DeleteFaceFeature) else None
DeleteFaceFeature.cast = lambda arg: arg if isinstance(arg, DeleteFaceFeature) else None

class DistanceAndAngleChamferTypeDefinition(ChamferTypeDefinition):
    """Provides information to create a chamfer that is defined by a distance from the edge and an angle."""
    __swig_setmethods__ = {}
    for _s in [ChamferTypeDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DistanceAndAngleChamferTypeDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ChamferTypeDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DistanceAndAngleChamferTypeDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::DistanceAndAngleChamferTypeDefinition *" : return _fusion.DistanceAndAngleChamferTypeDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.DistanceAndAngleChamferTypeDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.DistanceAndAngleChamferTypeDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.DistanceAndAngleChamferTypeDefinition_classType
    if _newclass:classType = staticmethod(_fusion.DistanceAndAngleChamferTypeDefinition_classType)
    __swig_destroy__ = _fusion.delete_DistanceAndAngleChamferTypeDefinition
    __del__ = lambda self : None;
    def _get_distance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter controlling the distance. You can edit the distance
        by editing the value of the parameter object.
        """
        return _fusion.DistanceAndAngleChamferTypeDefinition__get_distance(self)

    def _get_angle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter controlling the angle. You can edit the angle
        by editing the value of the parameter object.
        """
        return _fusion.DistanceAndAngleChamferTypeDefinition__get_angle(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >" :
        """Returns the feature that owns this chamfer type definition"""
        return _fusion.DistanceAndAngleChamferTypeDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.DistanceAndAngleChamferTypeDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.DistanceAndAngleChamferTypeDefinition__get_isValid(self)
DistanceAndAngleChamferTypeDefinition_swigregister = _fusion.DistanceAndAngleChamferTypeDefinition_swigregister
DistanceAndAngleChamferTypeDefinition_swigregister(DistanceAndAngleChamferTypeDefinition)

def DistanceAndAngleChamferTypeDefinition_classType() -> "char const *" :
  return _fusion.DistanceAndAngleChamferTypeDefinition_classType()
DistanceAndAngleChamferTypeDefinition_classType = _fusion.DistanceAndAngleChamferTypeDefinition_classType

DistanceAndAngleChamferTypeDefinition.__swig_getmethods__["distance"] = DistanceAndAngleChamferTypeDefinition._get_distance
DistanceAndAngleChamferTypeDefinition.distance = property(DistanceAndAngleChamferTypeDefinition._get_distance, doc="Returns the parameter controlling the distance. You can edit the distance\nby editing the value of the parameter object.")

DistanceAndAngleChamferTypeDefinition.__swig_getmethods__["angle"] = DistanceAndAngleChamferTypeDefinition._get_angle
DistanceAndAngleChamferTypeDefinition.angle = property(DistanceAndAngleChamferTypeDefinition._get_angle, doc="Returns the parameter controlling the angle. You can edit the angle\nby editing the value of the parameter object.")

DistanceAndAngleChamferTypeDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DistanceAndAngleChamferTypeDefinition) else None
DistanceAndAngleChamferTypeDefinition.cast = lambda arg: arg if isinstance(arg, DistanceAndAngleChamferTypeDefinition) else None

class DistanceExtentDefinition(ExtentDefinition):
    """
    Defines the inputs for a distance ExtentDefinition object. 
    This feature extent type defines the distance as well as whether the extent is symmetric
    or in only one direction. If the extent is not symmetric, a positive or negative distance 
    can be used to control the direction. 
    For a hole, the IsSymmetric property value will always be false.
    """
    __swig_setmethods__ = {}
    for _s in [ExtentDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DistanceExtentDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ExtentDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DistanceExtentDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::DistanceExtentDefinition *" : return _fusion.DistanceExtentDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.DistanceExtentDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.DistanceExtentDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.DistanceExtentDefinition_classType
    if _newclass:classType = staticmethod(_fusion.DistanceExtentDefinition_classType)
    __swig_getmethods__["create"] = lambda x: _fusion.DistanceExtentDefinition_create
    if _newclass:create = staticmethod(_fusion.DistanceExtentDefinition_create)
    __swig_destroy__ = _fusion.delete_DistanceExtentDefinition
    __del__ = lambda self : None;
    def _get_isSymmetric(self) -> "bool" :
        """
        Gets and sets if the distance extent is symmetric or not
        For a hole this property will always return false and setting it is ignored.
        """
        return _fusion.DistanceExtentDefinition__get_isSymmetric(self)

    def _set_isSymmetric(self, *args) -> "bool" :
        """
        Gets and sets if the distance extent is symmetric or not
        For a hole this property will always return false and setting it is ignored.
        """
        return _fusion.DistanceExtentDefinition__set_isSymmetric(self, *args)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter controlling the distance. You can edit the distance
        by editing the value of the parameter object.
        """
        return _fusion.DistanceExtentDefinition__get_distance(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        """
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.DistanceExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.DistanceExtentDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.DistanceExtentDefinition__get_isValid(self)
DistanceExtentDefinition_swigregister = _fusion.DistanceExtentDefinition_swigregister
DistanceExtentDefinition_swigregister(DistanceExtentDefinition)

def DistanceExtentDefinition_classType() -> "char const *" :
  return _fusion.DistanceExtentDefinition_classType()
DistanceExtentDefinition_classType = _fusion.DistanceExtentDefinition_classType

def DistanceExtentDefinition_create(*args) -> "adsk::core::Ptr< adsk::core::ValueInput > const &" :
  return _fusion.DistanceExtentDefinition_create(*args)
DistanceExtentDefinition_create = _fusion.DistanceExtentDefinition_create

DistanceExtentDefinition.__swig_getmethods__["isSymmetric"] = DistanceExtentDefinition._get_isSymmetric
DistanceExtentDefinition.__swig_setmethods__["isSymmetric"] = DistanceExtentDefinition._set_isSymmetric
DistanceExtentDefinition.isSymmetric = property(DistanceExtentDefinition._get_isSymmetric, DistanceExtentDefinition._set_isSymmetric, doc="Gets and sets if the distance extent is symmetric or not\nFor a hole this property will always return false and setting it is ignored.")

DistanceExtentDefinition.__swig_getmethods__["distance"] = DistanceExtentDefinition._get_distance
DistanceExtentDefinition.distance = property(DistanceExtentDefinition._get_distance, doc="Returns the parameter controlling the distance. You can edit the distance\nby editing the value of the parameter object.")

DistanceExtentDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DistanceExtentDefinition) else None
DistanceExtentDefinition.cast = lambda arg: arg if isinstance(arg, DistanceExtentDefinition) else None

class DraftFeature(Feature):
    """Object that represents an existing draft feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DraftFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DraftFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::DraftFeature *" : return _fusion.DraftFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.DraftFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.DraftFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.DraftFeature_classType
    if _newclass:classType = staticmethod(_fusion.DraftFeature_classType)
    __swig_destroy__ = _fusion.delete_DraftFeature
    __del__ = lambda self : None;
    def _get_inputFaces(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepFace > > >" :
        """
        Gets and sets the input faces.
        If isTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.
        """
        return _fusion.DraftFeature__get_inputFaces(self)

    def _set_inputFaces(self, *args) -> "bool" :
        """
        Gets and sets the input faces.
        If isTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.
        """
        return _fusion.DraftFeature__set_inputFaces(self, *args)

    def _get_plane(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets and sets the plane that defines the direction in which the draft is applied. This can be a planar BrepFace, or a ConstructionPlane."""
        return _fusion.DraftFeature__get_plane(self)

    def _set_plane(self, *args) -> "bool" :
        """Gets and sets the plane that defines the direction in which the draft is applied. This can be a planar BrepFace, or a ConstructionPlane."""
        return _fusion.DraftFeature__set_plane(self, *args)

    def _get_isTangentChain(self) -> "bool" :
        """
        Gets and sets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities. It defaults to true.
        """
        return _fusion.DraftFeature__get_isTangentChain(self)

    def _set_isTangentChain(self, *args) -> "bool" :
        """
        Gets and sets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities. It defaults to true.
        """
        return _fusion.DraftFeature__set_isTangentChain(self, *args)

    def _get_isDirectionFlipped(self) -> "bool" :
        """Gets and sets if the direction of the draft is flipped."""
        return _fusion.DraftFeature__get_isDirectionFlipped(self)

    def _set_isDirectionFlipped(self, *args) -> "bool" :
        """Gets and sets if the direction of the draft is flipped."""
        return _fusion.DraftFeature__set_isDirectionFlipped(self, *args)

    def _get_draftDefinition(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >" :
        """
        Gets the definition object that specifies how the draft is defined. Modifying the
        definition object will cause the draft to recompute. This can return either an
        AngleExtentDefinition or TwoSidesAngleExtentDefinition object. This property 
        returns nothing in the case where the feature is non-parametric. Use this property
        to access the parameters controlling the draft and whether the draft is symmetric or not.
        """
        return _fusion.DraftFeature__get_draftDefinition(self)

    def setSingleAngle(self, *args) -> "bool" :
        """
        Changes the definition of the feature so that a single angle is used for all drafts.
        If the isSymmetric is true then the faces are split along the parting plane and drafted
        independently using the same angle. 
        isSymmetric : Set to 'true' if the faces are to be split along the plane and drafted symmetrically. This 
        will have the side effect of setting the isSymmetric property to the same value. 
        angle : The ValueInput object that defines the angle of the draft. This can be a positive or negative
        value which will affect the direction of the draft along with the isDirectionFlipped property. 
        Returns true if successful
        """
        return _fusion.DraftFeature_setSingleAngle(self, *args)

    def setTwoAngles(self, *args) -> "bool" :
        """
        Changes the definition of the feature so that the surfaces are split along the draft plane and
        the faces on each side of the plane are drafted independently from the other side. 
        angleOne : The ValueInput object that defines the angle for the faces on the first side of the draft plane. 
        angleTwo : The ValueInput object that defines the angle for the faces on the second side of the draft plane. 
        Returns true if successful
        """
        return _fusion.DraftFeature_setTwoAngles(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::DraftFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.DraftFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::DraftFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.DraftFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.DraftFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.DraftFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.DraftFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.DraftFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.DraftFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.DraftFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.DraftFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.DraftFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.DraftFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.DraftFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.DraftFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.DraftFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.DraftFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.DraftFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.DraftFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.DraftFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.DraftFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.DraftFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.DraftFeature__get_isValid(self)
DraftFeature_swigregister = _fusion.DraftFeature_swigregister
DraftFeature_swigregister(DraftFeature)

def DraftFeature_classType() -> "char const *" :
  return _fusion.DraftFeature_classType()
DraftFeature_classType = _fusion.DraftFeature_classType

DraftFeature.__swig_getmethods__["inputFaces"] = DraftFeature._get_inputFaces
DraftFeature.__swig_setmethods__["inputFaces"] = DraftFeature._set_inputFaces
DraftFeature.inputFaces = property(DraftFeature._get_inputFaces, DraftFeature._set_inputFaces, doc="Gets and sets the input faces.\nIf isTangentChain is true, all the faces that are tangentially connected to the input faces (if any) will also be included.")

DraftFeature.__swig_getmethods__["plane"] = DraftFeature._get_plane
DraftFeature.__swig_setmethods__["plane"] = DraftFeature._set_plane
DraftFeature.plane = property(DraftFeature._get_plane, DraftFeature._set_plane, doc="Gets and sets the plane that defines the direction in which the draft is applied. This can be a planar BrepFace, or a ConstructionPlane.")

DraftFeature.__swig_getmethods__["isTangentChain"] = DraftFeature._get_isTangentChain
DraftFeature.__swig_setmethods__["isTangentChain"] = DraftFeature._set_isTangentChain
DraftFeature.isTangentChain = property(DraftFeature._get_isTangentChain, DraftFeature._set_isTangentChain, doc="Gets and sets if any faces that are tangentially connected to any of\nthe input faces will also be included in setting InputEntities. It defaults to true.")

DraftFeature.__swig_getmethods__["isDirectionFlipped"] = DraftFeature._get_isDirectionFlipped
DraftFeature.__swig_setmethods__["isDirectionFlipped"] = DraftFeature._set_isDirectionFlipped
DraftFeature.isDirectionFlipped = property(DraftFeature._get_isDirectionFlipped, DraftFeature._set_isDirectionFlipped, doc="Gets and sets if the direction of the draft is flipped.")

DraftFeature.__swig_getmethods__["draftDefinition"] = DraftFeature._get_draftDefinition
DraftFeature.draftDefinition = property(DraftFeature._get_draftDefinition, doc="Gets the definition object that specifies how the draft is defined. Modifying the\ndefinition object will cause the draft to recompute. This can return either an\nAngleExtentDefinition or TwoSidesAngleExtentDefinition object. This property\nreturns nothing in the case where the feature is non-parametric. Use this property\nto access the parameters controlling the draft and whether the draft is symmetric or not.")

DraftFeature.__swig_getmethods__["nativeObject"] = DraftFeature._get_nativeObject
DraftFeature.nativeObject = property(DraftFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

DraftFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, DraftFeature) else None
DraftFeature.cast = lambda arg: arg if isinstance(arg, DraftFeature) else None

class EqualConstraint(GeometricConstraint):
    """An equal constraint in a sketch."""
    __swig_setmethods__ = {}
    for _s in [GeometricConstraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EqualConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricConstraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EqualConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::EqualConstraint *" : return _fusion.EqualConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.EqualConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.EqualConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.EqualConstraint_classType
    if _newclass:classType = staticmethod(_fusion.EqualConstraint_classType)
    __swig_destroy__ = _fusion.delete_EqualConstraint
    __del__ = lambda self : None;
    def _get_curveOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >" :
        """Returns the first curve."""
        return _fusion.EqualConstraint__get_curveOne(self)

    def _get_curveTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >" :
        """Returns the second curve."""
        return _fusion.EqualConstraint__get_curveTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::EqualConstraint >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.EqualConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::EqualConstraint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.EqualConstraint_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.EqualConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.EqualConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.EqualConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.EqualConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.EqualConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.EqualConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.EqualConstraint__get_isValid(self)
EqualConstraint_swigregister = _fusion.EqualConstraint_swigregister
EqualConstraint_swigregister(EqualConstraint)

def EqualConstraint_classType() -> "char const *" :
  return _fusion.EqualConstraint_classType()
EqualConstraint_classType = _fusion.EqualConstraint_classType

EqualConstraint.__swig_getmethods__["curveOne"] = EqualConstraint._get_curveOne
EqualConstraint.curveOne = property(EqualConstraint._get_curveOne, doc="Returns the first curve.")

EqualConstraint.__swig_getmethods__["curveTwo"] = EqualConstraint._get_curveTwo
EqualConstraint.curveTwo = property(EqualConstraint._get_curveTwo, doc="Returns the second curve.")

EqualConstraint.__swig_getmethods__["nativeObject"] = EqualConstraint._get_nativeObject
EqualConstraint.nativeObject = property(EqualConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

EqualConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, EqualConstraint) else None
EqualConstraint.cast = lambda arg: arg if isinstance(arg, EqualConstraint) else None

class EqualDistanceChamferTypeDefinition(ChamferTypeDefinition):
    """Provides information to create a chamfer that is defined by a single distance and has an equal offset from the edge."""
    __swig_setmethods__ = {}
    for _s in [ChamferTypeDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EqualDistanceChamferTypeDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ChamferTypeDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EqualDistanceChamferTypeDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::EqualDistanceChamferTypeDefinition *" : return _fusion.EqualDistanceChamferTypeDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.EqualDistanceChamferTypeDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.EqualDistanceChamferTypeDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.EqualDistanceChamferTypeDefinition_classType
    if _newclass:classType = staticmethod(_fusion.EqualDistanceChamferTypeDefinition_classType)
    __swig_destroy__ = _fusion.delete_EqualDistanceChamferTypeDefinition
    __del__ = lambda self : None;
    def _get_distance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter controlling the distance. You can edit the distance
        by editing the value of the parameter object.
        """
        return _fusion.EqualDistanceChamferTypeDefinition__get_distance(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >" :
        """Returns the feature that owns this chamfer type definition"""
        return _fusion.EqualDistanceChamferTypeDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.EqualDistanceChamferTypeDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.EqualDistanceChamferTypeDefinition__get_isValid(self)
EqualDistanceChamferTypeDefinition_swigregister = _fusion.EqualDistanceChamferTypeDefinition_swigregister
EqualDistanceChamferTypeDefinition_swigregister(EqualDistanceChamferTypeDefinition)

def EqualDistanceChamferTypeDefinition_classType() -> "char const *" :
  return _fusion.EqualDistanceChamferTypeDefinition_classType()
EqualDistanceChamferTypeDefinition_classType = _fusion.EqualDistanceChamferTypeDefinition_classType

EqualDistanceChamferTypeDefinition.__swig_getmethods__["distance"] = EqualDistanceChamferTypeDefinition._get_distance
EqualDistanceChamferTypeDefinition.distance = property(EqualDistanceChamferTypeDefinition._get_distance, doc="Returns the parameter controlling the distance. You can edit the distance\nby editing the value of the parameter object.")

EqualDistanceChamferTypeDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, EqualDistanceChamferTypeDefinition) else None
EqualDistanceChamferTypeDefinition.cast = lambda arg: arg if isinstance(arg, EqualDistanceChamferTypeDefinition) else None

class ExtendFeature(Feature):
    """Object that represents an existing extend feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExtendFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExtendFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ExtendFeature *" : return _fusion.ExtendFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ExtendFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ExtendFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ExtendFeature_classType
    if _newclass:classType = staticmethod(_fusion.ExtendFeature_classType)
    __swig_destroy__ = _fusion.delete_ExtendFeature
    __del__ = lambda self : None;
    def setInputEntities(self, *args) -> "bool" :
        """
        Sets the edges for the extend feature 
        edges : The surface edges to extend.
        Only the surface edges from an open body can be extended.
        The edges must all be from the same open body. 
        isChainingEnabled : An optional boolean argument whose default is true. If this argument is set to true, all edges that are 
        tangent or curvature continuous, and end point connected, will be found automatically and extended. 
        Returns true if successful
        """
        return _fusion.ExtendFeature_setInputEntities(self, *args)

    def _get_edges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets the edges that were extended. In many cases the extend operation results in 
        the edges being consumed so they're no longer available after the feature is created.
        in this case you need to reposition the timeline marker to just before this feature
        when the edges do exist.
        """
        return _fusion.ExtendFeature__get_edges(self)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter controlling the extend distance. You can edit the distance
        by editing the value of the parameter object.
        """
        return _fusion.ExtendFeature__get_distance(self)

    def _get_extendType(self) -> "adsk::fusion::SurfaceExtendTypes" :
        """Gets and sets surface extend type to use"""
        return _fusion.ExtendFeature__get_extendType(self)

    def _set_extendType(self, *args) -> "bool" :
        """Gets and sets surface extend type to use"""
        return _fusion.ExtendFeature__set_extendType(self, *args)

    def _get_isChainingEnabled(self) -> "bool" :
        """
        Gets if all edges that are tangent or curvature continuous, and end point connected, will be found 
        automatically and extended.
        """
        return _fusion.ExtendFeature__get_isChainingEnabled(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ExtendFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ExtendFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::ExtendFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.ExtendFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ExtendFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ExtendFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ExtendFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.ExtendFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ExtendFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ExtendFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.ExtendFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.ExtendFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.ExtendFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.ExtendFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ExtendFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.ExtendFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.ExtendFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.ExtendFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ExtendFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.ExtendFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ExtendFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ExtendFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ExtendFeature__get_isValid(self)
ExtendFeature_swigregister = _fusion.ExtendFeature_swigregister
ExtendFeature_swigregister(ExtendFeature)

def ExtendFeature_classType() -> "char const *" :
  return _fusion.ExtendFeature_classType()
ExtendFeature_classType = _fusion.ExtendFeature_classType

ExtendFeature.__swig_getmethods__["edges"] = ExtendFeature._get_edges
ExtendFeature.edges = property(ExtendFeature._get_edges, doc="Gets the edges that were extended. In many cases the extend operation results in\nthe edges being consumed so they're no longer available after the feature is created.\nin this case you need to reposition the timeline marker to just before this feature\nwhen the edges do exist.")

ExtendFeature.__swig_getmethods__["distance"] = ExtendFeature._get_distance
ExtendFeature.distance = property(ExtendFeature._get_distance, doc="Returns the parameter controlling the extend distance. You can edit the distance\nby editing the value of the parameter object.")

ExtendFeature.__swig_getmethods__["extendType"] = ExtendFeature._get_extendType
ExtendFeature.__swig_setmethods__["extendType"] = ExtendFeature._set_extendType
ExtendFeature.extendType = property(ExtendFeature._get_extendType, ExtendFeature._set_extendType, doc="Gets and sets surface extend type to use")

ExtendFeature.__swig_getmethods__["isChainingEnabled"] = ExtendFeature._get_isChainingEnabled
ExtendFeature.isChainingEnabled = property(ExtendFeature._get_isChainingEnabled, doc="Gets if all edges that are tangent or curvature continuous, and end point connected, will be found\nautomatically and extended.")

ExtendFeature.__swig_getmethods__["nativeObject"] = ExtendFeature._get_nativeObject
ExtendFeature.nativeObject = property(ExtendFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

ExtendFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ExtendFeature) else None
ExtendFeature.cast = lambda arg: arg if isinstance(arg, ExtendFeature) else None

class ExtrudeFeature(Feature):
    """Object that represents an existing extrude feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExtrudeFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExtrudeFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ExtrudeFeature *" : return _fusion.ExtrudeFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ExtrudeFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ExtrudeFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ExtrudeFeature_classType
    if _newclass:classType = staticmethod(_fusion.ExtrudeFeature_classType)
    __swig_destroy__ = _fusion.delete_ExtrudeFeature
    __del__ = lambda self : None;
    def _get_profile(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the profiles or planar faces used to define the shape of the extrude.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        When setting this property of a surface (non-solid) extrusion, you can use the 
        createOpenProfile and createBRepEdgeProfile methods of the Component object to create
        an open profile.
        This property returns null in the case where the feature is non-parametric.
        """
        return _fusion.ExtrudeFeature__get_profile(self)

    def _set_profile(self, *args) -> "bool" :
        """
        Gets and sets the profiles or planar faces used to define the shape of the extrude.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        When setting this property of a surface (non-solid) extrusion, you can use the 
        createOpenProfile and createBRepEdgeProfile methods of the Component object to create
        an open profile.
        This property returns null in the case where the feature is non-parametric.
        """
        return _fusion.ExtrudeFeature__set_profile(self, *args)

    def _get_taperAngle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter controlling the taper angle of the extrusion. To 
        edit the taper angle use properties on the parameter to edit its value.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ExtrudeFeature__get_taperAngle(self)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """Gets and sets the type of operation performed by the extrusion."""
        return _fusion.ExtrudeFeature__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """Gets and sets the type of operation performed by the extrusion."""
        return _fusion.ExtrudeFeature__set_operation(self, *args)

    def _get_extentDefinition(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >" :
        """
        Gets the ExtentDefinition object that defines the extent of the extrude. Modifying the
        properties of the returned extent definition object will cause the extrude to recompute. 
        Various types of objects can be returned depending on the type of extent currently defined for 
        the extrusion. This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ExtrudeFeature__get_extentDefinition(self)

    def setDistanceExtent(self, *args) -> "bool" :
        """
        Sets the extrusion extents option to 'Distance'. 
        isSymmetric : Set to 'true' for an extrusion symmetrical about the profile plane 
        distance : ValueInput object that defines the extrude distance.
        If the isSymmetric argument is 'false', a positive or negative distance can be used to control the direction. 
        Returns true if successful
        """
        return _fusion.ExtrudeFeature_setDistanceExtent(self, *args)

    def setTwoSidesDistanceExtent(self, *args) -> "bool" :
        """
        Sets the extrusion extents option to 'Two Side'.
        This method will fail in the case of a non-parametric extrusion. 
        distanceOne : ValueInput object that defines the extrude distance for the first side. 
        distanceTwo : ValueInput object that defines the extrude distance for the second side. 
        Returns true if successful
        """
        return _fusion.ExtrudeFeature_setTwoSidesDistanceExtent(self, *args)

    def setAllExtent(self, *args) -> "bool" :
        """
        Sets the extrusion extents option to 'All' (i.e. the extrusion is through-all, in both directions.)
        This method will fail in the case of a non-parametric extrusion. 
        direction : The direction can be either positive, negative, or symmetric. 
        Returns true if successful
        """
        return _fusion.ExtrudeFeature_setAllExtent(self, *args)

    def setOneSideToExtent(self, *args) -> "bool" :
        """
        Sets the extrusion Direction option to 'One Side' and the Extents option to 'To' (a specified face) 
        toEntity : The entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For an extrude it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        matchShape : If the matchShape argument is 'true', the toEntity is extended to fully intersect the extrusion. 
        directionHint : Specifies the direction of the extrusion. This is only used in the case where there are two possible solutions and the extrusion can
        hit the toEntity in either direction. An example is if the profile of the extrusion is within a hole.
        The extrusion will intersect the cylinder of the hole in either direction.
        Typically there is only a single solution and the direction is determined automatically. 
        Returns true if successful.
        """
        return _fusion.ExtrudeFeature_setOneSideToExtent(self, *args)

    def setTwoSidesToExtent(self, *args) -> "bool" :
        """
        Set the extrusion Direction option to 'Two Side'
        This method will fail in the case of a non-parametric extrusion. 
        toEntityOne : The first entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For an extrude it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        toEntityTwo : The second entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For an extrude it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        matchShape : If the matchShape argument is 'true', the toEntity is extended to fully intersect the extrusion. 
        Returns true if successful.
        """
        return _fusion.ExtrudeFeature_setTwoSidesToExtent(self, *args)

    def _get_startFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Property that returns the set of faces that cap the end of the extrusion and are coincident 
        with the sketch plane. In the case of a symmetric extrusion, these faces are the ones on the 
        positive normal side of the sketch plane. In the case where there are no start faces,
        this property will return null.
        """
        return _fusion.ExtrudeFeature__get_startFaces(self)

    def _get_endFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Property that returns the set of faces that cap the end of the extrusion, opposite the
        start faces. In the case where there are no end faces, this property will return null.
        """
        return _fusion.ExtrudeFeature__get_endFaces(self)

    def _get_sideFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Property that returns all of the side faces (i.e. those running perpendicular to the extrude direction) 
        of the feature.
        """
        return _fusion.ExtrudeFeature__get_sideFaces(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ExtrudeFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ExtrudeFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::ExtrudeFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ExtrudeFeature_createForAssemblyContext(self, *args)

    def _get_isSolid(self) -> "bool" :
        """Indicates if this feature was initially created as a solid or a surface."""
        return _fusion.ExtrudeFeature__get_isSolid(self)

    def _get_startExtent(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >" :
        """
        Gets and sets the extent used to define the start of the extrusion. You can set this property
        with either a ProfilePlaneStartDefinition, ProfilePlaneWithOffsetStartDefinition or a 
        EntityStartDefinition object. You can get any of those objects by using the static create method on the class.
        """
        return _fusion.ExtrudeFeature__get_startExtent(self)

    def _set_startExtent(self, *args) -> "bool" :
        """
        Gets and sets the extent used to define the start of the extrusion. You can set this property
        with either a ProfilePlaneStartDefinition, ProfilePlaneWithOffsetStartDefinition or a 
        EntityStartDefinition object. You can get any of those objects by using the static create method on the class.
        """
        return _fusion.ExtrudeFeature__set_startExtent(self, *args)

    def setOneSideExtent(self, *args) -> "bool" :
        """
        Redefines the extrusion to go in one direction from the profile. The extent of the extrusion is 
        defined by the extent argument. 
        extent : An ExtentDefinition object that defines how the extent of the extrusion is defined. This can be
        a specified distance (DistanceExtentDefinition), to an entity (ToEntityExtent), or through-all (AllExtentDefinition).
        These objects can be obtained by using the static create method on the appropriate class. 
        direction : Specifies the direction of the extrusion. PositiveExtentDirection and NegativeExtentDirection
        are valid values. PositiveExtentDirection is in the same direction as the normal of the profile's
        parent sketch plane. 
        taperAngle : Optional argument that specifies the taper angle. If omitted a taper angle of 0 is used. 
        Returns true is setting the input to a one sided extent was successful.
        """
        return _fusion.ExtrudeFeature_setOneSideExtent(self, *args)

    def setTwoSidesExtent(self, *args) -> "bool" :
        """
        Redefines the extrusion to go in both directions from the profile. The extent is defined independently
        for each direction using the input arguments. 
        sideOneExtent : An ExtentDefinition object that defines how the extent of the extrusion towards side one is defined. This can be
        a specified distance (DistanceExtentDefinition), to an entity (ToEntityExtent), or through-all (AllExtentDefinition).
        These objects can be obtained by using the static create method on the appropriate class. 
        sideTwoExtent : An ExtentDefinition object that defines how the extent of the extrusion towards side two is defined. This can be
        a specified distance (DistanceExtentDefinition), to an entity (ToEntityExtent), or through-all (AllExtentDefinition).
        These objects can be obtained by using the static create method on the appropriate class. 
        sideOneTaperAngle : Optional argument that specifies the taper angle for side one. If omitted a taper angle of 0 is used. 
        sideTwoTaperAngle : Optional argument that specifies the taper angle for side two. If omitted a taper angle of 0 is used. 
        Returns true, if the call was successful.
        """
        return _fusion.ExtrudeFeature_setTwoSidesExtent(self, *args)

    def setSymmetricExtent(self, *args) -> "bool" :
        """
        Redefines the extrusion to go symmetrically in both directions from the profile. 
        distance : The distance of the extrusions. This is either the full length of half of the length of the final extrusion
        depending on the value of the isFullLength property. 
        isFullLength : Defines if the value defines the full length of the extrusion or half of the length. A value of true indicates
        it defines the full length. 
        taperAngle : Optional argument that specifies the taper angle. The same taper angle is used for both sides for a symmetric 
        extrusion. If omitted a taper angle of 0 is used. 
        Returns true, if the call was successful.
        """
        return _fusion.ExtrudeFeature_setSymmetricExtent(self, *args)

    def _get_extentOne(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >" :
        """
        Gets and sets the extent used for a single sided extrude or side one of a two-sided extrusion. Valid 
        inputs are DistanceExtentDefinition, ToEntityExtentDefinition, and ThroughAllExtentDefinition object, 
        which can be created statically using the create method on the classes.
        """
        return _fusion.ExtrudeFeature__get_extentOne(self)

    def _set_extentOne(self, *args) -> "bool" :
        """
        Gets and sets the extent used for a single sided extrude or side one of a two-sided extrusion. Valid 
        inputs are DistanceExtentDefinition, ToEntityExtentDefinition, and ThroughAllExtentDefinition object, 
        which can be created statically using the create method on the classes.
        """
        return _fusion.ExtrudeFeature__set_extentOne(self, *args)

    def _get_extentTwo(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >" :
        """
        Gets and sets the extent used for side two of the extrusion. If the extrude is a single sided extrude this
        property will return null and will fail if set. The hasTwoExtents property can be used to determine if
        there are two sides or not. When setting this property, valid inputs are DistanceExtentDefinition,
        ToEntityExtentDefinition, and ThroughAllExtentDefinition object, which can be created 
        statically using the create method on the classes.
        """
        return _fusion.ExtrudeFeature__get_extentTwo(self)

    def _set_extentTwo(self, *args) -> "bool" :
        """
        Gets and sets the extent used for side two of the extrusion. If the extrude is a single sided extrude this
        property will return null and will fail if set. The hasTwoExtents property can be used to determine if
        there are two sides or not. When setting this property, valid inputs are DistanceExtentDefinition,
        ToEntityExtentDefinition, and ThroughAllExtentDefinition object, which can be created 
        statically using the create method on the classes.
        """
        return _fusion.ExtrudeFeature__set_extentTwo(self, *args)

    def _get_taperAngleOne(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the parameter controlling the taper angle for a single sided extrusion or side one of a two-sided
        extrusion. To edit the angle, use properties on the parameter to change the value of the parameter.
        """
        return _fusion.ExtrudeFeature__get_taperAngleOne(self)

    def _get_taperAngleTwo(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the parameter controlling the taper angle for side two of a two-sided extrusion. if the extrusion is 
        single-sided, this property will return null. The hasTwoExtents property can be used to determine if there
        are two sides or not. To edit the angle, use properties on the parameter to change the value of the parameter.
        """
        return _fusion.ExtrudeFeature__get_taperAngleTwo(self)

    def _get_hasTwoExtents(self) -> "bool" :
        """
        Property that indicates if the extrusion is a single or two-sided extrusion. If false, the extentTwo
        and taperAngleTwo properties should not be used.
        """
        return _fusion.ExtrudeFeature__get_hasTwoExtents(self)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >" :
        """
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        When setting or getting this property, you must roll the timeline back to just before the feature 
        so that the model is in the state just before the feature is computed.
        """
        return _fusion.ExtrudeFeature__get_participantBodies(self)

    def _set_participantBodies(self, *args) -> "bool" :
        """
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        When setting or getting this property, you must roll the timeline back to just before the feature 
        so that the model is in the state just before the feature is computed.
        """
        return _fusion.ExtrudeFeature__set_participantBodies(self, *args)

    def _get_extentType(self) -> "adsk::fusion::FeatureExtentTypes" :
        """Returns a value indicating how the extent is defined for this extrude."""
        return _fusion.ExtrudeFeature__get_extentType(self)

    def _get_symmetricExtent(self) -> "adsk::core::Ptr< adsk::fusion::SymmetricExtentDefinition >" :
        """
        If the current extent of the feautre is defined as a symmetric extent, this property
        returns the SymmericExtentDefinition object that provides access to the information
        defining the symmetric extent. If the current extent is not symmetric, this property
        returns null. You can determine the type of extent by using the extentType property.
        To change the extent of a feature to symmetric extent you can use the setSymmetricExtent
        method.
        """
        return _fusion.ExtrudeFeature__get_symmetricExtent(self)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ExtrudeFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ExtrudeFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ExtrudeFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.ExtrudeFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ExtrudeFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ExtrudeFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.ExtrudeFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.ExtrudeFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.ExtrudeFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.ExtrudeFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ExtrudeFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.ExtrudeFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.ExtrudeFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.ExtrudeFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ExtrudeFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.ExtrudeFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ExtrudeFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ExtrudeFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ExtrudeFeature__get_isValid(self)
ExtrudeFeature_swigregister = _fusion.ExtrudeFeature_swigregister
ExtrudeFeature_swigregister(ExtrudeFeature)

def ExtrudeFeature_classType() -> "char const *" :
  return _fusion.ExtrudeFeature_classType()
ExtrudeFeature_classType = _fusion.ExtrudeFeature_classType

ExtrudeFeature.__swig_getmethods__["profile"] = ExtrudeFeature._get_profile
ExtrudeFeature.__swig_setmethods__["profile"] = ExtrudeFeature._set_profile
ExtrudeFeature.profile = property(ExtrudeFeature._get_profile, ExtrudeFeature._set_profile, doc="Gets and sets the profiles or planar faces used to define the shape of the extrude.\nThis property can return or be set with a single Profile, a single planar face, or\nan ObjectCollection consisting of multiple profiles and planar faces. When an\nObjectCollection is used all of the profiles and faces must be co-planar.\nWhen setting this property of a surface (non-solid) extrusion, you can use the\ncreateOpenProfile and createBRepEdgeProfile methods of the Component object to create\nan open profile.\nThis property returns null in the case where the feature is non-parametric.")

ExtrudeFeature.__swig_getmethods__["taperAngle"] = ExtrudeFeature._get_taperAngle
ExtrudeFeature.taperAngle = property(ExtrudeFeature._get_taperAngle, doc="Returns the parameter controlling the taper angle of the extrusion. To\nedit the taper angle use properties on the parameter to edit its value.\nThis property returns nothing in the case where the feature is non-parametric.")

ExtrudeFeature.__swig_getmethods__["operation"] = ExtrudeFeature._get_operation
ExtrudeFeature.__swig_setmethods__["operation"] = ExtrudeFeature._set_operation
ExtrudeFeature.operation = property(ExtrudeFeature._get_operation, ExtrudeFeature._set_operation, doc="Gets and sets the type of operation performed by the extrusion.")

ExtrudeFeature.__swig_getmethods__["extentDefinition"] = ExtrudeFeature._get_extentDefinition
ExtrudeFeature.extentDefinition = property(ExtrudeFeature._get_extentDefinition, doc="Gets the ExtentDefinition object that defines the extent of the extrude. Modifying the\nproperties of the returned extent definition object will cause the extrude to recompute.\nVarious types of objects can be returned depending on the type of extent currently defined for\nthe extrusion. This property returns nothing in the case where the feature is non-parametric.")

ExtrudeFeature.__swig_getmethods__["startFaces"] = ExtrudeFeature._get_startFaces
ExtrudeFeature.startFaces = property(ExtrudeFeature._get_startFaces, doc="Property that returns the set of faces that cap the end of the extrusion and are coincident\nwith the sketch plane. In the case of a symmetric extrusion, these faces are the ones on the\npositive normal side of the sketch plane. In the case where there are no start faces,\nthis property will return null.")

ExtrudeFeature.__swig_getmethods__["endFaces"] = ExtrudeFeature._get_endFaces
ExtrudeFeature.endFaces = property(ExtrudeFeature._get_endFaces, doc="Property that returns the set of faces that cap the end of the extrusion, opposite the\nstart faces. In the case where there are no end faces, this property will return null.")

ExtrudeFeature.__swig_getmethods__["sideFaces"] = ExtrudeFeature._get_sideFaces
ExtrudeFeature.sideFaces = property(ExtrudeFeature._get_sideFaces, doc="Property that returns all of the side faces (i.e. those running perpendicular to the extrude direction)\nof the feature.")

ExtrudeFeature.__swig_getmethods__["nativeObject"] = ExtrudeFeature._get_nativeObject
ExtrudeFeature.nativeObject = property(ExtrudeFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

ExtrudeFeature.__swig_getmethods__["isSolid"] = ExtrudeFeature._get_isSolid
ExtrudeFeature.isSolid = property(ExtrudeFeature._get_isSolid, doc="Indicates if this feature was initially created as a solid or a surface.")

ExtrudeFeature.__swig_getmethods__["startExtent"] = ExtrudeFeature._get_startExtent
ExtrudeFeature.__swig_setmethods__["startExtent"] = ExtrudeFeature._set_startExtent
ExtrudeFeature.startExtent = property(ExtrudeFeature._get_startExtent, ExtrudeFeature._set_startExtent, doc="Gets and sets the extent used to define the start of the extrusion. You can set this property\nwith either a ProfilePlaneStartDefinition, ProfilePlaneWithOffsetStartDefinition or a\nEntityStartDefinition object. You can get any of those objects by using the static create method on the class.")

ExtrudeFeature.__swig_getmethods__["extentOne"] = ExtrudeFeature._get_extentOne
ExtrudeFeature.__swig_setmethods__["extentOne"] = ExtrudeFeature._set_extentOne
ExtrudeFeature.extentOne = property(ExtrudeFeature._get_extentOne, ExtrudeFeature._set_extentOne, doc="Gets and sets the extent used for a single sided extrude or side one of a two-sided extrusion. Valid\ninputs are DistanceExtentDefinition, ToEntityExtentDefinition, and ThroughAllExtentDefinition object,\nwhich can be created statically using the create method on the classes.")

ExtrudeFeature.__swig_getmethods__["extentTwo"] = ExtrudeFeature._get_extentTwo
ExtrudeFeature.__swig_setmethods__["extentTwo"] = ExtrudeFeature._set_extentTwo
ExtrudeFeature.extentTwo = property(ExtrudeFeature._get_extentTwo, ExtrudeFeature._set_extentTwo, doc="Gets and sets the extent used for side two of the extrusion. If the extrude is a single sided extrude this\nproperty will return null and will fail if set. The hasTwoExtents property can be used to determine if\nthere are two sides or not. When setting this property, valid inputs are DistanceExtentDefinition,\nToEntityExtentDefinition, and ThroughAllExtentDefinition object, which can be created\nstatically using the create method on the classes.")

ExtrudeFeature.__swig_getmethods__["taperAngleOne"] = ExtrudeFeature._get_taperAngleOne
ExtrudeFeature.taperAngleOne = property(ExtrudeFeature._get_taperAngleOne, doc="Gets the parameter controlling the taper angle for a single sided extrusion or side one of a two-sided\nextrusion. To edit the angle, use properties on the parameter to change the value of the parameter.")

ExtrudeFeature.__swig_getmethods__["taperAngleTwo"] = ExtrudeFeature._get_taperAngleTwo
ExtrudeFeature.taperAngleTwo = property(ExtrudeFeature._get_taperAngleTwo, doc="Gets the parameter controlling the taper angle for side two of a two-sided extrusion. if the extrusion is\nsingle-sided, this property will return null. The hasTwoExtents property can be used to determine if there\nare two sides or not. To edit the angle, use properties on the parameter to change the value of the parameter.")

ExtrudeFeature.__swig_getmethods__["hasTwoExtents"] = ExtrudeFeature._get_hasTwoExtents
ExtrudeFeature.hasTwoExtents = property(ExtrudeFeature._get_hasTwoExtents, doc="Property that indicates if the extrusion is a single or two-sided extrusion. If false, the extentTwo\nand taperAngleTwo properties should not be used.")

ExtrudeFeature.__swig_getmethods__["participantBodies"] = ExtrudeFeature._get_participantBodies
ExtrudeFeature.__swig_setmethods__["participantBodies"] = ExtrudeFeature._set_participantBodies
ExtrudeFeature.participantBodies = property(ExtrudeFeature._get_participantBodies, ExtrudeFeature._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.\nWhen setting or getting this property, you must roll the timeline back to just before the feature\nso that the model is in the state just before the feature is computed.")

ExtrudeFeature.__swig_getmethods__["extentType"] = ExtrudeFeature._get_extentType
ExtrudeFeature.extentType = property(ExtrudeFeature._get_extentType, doc="Returns a value indicating how the extent is defined for this extrude.")

ExtrudeFeature.__swig_getmethods__["symmetricExtent"] = ExtrudeFeature._get_symmetricExtent
ExtrudeFeature.symmetricExtent = property(ExtrudeFeature._get_symmetricExtent, doc="If the current extent of the feautre is defined as a symmetric extent, this property\nreturns the SymmericExtentDefinition object that provides access to the information\ndefining the symmetric extent. If the current extent is not symmetric, this property\nreturns null. You can determine the type of extent by using the extentType property.\nTo change the extent of a feature to symmetric extent you can use the setSymmetricExtent\nmethod.")

ExtrudeFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ExtrudeFeature) else None
ExtrudeFeature.cast = lambda arg: arg if isinstance(arg, ExtrudeFeature) else None

class FilletFeature(Feature):
    """Object that represents an existing fillet feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FilletFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FilletFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::FilletFeature *" : return _fusion.FilletFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.FilletFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.FilletFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.FilletFeature_classType
    if _newclass:classType = staticmethod(_fusion.FilletFeature_classType)
    __swig_destroy__ = _fusion.delete_FilletFeature
    __del__ = lambda self : None;
    def _get_edgeSets(self) -> "adsk::core::Ptr< adsk::fusion::FilletEdgeSets >" :
        """Returns the edge sets associated with this fillet."""
        return _fusion.FilletFeature__get_edgeSets(self)

    def _get_isG2(self) -> "bool" :
        """Gets and sets if the fillet uses the G2 (curvature-continuity) surface quality option ."""
        return _fusion.FilletFeature__get_isG2(self)

    def _set_isG2(self, *args) -> "bool" :
        """Gets and sets if the fillet uses the G2 (curvature-continuity) surface quality option ."""
        return _fusion.FilletFeature__set_isG2(self, *args)

    def _get_isRollingBallCorner(self) -> "bool" :
        """Gets and sets if a rolling ball solution is to be used in any corners."""
        return _fusion.FilletFeature__get_isRollingBallCorner(self)

    def _set_isRollingBallCorner(self, *args) -> "bool" :
        """Gets and sets if a rolling ball solution is to be used in any corners."""
        return _fusion.FilletFeature__set_isRollingBallCorner(self, *args)

    def _get_isTangentChain(self) -> "bool" :
        """
        Gets and sets whether or not edges that are tangentially connected to 
        the input edges (if any) will also be filleted.
        """
        return _fusion.FilletFeature__get_isTangentChain(self)

    def _set_isTangentChain(self, *args) -> "bool" :
        """
        Gets and sets whether or not edges that are tangentially connected to 
        the input edges (if any) will also be filleted.
        """
        return _fusion.FilletFeature__set_isTangentChain(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::FilletFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of its parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.FilletFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::FilletFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.FilletFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.FilletFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.FilletFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.FilletFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.FilletFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.FilletFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.FilletFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.FilletFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.FilletFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.FilletFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.FilletFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.FilletFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.FilletFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.FilletFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.FilletFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.FilletFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.FilletFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.FilletFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.FilletFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.FilletFeature__get_isValid(self)
FilletFeature_swigregister = _fusion.FilletFeature_swigregister
FilletFeature_swigregister(FilletFeature)

def FilletFeature_classType() -> "char const *" :
  return _fusion.FilletFeature_classType()
FilletFeature_classType = _fusion.FilletFeature_classType

FilletFeature.__swig_getmethods__["edgeSets"] = FilletFeature._get_edgeSets
FilletFeature.edgeSets = property(FilletFeature._get_edgeSets, doc="Returns the edge sets associated with this fillet.")

FilletFeature.__swig_getmethods__["isG2"] = FilletFeature._get_isG2
FilletFeature.__swig_setmethods__["isG2"] = FilletFeature._set_isG2
FilletFeature.isG2 = property(FilletFeature._get_isG2, FilletFeature._set_isG2, doc="Gets and sets if the fillet uses the G2 (curvature-continuity) surface quality option .")

FilletFeature.__swig_getmethods__["isRollingBallCorner"] = FilletFeature._get_isRollingBallCorner
FilletFeature.__swig_setmethods__["isRollingBallCorner"] = FilletFeature._set_isRollingBallCorner
FilletFeature.isRollingBallCorner = property(FilletFeature._get_isRollingBallCorner, FilletFeature._set_isRollingBallCorner, doc="Gets and sets if a rolling ball solution is to be used in any corners.")

FilletFeature.__swig_getmethods__["isTangentChain"] = FilletFeature._get_isTangentChain
FilletFeature.__swig_setmethods__["isTangentChain"] = FilletFeature._set_isTangentChain
FilletFeature.isTangentChain = property(FilletFeature._get_isTangentChain, FilletFeature._set_isTangentChain, doc="Gets and sets whether or not edges that are tangentially connected to\nthe input edges (if any) will also be filleted.")

FilletFeature.__swig_getmethods__["nativeObject"] = FilletFeature._get_nativeObject
FilletFeature.nativeObject = property(FilletFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of its parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

FilletFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FilletFeature) else None
FilletFeature.cast = lambda arg: arg if isinstance(arg, FilletFeature) else None

class FormFeature(Feature):
    """Object that represents an existing Form feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::FormFeature *" : return _fusion.FormFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.FormFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.FormFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.FormFeature_classType
    if _newclass:classType = staticmethod(_fusion.FormFeature_classType)
    __swig_destroy__ = _fusion.delete_FormFeature
    __del__ = lambda self : None;
    def _get_tSplineBodies(self) -> "adsk::core::Ptr< adsk::fusion::TSplineBodies >" :
        """
        Returns a TSplineBodies collection where you can access any existing 
        T-Spline bodies and through it create new T-Spline bodies.
        """
        return _fusion.FormFeature__get_tSplineBodies(self)

    def startEdit(self) -> "bool" :
        """
        Set the user-interface so that the form body is in edit mode. 
        Returns true if successful.
        """
        return _fusion.FormFeature_startEdit(self)

    def finishEdit(self) -> "bool" :
        """
        Exits from edit mode in the user-interface. If this form feature in not
        in edit mode, then nothing happens. 
        Returns true if successful.
        """
        return _fusion.FormFeature_finishEdit(self)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.FormFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.FormFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.FormFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.FormFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.FormFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.FormFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.FormFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.FormFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.FormFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.FormFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.FormFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.FormFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.FormFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.FormFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.FormFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.FormFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.FormFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.FormFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.FormFeature__get_isValid(self)
FormFeature_swigregister = _fusion.FormFeature_swigregister
FormFeature_swigregister(FormFeature)

def FormFeature_classType() -> "char const *" :
  return _fusion.FormFeature_classType()
FormFeature_classType = _fusion.FormFeature_classType

FormFeature.__swig_getmethods__["tSplineBodies"] = FormFeature._get_tSplineBodies
FormFeature.tSplineBodies = property(FormFeature._get_tSplineBodies, doc="Returns a TSplineBodies collection where you can access any existing\nT-Spline bodies and through it create new T-Spline bodies.")

FormFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FormFeature) else None
FormFeature.cast = lambda arg: arg if isinstance(arg, FormFeature) else None

class FromEntityStartDefinition(ExtentDefinition):
    """
    A definition object that is used to define a feature whose start is defined by a specified construction
    plane or face. If a face is specified it must be large enough to completely contain the projected profile.
    """
    __swig_setmethods__ = {}
    for _s in [ExtentDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FromEntityStartDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ExtentDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FromEntityStartDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::FromEntityStartDefinition *" : return _fusion.FromEntityStartDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.FromEntityStartDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.FromEntityStartDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.FromEntityStartDefinition_classType
    if _newclass:classType = staticmethod(_fusion.FromEntityStartDefinition_classType)
    __swig_getmethods__["create"] = lambda x: _fusion.FromEntityStartDefinition_create
    if _newclass:create = staticmethod(_fusion.FromEntityStartDefinition_create)
    __swig_destroy__ = _fusion.delete_FromEntityStartDefinition
    __del__ = lambda self : None;
    def _get_offset(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the currently defined offset value. If the FromEntityStartDefinition object was
        created statically and is not associated with a feature, this will return a ValueInput object.
        if the FromEntityStartDefinition is associated with an existing feature, this will return
        the parameter that was created when the feature was created. To edit the offset, use properties
        on the parameter to change the value of the parameter.
        """
        return _fusion.FromEntityStartDefinition__get_offset(self)

    def _get_entity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets and sets the entity defining the start of the feature."""
        return _fusion.FromEntityStartDefinition__get_entity(self)

    def _set_entity(self, *args) -> "bool" :
        """Gets and sets the entity defining the start of the feature."""
        return _fusion.FromEntityStartDefinition__set_entity(self, *args)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        """
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.FromEntityStartDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.FromEntityStartDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.FromEntityStartDefinition__get_isValid(self)
FromEntityStartDefinition_swigregister = _fusion.FromEntityStartDefinition_swigregister
FromEntityStartDefinition_swigregister(FromEntityStartDefinition)

def FromEntityStartDefinition_classType() -> "char const *" :
  return _fusion.FromEntityStartDefinition_classType()
FromEntityStartDefinition_classType = _fusion.FromEntityStartDefinition_classType

def FromEntityStartDefinition_create(*args) -> "adsk::core::Ptr< adsk::core::ValueInput > const &" :
  return _fusion.FromEntityStartDefinition_create(*args)
FromEntityStartDefinition_create = _fusion.FromEntityStartDefinition_create

FromEntityStartDefinition.__swig_getmethods__["offset"] = FromEntityStartDefinition._get_offset
FromEntityStartDefinition.offset = property(FromEntityStartDefinition._get_offset, doc="Gets the currently defined offset value. If the FromEntityStartDefinition object was\ncreated statically and is not associated with a feature, this will return a ValueInput object.\nif the FromEntityStartDefinition is associated with an existing feature, this will return\nthe parameter that was created when the feature was created. To edit the offset, use properties\non the parameter to change the value of the parameter.")

FromEntityStartDefinition.__swig_getmethods__["entity"] = FromEntityStartDefinition._get_entity
FromEntityStartDefinition.__swig_setmethods__["entity"] = FromEntityStartDefinition._set_entity
FromEntityStartDefinition.entity = property(FromEntityStartDefinition._get_entity, FromEntityStartDefinition._set_entity, doc="Gets and sets the entity defining the start of the feature.")

FromEntityStartDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FromEntityStartDefinition) else None
FromEntityStartDefinition.cast = lambda arg: arg if isinstance(arg, FromEntityStartDefinition) else None

class FusionArchiveExportOptions(ExportOptions):
    """Defines that a Fusion 360 Archive export is to be done and specifies the various options."""
    __swig_setmethods__ = {}
    for _s in [ExportOptions]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FusionArchiveExportOptions, name, value)
    __swig_getmethods__ = {}
    for _s in [ExportOptions]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FusionArchiveExportOptions, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::FusionArchiveExportOptions *" : return _fusion.FusionArchiveExportOptions___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.FusionArchiveExportOptions___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.FusionArchiveExportOptions___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.FusionArchiveExportOptions_classType
    if _newclass:classType = staticmethod(_fusion.FusionArchiveExportOptions_classType)
    __swig_destroy__ = _fusion.delete_FusionArchiveExportOptions
    __del__ = lambda self : None;
    def _get_filename(self) -> "std::string" :
        """
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.FusionArchiveExportOptions__get_filename(self)

    def _set_filename(self, *args) -> "bool" :
        """
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.FusionArchiveExportOptions__set_filename(self, *args)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Specifies the geometry to export. This can be Occurrence, or the root Component. For STLExport, we also support BRepBody."""
        return _fusion.FusionArchiveExportOptions__get_geometry(self)

    def _set_geometry(self, *args) -> "bool" :
        """Specifies the geometry to export. This can be Occurrence, or the root Component. For STLExport, we also support BRepBody."""
        return _fusion.FusionArchiveExportOptions__set_geometry(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.FusionArchiveExportOptions__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.FusionArchiveExportOptions__get_isValid(self)
FusionArchiveExportOptions_swigregister = _fusion.FusionArchiveExportOptions_swigregister
FusionArchiveExportOptions_swigregister(FusionArchiveExportOptions)

def FusionArchiveExportOptions_classType() -> "char const *" :
  return _fusion.FusionArchiveExportOptions_classType()
FusionArchiveExportOptions_classType = _fusion.FusionArchiveExportOptions_classType

FusionArchiveExportOptions.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, FusionArchiveExportOptions) else None
FusionArchiveExportOptions.cast = lambda arg: arg if isinstance(arg, FusionArchiveExportOptions) else None

class HoleFeature(Feature):
    """Object that represents an existing hole feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HoleFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HoleFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::HoleFeature *" : return _fusion.HoleFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.HoleFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.HoleFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.HoleFeature_classType
    if _newclass:classType = staticmethod(_fusion.HoleFeature_classType)
    __swig_destroy__ = _fusion.delete_HoleFeature
    __del__ = lambda self : None;
    def _get_position(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Returns the position of the hole."""
        return _fusion.HoleFeature__get_position(self)

    def _get_direction(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Returns the direction of the hole."""
        return _fusion.HoleFeature__get_direction(self)

    def _get_holeType(self) -> "adsk::fusion::HoleTypes" :
        """Returns the current type of hole this feature represents."""
        return _fusion.HoleFeature__get_holeType(self)

    def _get_holeDiameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the model parameter controlling the hole diameter. The diameter of
        the hole can be edited through the returned parameter object.
        """
        return _fusion.HoleFeature__get_holeDiameter(self)

    def _get_tipAngle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the model parameter controlling the angle of the tip of the hole. The tip angle of
        the hole can be edited through the returned parameter object.
        """
        return _fusion.HoleFeature__get_tipAngle(self)

    def _get_counterboreDiameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the model parameter controlling the counterbore diameter.
        This will return null in the case the hole type is not a counterbore.
        The diameter of the counterbore can be edited through the returned parameter.
        """
        return _fusion.HoleFeature__get_counterboreDiameter(self)

    def _get_counterboreDepth(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the model parameter controlling the counterbore depth.
        This will return null in the case the hole type is not a counterbore.
        The depth of the counterbore can be edited through the returned parameter.
        """
        return _fusion.HoleFeature__get_counterboreDepth(self)

    def _get_countersinkDiameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the model parameter controlling the countersink diameter.
        This will return null in the case the hole type is not a countersink.
        The diameter of the countersink can be edited through the returned parameter.
        """
        return _fusion.HoleFeature__get_countersinkDiameter(self)

    def _get_countersinkAngle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the model parameter controlling the countersink angle.
        This will return null in the case the hole type is not a countersink.
        The angle of the countersink can be edited through the returned parameter.
        """
        return _fusion.HoleFeature__get_countersinkAngle(self)

    def _get_isDefaultDirection(self) -> "bool" :
        """Gets and sets if the hole is in the default direction or not."""
        return _fusion.HoleFeature__get_isDefaultDirection(self)

    def _set_isDefaultDirection(self, *args) -> "bool" :
        """Gets and sets if the hole is in the default direction or not."""
        return _fusion.HoleFeature__set_isDefaultDirection(self, *args)

    def setToSimple(self) -> "bool" :
        """
        Calling this method will change the hole to a simple hole. 
        Returns true if changing the hole was successful.
        """
        return _fusion.HoleFeature_setToSimple(self)

    def setToCounterbore(self, *args) -> "bool" :
        """
        Calling this method will change the hole to a counterbore hole. 
        counterboreDiameter : A ValueInput object that defines the counterbore diameter. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '3 in'). If no units are specified
        it is interpreted using the current default units for length. 
        counterboreDepth : A ValueInput object that defines the counterbore depth. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '3 in'). If no units are specified
        it is interpreted using the current default units for length. 
        Returns true if changing the hole was successful.
        """
        return _fusion.HoleFeature_setToCounterbore(self, *args)

    def setToCountersink(self, *args) -> "bool" :
        """
        Calling this method will change the hole to a countersink hole. 
        countersinkDiameter : A ValueInput object that defines the countersink diameter. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '3 in'). If no units are specified
        it is interpreted using the current default units for length. 
        countersinkAngle : A ValueInput object that defines the countersink angle. If the ValueInput uses
        a real then it is interpreted as radians. If it is a string then the units
        can be defined as part of the string (i.e. '120 deg'). If no units are specified
        it is interpreted using the current default units for length. 
        Returns true if changing the hole was successful.
        """
        return _fusion.HoleFeature_setToCountersink(self, *args)

    def _get_extentDefinition(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >" :
        """
        Gets the definition object that is defining the extent of the hole. Modifying the
        definition object will cause the hole to recompute. The extent type of a hole
        is currently limited to a distance extent.
        """
        return _fusion.HoleFeature__get_extentDefinition(self)

    def setDistanceExtent(self, *args) -> "bool" :
        """
        Defines the depth of the hole using a specific distance. 
        distance : The depth of the hole. If a real is specified the value is in centimeters. If a string is 
        specified the units are derived from the string. If no units are specified, the default 
        units of the document are used. 
        Returns true if setting the extent was successful.
        """
        return _fusion.HoleFeature_setDistanceExtent(self, *args)

    def setAllExtent(self, *args) -> "bool" :
        """
        Defines the extent of the hole to be through-all. The direction can be
        either positive, negative. 
        direction : The direction of the hole relative to the normal of the sketch plane. 
        Returns true if successful.
        """
        return _fusion.HoleFeature_setAllExtent(self, *args)

    def setOneSideToExtent(self, *args) -> "bool" :
        """
        Sets the extent of the hole to be from the sketch plane to the specified 'to' face. 
        toEntity : The entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For a hole it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        matchShape : Indicates if the hole is not contained on the face that the hole should match
        the shape of the entity as if it extended beyond it's current boundaries. 
        directionHint : Specifies the direction of the hole. This is only used in the case where there are two possible solutions and the hole can
        hit the toEntity in either direction.
        Typically there is only a single solution and the direction is determined automatically. 
        Returns true if successful.
        """
        return _fusion.HoleFeature_setOneSideToExtent(self, *args)

    def _get_endFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Property that returns the faces at the bottom of the hole. This will typically be a single face
        but could return more than one face in the case where the bottom of the hole is uneven.
        """
        return _fusion.HoleFeature__get_endFaces(self)

    def _get_sideFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """Property that returns all of the side faces of the hole."""
        return _fusion.HoleFeature__get_sideFaces(self)

    def setPositionByPoint(self, *args) -> "bool" :
        """
        Redefines the position of a the hole using a point. The point can be a vertex on the face
        or it can be a Point3D object to define any location on the face. If a Point3D object is 
        provided it will be projected onto the plane along the planes normal. The orientation of the
        hole is defined by the planar face or construction plane. If a vertex is used, the position of 
        the hole is associative to that vertex. If a Point3D object is used the position of the hole 
        is not associative. 
        planarEntity : The planar BRepFace or ConstructionPlane object that defines the orientation of the hole.
        The natural direction of the hole will be opposite the normal of the face or construction plane. 
        point : A Point3D object or vertex that defines the position of the hole. The point will be projected 
        onto the plane along the normal of the plane. 
        Returns true if successful.
        """
        return _fusion.HoleFeature_setPositionByPoint(self, *args)

    def setPositionAtCenter(self, *args) -> "bool" :
        """
        Redefines the position of the hole at the center of a circular or elliptical edge of the face. 
        planarEntity : The planar BRepFace or ConstructionPlane object that defines the orientation of the hole.
        The natural direction of the hole will be opposite the normal of the face or construction plane. 
        centerEdge : A circular or elliptical edge whose center point will be the position of the hole. 
        Returns true if successful.
        """
        return _fusion.HoleFeature_setPositionAtCenter(self, *args)

    def setPositionBySketchPoint(self, *args) -> "bool" :
        """
        Redefines the position and orienation of the hole using a sketch point. 
        sketchPoint : The sketch point that defines the position of the hole. The orientation is
        inferred from the normal of the point's parent sketch. The natural direction will be 
        opposite the normal of the sketch. 
        Returns true if successful.
        """
        return _fusion.HoleFeature_setPositionBySketchPoint(self, *args)

    def setPositionBySketchPoints(self, *args) -> "bool" :
        """
        Redefines the position and orientation of the hole using a set of points. 
        sketchPoints : A collection of sketch points that defines the positions of the holes. The orientation is
        inferred from the normal of the point's parent sketch. The natural direction will be 
        opposite the normal of the sketch. All of the points must be in the same sketch. 
        Returns true if successful.
        """
        return _fusion.HoleFeature_setPositionBySketchPoints(self, *args)

    def setPositionByPlaneAndOffsets(self, *args) -> "bool" :
        """
        Redefines the orientation of the hole using a planar face or construction plane. 
        The position of the hole is defined by the distance from one or two edges. 
        planarEntity : The planar BRepFace or ConstructionPlane object that defines the orientation of the hole.
        The natural direction of the hole will be opposite the normal of the face or construction plane. 
        point : A Point3D object that defines the approximate initial position of the hole. The point will be 
        projected onto the plane. This point should be close to the final position of the hole and 
        is used to determine which solution out of several possible solutions should be chosen 
        for the hole location. 
        edgeOne : A linear BRepEdge object that the position of the hole will be measured from. The position 
        of the hole will be measured along a perpendicular from this edge. 
        offsetOne : A ValueInput object that defines the offset distance from edgeOne. If the ValueInput uses
        a real then it is interpreted as centimeters. If it is a string then the units
        can be defined as part of the string (i.e. '3 in'). If no units are specified
        it is interpreted using the current default units for length. 
        edgeTwo : You can optionally define a second edge and offset to specify the position of the hole. If you use a
        second edge it has the same requirements as the edgeOne argument. If you provide a second edge you 
        must also provide the offsetTwo argument. 
        offsetTwo : If edgeTwo is defined, you must provide this argument which is a ValueInput object that 
        defines the offset from the edgeTwo. If the ValueInput uses a real then it is interpreted 
        as centimeters. If it is a string then the units can be defined as part of the string 
        (i.e. '3 in'). If no units are specified it is interpreted using the current default units 
        for length. 
        Returns true if successful.
        """
        return _fusion.HoleFeature_setPositionByPlaneAndOffsets(self, *args)

    def setPositionOnEdge(self, *args) -> "bool" :
        """
        Redefines the position and orientation of the hole to be on the start, end or center of an edge. 
        planarEntity : The planar BRepFace or ConstructionPlane object that defines the orientation of the hole
        and start of the hole. The natural direction of the hole will be opposite the normal of 
        the face or construction plane. 
        edge : The edge to position the hole on. 
        position : The position along the edge to place the hole. 
        Returns true if successful.
        """
        return _fusion.HoleFeature_setPositionOnEdge(self, *args)

    def _get_holePositionDefinition(self) -> "adsk::core::Ptr< adsk::fusion::HolePositionDefinition >" :
        """
        Returns a HolePositionDefinition object that provides access to the information used 
        to define the position of the hole. This returns null in the case where IsParametric 
        is false.
        """
        return _fusion.HoleFeature__get_holePositionDefinition(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::HoleFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.HoleFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::HoleFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.HoleFeature_createForAssemblyContext(self, *args)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >" :
        """
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        When setting or getting this property, you must roll the timeline back to just before the feature 
        so that the model is in the state just before the feature is computed.
        """
        return _fusion.HoleFeature__get_participantBodies(self)

    def _set_participantBodies(self, *args) -> "bool" :
        """
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        When setting or getting this property, you must roll the timeline back to just before the feature 
        so that the model is in the state just before the feature is computed.
        """
        return _fusion.HoleFeature__set_participantBodies(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.HoleFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.HoleFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.HoleFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.HoleFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.HoleFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.HoleFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.HoleFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.HoleFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.HoleFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.HoleFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.HoleFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.HoleFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.HoleFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.HoleFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.HoleFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.HoleFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.HoleFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.HoleFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.HoleFeature__get_isValid(self)
HoleFeature_swigregister = _fusion.HoleFeature_swigregister
HoleFeature_swigregister(HoleFeature)

def HoleFeature_classType() -> "char const *" :
  return _fusion.HoleFeature_classType()
HoleFeature_classType = _fusion.HoleFeature_classType

HoleFeature.__swig_getmethods__["position"] = HoleFeature._get_position
HoleFeature.position = property(HoleFeature._get_position, doc="Returns the position of the hole.")

HoleFeature.__swig_getmethods__["direction"] = HoleFeature._get_direction
HoleFeature.direction = property(HoleFeature._get_direction, doc="Returns the direction of the hole.")

HoleFeature.__swig_getmethods__["holeType"] = HoleFeature._get_holeType
HoleFeature.holeType = property(HoleFeature._get_holeType, doc="Returns the current type of hole this feature represents.")

HoleFeature.__swig_getmethods__["holeDiameter"] = HoleFeature._get_holeDiameter
HoleFeature.holeDiameter = property(HoleFeature._get_holeDiameter, doc="Returns the model parameter controlling the hole diameter. The diameter of\nthe hole can be edited through the returned parameter object.")

HoleFeature.__swig_getmethods__["tipAngle"] = HoleFeature._get_tipAngle
HoleFeature.tipAngle = property(HoleFeature._get_tipAngle, doc="Returns the model parameter controlling the angle of the tip of the hole. The tip angle of\nthe hole can be edited through the returned parameter object.")

HoleFeature.__swig_getmethods__["counterboreDiameter"] = HoleFeature._get_counterboreDiameter
HoleFeature.counterboreDiameter = property(HoleFeature._get_counterboreDiameter, doc="Returns the model parameter controlling the counterbore diameter.\nThis will return null in the case the hole type is not a counterbore.\nThe diameter of the counterbore can be edited through the returned parameter.")

HoleFeature.__swig_getmethods__["counterboreDepth"] = HoleFeature._get_counterboreDepth
HoleFeature.counterboreDepth = property(HoleFeature._get_counterboreDepth, doc="Returns the model parameter controlling the counterbore depth.\nThis will return null in the case the hole type is not a counterbore.\nThe depth of the counterbore can be edited through the returned parameter.")

HoleFeature.__swig_getmethods__["countersinkDiameter"] = HoleFeature._get_countersinkDiameter
HoleFeature.countersinkDiameter = property(HoleFeature._get_countersinkDiameter, doc="Returns the model parameter controlling the countersink diameter.\nThis will return null in the case the hole type is not a countersink.\nThe diameter of the countersink can be edited through the returned parameter.")

HoleFeature.__swig_getmethods__["countersinkAngle"] = HoleFeature._get_countersinkAngle
HoleFeature.countersinkAngle = property(HoleFeature._get_countersinkAngle, doc="Returns the model parameter controlling the countersink angle.\nThis will return null in the case the hole type is not a countersink.\nThe angle of the countersink can be edited through the returned parameter.")

HoleFeature.__swig_getmethods__["isDefaultDirection"] = HoleFeature._get_isDefaultDirection
HoleFeature.__swig_setmethods__["isDefaultDirection"] = HoleFeature._set_isDefaultDirection
HoleFeature.isDefaultDirection = property(HoleFeature._get_isDefaultDirection, HoleFeature._set_isDefaultDirection, doc="Gets and sets if the hole is in the default direction or not.")

HoleFeature.__swig_getmethods__["extentDefinition"] = HoleFeature._get_extentDefinition
HoleFeature.extentDefinition = property(HoleFeature._get_extentDefinition, doc="Gets the definition object that is defining the extent of the hole. Modifying the\ndefinition object will cause the hole to recompute. The extent type of a hole\nis currently limited to a distance extent.")

HoleFeature.__swig_getmethods__["endFaces"] = HoleFeature._get_endFaces
HoleFeature.endFaces = property(HoleFeature._get_endFaces, doc="Property that returns the faces at the bottom of the hole. This will typically be a single face\nbut could return more than one face in the case where the bottom of the hole is uneven.")

HoleFeature.__swig_getmethods__["sideFaces"] = HoleFeature._get_sideFaces
HoleFeature.sideFaces = property(HoleFeature._get_sideFaces, doc="Property that returns all of the side faces of the hole.")

HoleFeature.__swig_getmethods__["holePositionDefinition"] = HoleFeature._get_holePositionDefinition
HoleFeature.holePositionDefinition = property(HoleFeature._get_holePositionDefinition, doc="Returns a HolePositionDefinition object that provides access to the information used\nto define the position of the hole. This returns null in the case where IsParametric\nis false.")

HoleFeature.__swig_getmethods__["nativeObject"] = HoleFeature._get_nativeObject
HoleFeature.nativeObject = property(HoleFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

HoleFeature.__swig_getmethods__["participantBodies"] = HoleFeature._get_participantBodies
HoleFeature.__swig_setmethods__["participantBodies"] = HoleFeature._set_participantBodies
HoleFeature.participantBodies = property(HoleFeature._get_participantBodies, HoleFeature._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.\nWhen setting or getting this property, you must roll the timeline back to just before the feature\nso that the model is in the state just before the feature is computed.")

HoleFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, HoleFeature) else None
HoleFeature.cast = lambda arg: arg if isinstance(arg, HoleFeature) else None

class HorizontalConstraint(GeometricConstraint):
    """A horizontal constraint in a sketch."""
    __swig_setmethods__ = {}
    for _s in [GeometricConstraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HorizontalConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricConstraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HorizontalConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::HorizontalConstraint *" : return _fusion.HorizontalConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.HorizontalConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.HorizontalConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.HorizontalConstraint_classType
    if _newclass:classType = staticmethod(_fusion.HorizontalConstraint_classType)
    __swig_destroy__ = _fusion.delete_HorizontalConstraint
    __del__ = lambda self : None;
    def _get_line(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """Returns the line being constrained."""
        return _fusion.HorizontalConstraint__get_line(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::HorizontalConstraint >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.HorizontalConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::HorizontalConstraint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.HorizontalConstraint_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.HorizontalConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.HorizontalConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.HorizontalConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.HorizontalConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.HorizontalConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.HorizontalConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.HorizontalConstraint__get_isValid(self)
HorizontalConstraint_swigregister = _fusion.HorizontalConstraint_swigregister
HorizontalConstraint_swigregister(HorizontalConstraint)

def HorizontalConstraint_classType() -> "char const *" :
  return _fusion.HorizontalConstraint_classType()
HorizontalConstraint_classType = _fusion.HorizontalConstraint_classType

HorizontalConstraint.__swig_getmethods__["line"] = HorizontalConstraint._get_line
HorizontalConstraint.line = property(HorizontalConstraint._get_line, doc="Returns the line being constrained.")

HorizontalConstraint.__swig_getmethods__["nativeObject"] = HorizontalConstraint._get_nativeObject
HorizontalConstraint.nativeObject = property(HorizontalConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

HorizontalConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, HorizontalConstraint) else None
HorizontalConstraint.cast = lambda arg: arg if isinstance(arg, HorizontalConstraint) else None

class HorizontalPointsConstraint(GeometricConstraint):
    """A horizontal constraint between two points in a sketch."""
    __swig_setmethods__ = {}
    for _s in [GeometricConstraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HorizontalPointsConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricConstraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HorizontalPointsConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::HorizontalPointsConstraint *" : return _fusion.HorizontalPointsConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.HorizontalPointsConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.HorizontalPointsConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.HorizontalPointsConstraint_classType
    if _newclass:classType = staticmethod(_fusion.HorizontalPointsConstraint_classType)
    __swig_destroy__ = _fusion.delete_HorizontalPointsConstraint
    __del__ = lambda self : None;
    def _get_pointOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """Returns the first point."""
        return _fusion.HorizontalPointsConstraint__get_pointOne(self)

    def _get_pointTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """Returns the second point."""
        return _fusion.HorizontalPointsConstraint__get_pointTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::HorizontalPointsConstraint >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.HorizontalPointsConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::HorizontalPointsConstraint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.HorizontalPointsConstraint_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.HorizontalPointsConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.HorizontalPointsConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.HorizontalPointsConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.HorizontalPointsConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.HorizontalPointsConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.HorizontalPointsConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.HorizontalPointsConstraint__get_isValid(self)
HorizontalPointsConstraint_swigregister = _fusion.HorizontalPointsConstraint_swigregister
HorizontalPointsConstraint_swigregister(HorizontalPointsConstraint)

def HorizontalPointsConstraint_classType() -> "char const *" :
  return _fusion.HorizontalPointsConstraint_classType()
HorizontalPointsConstraint_classType = _fusion.HorizontalPointsConstraint_classType

HorizontalPointsConstraint.__swig_getmethods__["pointOne"] = HorizontalPointsConstraint._get_pointOne
HorizontalPointsConstraint.pointOne = property(HorizontalPointsConstraint._get_pointOne, doc="Returns the first point.")

HorizontalPointsConstraint.__swig_getmethods__["pointTwo"] = HorizontalPointsConstraint._get_pointTwo
HorizontalPointsConstraint.pointTwo = property(HorizontalPointsConstraint._get_pointTwo, doc="Returns the second point.")

HorizontalPointsConstraint.__swig_getmethods__["nativeObject"] = HorizontalPointsConstraint._get_nativeObject
HorizontalPointsConstraint.nativeObject = property(HorizontalPointsConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

HorizontalPointsConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, HorizontalPointsConstraint) else None
HorizontalPointsConstraint.cast = lambda arg: arg if isinstance(arg, HorizontalPointsConstraint) else None

class IGESExportOptions(ExportOptions):
    """Defines that an IGES export is to be done and specifies the various options."""
    __swig_setmethods__ = {}
    for _s in [ExportOptions]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IGESExportOptions, name, value)
    __swig_getmethods__ = {}
    for _s in [ExportOptions]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IGESExportOptions, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::IGESExportOptions *" : return _fusion.IGESExportOptions___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.IGESExportOptions___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.IGESExportOptions___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.IGESExportOptions_classType
    if _newclass:classType = staticmethod(_fusion.IGESExportOptions_classType)
    __swig_destroy__ = _fusion.delete_IGESExportOptions
    __del__ = lambda self : None;
    def _get_filename(self) -> "std::string" :
        """
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.IGESExportOptions__get_filename(self)

    def _set_filename(self, *args) -> "bool" :
        """
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.IGESExportOptions__set_filename(self, *args)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Specifies the geometry to export. This can be Occurrence, or the root Component. For STLExport, we also support BRepBody."""
        return _fusion.IGESExportOptions__get_geometry(self)

    def _set_geometry(self, *args) -> "bool" :
        """Specifies the geometry to export. This can be Occurrence, or the root Component. For STLExport, we also support BRepBody."""
        return _fusion.IGESExportOptions__set_geometry(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.IGESExportOptions__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.IGESExportOptions__get_isValid(self)
IGESExportOptions_swigregister = _fusion.IGESExportOptions_swigregister
IGESExportOptions_swigregister(IGESExportOptions)

def IGESExportOptions_classType() -> "char const *" :
  return _fusion.IGESExportOptions_classType()
IGESExportOptions_classType = _fusion.IGESExportOptions_classType

IGESExportOptions.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, IGESExportOptions) else None
IGESExportOptions.cast = lambda arg: arg if isinstance(arg, IGESExportOptions) else None

class LoftDirectionEndCondition(LoftEndCondition):
    """Represents a 'Direction' loft end condition."""
    __swig_setmethods__ = {}
    for _s in [LoftEndCondition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoftDirectionEndCondition, name, value)
    __swig_getmethods__ = {}
    for _s in [LoftEndCondition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoftDirectionEndCondition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::LoftDirectionEndCondition *" : return _fusion.LoftDirectionEndCondition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.LoftDirectionEndCondition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.LoftDirectionEndCondition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.LoftDirectionEndCondition_classType
    if _newclass:classType = staticmethod(_fusion.LoftDirectionEndCondition_classType)
    __swig_destroy__ = _fusion.delete_LoftDirectionEndCondition
    __del__ = lambda self : None;
    def _get_angle(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the valueInput or Parameter that defines the angle of the direction of the loft.
        If this object was obtained from a LoftFeatureInput object then this will return a 
        valueInput object with the initial value provided. If this object was obtained from 
        an exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the angle, 
        edit the value of the associated parameter.
        """
        return _fusion.LoftDirectionEndCondition__get_angle(self)

    def _get_weight(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the valueInput or Parameter that defines the weight of the loft.
        If this object was obtained from a LoftFeatureInput object then this will return a 
        valueInput object with the initial value provided. If this object was obtained from 
        an exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight, 
        edit the value of the associated parameter.
        """
        return _fusion.LoftDirectionEndCondition__get_weight(self)

    def _get_parentLoftSection(self) -> "adsk::core::Ptr< adsk::fusion::LoftSection >" :
        """Returns the parent loft section."""
        return _fusion.LoftDirectionEndCondition__get_parentLoftSection(self)

    def _get_objectType(self) -> "char const *" : return _fusion.LoftDirectionEndCondition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.LoftDirectionEndCondition__get_isValid(self)
LoftDirectionEndCondition_swigregister = _fusion.LoftDirectionEndCondition_swigregister
LoftDirectionEndCondition_swigregister(LoftDirectionEndCondition)

def LoftDirectionEndCondition_classType() -> "char const *" :
  return _fusion.LoftDirectionEndCondition_classType()
LoftDirectionEndCondition_classType = _fusion.LoftDirectionEndCondition_classType

LoftDirectionEndCondition.__swig_getmethods__["angle"] = LoftDirectionEndCondition._get_angle
LoftDirectionEndCondition.angle = property(LoftDirectionEndCondition._get_angle, doc="Gets the valueInput or Parameter that defines the angle of the direction of the loft.\nIf this object was obtained from a LoftFeatureInput object then this will return a\nvalueInput object with the initial value provided. If this object was obtained from\nan exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the angle,\nedit the value of the associated parameter.")

LoftDirectionEndCondition.__swig_getmethods__["weight"] = LoftDirectionEndCondition._get_weight
LoftDirectionEndCondition.weight = property(LoftDirectionEndCondition._get_weight, doc="Gets the valueInput or Parameter that defines the weight of the loft.\nIf this object was obtained from a LoftFeatureInput object then this will return a\nvalueInput object with the initial value provided. If this object was obtained from\nan exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight,\nedit the value of the associated parameter.")

LoftDirectionEndCondition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, LoftDirectionEndCondition) else None
LoftDirectionEndCondition.cast = lambda arg: arg if isinstance(arg, LoftDirectionEndCondition) else None

class LoftFeature(Feature):
    """Object that represents an existing loft feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoftFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoftFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::LoftFeature *" : return _fusion.LoftFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.LoftFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.LoftFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.LoftFeature_classType
    if _newclass:classType = staticmethod(_fusion.LoftFeature_classType)
    __swig_destroy__ = _fusion.delete_LoftFeature
    __del__ = lambda self : None;
    def _get_loftSections(self) -> "adsk::core::Ptr< adsk::fusion::LoftSections >" :
        """
        Returns the set of sections that the loft passes through.
        This property returns null in the case where the feature is non-parametric.
        """
        return _fusion.LoftFeature__get_loftSections(self)

    def _get_centerLineOrRails(self) -> "adsk::core::Ptr< adsk::fusion::LoftCenterLineOrRails >" :
        """
        Returns the single centerline or the set of rails that define the shape of the loft.
        This property returns null in the case where the feature is non-parametric.
        """
        return _fusion.LoftFeature__get_centerLineOrRails(self)

    def _get_startFace(self) -> "adsk::core::Ptr< adsk::fusion::BRepFace >" :
        """
        Property that returns the face that caps the start of the loft and is coincident 
        with the first section. In the case where the loft isn't capped and there isn't
        a start face, this property will return null.
        """
        return _fusion.LoftFeature__get_startFace(self)

    def _get_endFace(self) -> "adsk::core::Ptr< adsk::fusion::BRepFace >" :
        """
        Property that returns the face that caps the end of the loft and is coincident
        with the last section. In the case where the loft isn't capped and there isn't an end face,
        this property will return null.
        """
        return _fusion.LoftFeature__get_endFace(self)

    def _get_sideFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Property that returns all of the side faces (i.e. those running through the sections) 
        of the feature.
        """
        return _fusion.LoftFeature__get_sideFaces(self)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """Gets and sets the type of operation performed by the extrusion."""
        return _fusion.LoftFeature__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """Gets and sets the type of operation performed by the extrusion."""
        return _fusion.LoftFeature__set_operation(self, *args)

    def _get_isSolid(self) -> "bool" :
        """Indicates if this feature was initially created as a solid or a surface."""
        return _fusion.LoftFeature__get_isSolid(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::LoftFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.LoftFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::LoftFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.LoftFeature_createForAssemblyContext(self, *args)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >" :
        """
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        When setting or getting this property, you must roll the timeline back to just before the feature 
        so that the model is in the state just before the feature is computed.
        """
        return _fusion.LoftFeature__get_participantBodies(self)

    def _set_participantBodies(self, *args) -> "bool" :
        """
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        When setting or getting this property, you must roll the timeline back to just before the feature 
        so that the model is in the state just before the feature is computed.
        """
        return _fusion.LoftFeature__set_participantBodies(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.LoftFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.LoftFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.LoftFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.LoftFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.LoftFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.LoftFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.LoftFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.LoftFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.LoftFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.LoftFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.LoftFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.LoftFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.LoftFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.LoftFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.LoftFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.LoftFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.LoftFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.LoftFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.LoftFeature__get_isValid(self)
LoftFeature_swigregister = _fusion.LoftFeature_swigregister
LoftFeature_swigregister(LoftFeature)

def LoftFeature_classType() -> "char const *" :
  return _fusion.LoftFeature_classType()
LoftFeature_classType = _fusion.LoftFeature_classType

LoftFeature.__swig_getmethods__["loftSections"] = LoftFeature._get_loftSections
LoftFeature.loftSections = property(LoftFeature._get_loftSections, doc="Returns the set of sections that the loft passes through.\nThis property returns null in the case where the feature is non-parametric.")

LoftFeature.__swig_getmethods__["centerLineOrRails"] = LoftFeature._get_centerLineOrRails
LoftFeature.centerLineOrRails = property(LoftFeature._get_centerLineOrRails, doc="Returns the single centerline or the set of rails that define the shape of the loft.\nThis property returns null in the case where the feature is non-parametric.")

LoftFeature.__swig_getmethods__["startFace"] = LoftFeature._get_startFace
LoftFeature.startFace = property(LoftFeature._get_startFace, doc="Property that returns the face that caps the start of the loft and is coincident\nwith the first section. In the case where the loft isn't capped and there isn't\na start face, this property will return null.")

LoftFeature.__swig_getmethods__["endFace"] = LoftFeature._get_endFace
LoftFeature.endFace = property(LoftFeature._get_endFace, doc="Property that returns the face that caps the end of the loft and is coincident\nwith the last section. In the case where the loft isn't capped and there isn't an end face,\nthis property will return null.")

LoftFeature.__swig_getmethods__["sideFaces"] = LoftFeature._get_sideFaces
LoftFeature.sideFaces = property(LoftFeature._get_sideFaces, doc="Property that returns all of the side faces (i.e. those running through the sections)\nof the feature.")

LoftFeature.__swig_getmethods__["operation"] = LoftFeature._get_operation
LoftFeature.__swig_setmethods__["operation"] = LoftFeature._set_operation
LoftFeature.operation = property(LoftFeature._get_operation, LoftFeature._set_operation, doc="Gets and sets the type of operation performed by the extrusion.")

LoftFeature.__swig_getmethods__["isSolid"] = LoftFeature._get_isSolid
LoftFeature.isSolid = property(LoftFeature._get_isSolid, doc="Indicates if this feature was initially created as a solid or a surface.")

LoftFeature.__swig_getmethods__["nativeObject"] = LoftFeature._get_nativeObject
LoftFeature.nativeObject = property(LoftFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

LoftFeature.__swig_getmethods__["participantBodies"] = LoftFeature._get_participantBodies
LoftFeature.__swig_setmethods__["participantBodies"] = LoftFeature._set_participantBodies
LoftFeature.participantBodies = property(LoftFeature._get_participantBodies, LoftFeature._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.\nWhen setting or getting this property, you must roll the timeline back to just before the feature\nso that the model is in the state just before the feature is computed.")

LoftFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, LoftFeature) else None
LoftFeature.cast = lambda arg: arg if isinstance(arg, LoftFeature) else None

class LoftFreeEndCondition(LoftEndCondition):
    """Represents a 'Free' loft end condition."""
    __swig_setmethods__ = {}
    for _s in [LoftEndCondition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoftFreeEndCondition, name, value)
    __swig_getmethods__ = {}
    for _s in [LoftEndCondition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoftFreeEndCondition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::LoftFreeEndCondition *" : return _fusion.LoftFreeEndCondition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.LoftFreeEndCondition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.LoftFreeEndCondition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.LoftFreeEndCondition_classType
    if _newclass:classType = staticmethod(_fusion.LoftFreeEndCondition_classType)
    __swig_destroy__ = _fusion.delete_LoftFreeEndCondition
    __del__ = lambda self : None;
    def _get_parentLoftSection(self) -> "adsk::core::Ptr< adsk::fusion::LoftSection >" :
        """Returns the parent loft section."""
        return _fusion.LoftFreeEndCondition__get_parentLoftSection(self)

    def _get_objectType(self) -> "char const *" : return _fusion.LoftFreeEndCondition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.LoftFreeEndCondition__get_isValid(self)
LoftFreeEndCondition_swigregister = _fusion.LoftFreeEndCondition_swigregister
LoftFreeEndCondition_swigregister(LoftFreeEndCondition)

def LoftFreeEndCondition_classType() -> "char const *" :
  return _fusion.LoftFreeEndCondition_classType()
LoftFreeEndCondition_classType = _fusion.LoftFreeEndCondition_classType

LoftFreeEndCondition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, LoftFreeEndCondition) else None
LoftFreeEndCondition.cast = lambda arg: arg if isinstance(arg, LoftFreeEndCondition) else None

class LoftPointSharpEndCondition(LoftEndCondition):
    """Represents a 'Point Sharp' loft end condition."""
    __swig_setmethods__ = {}
    for _s in [LoftEndCondition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoftPointSharpEndCondition, name, value)
    __swig_getmethods__ = {}
    for _s in [LoftEndCondition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoftPointSharpEndCondition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::LoftPointSharpEndCondition *" : return _fusion.LoftPointSharpEndCondition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.LoftPointSharpEndCondition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.LoftPointSharpEndCondition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.LoftPointSharpEndCondition_classType
    if _newclass:classType = staticmethod(_fusion.LoftPointSharpEndCondition_classType)
    __swig_destroy__ = _fusion.delete_LoftPointSharpEndCondition
    __del__ = lambda self : None;
    def _get_parentLoftSection(self) -> "adsk::core::Ptr< adsk::fusion::LoftSection >" :
        """Returns the parent loft section."""
        return _fusion.LoftPointSharpEndCondition__get_parentLoftSection(self)

    def _get_objectType(self) -> "char const *" : return _fusion.LoftPointSharpEndCondition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.LoftPointSharpEndCondition__get_isValid(self)
LoftPointSharpEndCondition_swigregister = _fusion.LoftPointSharpEndCondition_swigregister
LoftPointSharpEndCondition_swigregister(LoftPointSharpEndCondition)

def LoftPointSharpEndCondition_classType() -> "char const *" :
  return _fusion.LoftPointSharpEndCondition_classType()
LoftPointSharpEndCondition_classType = _fusion.LoftPointSharpEndCondition_classType

LoftPointSharpEndCondition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, LoftPointSharpEndCondition) else None
LoftPointSharpEndCondition.cast = lambda arg: arg if isinstance(arg, LoftPointSharpEndCondition) else None

class LoftPointTangentEndCondition(LoftEndCondition):
    """Represents a 'Point Tangent' loft end condition."""
    __swig_setmethods__ = {}
    for _s in [LoftEndCondition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoftPointTangentEndCondition, name, value)
    __swig_getmethods__ = {}
    for _s in [LoftEndCondition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoftPointTangentEndCondition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::LoftPointTangentEndCondition *" : return _fusion.LoftPointTangentEndCondition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.LoftPointTangentEndCondition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.LoftPointTangentEndCondition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.LoftPointTangentEndCondition_classType
    if _newclass:classType = staticmethod(_fusion.LoftPointTangentEndCondition_classType)
    __swig_destroy__ = _fusion.delete_LoftPointTangentEndCondition
    __del__ = lambda self : None;
    def _get_weight(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the valueInput or Parameter that defines the weight of the loft.
        If this object was obtained from a LoftFeatureInput object then this will return a 
        valueInput object with the initial value provided. If this object was obtained from 
        an exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight, 
        edit the value of the associated parameter.
        """
        return _fusion.LoftPointTangentEndCondition__get_weight(self)

    def _get_parentLoftSection(self) -> "adsk::core::Ptr< adsk::fusion::LoftSection >" :
        """Returns the parent loft section."""
        return _fusion.LoftPointTangentEndCondition__get_parentLoftSection(self)

    def _get_objectType(self) -> "char const *" : return _fusion.LoftPointTangentEndCondition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.LoftPointTangentEndCondition__get_isValid(self)
LoftPointTangentEndCondition_swigregister = _fusion.LoftPointTangentEndCondition_swigregister
LoftPointTangentEndCondition_swigregister(LoftPointTangentEndCondition)

def LoftPointTangentEndCondition_classType() -> "char const *" :
  return _fusion.LoftPointTangentEndCondition_classType()
LoftPointTangentEndCondition_classType = _fusion.LoftPointTangentEndCondition_classType

LoftPointTangentEndCondition.__swig_getmethods__["weight"] = LoftPointTangentEndCondition._get_weight
LoftPointTangentEndCondition.weight = property(LoftPointTangentEndCondition._get_weight, doc="Gets the valueInput or Parameter that defines the weight of the loft.\nIf this object was obtained from a LoftFeatureInput object then this will return a\nvalueInput object with the initial value provided. If this object was obtained from\nan exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight,\nedit the value of the associated parameter.")

LoftPointTangentEndCondition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, LoftPointTangentEndCondition) else None
LoftPointTangentEndCondition.cast = lambda arg: arg if isinstance(arg, LoftPointTangentEndCondition) else None

class LoftSmoothEndCondition(LoftEndCondition):
    """Represents a 'Smooth' loft end condition."""
    __swig_setmethods__ = {}
    for _s in [LoftEndCondition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoftSmoothEndCondition, name, value)
    __swig_getmethods__ = {}
    for _s in [LoftEndCondition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoftSmoothEndCondition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::LoftSmoothEndCondition *" : return _fusion.LoftSmoothEndCondition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.LoftSmoothEndCondition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.LoftSmoothEndCondition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.LoftSmoothEndCondition_classType
    if _newclass:classType = staticmethod(_fusion.LoftSmoothEndCondition_classType)
    __swig_destroy__ = _fusion.delete_LoftSmoothEndCondition
    __del__ = lambda self : None;
    def _get_weight(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the valueInput or Parameter that defines the weight of the loft.
        If this object was obtained from a LoftFeatureInput object then this will return a 
        valueInput object with the initial value provided. If this object was obtained from 
        an exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight, 
        edit the value of the associated parameter.
        """
        return _fusion.LoftSmoothEndCondition__get_weight(self)

    def _get_parentLoftSection(self) -> "adsk::core::Ptr< adsk::fusion::LoftSection >" :
        """Returns the parent loft section."""
        return _fusion.LoftSmoothEndCondition__get_parentLoftSection(self)

    def _get_objectType(self) -> "char const *" : return _fusion.LoftSmoothEndCondition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.LoftSmoothEndCondition__get_isValid(self)
LoftSmoothEndCondition_swigregister = _fusion.LoftSmoothEndCondition_swigregister
LoftSmoothEndCondition_swigregister(LoftSmoothEndCondition)

def LoftSmoothEndCondition_classType() -> "char const *" :
  return _fusion.LoftSmoothEndCondition_classType()
LoftSmoothEndCondition_classType = _fusion.LoftSmoothEndCondition_classType

LoftSmoothEndCondition.__swig_getmethods__["weight"] = LoftSmoothEndCondition._get_weight
LoftSmoothEndCondition.weight = property(LoftSmoothEndCondition._get_weight, doc="Gets the valueInput or Parameter that defines the weight of the loft.\nIf this object was obtained from a LoftFeatureInput object then this will return a\nvalueInput object with the initial value provided. If this object was obtained from\nan exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight,\nedit the value of the associated parameter.")

LoftSmoothEndCondition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, LoftSmoothEndCondition) else None
LoftSmoothEndCondition.cast = lambda arg: arg if isinstance(arg, LoftSmoothEndCondition) else None

class LoftTangentEndCondition(LoftEndCondition):
    """Represents a 'Tangent' loft end condition."""
    __swig_setmethods__ = {}
    for _s in [LoftEndCondition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoftTangentEndCondition, name, value)
    __swig_getmethods__ = {}
    for _s in [LoftEndCondition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoftTangentEndCondition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::LoftTangentEndCondition *" : return _fusion.LoftTangentEndCondition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.LoftTangentEndCondition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.LoftTangentEndCondition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.LoftTangentEndCondition_classType
    if _newclass:classType = staticmethod(_fusion.LoftTangentEndCondition_classType)
    __swig_destroy__ = _fusion.delete_LoftTangentEndCondition
    __del__ = lambda self : None;
    def _get_weight(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the valueInput or Parameter that defines the weight of the loft.
        If this object was obtained from a LoftFeatureInput object then this will return a 
        valueInput object with the initial value provided. If this object was obtained from 
        an exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight, 
        edit the value of the associated parameter.
        """
        return _fusion.LoftTangentEndCondition__get_weight(self)

    def _get_parentLoftSection(self) -> "adsk::core::Ptr< adsk::fusion::LoftSection >" :
        """Returns the parent loft section."""
        return _fusion.LoftTangentEndCondition__get_parentLoftSection(self)

    def _get_objectType(self) -> "char const *" : return _fusion.LoftTangentEndCondition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.LoftTangentEndCondition__get_isValid(self)
LoftTangentEndCondition_swigregister = _fusion.LoftTangentEndCondition_swigregister
LoftTangentEndCondition_swigregister(LoftTangentEndCondition)

def LoftTangentEndCondition_classType() -> "char const *" :
  return _fusion.LoftTangentEndCondition_classType()
LoftTangentEndCondition_classType = _fusion.LoftTangentEndCondition_classType

LoftTangentEndCondition.__swig_getmethods__["weight"] = LoftTangentEndCondition._get_weight
LoftTangentEndCondition.weight = property(LoftTangentEndCondition._get_weight, doc="Gets the valueInput or Parameter that defines the weight of the loft.\nIf this object was obtained from a LoftFeatureInput object then this will return a\nvalueInput object with the initial value provided. If this object was obtained from\nan exiting LoftFeature then it returns a Parameter. In the case of a parameter, to change the weight,\nedit the value of the associated parameter.")

LoftTangentEndCondition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, LoftTangentEndCondition) else None
LoftTangentEndCondition.cast = lambda arg: arg if isinstance(arg, LoftTangentEndCondition) else None

class MidPointConstraint(GeometricConstraint):
    """A midpoint constraint in a sketch."""
    __swig_setmethods__ = {}
    for _s in [GeometricConstraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MidPointConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricConstraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MidPointConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::MidPointConstraint *" : return _fusion.MidPointConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.MidPointConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.MidPointConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.MidPointConstraint_classType
    if _newclass:classType = staticmethod(_fusion.MidPointConstraint_classType)
    __swig_destroy__ = _fusion.delete_MidPointConstraint
    __del__ = lambda self : None;
    def _get_point(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """Returns the sketch point being constrained."""
        return _fusion.MidPointConstraint__get_point(self)

    def _get_midPointCurve(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >" :
        """Returns the curve defining the midpoint."""
        return _fusion.MidPointConstraint__get_midPointCurve(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::MidPointConstraint >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.MidPointConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::MidPointConstraint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.MidPointConstraint_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.MidPointConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.MidPointConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.MidPointConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.MidPointConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.MidPointConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.MidPointConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.MidPointConstraint__get_isValid(self)
MidPointConstraint_swigregister = _fusion.MidPointConstraint_swigregister
MidPointConstraint_swigregister(MidPointConstraint)

def MidPointConstraint_classType() -> "char const *" :
  return _fusion.MidPointConstraint_classType()
MidPointConstraint_classType = _fusion.MidPointConstraint_classType

MidPointConstraint.__swig_getmethods__["point"] = MidPointConstraint._get_point
MidPointConstraint.point = property(MidPointConstraint._get_point, doc="Returns the sketch point being constrained.")

MidPointConstraint.__swig_getmethods__["midPointCurve"] = MidPointConstraint._get_midPointCurve
MidPointConstraint.midPointCurve = property(MidPointConstraint._get_midPointCurve, doc="Returns the curve defining the midpoint.")

MidPointConstraint.__swig_getmethods__["nativeObject"] = MidPointConstraint._get_nativeObject
MidPointConstraint.nativeObject = property(MidPointConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

MidPointConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MidPointConstraint) else None
MidPointConstraint.cast = lambda arg: arg if isinstance(arg, MidPointConstraint) else None

class MirrorFeature(Feature):
    """Object that represents an existing mirror feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MirrorFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MirrorFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::MirrorFeature *" : return _fusion.MirrorFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.MirrorFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.MirrorFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.MirrorFeature_classType
    if _newclass:classType = staticmethod(_fusion.MirrorFeature_classType)
    __swig_destroy__ = _fusion.delete_MirrorFeature
    __del__ = lambda self : None;
    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the entities that are mirrored. It can contain faces, features, bodies, or components. 
        The input must all be of a single type. For example, you can't provide a body and a component but 
        the collection must be either all bodies or all components.
        """
        return _fusion.MirrorFeature__get_inputEntities(self)

    def _set_inputEntities(self, *args) -> "bool" :
        """
        Gets and sets the entities that are mirrored. It can contain faces, features, bodies, or components. 
        The input must all be of a single type. For example, you can't provide a body and a component but 
        the collection must be either all bodies or all components.
        """
        return _fusion.MirrorFeature__set_inputEntities(self, *args)

    def _get_mirrorPlane(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the mirror plane. This can be either a planar face or construction plane. 
        This works only for parametric features.
        """
        return _fusion.MirrorFeature__get_mirrorPlane(self)

    def _set_mirrorPlane(self, *args) -> "bool" :
        """
        Gets and sets the mirror plane. This can be either a planar face or construction plane. 
        This works only for parametric features.
        """
        return _fusion.MirrorFeature__set_mirrorPlane(self, *args)

    def _get_patternElements(self) -> "adsk::core::Ptr< adsk::fusion::PatternElements >" :
        """Gets the PatternElements collection that contains the elements created by this pattern."""
        return _fusion.MirrorFeature__get_patternElements(self)

    def _get_resultFeatures(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Get the features that were created for this mirror.
        Returns null in the case where the feature is not parametric.
        """
        return _fusion.MirrorFeature__get_resultFeatures(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::MirrorFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.MirrorFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::MirrorFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.MirrorFeature_createForAssemblyContext(self, *args)

    def _get_patternComputeOption(self) -> "adsk::fusion::PatternComputeOptions" :
        """
        Gets and sets the compute option for this mirror feature.
        This property only applies when mirroring features and is ignored in the direct modeling environment.
        """
        return _fusion.MirrorFeature__get_patternComputeOption(self)

    def _set_patternComputeOption(self, *args) -> "bool" :
        """
        Gets and sets the compute option for this mirror feature.
        This property only applies when mirroring features and is ignored in the direct modeling environment.
        """
        return _fusion.MirrorFeature__set_patternComputeOption(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.MirrorFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.MirrorFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.MirrorFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.MirrorFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.MirrorFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.MirrorFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.MirrorFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.MirrorFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.MirrorFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.MirrorFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.MirrorFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.MirrorFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.MirrorFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.MirrorFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.MirrorFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.MirrorFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.MirrorFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.MirrorFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.MirrorFeature__get_isValid(self)
MirrorFeature_swigregister = _fusion.MirrorFeature_swigregister
MirrorFeature_swigregister(MirrorFeature)

def MirrorFeature_classType() -> "char const *" :
  return _fusion.MirrorFeature_classType()
MirrorFeature_classType = _fusion.MirrorFeature_classType

MirrorFeature.__swig_getmethods__["inputEntities"] = MirrorFeature._get_inputEntities
MirrorFeature.__swig_setmethods__["inputEntities"] = MirrorFeature._set_inputEntities
MirrorFeature.inputEntities = property(MirrorFeature._get_inputEntities, MirrorFeature._set_inputEntities, doc="Gets and sets the entities that are mirrored. It can contain faces, features, bodies, or components.\nThe input must all be of a single type. For example, you can't provide a body and a component but\nthe collection must be either all bodies or all components.")

MirrorFeature.__swig_getmethods__["mirrorPlane"] = MirrorFeature._get_mirrorPlane
MirrorFeature.__swig_setmethods__["mirrorPlane"] = MirrorFeature._set_mirrorPlane
MirrorFeature.mirrorPlane = property(MirrorFeature._get_mirrorPlane, MirrorFeature._set_mirrorPlane, doc="Gets and sets the mirror plane. This can be either a planar face or construction plane.\nThis works only for parametric features.")

MirrorFeature.__swig_getmethods__["patternElements"] = MirrorFeature._get_patternElements
MirrorFeature.patternElements = property(MirrorFeature._get_patternElements, doc="Gets the PatternElements collection that contains the elements created by this pattern.")

MirrorFeature.__swig_getmethods__["resultFeatures"] = MirrorFeature._get_resultFeatures
MirrorFeature.resultFeatures = property(MirrorFeature._get_resultFeatures, doc="Get the features that were created for this mirror.\nReturns null in the case where the feature is not parametric.")

MirrorFeature.__swig_getmethods__["nativeObject"] = MirrorFeature._get_nativeObject
MirrorFeature.nativeObject = property(MirrorFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

MirrorFeature.__swig_getmethods__["patternComputeOption"] = MirrorFeature._get_patternComputeOption
MirrorFeature.__swig_setmethods__["patternComputeOption"] = MirrorFeature._set_patternComputeOption
MirrorFeature.patternComputeOption = property(MirrorFeature._get_patternComputeOption, MirrorFeature._set_patternComputeOption, doc="Gets and sets the compute option for this mirror feature.\nThis property only applies when mirroring features and is ignored in the direct modeling environment.")

MirrorFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MirrorFeature) else None
MirrorFeature.cast = lambda arg: arg if isinstance(arg, MirrorFeature) else None

class ModelParameter(Parameter):
    """Represents a Model Parameter."""
    __swig_setmethods__ = {}
    for _s in [Parameter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModelParameter, name, value)
    __swig_getmethods__ = {}
    for _s in [Parameter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ModelParameter, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ModelParameter *" : return _fusion.ModelParameter___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ModelParameter___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ModelParameter___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ModelParameter_classType
    if _newclass:classType = staticmethod(_fusion.ModelParameter_classType)
    __swig_destroy__ = _fusion.delete_ModelParameter
    __del__ = lambda self : None;
    def _get_modelParameters(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameters >" :
        """Returns the Collection containing the ModelParameter."""
        return _fusion.ModelParameter__get_modelParameters(self)

    def _get_component(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the Component containing the ModelParameter."""
        return _fusion.ModelParameter__get_component(self)

    def _get_role(self) -> "std::string" :
        """
        This property identifies what the parameter is used for. For an extrude, it 
        could be 'Depth', for a Workplane it could be 'Offset'.
        """
        return _fusion.ModelParameter__get_role(self)

    def _get_createdBy(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the object that created this parameter. For example,
        a feature, a sketch dimension, or a construction plane.
        """
        return _fusion.ModelParameter__get_createdBy(self)

    def _get_value(self) -> "double" :
        """
        Gets and sets the real value (a double) of the parameter in database units. 
        Setting this property will set/reset the expression value for this parameter
        """
        return _fusion.ModelParameter__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """
        Gets and sets the real value (a double) of the parameter in database units. 
        Setting this property will set/reset the expression value for this parameter
        """
        return _fusion.ModelParameter__set_value(self, *args)

    def _get_expression(self) -> "std::string" :
        """Gets and sets the expression (ie. '22.064 mm') used to calculate the value of the parameter"""
        return _fusion.ModelParameter__get_expression(self)

    def _set_expression(self, *args) -> "bool" :
        """Gets and sets the expression (ie. '22.064 mm') used to calculate the value of the parameter"""
        return _fusion.ModelParameter__set_expression(self, *args)

    def _get_name(self) -> "std::string" :
        """
        Gets and sets the name of the parameter. Setting the name can fail if the name 
        is not unique with respect to all other parameters in the design.
        """
        return _fusion.ModelParameter__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """
        Gets and sets the name of the parameter. Setting the name can fail if the name 
        is not unique with respect to all other parameters in the design.
        """
        return _fusion.ModelParameter__set_name(self, *args)

    def _get_unit(self) -> "std::string" :
        """
        The unit type associated with this parameter. An empty string is returned for parameters
        that don't have a unit type.
        """
        return _fusion.ModelParameter__get_unit(self)

    def _get_comment(self) -> "std::string" :
        """The comment associated with this parameter"""
        return _fusion.ModelParameter__get_comment(self)

    def _set_comment(self, *args) -> "bool" :
        """The comment associated with this parameter"""
        return _fusion.ModelParameter__set_comment(self, *args)

    def _get_isFavorite(self) -> "bool" :
        """
        Gets and sets whether this parameter is included in the Favorites list in the
        parameters dialog
        """
        return _fusion.ModelParameter__get_isFavorite(self)

    def _set_isFavorite(self, *args) -> "bool" :
        """
        Gets and sets whether this parameter is included in the Favorites list in the
        parameters dialog
        """
        return _fusion.ModelParameter__set_isFavorite(self, *args)

    def _get_dependentParameters(self) -> "adsk::core::Ptr< adsk::fusion::ParameterList >" :
        """
        Returns a list of parameters that are dependent on this parameter as a result
        of this parameter being referenced in their equation.
        """
        return _fusion.ModelParameter__get_dependentParameters(self)

    def _get_isDeletable(self) -> "bool" :
        """
        Gets if this parameter can be deleted. Parameters that cannot be deleted are: Model Parameters and 
        User Parameters that have dependents.
        """
        return _fusion.ModelParameter__get_isDeletable(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.ModelParameter__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ModelParameter__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ModelParameter__get_isValid(self)
ModelParameter_swigregister = _fusion.ModelParameter_swigregister
ModelParameter_swigregister(ModelParameter)

def ModelParameter_classType() -> "char const *" :
  return _fusion.ModelParameter_classType()
ModelParameter_classType = _fusion.ModelParameter_classType

ModelParameter.__swig_getmethods__["modelParameters"] = ModelParameter._get_modelParameters
ModelParameter.modelParameters = property(ModelParameter._get_modelParameters, doc="Returns the Collection containing the ModelParameter.")

ModelParameter.__swig_getmethods__["component"] = ModelParameter._get_component
ModelParameter.component = property(ModelParameter._get_component, doc="Returns the Component containing the ModelParameter.")

ModelParameter.__swig_getmethods__["role"] = ModelParameter._get_role
ModelParameter.role = property(ModelParameter._get_role, doc="This property identifies what the parameter is used for. For an extrude, it\ncould be 'Depth', for a Workplane it could be 'Offset'.")

ModelParameter.__swig_getmethods__["createdBy"] = ModelParameter._get_createdBy
ModelParameter.createdBy = property(ModelParameter._get_createdBy, doc="Returns the object that created this parameter. For example,\na feature, a sketch dimension, or a construction plane.")

ModelParameter.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ModelParameter) else None
ModelParameter.cast = lambda arg: arg if isinstance(arg, ModelParameter) else None

class MoveFeature(Feature):
    """Object that represents an existing move feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoveFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MoveFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::MoveFeature *" : return _fusion.MoveFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.MoveFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.MoveFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.MoveFeature_classType
    if _newclass:classType = staticmethod(_fusion.MoveFeature_classType)
    __swig_destroy__ = _fusion.delete_MoveFeature
    __del__ = lambda self : None;
    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the entities to move.
        This collection can only contain BRepBody objects in parametric modeling.
        """
        return _fusion.MoveFeature__get_inputEntities(self)

    def _set_inputEntities(self, *args) -> "bool" :
        """
        Gets and sets the entities to move.
        This collection can only contain BRepBody objects in parametric modeling.
        """
        return _fusion.MoveFeature__set_inputEntities(self, *args)

    def _get_transform(self) -> "adsk::core::Ptr< adsk::core::Matrix3D >" :
        """Gets and sets the move transform of the input bodies."""
        return _fusion.MoveFeature__get_transform(self)

    def _set_transform(self, *args) -> "bool" :
        """Gets and sets the move transform of the input bodies."""
        return _fusion.MoveFeature__set_transform(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::MoveFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.MoveFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::MoveFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.MoveFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.MoveFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.MoveFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.MoveFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.MoveFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.MoveFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.MoveFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.MoveFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.MoveFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.MoveFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.MoveFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.MoveFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.MoveFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.MoveFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.MoveFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.MoveFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.MoveFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.MoveFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.MoveFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.MoveFeature__get_isValid(self)
MoveFeature_swigregister = _fusion.MoveFeature_swigregister
MoveFeature_swigregister(MoveFeature)

def MoveFeature_classType() -> "char const *" :
  return _fusion.MoveFeature_classType()
MoveFeature_classType = _fusion.MoveFeature_classType

MoveFeature.__swig_getmethods__["inputEntities"] = MoveFeature._get_inputEntities
MoveFeature.__swig_setmethods__["inputEntities"] = MoveFeature._set_inputEntities
MoveFeature.inputEntities = property(MoveFeature._get_inputEntities, MoveFeature._set_inputEntities, doc="Gets and sets the entities to move.\nThis collection can only contain BRepBody objects in parametric modeling.")

MoveFeature.__swig_getmethods__["transform"] = MoveFeature._get_transform
MoveFeature.__swig_setmethods__["transform"] = MoveFeature._set_transform
MoveFeature.transform = property(MoveFeature._get_transform, MoveFeature._set_transform, doc="Gets and sets the move transform of the input bodies.")

MoveFeature.__swig_getmethods__["nativeObject"] = MoveFeature._get_nativeObject
MoveFeature.nativeObject = property(MoveFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

MoveFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, MoveFeature) else None
MoveFeature.cast = lambda arg: arg if isinstance(arg, MoveFeature) else None

class OffsetConstraint(GeometricConstraint):
    """An offset constraint in a sketch."""
    __swig_setmethods__ = {}
    for _s in [GeometricConstraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OffsetConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricConstraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OffsetConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::OffsetConstraint *" : return _fusion.OffsetConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.OffsetConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.OffsetConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.OffsetConstraint_classType
    if _newclass:classType = staticmethod(_fusion.OffsetConstraint_classType)
    __swig_destroy__ = _fusion.delete_OffsetConstraint
    __del__ = lambda self : None;
    def _get_parentCurves(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve >,std::allocator< adsk::core::Ptr< adsk::fusion::SketchCurve > > >" :
        """
        Returns an array of sketch curves that are the set of parent curves.
        Nothing should be assumed about the order in how the curves are returned.
        """
        return _fusion.OffsetConstraint__get_parentCurves(self)

    def _get_childCurves(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve >,std::allocator< adsk::core::Ptr< adsk::fusion::SketchCurve > > >" :
        """
        Returns an array of sketch curves that are the set of child curves resulting from the offset.
        Nothing should be assumed about the order in how the curves are returned.
        """
        return _fusion.OffsetConstraint__get_childCurves(self)

    def _get_distance(self) -> "double" :
        """
        The current distance of the offset in centimeters. To change the offset you need to
        modify the value of the parameter associated with the dimension, which you can get
        using the dimension property.
        """
        return _fusion.OffsetConstraint__get_distance(self)

    def _get_dimension(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimension >" :
        """
        Returns the dimension controlling the offset distance. This can return null in the 
        case where the dimension has been deleted. To change the offset distance you can use
        the parameter property of the returned dimension to get the parameter that controls the value and
        use properties on the parameter to change the value. This can return either a SketchOffsetCurvesDimension
        or an SketchOffsetDimension. A SketchOffsetCurvesDimension is created automatically when curves are
        offset but if it is deleted the offset can also be controlled by a SketchOffsetDimension.
        """
        return _fusion.OffsetConstraint__get_dimension(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::OffsetConstraint >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.OffsetConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::OffsetConstraint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.OffsetConstraint_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.OffsetConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.OffsetConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.OffsetConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.OffsetConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.OffsetConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.OffsetConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.OffsetConstraint__get_isValid(self)
OffsetConstraint_swigregister = _fusion.OffsetConstraint_swigregister
OffsetConstraint_swigregister(OffsetConstraint)

def OffsetConstraint_classType() -> "char const *" :
  return _fusion.OffsetConstraint_classType()
OffsetConstraint_classType = _fusion.OffsetConstraint_classType

OffsetConstraint.__swig_getmethods__["parentCurves"] = OffsetConstraint._get_parentCurves
OffsetConstraint.parentCurves = property(OffsetConstraint._get_parentCurves, doc="Returns an array of sketch curves that are the set of parent curves.\nNothing should be assumed about the order in how the curves are returned.")

OffsetConstraint.__swig_getmethods__["childCurves"] = OffsetConstraint._get_childCurves
OffsetConstraint.childCurves = property(OffsetConstraint._get_childCurves, doc="Returns an array of sketch curves that are the set of child curves resulting from the offset.\nNothing should be assumed about the order in how the curves are returned.")

OffsetConstraint.__swig_getmethods__["distance"] = OffsetConstraint._get_distance
OffsetConstraint.distance = property(OffsetConstraint._get_distance, doc="The current distance of the offset in centimeters. To change the offset you need to\nmodify the value of the parameter associated with the dimension, which you can get\nusing the dimension property.")

OffsetConstraint.__swig_getmethods__["dimension"] = OffsetConstraint._get_dimension
OffsetConstraint.dimension = property(OffsetConstraint._get_dimension, doc="Returns the dimension controlling the offset distance. This can return null in the\ncase where the dimension has been deleted. To change the offset distance you can use\nthe parameter property of the returned dimension to get the parameter that controls the value and\nuse properties on the parameter to change the value. This can return either a SketchOffsetCurvesDimension\nor an SketchOffsetDimension. A SketchOffsetCurvesDimension is created automatically when curves are\noffset but if it is deleted the offset can also be controlled by a SketchOffsetDimension.")

OffsetConstraint.__swig_getmethods__["nativeObject"] = OffsetConstraint._get_nativeObject
OffsetConstraint.nativeObject = property(OffsetConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

OffsetConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, OffsetConstraint) else None
OffsetConstraint.cast = lambda arg: arg if isinstance(arg, OffsetConstraint) else None

class OffsetFacesFeature(Feature):
    """
    Object that represents an existing Offset Face feature in a design.
    Offset Face features are created in the UI using the 'Press Pull' command.
    """
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OffsetFacesFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OffsetFacesFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::OffsetFacesFeature *" : return _fusion.OffsetFacesFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.OffsetFacesFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.OffsetFacesFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.OffsetFacesFeature_classType
    if _newclass:classType = staticmethod(_fusion.OffsetFacesFeature_classType)
    __swig_destroy__ = _fusion.delete_OffsetFacesFeature
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.OffsetFacesFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.OffsetFacesFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.OffsetFacesFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.OffsetFacesFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.OffsetFacesFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.OffsetFacesFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.OffsetFacesFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.OffsetFacesFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.OffsetFacesFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.OffsetFacesFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.OffsetFacesFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.OffsetFacesFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.OffsetFacesFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.OffsetFacesFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.OffsetFacesFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.OffsetFacesFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.OffsetFacesFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.OffsetFacesFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.OffsetFacesFeature__get_isValid(self)
OffsetFacesFeature_swigregister = _fusion.OffsetFacesFeature_swigregister
OffsetFacesFeature_swigregister(OffsetFacesFeature)

def OffsetFacesFeature_classType() -> "char const *" :
  return _fusion.OffsetFacesFeature_classType()
OffsetFacesFeature_classType = _fusion.OffsetFacesFeature_classType

OffsetFacesFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, OffsetFacesFeature) else None
OffsetFacesFeature.cast = lambda arg: arg if isinstance(arg, OffsetFacesFeature) else None

class OffsetFeature(Feature):
    """Object that represents an existing offset feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OffsetFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OffsetFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::OffsetFeature *" : return _fusion.OffsetFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.OffsetFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.OffsetFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.OffsetFeature_classType
    if _newclass:classType = staticmethod(_fusion.OffsetFeature_classType)
    __swig_destroy__ = _fusion.delete_OffsetFeature
    __del__ = lambda self : None;
    def setInputEntities(self, *args) -> "bool" :
        """
        Sets the faces and sheet bodies to offset 
        entities : An ObjectCollection containing the BRepFace objects to offset. Additional faces may be
        automatically used depending on the value of the isChainSelection argument.
        Input faces need not be from the same body. 
        isChainSelection : A boolean value for setting whether or not faces that are tangentially connected to 
        the input faces (if any) will also be offset. The default value is true. 
        Returns true if successful
        """
        return _fusion.OffsetFeature_setInputEntities(self, *args)

    def _get_entities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """Gets and sets the faces to be offset."""
        return _fusion.OffsetFeature__get_entities(self)

    def _set_entities(self, *args) -> "bool" :
        """Gets and sets the faces to be offset."""
        return _fusion.OffsetFeature__set_entities(self, *args)

    def _get_isChainSelection(self) -> "bool" :
        """Get if the faces that are tangentially connected to the input faces (if any) are also offset."""
        return _fusion.OffsetFeature__get_isChainSelection(self)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter controlling the offset distance. You can edit the distance
        by editing the value of the parameter object. A positive value specifies that the offset
        is in the same direction as the normal direction of the face.
        """
        return _fusion.OffsetFeature__get_distance(self)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """
        Gets the feature operation that was performed when the feature was created, 
        (either 'NewBodyFeatureOperation' or 'NewComponentFeatureOperation'.
        """
        return _fusion.OffsetFeature__get_operation(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::OffsetFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.OffsetFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::OffsetFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.OffsetFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.OffsetFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.OffsetFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.OffsetFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.OffsetFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.OffsetFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.OffsetFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.OffsetFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.OffsetFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.OffsetFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.OffsetFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.OffsetFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.OffsetFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.OffsetFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.OffsetFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.OffsetFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.OffsetFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.OffsetFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.OffsetFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.OffsetFeature__get_isValid(self)
OffsetFeature_swigregister = _fusion.OffsetFeature_swigregister
OffsetFeature_swigregister(OffsetFeature)

def OffsetFeature_classType() -> "char const *" :
  return _fusion.OffsetFeature_classType()
OffsetFeature_classType = _fusion.OffsetFeature_classType

OffsetFeature.__swig_getmethods__["entities"] = OffsetFeature._get_entities
OffsetFeature.__swig_setmethods__["entities"] = OffsetFeature._set_entities
OffsetFeature.entities = property(OffsetFeature._get_entities, OffsetFeature._set_entities, doc="Gets and sets the faces to be offset.")

OffsetFeature.__swig_getmethods__["isChainSelection"] = OffsetFeature._get_isChainSelection
OffsetFeature.isChainSelection = property(OffsetFeature._get_isChainSelection, doc="Get if the faces that are tangentially connected to the input faces (if any) are also offset.")

OffsetFeature.__swig_getmethods__["distance"] = OffsetFeature._get_distance
OffsetFeature.distance = property(OffsetFeature._get_distance, doc="Returns the parameter controlling the offset distance. You can edit the distance\nby editing the value of the parameter object. A positive value specifies that the offset\nis in the same direction as the normal direction of the face.")

OffsetFeature.__swig_getmethods__["operation"] = OffsetFeature._get_operation
OffsetFeature.operation = property(OffsetFeature._get_operation, doc="Gets the feature operation that was performed when the feature was created,\n(either 'NewBodyFeatureOperation' or 'NewComponentFeatureOperation'.")

OffsetFeature.__swig_getmethods__["nativeObject"] = OffsetFeature._get_nativeObject
OffsetFeature.nativeObject = property(OffsetFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

OffsetFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, OffsetFeature) else None
OffsetFeature.cast = lambda arg: arg if isinstance(arg, OffsetFeature) else None

class OffsetStartDefinition(ExtentDefinition):
    """
    A definition object that is used to define a feature whose start plane is defined as plane that is
    offset from the sketch plane of the profile.
    """
    __swig_setmethods__ = {}
    for _s in [ExtentDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OffsetStartDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ExtentDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OffsetStartDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::OffsetStartDefinition *" : return _fusion.OffsetStartDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.OffsetStartDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.OffsetStartDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.OffsetStartDefinition_classType
    if _newclass:classType = staticmethod(_fusion.OffsetStartDefinition_classType)
    __swig_getmethods__["create"] = lambda x: _fusion.OffsetStartDefinition_create
    if _newclass:create = staticmethod(_fusion.OffsetStartDefinition_create)
    __swig_destroy__ = _fusion.delete_OffsetStartDefinition
    __del__ = lambda self : None;
    def _get_offset(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the currently defined offset value. If the ProfilePlaneWithOffsetDefinition object was
        created statically and is not associated with a feature, this will return a ValueInput object.
        if the ProfilePlaneWithOffsetDefinition is associated with an existing feature, this will return
        the parameter that was created when the feature was created. To edit the offset, use properties
        on the parameter to change the value of the parameter.
        """
        return _fusion.OffsetStartDefinition__get_offset(self)

    def _get_profilePlane(self) -> "adsk::core::Ptr< adsk::core::Plane >" :
        """Returns the geometric definition of the profile plane."""
        return _fusion.OffsetStartDefinition__get_profilePlane(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        """
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.OffsetStartDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.OffsetStartDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.OffsetStartDefinition__get_isValid(self)
OffsetStartDefinition_swigregister = _fusion.OffsetStartDefinition_swigregister
OffsetStartDefinition_swigregister(OffsetStartDefinition)

def OffsetStartDefinition_classType() -> "char const *" :
  return _fusion.OffsetStartDefinition_classType()
OffsetStartDefinition_classType = _fusion.OffsetStartDefinition_classType

def OffsetStartDefinition_create(*args) -> "adsk::core::Ptr< adsk::core::ValueInput > const &" :
  return _fusion.OffsetStartDefinition_create(*args)
OffsetStartDefinition_create = _fusion.OffsetStartDefinition_create

OffsetStartDefinition.__swig_getmethods__["offset"] = OffsetStartDefinition._get_offset
OffsetStartDefinition.offset = property(OffsetStartDefinition._get_offset, doc="Gets the currently defined offset value. If the ProfilePlaneWithOffsetDefinition object was\ncreated statically and is not associated with a feature, this will return a ValueInput object.\nif the ProfilePlaneWithOffsetDefinition is associated with an existing feature, this will return\nthe parameter that was created when the feature was created. To edit the offset, use properties\non the parameter to change the value of the parameter.")

OffsetStartDefinition.__swig_getmethods__["profilePlane"] = OffsetStartDefinition._get_profilePlane
OffsetStartDefinition.profilePlane = property(OffsetStartDefinition._get_profilePlane, doc="Returns the geometric definition of the profile plane.")

OffsetStartDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, OffsetStartDefinition) else None
OffsetStartDefinition.cast = lambda arg: arg if isinstance(arg, OffsetStartDefinition) else None

class OnEdgeHolePositionDefinition(HolePositionDefinition):
    """
    Provides positioning information for a hole that is positioned
    on the start, end or center of an edge.
    """
    __swig_setmethods__ = {}
    for _s in [HolePositionDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OnEdgeHolePositionDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [HolePositionDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OnEdgeHolePositionDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::OnEdgeHolePositionDefinition *" : return _fusion.OnEdgeHolePositionDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.OnEdgeHolePositionDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.OnEdgeHolePositionDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.OnEdgeHolePositionDefinition_classType
    if _newclass:classType = staticmethod(_fusion.OnEdgeHolePositionDefinition_classType)
    __swig_destroy__ = _fusion.delete_OnEdgeHolePositionDefinition
    __del__ = lambda self : None;
    def _get_planarEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the plane that defines the orientation and start of the hole."""
        return _fusion.OnEdgeHolePositionDefinition__get_planarEntity(self)

    def _get_edge(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdge >" :
        """Returns the edge the hole is positioned on."""
        return _fusion.OnEdgeHolePositionDefinition__get_edge(self)

    def _get_position(self) -> "adsk::fusion::HoleEdgePositions" :
        """
        Returns the position of the hole on the edge.
        The hole can be at the start, midpoint, or end of the edge.
        """
        return _fusion.OnEdgeHolePositionDefinition__get_position(self)

    def _get_objectType(self) -> "char const *" : return _fusion.OnEdgeHolePositionDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.OnEdgeHolePositionDefinition__get_isValid(self)
OnEdgeHolePositionDefinition_swigregister = _fusion.OnEdgeHolePositionDefinition_swigregister
OnEdgeHolePositionDefinition_swigregister(OnEdgeHolePositionDefinition)

def OnEdgeHolePositionDefinition_classType() -> "char const *" :
  return _fusion.OnEdgeHolePositionDefinition_classType()
OnEdgeHolePositionDefinition_classType = _fusion.OnEdgeHolePositionDefinition_classType

OnEdgeHolePositionDefinition.__swig_getmethods__["planarEntity"] = OnEdgeHolePositionDefinition._get_planarEntity
OnEdgeHolePositionDefinition.planarEntity = property(OnEdgeHolePositionDefinition._get_planarEntity, doc="Returns the plane that defines the orientation and start of the hole.")

OnEdgeHolePositionDefinition.__swig_getmethods__["edge"] = OnEdgeHolePositionDefinition._get_edge
OnEdgeHolePositionDefinition.edge = property(OnEdgeHolePositionDefinition._get_edge, doc="Returns the edge the hole is positioned on.")

OnEdgeHolePositionDefinition.__swig_getmethods__["position"] = OnEdgeHolePositionDefinition._get_position
OnEdgeHolePositionDefinition.position = property(OnEdgeHolePositionDefinition._get_position, doc="Returns the position of the hole on the edge.\nThe hole can be at the start, midpoint, or end of the edge.")

OnEdgeHolePositionDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, OnEdgeHolePositionDefinition) else None
OnEdgeHolePositionDefinition.cast = lambda arg: arg if isinstance(arg, OnEdgeHolePositionDefinition) else None

class OneSideToExtentDefinition(ExtentDefinition):
    """
    Defines the inputs for a OneSideToExtentDefinition object.
    This defines a feature extent that goes up to a face or construction plane in one direction.
    """
    __swig_setmethods__ = {}
    for _s in [ExtentDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OneSideToExtentDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ExtentDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OneSideToExtentDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::OneSideToExtentDefinition *" : return _fusion.OneSideToExtentDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.OneSideToExtentDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.OneSideToExtentDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.OneSideToExtentDefinition_classType
    if _newclass:classType = staticmethod(_fusion.OneSideToExtentDefinition_classType)
    __swig_destroy__ = _fusion.delete_OneSideToExtentDefinition
    __del__ = lambda self : None;
    def _get_toEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the entity that defines the extent. The valid types of entities can vary depending on
        the type of feature this is being used with.
        """
        return _fusion.OneSideToExtentDefinition__get_toEntity(self)

    def _set_toEntity(self, *args) -> "bool" :
        """
        Gets and sets the entity that defines the extent. The valid types of entities can vary depending on
        the type of feature this is being used with.
        """
        return _fusion.OneSideToExtentDefinition__set_toEntity(self, *args)

    def _get_matchShape(self) -> "bool" :
        """
        Specifies if the face should be extended or use adjacent faces if necessary to define the termination 
        of the extrusion.
        When used for a revolve feature this is ignored and is always treated as true.
        """
        return _fusion.OneSideToExtentDefinition__get_matchShape(self)

    def _set_matchShape(self, *args) -> "bool" :
        """
        Specifies if the face should be extended or use adjacent faces if necessary to define the termination 
        of the extrusion.
        When used for a revolve feature this is ignored and is always treated as true.
        """
        return _fusion.OneSideToExtentDefinition__set_matchShape(self, *args)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        """
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.OneSideToExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.OneSideToExtentDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.OneSideToExtentDefinition__get_isValid(self)
OneSideToExtentDefinition_swigregister = _fusion.OneSideToExtentDefinition_swigregister
OneSideToExtentDefinition_swigregister(OneSideToExtentDefinition)

def OneSideToExtentDefinition_classType() -> "char const *" :
  return _fusion.OneSideToExtentDefinition_classType()
OneSideToExtentDefinition_classType = _fusion.OneSideToExtentDefinition_classType

OneSideToExtentDefinition.__swig_getmethods__["toEntity"] = OneSideToExtentDefinition._get_toEntity
OneSideToExtentDefinition.__swig_setmethods__["toEntity"] = OneSideToExtentDefinition._set_toEntity
OneSideToExtentDefinition.toEntity = property(OneSideToExtentDefinition._get_toEntity, OneSideToExtentDefinition._set_toEntity, doc="Gets and sets the entity that defines the extent. The valid types of entities can vary depending on\nthe type of feature this is being used with.")

OneSideToExtentDefinition.__swig_getmethods__["matchShape"] = OneSideToExtentDefinition._get_matchShape
OneSideToExtentDefinition.__swig_setmethods__["matchShape"] = OneSideToExtentDefinition._set_matchShape
OneSideToExtentDefinition.matchShape = property(OneSideToExtentDefinition._get_matchShape, OneSideToExtentDefinition._set_matchShape, doc="Specifies if the face should be extended or use adjacent faces if necessary to define the termination\nof the extrusion.\nWhen used for a revolve feature this is ignored and is always treated as true.")

OneSideToExtentDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, OneSideToExtentDefinition) else None
OneSideToExtentDefinition.cast = lambda arg: arg if isinstance(arg, OneSideToExtentDefinition) else None

class ParallelConstraint(GeometricConstraint):
    """A parallel constraint in a sketch."""
    __swig_setmethods__ = {}
    for _s in [GeometricConstraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParallelConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricConstraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ParallelConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ParallelConstraint *" : return _fusion.ParallelConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ParallelConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ParallelConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ParallelConstraint_classType
    if _newclass:classType = staticmethod(_fusion.ParallelConstraint_classType)
    __swig_destroy__ = _fusion.delete_ParallelConstraint
    __del__ = lambda self : None;
    def _get_lineOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """Returns the first line."""
        return _fusion.ParallelConstraint__get_lineOne(self)

    def _get_lineTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """Returns the second line."""
        return _fusion.ParallelConstraint__get_lineTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ParallelConstraint >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ParallelConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::ParallelConstraint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ParallelConstraint_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.ParallelConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.ParallelConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.ParallelConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ParallelConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.ParallelConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ParallelConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ParallelConstraint__get_isValid(self)
ParallelConstraint_swigregister = _fusion.ParallelConstraint_swigregister
ParallelConstraint_swigregister(ParallelConstraint)

def ParallelConstraint_classType() -> "char const *" :
  return _fusion.ParallelConstraint_classType()
ParallelConstraint_classType = _fusion.ParallelConstraint_classType

ParallelConstraint.__swig_getmethods__["lineOne"] = ParallelConstraint._get_lineOne
ParallelConstraint.lineOne = property(ParallelConstraint._get_lineOne, doc="Returns the first line.")

ParallelConstraint.__swig_getmethods__["lineTwo"] = ParallelConstraint._get_lineTwo
ParallelConstraint.lineTwo = property(ParallelConstraint._get_lineTwo, doc="Returns the second line.")

ParallelConstraint.__swig_getmethods__["nativeObject"] = ParallelConstraint._get_nativeObject
ParallelConstraint.nativeObject = property(ParallelConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

ParallelConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ParallelConstraint) else None
ParallelConstraint.cast = lambda arg: arg if isinstance(arg, ParallelConstraint) else None

class PatchFeature(Feature):
    """Object that represents an existing patch feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PatchFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PatchFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PatchFeature *" : return _fusion.PatchFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PatchFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PatchFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PatchFeature_classType
    if _newclass:classType = staticmethod(_fusion.PatchFeature_classType)
    __swig_destroy__ = _fusion.delete_PatchFeature
    __del__ = lambda self : None;
    def _get_boundaryCurve(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns an ObjectCollection that contains all of the sketch curves or B-Rep edges
        that define the closed outer boundary of the patch feature.
        When setting this property, the input can be a sketch profile, a single sketch curve, a single B-Rep edge, 
        or an ObjectCollection of sketch curves or B-Rep edges. 
        If a single sketch curve or B-Rep edge is input, that is not closed, Fusion 360 will automatically find connected sketch curves 
        or B-Rep edges in order to define a closed loop. All sketch curves are valid as input. BRepEdges are valid if they are 
        an 'open' edge, which means they are only used by one face.
        If an ObjectCollection of sketch curves or B-Rep edges is input they must define a closed shape and the B-Rep 
        edges must be valid 'open' edges.
        """
        return _fusion.PatchFeature__get_boundaryCurve(self)

    def _set_boundaryCurve(self, *args) -> "bool" :
        """
        Returns an ObjectCollection that contains all of the sketch curves or B-Rep edges
        that define the closed outer boundary of the patch feature.
        When setting this property, the input can be a sketch profile, a single sketch curve, a single B-Rep edge, 
        or an ObjectCollection of sketch curves or B-Rep edges. 
        If a single sketch curve or B-Rep edge is input, that is not closed, Fusion 360 will automatically find connected sketch curves 
        or B-Rep edges in order to define a closed loop. All sketch curves are valid as input. BRepEdges are valid if they are 
        an 'open' edge, which means they are only used by one face.
        If an ObjectCollection of sketch curves or B-Rep edges is input they must define a closed shape and the B-Rep 
        edges must be valid 'open' edges.
        """
        return _fusion.PatchFeature__set_boundaryCurve(self, *args)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """Gets the type of operation performed by the patch feature."""
        return _fusion.PatchFeature__get_operation(self)

    def _get_continuity(self) -> "adsk::fusion::SurfaceContinuityTypes" :
        """
        Gets and sets the type of surface continuity used when creating the patch face. This is only used when BRepEdges are input and 
        defines the continuity of how the patch face connects to the face adjacent to each of the input edges.
        """
        return _fusion.PatchFeature__get_continuity(self)

    def _set_continuity(self, *args) -> "bool" :
        """
        Gets and sets the type of surface continuity used when creating the patch face. This is only used when BRepEdges are input and 
        defines the continuity of how the patch face connects to the face adjacent to each of the input edges.
        """
        return _fusion.PatchFeature__set_continuity(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::PatchFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.PatchFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::PatchFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.PatchFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.PatchFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.PatchFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.PatchFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.PatchFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.PatchFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.PatchFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.PatchFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.PatchFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.PatchFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.PatchFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.PatchFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.PatchFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.PatchFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.PatchFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.PatchFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.PatchFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.PatchFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.PatchFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PatchFeature__get_isValid(self)
PatchFeature_swigregister = _fusion.PatchFeature_swigregister
PatchFeature_swigregister(PatchFeature)

def PatchFeature_classType() -> "char const *" :
  return _fusion.PatchFeature_classType()
PatchFeature_classType = _fusion.PatchFeature_classType

PatchFeature.__swig_getmethods__["boundaryCurve"] = PatchFeature._get_boundaryCurve
PatchFeature.__swig_setmethods__["boundaryCurve"] = PatchFeature._set_boundaryCurve
PatchFeature.boundaryCurve = property(PatchFeature._get_boundaryCurve, PatchFeature._set_boundaryCurve, doc="Returns an ObjectCollection that contains all of the sketch curves or B-Rep edges\nthat define the closed outer boundary of the patch feature.\nWhen setting this property, the input can be a sketch profile, a single sketch curve, a single B-Rep edge,\nor an ObjectCollection of sketch curves or B-Rep edges.\nIf a single sketch curve or B-Rep edge is input, that is not closed, Fusion 360 will automatically find connected sketch curves\nor B-Rep edges in order to define a closed loop. All sketch curves are valid as input. BRepEdges are valid if they are\nan 'open' edge, which means they are only used by one face.\nIf an ObjectCollection of sketch curves or B-Rep edges is input they must define a closed shape and the B-Rep\nedges must be valid 'open' edges.")

PatchFeature.__swig_getmethods__["operation"] = PatchFeature._get_operation
PatchFeature.operation = property(PatchFeature._get_operation, doc="Gets the type of operation performed by the patch feature.")

PatchFeature.__swig_getmethods__["continuity"] = PatchFeature._get_continuity
PatchFeature.__swig_setmethods__["continuity"] = PatchFeature._set_continuity
PatchFeature.continuity = property(PatchFeature._get_continuity, PatchFeature._set_continuity, doc="Gets and sets the type of surface continuity used when creating the patch face. This is only used when BRepEdges are input and\ndefines the continuity of how the patch face connects to the face adjacent to each of the input edges.")

PatchFeature.__swig_getmethods__["nativeObject"] = PatchFeature._get_nativeObject
PatchFeature.nativeObject = property(PatchFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

PatchFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PatchFeature) else None
PatchFeature.cast = lambda arg: arg if isinstance(arg, PatchFeature) else None

class PathPatternFeature(Feature):
    """Object that represents an existing path pattern feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PathPatternFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PathPatternFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PathPatternFeature *" : return _fusion.PathPatternFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PathPatternFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PathPatternFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PathPatternFeature_classType
    if _newclass:classType = staticmethod(_fusion.PathPatternFeature_classType)
    __swig_destroy__ = _fusion.delete_PathPatternFeature
    __del__ = lambda self : None;
    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        """
        return _fusion.PathPatternFeature__get_inputEntities(self)

    def _set_inputEntities(self, *args) -> "bool" :
        """
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        """
        return _fusion.PathPatternFeature__set_inputEntities(self, *args)

    def _get_path(self) -> "adsk::core::Ptr< adsk::fusion::Path >" :
        """Gets and sets the path to create the pattern on path."""
        return _fusion.PathPatternFeature__get_path(self)

    def _set_path(self, *args) -> "bool" :
        """Gets and sets the path to create the pattern on path."""
        return _fusion.PathPatternFeature__set_path(self, *args)

    def _get_quantity(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the quantity of the elements.
        Edit the value through ModelParameter.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.PathPatternFeature__get_quantity(self)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the distance.
        Edit the value through ModelParameter.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.PathPatternFeature__get_distance(self)

    def _get_startPoint(self) -> "double" :
        """
        Gets and sets the start point on the path to count the distance.
        It's between 0 and 1. 0 means start point of the path, 1 means end point of the path.
        """
        return _fusion.PathPatternFeature__get_startPoint(self)

    def _set_startPoint(self, *args) -> "bool" :
        """
        Gets and sets the start point on the path to count the distance.
        It's between 0 and 1. 0 means start point of the path, 1 means end point of the path.
        """
        return _fusion.PathPatternFeature__set_startPoint(self, *args)

    def _get_isFlipDirection(self) -> "bool" :
        """Gets and sets if flip the direction from start point."""
        return _fusion.PathPatternFeature__get_isFlipDirection(self)

    def _set_isFlipDirection(self, *args) -> "bool" :
        """Gets and sets if flip the direction from start point."""
        return _fusion.PathPatternFeature__set_isFlipDirection(self, *args)

    def _get_patternDistanceType(self) -> "adsk::fusion::PatternDistanceType" :
        """Gets and sets how the distance between elements is computed."""
        return _fusion.PathPatternFeature__get_patternDistanceType(self)

    def _set_patternDistanceType(self, *args) -> "bool" :
        """Gets and sets how the distance between elements is computed."""
        return _fusion.PathPatternFeature__set_patternDistanceType(self, *args)

    def _get_isSymmetric(self) -> "bool" :
        """Gets and sets if the pattern is in one direction or symmetric."""
        return _fusion.PathPatternFeature__get_isSymmetric(self)

    def _set_isSymmetric(self, *args) -> "bool" :
        """Gets and sets if the pattern is in one direction or symmetric."""
        return _fusion.PathPatternFeature__set_isSymmetric(self, *args)

    def _get_isOrientationAlongPath(self) -> "bool" :
        """
        Gets and sets if the orientation is along path.
        If false, the orientation is identical.
        """
        return _fusion.PathPatternFeature__get_isOrientationAlongPath(self)

    def _set_isOrientationAlongPath(self, *args) -> "bool" :
        """
        Gets and sets if the orientation is along path.
        If false, the orientation is identical.
        """
        return _fusion.PathPatternFeature__set_isOrientationAlongPath(self, *args)

    def _get_suppressedElementsIds(self) -> "std::vector< size_t,std::allocator< size_t > >" :
        """Gets and sets the id's of the elements to suppress."""
        return _fusion.PathPatternFeature__get_suppressedElementsIds(self)

    def _set_suppressedElementsIds(self, *args) -> "bool" :
        """Gets and sets the id's of the elements to suppress."""
        return _fusion.PathPatternFeature__set_suppressedElementsIds(self, *args)

    def _get_patternElements(self) -> "adsk::core::Ptr< adsk::fusion::PatternElements >" :
        """Gets the PatternElements collection that contains the elements created by this pattern."""
        return _fusion.PathPatternFeature__get_patternElements(self)

    def _get_resultFeatures(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Get the features that were created for this mirror.
        Returns null in the case where the feature is parametric.
        """
        return _fusion.PathPatternFeature__get_resultFeatures(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::PathPatternFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.PathPatternFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::PathPatternFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.PathPatternFeature_createForAssemblyContext(self, *args)

    def _get_patternEntityType(self) -> "adsk::fusion::PatternEntityTypes" :
        """
        Returns the type of entities the pattern consists of. This can be used to help
        determine the type of results that will be found in the pattern elements.
        """
        return _fusion.PathPatternFeature__get_patternEntityType(self)

    def _get_patternComputeOption(self) -> "adsk::fusion::PatternComputeOptions" :
        """
        Gets and sets the compute option for this pattern feature.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        """
        return _fusion.PathPatternFeature__get_patternComputeOption(self)

    def _set_patternComputeOption(self, *args) -> "bool" :
        """
        Gets and sets the compute option for this pattern feature.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        """
        return _fusion.PathPatternFeature__set_patternComputeOption(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.PathPatternFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.PathPatternFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.PathPatternFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.PathPatternFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.PathPatternFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.PathPatternFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.PathPatternFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.PathPatternFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.PathPatternFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.PathPatternFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.PathPatternFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.PathPatternFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.PathPatternFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.PathPatternFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.PathPatternFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.PathPatternFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.PathPatternFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.PathPatternFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PathPatternFeature__get_isValid(self)
PathPatternFeature_swigregister = _fusion.PathPatternFeature_swigregister
PathPatternFeature_swigregister(PathPatternFeature)

def PathPatternFeature_classType() -> "char const *" :
  return _fusion.PathPatternFeature_classType()
PathPatternFeature_classType = _fusion.PathPatternFeature_classType

PathPatternFeature.__swig_getmethods__["inputEntities"] = PathPatternFeature._get_inputEntities
PathPatternFeature.__swig_setmethods__["inputEntities"] = PathPatternFeature._set_inputEntities
PathPatternFeature.inputEntities = property(PathPatternFeature._get_inputEntities, PathPatternFeature._set_inputEntities, doc="Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.\nAll of the entities must be of a single type. For example, it can't contain features and occurrences\nbut only features or occurrences.")

PathPatternFeature.__swig_getmethods__["path"] = PathPatternFeature._get_path
PathPatternFeature.__swig_setmethods__["path"] = PathPatternFeature._set_path
PathPatternFeature.path = property(PathPatternFeature._get_path, PathPatternFeature._set_path, doc="Gets and sets the path to create the pattern on path.")

PathPatternFeature.__swig_getmethods__["quantity"] = PathPatternFeature._get_quantity
PathPatternFeature.quantity = property(PathPatternFeature._get_quantity, doc="Gets the quantity of the elements.\nEdit the value through ModelParameter.\nReturns nothing in the case where the feature is non-parametric.")

PathPatternFeature.__swig_getmethods__["distance"] = PathPatternFeature._get_distance
PathPatternFeature.distance = property(PathPatternFeature._get_distance, doc="Gets the distance.\nEdit the value through ModelParameter.\nReturns nothing in the case where the feature is non-parametric.")

PathPatternFeature.__swig_getmethods__["startPoint"] = PathPatternFeature._get_startPoint
PathPatternFeature.__swig_setmethods__["startPoint"] = PathPatternFeature._set_startPoint
PathPatternFeature.startPoint = property(PathPatternFeature._get_startPoint, PathPatternFeature._set_startPoint, doc="Gets and sets the start point on the path to count the distance.\nIt's between 0 and 1. 0 means start point of the path, 1 means end point of the path.")

PathPatternFeature.__swig_getmethods__["isFlipDirection"] = PathPatternFeature._get_isFlipDirection
PathPatternFeature.__swig_setmethods__["isFlipDirection"] = PathPatternFeature._set_isFlipDirection
PathPatternFeature.isFlipDirection = property(PathPatternFeature._get_isFlipDirection, PathPatternFeature._set_isFlipDirection, doc="Gets and sets if flip the direction from start point.")

PathPatternFeature.__swig_getmethods__["patternDistanceType"] = PathPatternFeature._get_patternDistanceType
PathPatternFeature.__swig_setmethods__["patternDistanceType"] = PathPatternFeature._set_patternDistanceType
PathPatternFeature.patternDistanceType = property(PathPatternFeature._get_patternDistanceType, PathPatternFeature._set_patternDistanceType, doc="Gets and sets how the distance between elements is computed.")

PathPatternFeature.__swig_getmethods__["isSymmetric"] = PathPatternFeature._get_isSymmetric
PathPatternFeature.__swig_setmethods__["isSymmetric"] = PathPatternFeature._set_isSymmetric
PathPatternFeature.isSymmetric = property(PathPatternFeature._get_isSymmetric, PathPatternFeature._set_isSymmetric, doc="Gets and sets if the pattern is in one direction or symmetric.")

PathPatternFeature.__swig_getmethods__["isOrientationAlongPath"] = PathPatternFeature._get_isOrientationAlongPath
PathPatternFeature.__swig_setmethods__["isOrientationAlongPath"] = PathPatternFeature._set_isOrientationAlongPath
PathPatternFeature.isOrientationAlongPath = property(PathPatternFeature._get_isOrientationAlongPath, PathPatternFeature._set_isOrientationAlongPath, doc="Gets and sets if the orientation is along path.\nIf false, the orientation is identical.")

PathPatternFeature.__swig_getmethods__["suppressedElementsIds"] = PathPatternFeature._get_suppressedElementsIds
PathPatternFeature.__swig_setmethods__["suppressedElementsIds"] = PathPatternFeature._set_suppressedElementsIds
PathPatternFeature.suppressedElementsIds = property(PathPatternFeature._get_suppressedElementsIds, PathPatternFeature._set_suppressedElementsIds, doc="Gets and sets the id's of the elements to suppress.")

PathPatternFeature.__swig_getmethods__["patternElements"] = PathPatternFeature._get_patternElements
PathPatternFeature.patternElements = property(PathPatternFeature._get_patternElements, doc="Gets the PatternElements collection that contains the elements created by this pattern.")

PathPatternFeature.__swig_getmethods__["resultFeatures"] = PathPatternFeature._get_resultFeatures
PathPatternFeature.resultFeatures = property(PathPatternFeature._get_resultFeatures, doc="Get the features that were created for this mirror.\nReturns null in the case where the feature is parametric.")

PathPatternFeature.__swig_getmethods__["nativeObject"] = PathPatternFeature._get_nativeObject
PathPatternFeature.nativeObject = property(PathPatternFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

PathPatternFeature.__swig_getmethods__["patternEntityType"] = PathPatternFeature._get_patternEntityType
PathPatternFeature.patternEntityType = property(PathPatternFeature._get_patternEntityType, doc="Returns the type of entities the pattern consists of. This can be used to help\ndetermine the type of results that will be found in the pattern elements.")

PathPatternFeature.__swig_getmethods__["patternComputeOption"] = PathPatternFeature._get_patternComputeOption
PathPatternFeature.__swig_setmethods__["patternComputeOption"] = PathPatternFeature._set_patternComputeOption
PathPatternFeature.patternComputeOption = property(PathPatternFeature._get_patternComputeOption, PathPatternFeature._set_patternComputeOption, doc="Gets and sets the compute option for this pattern feature.\nThis property only applies when patterning features and is ignored in the direct modeling environment.")

PathPatternFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PathPatternFeature) else None
PathPatternFeature.cast = lambda arg: arg if isinstance(arg, PathPatternFeature) else None

class PerpendicularConstraint(GeometricConstraint):
    """A perpendicular constraint in a sketch."""
    __swig_setmethods__ = {}
    for _s in [GeometricConstraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PerpendicularConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricConstraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PerpendicularConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PerpendicularConstraint *" : return _fusion.PerpendicularConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PerpendicularConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PerpendicularConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PerpendicularConstraint_classType
    if _newclass:classType = staticmethod(_fusion.PerpendicularConstraint_classType)
    __swig_destroy__ = _fusion.delete_PerpendicularConstraint
    __del__ = lambda self : None;
    def _get_lineOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """Returns the first line."""
        return _fusion.PerpendicularConstraint__get_lineOne(self)

    def _get_lineTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """Returns the second line."""
        return _fusion.PerpendicularConstraint__get_lineTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::PerpendicularConstraint >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.PerpendicularConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::PerpendicularConstraint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.PerpendicularConstraint_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.PerpendicularConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.PerpendicularConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.PerpendicularConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.PerpendicularConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.PerpendicularConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.PerpendicularConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PerpendicularConstraint__get_isValid(self)
PerpendicularConstraint_swigregister = _fusion.PerpendicularConstraint_swigregister
PerpendicularConstraint_swigregister(PerpendicularConstraint)

def PerpendicularConstraint_classType() -> "char const *" :
  return _fusion.PerpendicularConstraint_classType()
PerpendicularConstraint_classType = _fusion.PerpendicularConstraint_classType

PerpendicularConstraint.__swig_getmethods__["lineOne"] = PerpendicularConstraint._get_lineOne
PerpendicularConstraint.lineOne = property(PerpendicularConstraint._get_lineOne, doc="Returns the first line.")

PerpendicularConstraint.__swig_getmethods__["lineTwo"] = PerpendicularConstraint._get_lineTwo
PerpendicularConstraint.lineTwo = property(PerpendicularConstraint._get_lineTwo, doc="Returns the second line.")

PerpendicularConstraint.__swig_getmethods__["nativeObject"] = PerpendicularConstraint._get_nativeObject
PerpendicularConstraint.nativeObject = property(PerpendicularConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

PerpendicularConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PerpendicularConstraint) else None
PerpendicularConstraint.cast = lambda arg: arg if isinstance(arg, PerpendicularConstraint) else None

class PinSlotJointMotion(JointMotion):
    """Represents the set of information specific to a pin slot joint."""
    __swig_setmethods__ = {}
    for _s in [JointMotion]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PinSlotJointMotion, name, value)
    __swig_getmethods__ = {}
    for _s in [JointMotion]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PinSlotJointMotion, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PinSlotJointMotion *" : return _fusion.PinSlotJointMotion___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PinSlotJointMotion___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PinSlotJointMotion___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PinSlotJointMotion_classType
    if _newclass:classType = staticmethod(_fusion.PinSlotJointMotion_classType)
    __swig_destroy__ = _fusion.delete_PinSlotJointMotion
    __del__ = lambda self : None;
    def _get_rotationAxis(self) -> "adsk::fusion::JointDirections" :
        """
        Gets and sets the direction of the axis of rotation. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customRotationAxisEntity will return an entity
        that defines the axis. If there is a custom rotation axis defined and this
        property is set to one of the three standard axes, the custom rotation will
        be removed and customRotationAxisEntity will return null.
        """
        return _fusion.PinSlotJointMotion__get_rotationAxis(self)

    def _set_rotationAxis(self, *args) -> "bool" :
        """
        Gets and sets the direction of the axis of rotation. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customRotationAxisEntity will return an entity
        that defines the axis. If there is a custom rotation axis defined and this
        property is set to one of the three standard axes, the custom rotation will
        be removed and customRotationAxisEntity will return null.
        """
        return _fusion.PinSlotJointMotion__set_rotationAxis(self, *args)

    def _get_rotationAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Returns the direction of the rotation axis. This property will return null in the case
        where the PinSlotJointMotion object was obtained from a JointInput object.
        """
        return _fusion.PinSlotJointMotion__get_rotationAxisVector(self)

    def _get_customRotationAxisEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        This property can be set using various types of entities that can infer an
        axis. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the rotationAxis property returns
        CustomJointDirection. Setting this property will automatically set
        the rotationAxis property to CustomJointDirection.
        """
        return _fusion.PinSlotJointMotion__get_customRotationAxisEntity(self)

    def _set_customRotationAxisEntity(self, *args) -> "bool" :
        """
        This property can be set using various types of entities that can infer an
        axis. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the rotationAxis property returns
        CustomJointDirection. Setting this property will automatically set
        the rotationAxis property to CustomJointDirection.
        """
        return _fusion.PinSlotJointMotion__set_customRotationAxisEntity(self, *args)

    def _get_rotationValue(self) -> "double" :
        """
        Gets and sets the rotation value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.PinSlotJointMotion__get_rotationValue(self)

    def _set_rotationValue(self, *args) -> "bool" :
        """
        Gets and sets the rotation value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.PinSlotJointMotion__set_rotationValue(self, *args)

    def _get_rotationLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >" :
        """
        Returns a JointLimits object that defines the rotation limits for this joint.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.PinSlotJointMotion__get_rotationLimits(self)

    def _get_slideDirection(self) -> "adsk::fusion::JointDirections" :
        """
        Gets and sets the direction of the slide motion in the slot. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customSlideDirectionEntity will return an entity
        that defines the direction. If there is a custom direction defined and this
        property is set to one of the three standard axes, the custom direction will
        be removed and customSlideDirectionEntity will return null.
        """
        return _fusion.PinSlotJointMotion__get_slideDirection(self)

    def _set_slideDirection(self, *args) -> "bool" :
        """
        Gets and sets the direction of the slide motion in the slot. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customSlideDirectionEntity will return an entity
        that defines the direction. If there is a custom direction defined and this
        property is set to one of the three standard axes, the custom direction will
        be removed and customSlideDirectionEntity will return null.
        """
        return _fusion.PinSlotJointMotion__set_slideDirection(self, *args)

    def _get_slideDirectionVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Returns the direction of the primary slide direction. This property will return null in the case
        where the PinSlotJointMotion object was obtained from a JointInput object.
        """
        return _fusion.PinSlotJointMotion__get_slideDirectionVector(self)

    def _get_customSlideDirectionEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        This property can be set using various types of entities that can infer a
        direction. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the slideDirection property returns
        CustomJointDirection. Setting this property will automatically set
        the slideDirection property to CustomJointDirection.
        """
        return _fusion.PinSlotJointMotion__get_customSlideDirectionEntity(self)

    def _set_customSlideDirectionEntity(self, *args) -> "bool" :
        """
        This property can be set using various types of entities that can infer a
        direction. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the slideDirection property returns
        CustomJointDirection. Setting this property will automatically set
        the slideDirection property to CustomJointDirection.
        """
        return _fusion.PinSlotJointMotion__set_customSlideDirectionEntity(self, *args)

    def _get_slideValue(self) -> "double" :
        """
        Gets and sets the slide value. This is in centimeters. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.PinSlotJointMotion__get_slideValue(self)

    def _set_slideValue(self, *args) -> "bool" :
        """
        Gets and sets the slide value. This is in centimeters. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.PinSlotJointMotion__set_slideValue(self, *args)

    def _get_slideLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >" :
        """
        Returns a JointLimits object that defines the slide limits for this joint.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.PinSlotJointMotion__get_slideLimits(self)

    def _get_jointType(self) -> "adsk::fusion::JointTypes" :
        """Returns an enum value indicating the type of joint this joint represents."""
        return _fusion.PinSlotJointMotion__get_jointType(self)

    def _get_objectType(self) -> "char const *" : return _fusion.PinSlotJointMotion__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PinSlotJointMotion__get_isValid(self)
PinSlotJointMotion_swigregister = _fusion.PinSlotJointMotion_swigregister
PinSlotJointMotion_swigregister(PinSlotJointMotion)

def PinSlotJointMotion_classType() -> "char const *" :
  return _fusion.PinSlotJointMotion_classType()
PinSlotJointMotion_classType = _fusion.PinSlotJointMotion_classType

PinSlotJointMotion.__swig_getmethods__["rotationAxis"] = PinSlotJointMotion._get_rotationAxis
PinSlotJointMotion.__swig_setmethods__["rotationAxis"] = PinSlotJointMotion._set_rotationAxis
PinSlotJointMotion.rotationAxis = property(PinSlotJointMotion._get_rotationAxis, PinSlotJointMotion._set_rotationAxis, doc="Gets and sets the direction of the axis of rotation. This can be set to\nXAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can\nreturn those three directions and CustomJointDirection. If this returns\nCustomJointDirection then the customRotationAxisEntity will return an entity\nthat defines the axis. If there is a custom rotation axis defined and this\nproperty is set to one of the three standard axes, the custom rotation will\nbe removed and customRotationAxisEntity will return null.")

PinSlotJointMotion.__swig_getmethods__["rotationAxisVector"] = PinSlotJointMotion._get_rotationAxisVector
PinSlotJointMotion.rotationAxisVector = property(PinSlotJointMotion._get_rotationAxisVector, doc="Returns the direction of the rotation axis. This property will return null in the case\nwhere the PinSlotJointMotion object was obtained from a JointInput object.")

PinSlotJointMotion.__swig_getmethods__["customRotationAxisEntity"] = PinSlotJointMotion._get_customRotationAxisEntity
PinSlotJointMotion.__swig_setmethods__["customRotationAxisEntity"] = PinSlotJointMotion._set_customRotationAxisEntity
PinSlotJointMotion.customRotationAxisEntity = property(PinSlotJointMotion._get_customRotationAxisEntity, PinSlotJointMotion._set_customRotationAxisEntity, doc="This property can be set using various types of entities that can infer an\naxis. For example, a linear edge, sketch line, planar face, and cylindrical face.\nThis property is only valid in the case where the rotationAxis property returns\nCustomJointDirection. Setting this property will automatically set\nthe rotationAxis property to CustomJointDirection.")

PinSlotJointMotion.__swig_getmethods__["rotationValue"] = PinSlotJointMotion._get_rotationValue
PinSlotJointMotion.__swig_setmethods__["rotationValue"] = PinSlotJointMotion._set_rotationValue
PinSlotJointMotion.rotationValue = property(PinSlotJointMotion._get_rotationValue, PinSlotJointMotion._set_rotationValue, doc="Gets and sets the rotation value. This is in radians. Setting this value is\nthe equivalent of using the Drive Joints command.")

PinSlotJointMotion.__swig_getmethods__["rotationLimits"] = PinSlotJointMotion._get_rotationLimits
PinSlotJointMotion.rotationLimits = property(PinSlotJointMotion._get_rotationLimits, doc="Returns a JointLimits object that defines the rotation limits for this joint.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")

PinSlotJointMotion.__swig_getmethods__["slideDirection"] = PinSlotJointMotion._get_slideDirection
PinSlotJointMotion.__swig_setmethods__["slideDirection"] = PinSlotJointMotion._set_slideDirection
PinSlotJointMotion.slideDirection = property(PinSlotJointMotion._get_slideDirection, PinSlotJointMotion._set_slideDirection, doc="Gets and sets the direction of the slide motion in the slot. This can be set to\nXAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can\nreturn those three directions and CustomJointDirection. If this returns\nCustomJointDirection then the customSlideDirectionEntity will return an entity\nthat defines the direction. If there is a custom direction defined and this\nproperty is set to one of the three standard axes, the custom direction will\nbe removed and customSlideDirectionEntity will return null.")

PinSlotJointMotion.__swig_getmethods__["slideDirectionVector"] = PinSlotJointMotion._get_slideDirectionVector
PinSlotJointMotion.slideDirectionVector = property(PinSlotJointMotion._get_slideDirectionVector, doc="Returns the direction of the primary slide direction. This property will return null in the case\nwhere the PinSlotJointMotion object was obtained from a JointInput object.")

PinSlotJointMotion.__swig_getmethods__["customSlideDirectionEntity"] = PinSlotJointMotion._get_customSlideDirectionEntity
PinSlotJointMotion.__swig_setmethods__["customSlideDirectionEntity"] = PinSlotJointMotion._set_customSlideDirectionEntity
PinSlotJointMotion.customSlideDirectionEntity = property(PinSlotJointMotion._get_customSlideDirectionEntity, PinSlotJointMotion._set_customSlideDirectionEntity, doc="This property can be set using various types of entities that can infer a\ndirection. For example, a linear edge, sketch line, planar face, and cylindrical face.\nThis property is only valid in the case where the slideDirection property returns\nCustomJointDirection. Setting this property will automatically set\nthe slideDirection property to CustomJointDirection.")

PinSlotJointMotion.__swig_getmethods__["slideValue"] = PinSlotJointMotion._get_slideValue
PinSlotJointMotion.__swig_setmethods__["slideValue"] = PinSlotJointMotion._set_slideValue
PinSlotJointMotion.slideValue = property(PinSlotJointMotion._get_slideValue, PinSlotJointMotion._set_slideValue, doc="Gets and sets the slide value. This is in centimeters. Setting this value is\nthe equivalent of using the Drive Joints command.")

PinSlotJointMotion.__swig_getmethods__["slideLimits"] = PinSlotJointMotion._get_slideLimits
PinSlotJointMotion.slideLimits = property(PinSlotJointMotion._get_slideLimits, doc="Returns a JointLimits object that defines the slide limits for this joint.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")

PinSlotJointMotion.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PinSlotJointMotion) else None
PinSlotJointMotion.cast = lambda arg: arg if isinstance(arg, PinSlotJointMotion) else None

class PipeFeature(Feature):
    """Object that represents an existing pipe feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PipeFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PipeFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PipeFeature *" : return _fusion.PipeFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PipeFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PipeFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PipeFeature_classType
    if _newclass:classType = staticmethod(_fusion.PipeFeature_classType)
    __swig_destroy__ = _fusion.delete_PipeFeature
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.PipeFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.PipeFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.PipeFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.PipeFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.PipeFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.PipeFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.PipeFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.PipeFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.PipeFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.PipeFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.PipeFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.PipeFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.PipeFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.PipeFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.PipeFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.PipeFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.PipeFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.PipeFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PipeFeature__get_isValid(self)
PipeFeature_swigregister = _fusion.PipeFeature_swigregister
PipeFeature_swigregister(PipeFeature)

def PipeFeature_classType() -> "char const *" :
  return _fusion.PipeFeature_classType()
PipeFeature_classType = _fusion.PipeFeature_classType

PipeFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PipeFeature) else None
PipeFeature.cast = lambda arg: arg if isinstance(arg, PipeFeature) else None

class PlanarJointMotion(JointMotion):
    """Represents the set of information specific to a planar joint."""
    __swig_setmethods__ = {}
    for _s in [JointMotion]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PlanarJointMotion, name, value)
    __swig_getmethods__ = {}
    for _s in [JointMotion]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PlanarJointMotion, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PlanarJointMotion *" : return _fusion.PlanarJointMotion___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PlanarJointMotion___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PlanarJointMotion___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PlanarJointMotion_classType
    if _newclass:classType = staticmethod(_fusion.PlanarJointMotion_classType)
    __swig_destroy__ = _fusion.delete_PlanarJointMotion
    __del__ = lambda self : None;
    def _get_normalDirection(self) -> "adsk::fusion::JointDirections" :
        """
        Gets and sets the direction of the normal of the single degree of rotation.
        This can be set to XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. 
        It can return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customNormalDirectionEntity will return an entity
        that defines the direction. If there is a custom direction defined and this
        property is set to one of the three standard axes, the custom direction will
        be removed and customNormalDirectionEntity will return null.
        """
        return _fusion.PlanarJointMotion__get_normalDirection(self)

    def _set_normalDirection(self, *args) -> "bool" :
        """
        Gets and sets the direction of the normal of the single degree of rotation.
        This can be set to XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. 
        It can return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customNormalDirectionEntity will return an entity
        that defines the direction. If there is a custom direction defined and this
        property is set to one of the three standard axes, the custom direction will
        be removed and customNormalDirectionEntity will return null.
        """
        return _fusion.PlanarJointMotion__set_normalDirection(self, *args)

    def _get_normalDirectionVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Returns the direction of the normal direction. This property will return null in the case
        where the PlanarJointMotion object was obtained from a JointInput object.
        """
        return _fusion.PlanarJointMotion__get_normalDirectionVector(self)

    def _get_customNormalDirectionEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        This property defines a custom normal direction and can be set using various types 
        of entities that can infer a direction. For example, a linear edge, sketch line, 
        planar face, and cylindrical face.This property is only valid in the case where the 
        normalDirection property returns CustomJointDirection. Setting this property will 
        automatically set the normalDirection property to CustomJointDirection.
        """
        return _fusion.PlanarJointMotion__get_customNormalDirectionEntity(self)

    def _set_customNormalDirectionEntity(self, *args) -> "bool" :
        """
        This property defines a custom normal direction and can be set using various types 
        of entities that can infer a direction. For example, a linear edge, sketch line, 
        planar face, and cylindrical face.This property is only valid in the case where the 
        normalDirection property returns CustomJointDirection. Setting this property will 
        automatically set the normalDirection property to CustomJointDirection.
        """
        return _fusion.PlanarJointMotion__set_customNormalDirectionEntity(self, *args)

    def _get_primarySlideDirection(self) -> "adsk::fusion::JointDirections" :
        """
        Gets the direction used as the primary direction for the two translational degrees of 
        freedom. The value of this property is automatically set when setting the normalDirection.
        When reading this value it can return XAxisJointDirection, YAxisJointDirection, ZAxisJointDirection,
        or CustomJointDirection. If it's CustomJointDirection then the direction the direction can be
        determined using the primarySlideDirectionVector and the entity controlling the direction can
        be get and set using the customPrimarySlideDirectionEntity.
        """
        return _fusion.PlanarJointMotion__get_primarySlideDirection(self)

    def _get_primarySlideDirectionVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Returns the direction of the primary slide direction. This property will return null in the case
        where the PlanarJointMotion object was obtained from a JointInput object.
        """
        return _fusion.PlanarJointMotion__get_primarySlideDirectionVector(self)

    def _get_customPrimarySlideDirectionEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        This property can be set using various types of entities that can infer a
        direction. For example, a linear edge, sketch line, planar face, and cylindrical face.
        When reading this property, it is only valid in the case where the primarySlideDirection property returns
        CustomJointDirection. Setting this property will automatically set the primarySlideDirection property to 
        CustomJointDirection. The entity defining the custom direction by be perpendicular to the normal direction.
        """
        return _fusion.PlanarJointMotion__get_customPrimarySlideDirectionEntity(self)

    def _set_customPrimarySlideDirectionEntity(self, *args) -> "bool" :
        """
        This property can be set using various types of entities that can infer a
        direction. For example, a linear edge, sketch line, planar face, and cylindrical face.
        When reading this property, it is only valid in the case where the primarySlideDirection property returns
        CustomJointDirection. Setting this property will automatically set the primarySlideDirection property to 
        CustomJointDirection. The entity defining the custom direction by be perpendicular to the normal direction.
        """
        return _fusion.PlanarJointMotion__set_customPrimarySlideDirectionEntity(self, *args)

    def _get_secondarySlideDirectionVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Returns the direction of the secondary slide direction. This property will return null in the case
        where the PlanarJointMotion object was obtained from a JointInput object.
        """
        return _fusion.PlanarJointMotion__get_secondarySlideDirectionVector(self)

    def _get_rotationValue(self) -> "double" :
        """
        Gets and sets the rotation value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.PlanarJointMotion__get_rotationValue(self)

    def _set_rotationValue(self, *args) -> "bool" :
        """
        Gets and sets the rotation value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.PlanarJointMotion__set_rotationValue(self, *args)

    def _get_rotationLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >" :
        """
        Returns a JointLimits object that defines the limits of rotation for this joint.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.PlanarJointMotion__get_rotationLimits(self)

    def _get_primarySlideValue(self) -> "double" :
        """
        Gets and sets the offset value in the primary direction. This is in centimeters. 
        Setting this value is the equivalent of using the Drive Joints command.
        """
        return _fusion.PlanarJointMotion__get_primarySlideValue(self)

    def _set_primarySlideValue(self, *args) -> "bool" :
        """
        Gets and sets the offset value in the primary direction. This is in centimeters. 
        Setting this value is the equivalent of using the Drive Joints command.
        """
        return _fusion.PlanarJointMotion__set_primarySlideValue(self, *args)

    def _get_primarySlideLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >" :
        """
        Returns a JointLimits object that defines the limits in the primary direction for this joint.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.PlanarJointMotion__get_primarySlideLimits(self)

    def _get_secondarySlideValue(self) -> "double" :
        """
        Gets and sets the offset value in the secondary direction. This is in centimeters. 
        Setting this value is the equivalent of using the Drive Joints command.
        """
        return _fusion.PlanarJointMotion__get_secondarySlideValue(self)

    def _set_secondarySlideValue(self, *args) -> "bool" :
        """
        Gets and sets the offset value in the secondary direction. This is in centimeters. 
        Setting this value is the equivalent of using the Drive Joints command.
        """
        return _fusion.PlanarJointMotion__set_secondarySlideValue(self, *args)

    def _get_secondarySlideLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >" :
        """
        Returns a JointLimits object that defines the limits in the secondary direction for this joint.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.PlanarJointMotion__get_secondarySlideLimits(self)

    def _get_jointType(self) -> "adsk::fusion::JointTypes" :
        """Returns an enum value indicating the type of joint this joint represents."""
        return _fusion.PlanarJointMotion__get_jointType(self)

    def _get_objectType(self) -> "char const *" : return _fusion.PlanarJointMotion__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PlanarJointMotion__get_isValid(self)
PlanarJointMotion_swigregister = _fusion.PlanarJointMotion_swigregister
PlanarJointMotion_swigregister(PlanarJointMotion)

def PlanarJointMotion_classType() -> "char const *" :
  return _fusion.PlanarJointMotion_classType()
PlanarJointMotion_classType = _fusion.PlanarJointMotion_classType

PlanarJointMotion.__swig_getmethods__["normalDirection"] = PlanarJointMotion._get_normalDirection
PlanarJointMotion.__swig_setmethods__["normalDirection"] = PlanarJointMotion._set_normalDirection
PlanarJointMotion.normalDirection = property(PlanarJointMotion._get_normalDirection, PlanarJointMotion._set_normalDirection, doc="Gets and sets the direction of the normal of the single degree of rotation.\nThis can be set to XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection.\nIt can return those three directions and CustomJointDirection. If this returns\nCustomJointDirection then the customNormalDirectionEntity will return an entity\nthat defines the direction. If there is a custom direction defined and this\nproperty is set to one of the three standard axes, the custom direction will\nbe removed and customNormalDirectionEntity will return null.")

PlanarJointMotion.__swig_getmethods__["normalDirectionVector"] = PlanarJointMotion._get_normalDirectionVector
PlanarJointMotion.normalDirectionVector = property(PlanarJointMotion._get_normalDirectionVector, doc="Returns the direction of the normal direction. This property will return null in the case\nwhere the PlanarJointMotion object was obtained from a JointInput object.")

PlanarJointMotion.__swig_getmethods__["customNormalDirectionEntity"] = PlanarJointMotion._get_customNormalDirectionEntity
PlanarJointMotion.__swig_setmethods__["customNormalDirectionEntity"] = PlanarJointMotion._set_customNormalDirectionEntity
PlanarJointMotion.customNormalDirectionEntity = property(PlanarJointMotion._get_customNormalDirectionEntity, PlanarJointMotion._set_customNormalDirectionEntity, doc="This property defines a custom normal direction and can be set using various types\nof entities that can infer a direction. For example, a linear edge, sketch line,\nplanar face, and cylindrical face.This property is only valid in the case where the\nnormalDirection property returns CustomJointDirection. Setting this property will\nautomatically set the normalDirection property to CustomJointDirection.")

PlanarJointMotion.__swig_getmethods__["primarySlideDirection"] = PlanarJointMotion._get_primarySlideDirection
PlanarJointMotion.primarySlideDirection = property(PlanarJointMotion._get_primarySlideDirection, doc="Gets the direction used as the primary direction for the two translational degrees of\nfreedom. The value of this property is automatically set when setting the normalDirection.\nWhen reading this value it can return XAxisJointDirection, YAxisJointDirection, ZAxisJointDirection,\nor CustomJointDirection. If it's CustomJointDirection then the direction the direction can be\ndetermined using the primarySlideDirectionVector and the entity controlling the direction can\nbe get and set using the customPrimarySlideDirectionEntity.")

PlanarJointMotion.__swig_getmethods__["primarySlideDirectionVector"] = PlanarJointMotion._get_primarySlideDirectionVector
PlanarJointMotion.primarySlideDirectionVector = property(PlanarJointMotion._get_primarySlideDirectionVector, doc="Returns the direction of the primary slide direction. This property will return null in the case\nwhere the PlanarJointMotion object was obtained from a JointInput object.")

PlanarJointMotion.__swig_getmethods__["customPrimarySlideDirectionEntity"] = PlanarJointMotion._get_customPrimarySlideDirectionEntity
PlanarJointMotion.__swig_setmethods__["customPrimarySlideDirectionEntity"] = PlanarJointMotion._set_customPrimarySlideDirectionEntity
PlanarJointMotion.customPrimarySlideDirectionEntity = property(PlanarJointMotion._get_customPrimarySlideDirectionEntity, PlanarJointMotion._set_customPrimarySlideDirectionEntity, doc="This property can be set using various types of entities that can infer a\ndirection. For example, a linear edge, sketch line, planar face, and cylindrical face.\nWhen reading this property, it is only valid in the case where the primarySlideDirection property returns\nCustomJointDirection. Setting this property will automatically set the primarySlideDirection property to\nCustomJointDirection. The entity defining the custom direction by be perpendicular to the normal direction.")

PlanarJointMotion.__swig_getmethods__["secondarySlideDirectionVector"] = PlanarJointMotion._get_secondarySlideDirectionVector
PlanarJointMotion.secondarySlideDirectionVector = property(PlanarJointMotion._get_secondarySlideDirectionVector, doc="Returns the direction of the secondary slide direction. This property will return null in the case\nwhere the PlanarJointMotion object was obtained from a JointInput object.")

PlanarJointMotion.__swig_getmethods__["rotationValue"] = PlanarJointMotion._get_rotationValue
PlanarJointMotion.__swig_setmethods__["rotationValue"] = PlanarJointMotion._set_rotationValue
PlanarJointMotion.rotationValue = property(PlanarJointMotion._get_rotationValue, PlanarJointMotion._set_rotationValue, doc="Gets and sets the rotation value. This is in radians. Setting this value is\nthe equivalent of using the Drive Joints command.")

PlanarJointMotion.__swig_getmethods__["rotationLimits"] = PlanarJointMotion._get_rotationLimits
PlanarJointMotion.rotationLimits = property(PlanarJointMotion._get_rotationLimits, doc="Returns a JointLimits object that defines the limits of rotation for this joint.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")

PlanarJointMotion.__swig_getmethods__["primarySlideValue"] = PlanarJointMotion._get_primarySlideValue
PlanarJointMotion.__swig_setmethods__["primarySlideValue"] = PlanarJointMotion._set_primarySlideValue
PlanarJointMotion.primarySlideValue = property(PlanarJointMotion._get_primarySlideValue, PlanarJointMotion._set_primarySlideValue, doc="Gets and sets the offset value in the primary direction. This is in centimeters.\nSetting this value is the equivalent of using the Drive Joints command.")

PlanarJointMotion.__swig_getmethods__["primarySlideLimits"] = PlanarJointMotion._get_primarySlideLimits
PlanarJointMotion.primarySlideLimits = property(PlanarJointMotion._get_primarySlideLimits, doc="Returns a JointLimits object that defines the limits in the primary direction for this joint.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")

PlanarJointMotion.__swig_getmethods__["secondarySlideValue"] = PlanarJointMotion._get_secondarySlideValue
PlanarJointMotion.__swig_setmethods__["secondarySlideValue"] = PlanarJointMotion._set_secondarySlideValue
PlanarJointMotion.secondarySlideValue = property(PlanarJointMotion._get_secondarySlideValue, PlanarJointMotion._set_secondarySlideValue, doc="Gets and sets the offset value in the secondary direction. This is in centimeters.\nSetting this value is the equivalent of using the Drive Joints command.")

PlanarJointMotion.__swig_getmethods__["secondarySlideLimits"] = PlanarJointMotion._get_secondarySlideLimits
PlanarJointMotion.secondarySlideLimits = property(PlanarJointMotion._get_secondarySlideLimits, doc="Returns a JointLimits object that defines the limits in the secondary direction for this joint.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")

PlanarJointMotion.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PlanarJointMotion) else None
PlanarJointMotion.cast = lambda arg: arg if isinstance(arg, PlanarJointMotion) else None

class PlaneAndOffsetsHolePositionDefinition(HolePositionDefinition):
    """
    Provides positioning information for a hole that is positioned on a plane 
    and at a distance from one or two edges.
    """
    __swig_setmethods__ = {}
    for _s in [HolePositionDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PlaneAndOffsetsHolePositionDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [HolePositionDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PlaneAndOffsetsHolePositionDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PlaneAndOffsetsHolePositionDefinition *" : return _fusion.PlaneAndOffsetsHolePositionDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PlaneAndOffsetsHolePositionDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PlaneAndOffsetsHolePositionDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PlaneAndOffsetsHolePositionDefinition_classType
    if _newclass:classType = staticmethod(_fusion.PlaneAndOffsetsHolePositionDefinition_classType)
    __swig_destroy__ = _fusion.delete_PlaneAndOffsetsHolePositionDefinition
    __del__ = lambda self : None;
    def _get_planarEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the plane that defines the orientation and start of the hole."""
        return _fusion.PlaneAndOffsetsHolePositionDefinition__get_planarEntity(self)

    def _get_edgeOne(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdge >" :
        """
        The first of 2 edges the hole position is measured from. OffsetOne provides access to 
        the model parameter controlling the offset distance.
        """
        return _fusion.PlaneAndOffsetsHolePositionDefinition__get_edgeOne(self)

    def _get_offsetOne(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the model parameter controlling the distance from the center of the hole 
        to EdgeOne.
        """
        return _fusion.PlaneAndOffsetsHolePositionDefinition__get_offsetOne(self)

    def _get_edgeTwo(self) -> "adsk::core::Ptr< adsk::fusion::BRepEdge >" :
        """
        The second of two edges the hole position is measured from. OffsetTwo provides access 
        to the model parameter controlling the offset distance. This property can return null 
        in the case where only one edge is used.
        """
        return _fusion.PlaneAndOffsetsHolePositionDefinition__get_edgeTwo(self)

    def _get_offsetTwo(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the model parameter controlling the distance from the center of the hole 
        to EdgeTwo. This property returns null in the case where only one edge is used.
        """
        return _fusion.PlaneAndOffsetsHolePositionDefinition__get_offsetTwo(self)

    def _get_objectType(self) -> "char const *" : return _fusion.PlaneAndOffsetsHolePositionDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PlaneAndOffsetsHolePositionDefinition__get_isValid(self)
PlaneAndOffsetsHolePositionDefinition_swigregister = _fusion.PlaneAndOffsetsHolePositionDefinition_swigregister
PlaneAndOffsetsHolePositionDefinition_swigregister(PlaneAndOffsetsHolePositionDefinition)

def PlaneAndOffsetsHolePositionDefinition_classType() -> "char const *" :
  return _fusion.PlaneAndOffsetsHolePositionDefinition_classType()
PlaneAndOffsetsHolePositionDefinition_classType = _fusion.PlaneAndOffsetsHolePositionDefinition_classType

PlaneAndOffsetsHolePositionDefinition.__swig_getmethods__["planarEntity"] = PlaneAndOffsetsHolePositionDefinition._get_planarEntity
PlaneAndOffsetsHolePositionDefinition.planarEntity = property(PlaneAndOffsetsHolePositionDefinition._get_planarEntity, doc="Returns the plane that defines the orientation and start of the hole.")

PlaneAndOffsetsHolePositionDefinition.__swig_getmethods__["edgeOne"] = PlaneAndOffsetsHolePositionDefinition._get_edgeOne
PlaneAndOffsetsHolePositionDefinition.edgeOne = property(PlaneAndOffsetsHolePositionDefinition._get_edgeOne, doc="The first of 2 edges the hole position is measured from. OffsetOne provides access to\nthe model parameter controlling the offset distance.")

PlaneAndOffsetsHolePositionDefinition.__swig_getmethods__["offsetOne"] = PlaneAndOffsetsHolePositionDefinition._get_offsetOne
PlaneAndOffsetsHolePositionDefinition.offsetOne = property(PlaneAndOffsetsHolePositionDefinition._get_offsetOne, doc="Returns the model parameter controlling the distance from the center of the hole\nto EdgeOne.")

PlaneAndOffsetsHolePositionDefinition.__swig_getmethods__["edgeTwo"] = PlaneAndOffsetsHolePositionDefinition._get_edgeTwo
PlaneAndOffsetsHolePositionDefinition.edgeTwo = property(PlaneAndOffsetsHolePositionDefinition._get_edgeTwo, doc="The second of two edges the hole position is measured from. OffsetTwo provides access\nto the model parameter controlling the offset distance. This property can return null\nin the case where only one edge is used.")

PlaneAndOffsetsHolePositionDefinition.__swig_getmethods__["offsetTwo"] = PlaneAndOffsetsHolePositionDefinition._get_offsetTwo
PlaneAndOffsetsHolePositionDefinition.offsetTwo = property(PlaneAndOffsetsHolePositionDefinition._get_offsetTwo, doc="Returns the model parameter controlling the distance from the center of the hole\nto EdgeTwo. This property returns null in the case where only one edge is used.")

PlaneAndOffsetsHolePositionDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PlaneAndOffsetsHolePositionDefinition) else None
PlaneAndOffsetsHolePositionDefinition.cast = lambda arg: arg if isinstance(arg, PlaneAndOffsetsHolePositionDefinition) else None

class PointHolePositionDefinition(HolePositionDefinition):
    """
    Provides positioning information for a hole that is positioned relative to a 3D coordinate 
    point.
    """
    __swig_setmethods__ = {}
    for _s in [HolePositionDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PointHolePositionDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [HolePositionDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PointHolePositionDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PointHolePositionDefinition *" : return _fusion.PointHolePositionDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PointHolePositionDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PointHolePositionDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PointHolePositionDefinition_classType
    if _newclass:classType = staticmethod(_fusion.PointHolePositionDefinition_classType)
    __swig_destroy__ = _fusion.delete_PointHolePositionDefinition
    __del__ = lambda self : None;
    def _get_planarEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the plane that defines the orientation and start of the hole."""
        return _fusion.PointHolePositionDefinition__get_planarEntity(self)

    def _get_point(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Returns the coordinates defining the position of the hole."""
        return _fusion.PointHolePositionDefinition__get_point(self)

    def _get_objectType(self) -> "char const *" : return _fusion.PointHolePositionDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PointHolePositionDefinition__get_isValid(self)
PointHolePositionDefinition_swigregister = _fusion.PointHolePositionDefinition_swigregister
PointHolePositionDefinition_swigregister(PointHolePositionDefinition)

def PointHolePositionDefinition_classType() -> "char const *" :
  return _fusion.PointHolePositionDefinition_classType()
PointHolePositionDefinition_classType = _fusion.PointHolePositionDefinition_classType

PointHolePositionDefinition.__swig_getmethods__["planarEntity"] = PointHolePositionDefinition._get_planarEntity
PointHolePositionDefinition.planarEntity = property(PointHolePositionDefinition._get_planarEntity, doc="Returns the plane that defines the orientation and start of the hole.")

PointHolePositionDefinition.__swig_getmethods__["point"] = PointHolePositionDefinition._get_point
PointHolePositionDefinition.point = property(PointHolePositionDefinition._get_point, doc="Returns the coordinates defining the position of the hole.")

PointHolePositionDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PointHolePositionDefinition) else None
PointHolePositionDefinition.cast = lambda arg: arg if isinstance(arg, PointHolePositionDefinition) else None

class PolygonConstraint(GeometricConstraint):
    """A polygon constraint in a sketch."""
    __swig_setmethods__ = {}
    for _s in [GeometricConstraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolygonConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricConstraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PolygonConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::PolygonConstraint *" : return _fusion.PolygonConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.PolygonConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.PolygonConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.PolygonConstraint_classType
    if _newclass:classType = staticmethod(_fusion.PolygonConstraint_classType)
    __swig_destroy__ = _fusion.delete_PolygonConstraint
    __del__ = lambda self : None;
    def _get_lines(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchLine >,std::allocator< adsk::core::Ptr< adsk::fusion::SketchLine > > >" :
        """Returns the sketch lines that represent the polygon."""
        return _fusion.PolygonConstraint__get_lines(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.PolygonConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.PolygonConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.PolygonConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.PolygonConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.PolygonConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.PolygonConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.PolygonConstraint__get_isValid(self)
PolygonConstraint_swigregister = _fusion.PolygonConstraint_swigregister
PolygonConstraint_swigregister(PolygonConstraint)

def PolygonConstraint_classType() -> "char const *" :
  return _fusion.PolygonConstraint_classType()
PolygonConstraint_classType = _fusion.PolygonConstraint_classType

PolygonConstraint.__swig_getmethods__["lines"] = PolygonConstraint._get_lines
PolygonConstraint.lines = property(PolygonConstraint._get_lines, doc="Returns the sketch lines that represent the polygon.")

PolygonConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, PolygonConstraint) else None
PolygonConstraint.cast = lambda arg: arg if isinstance(arg, PolygonConstraint) else None

class ProfilePlaneStartDefinition(ExtentDefinition):
    """A definition object that is used to define a feature whose start plane is the sketch plane of the profile."""
    __swig_setmethods__ = {}
    for _s in [ExtentDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProfilePlaneStartDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ExtentDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ProfilePlaneStartDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ProfilePlaneStartDefinition *" : return _fusion.ProfilePlaneStartDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ProfilePlaneStartDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ProfilePlaneStartDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ProfilePlaneStartDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ProfilePlaneStartDefinition_classType)
    __swig_getmethods__["create"] = lambda x: _fusion.ProfilePlaneStartDefinition_create
    if _newclass:create = staticmethod(_fusion.ProfilePlaneStartDefinition_create)
    __swig_destroy__ = _fusion.delete_ProfilePlaneStartDefinition
    __del__ = lambda self : None;
    def _get_profilePlane(self) -> "adsk::core::Ptr< adsk::core::Plane >" :
        """Returns the geometric definition of the profile plane."""
        return _fusion.ProfilePlaneStartDefinition__get_profilePlane(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        """
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.ProfilePlaneStartDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ProfilePlaneStartDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ProfilePlaneStartDefinition__get_isValid(self)
ProfilePlaneStartDefinition_swigregister = _fusion.ProfilePlaneStartDefinition_swigregister
ProfilePlaneStartDefinition_swigregister(ProfilePlaneStartDefinition)

def ProfilePlaneStartDefinition_classType() -> "char const *" :
  return _fusion.ProfilePlaneStartDefinition_classType()
ProfilePlaneStartDefinition_classType = _fusion.ProfilePlaneStartDefinition_classType

def ProfilePlaneStartDefinition_create() -> "adsk::core::Ptr< adsk::fusion::ProfilePlaneStartDefinition >" :
  return _fusion.ProfilePlaneStartDefinition_create()
ProfilePlaneStartDefinition_create = _fusion.ProfilePlaneStartDefinition_create

ProfilePlaneStartDefinition.__swig_getmethods__["profilePlane"] = ProfilePlaneStartDefinition._get_profilePlane
ProfilePlaneStartDefinition.profilePlane = property(ProfilePlaneStartDefinition._get_profilePlane, doc="Returns the geometric definition of the profile plane.")

ProfilePlaneStartDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ProfilePlaneStartDefinition) else None
ProfilePlaneStartDefinition.cast = lambda arg: arg if isinstance(arg, ProfilePlaneStartDefinition) else None

class RectangularPatternConstraint(GeometricConstraint):
    """A rectangular pattern constraint in a sketch."""
    __swig_setmethods__ = {}
    for _s in [GeometricConstraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RectangularPatternConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricConstraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RectangularPatternConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::RectangularPatternConstraint *" : return _fusion.RectangularPatternConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.RectangularPatternConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.RectangularPatternConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.RectangularPatternConstraint_classType
    if _newclass:classType = staticmethod(_fusion.RectangularPatternConstraint_classType)
    __swig_destroy__ = _fusion.delete_RectangularPatternConstraint
    __del__ = lambda self : None;
    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.RectangularPatternConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.RectangularPatternConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.RectangularPatternConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.RectangularPatternConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.RectangularPatternConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.RectangularPatternConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.RectangularPatternConstraint__get_isValid(self)
RectangularPatternConstraint_swigregister = _fusion.RectangularPatternConstraint_swigregister
RectangularPatternConstraint_swigregister(RectangularPatternConstraint)

def RectangularPatternConstraint_classType() -> "char const *" :
  return _fusion.RectangularPatternConstraint_classType()
RectangularPatternConstraint_classType = _fusion.RectangularPatternConstraint_classType

RectangularPatternConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RectangularPatternConstraint) else None
RectangularPatternConstraint.cast = lambda arg: arg if isinstance(arg, RectangularPatternConstraint) else None

class RectangularPatternFeature(Feature):
    """Object that represents an existing rectangular pattern feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RectangularPatternFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RectangularPatternFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::RectangularPatternFeature *" : return _fusion.RectangularPatternFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.RectangularPatternFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.RectangularPatternFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.RectangularPatternFeature_classType
    if _newclass:classType = staticmethod(_fusion.RectangularPatternFeature_classType)
    __swig_destroy__ = _fusion.delete_RectangularPatternFeature
    __del__ = lambda self : None;
    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        """
        return _fusion.RectangularPatternFeature__get_inputEntities(self)

    def _set_inputEntities(self, *args) -> "bool" :
        """
        Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.
        All of the entities must be of a single type. For example, it can't contain features and occurrences
        but only features or occurrences.
        """
        return _fusion.RectangularPatternFeature__set_inputEntities(self, *args)

    def _get_directionOneEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the first direction entity.
        This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
        """
        return _fusion.RectangularPatternFeature__get_directionOneEntity(self)

    def _set_directionOneEntity(self, *args) -> "bool" :
        """
        Gets and sets the first direction entity.
        This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
        """
        return _fusion.RectangularPatternFeature__set_directionOneEntity(self, *args)

    def _get_directionTwoEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the second direction entity.
        This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
        This can be null when not entity has been specified to control the second direction. In this case Fusion 360 will compute a default direction which is
        90 degrees to the direction one.
        """
        return _fusion.RectangularPatternFeature__get_directionTwoEntity(self)

    def _set_directionTwoEntity(self, *args) -> "bool" :
        """
        Gets and sets the second direction entity.
        This can be a linear edge, construction axis, sketch line or rectangular pattern feature.
        If a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.
        This can be null when not entity has been specified to control the second direction. In this case Fusion 360 will compute a default direction which is
        90 degrees to the direction one.
        """
        return _fusion.RectangularPatternFeature__set_directionTwoEntity(self, *args)

    def _get_directionOne(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Returns a Vector3D indicating the positive direction of direction one."""
        return _fusion.RectangularPatternFeature__get_directionOne(self)

    def _get_directionTwo(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """Returns a Vector3D indicating the positive direction of direction two."""
        return _fusion.RectangularPatternFeature__get_directionTwo(self)

    def _get_quantityOne(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the number of instances in the first direction.
        Edit the value through ModelParameter.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.RectangularPatternFeature__get_quantityOne(self)

    def _get_quantityTwo(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the number of instances in the second direction.
        Edit the value through ModelParameter.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.RectangularPatternFeature__get_quantityTwo(self)

    def _get_distanceOne(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the distance in the first direction.
        Edit the value through ModelParameter.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.RectangularPatternFeature__get_distanceOne(self)

    def _get_distanceTwo(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the distance in the second direction.
        Edit the value through ModelParameter.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.RectangularPatternFeature__get_distanceTwo(self)

    def _get_isSymmetricInDirectionOne(self) -> "bool" :
        """Gets and sets if the pattern in direction one is in one direction or symmetric."""
        return _fusion.RectangularPatternFeature__get_isSymmetricInDirectionOne(self)

    def _set_isSymmetricInDirectionOne(self, *args) -> "bool" :
        """Gets and sets if the pattern in direction one is in one direction or symmetric."""
        return _fusion.RectangularPatternFeature__set_isSymmetricInDirectionOne(self, *args)

    def _get_isSymmetricInDirectionTwo(self) -> "bool" :
        """Gets and sets if the pattern in direction two is in one direction or symmetric."""
        return _fusion.RectangularPatternFeature__get_isSymmetricInDirectionTwo(self)

    def _set_isSymmetricInDirectionTwo(self, *args) -> "bool" :
        """Gets and sets if the pattern in direction two is in one direction or symmetric."""
        return _fusion.RectangularPatternFeature__set_isSymmetricInDirectionTwo(self, *args)

    def _get_patternDistanceType(self) -> "adsk::fusion::PatternDistanceType" :
        """
        Gets and sets how the distance between elements is computed. Is initialized to ExtentPatternDistanceType when a new
        RectangularPatternFeatureInput has been created.
        """
        return _fusion.RectangularPatternFeature__get_patternDistanceType(self)

    def _set_patternDistanceType(self, *args) -> "bool" :
        """
        Gets and sets how the distance between elements is computed. Is initialized to ExtentPatternDistanceType when a new
        RectangularPatternFeatureInput has been created.
        """
        return _fusion.RectangularPatternFeature__set_patternDistanceType(self, *args)

    def _get_suppressedElementsIds(self) -> "std::vector< size_t,std::allocator< size_t > >" :
        """Gets and sets the ids of the patterns to suppress."""
        return _fusion.RectangularPatternFeature__get_suppressedElementsIds(self)

    def _set_suppressedElementsIds(self, *args) -> "bool" :
        """Gets and sets the ids of the patterns to suppress."""
        return _fusion.RectangularPatternFeature__set_suppressedElementsIds(self, *args)

    def _get_patternElements(self) -> "adsk::core::Ptr< adsk::fusion::PatternElements >" :
        """Gets the PatternElements collection that contains the elements created by this pattern."""
        return _fusion.RectangularPatternFeature__get_patternElements(self)

    def _get_resultFeatures(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Get the features that were created for this pattern.
        Returns null in the case where the feature is parametric.
        """
        return _fusion.RectangularPatternFeature__get_resultFeatures(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::RectangularPatternFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.RectangularPatternFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::RectangularPatternFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.RectangularPatternFeature_createForAssemblyContext(self, *args)

    def _get_patternEntityType(self) -> "adsk::fusion::PatternEntityTypes" :
        """
        Returns the type of entities the pattern consists of. This can be used to help
        determine the type of results that will be found in the pattern elements.
        """
        return _fusion.RectangularPatternFeature__get_patternEntityType(self)

    def _get_patternComputeOption(self) -> "adsk::fusion::PatternComputeOptions" :
        """
        Gets and sets the compute option for this pattern feature.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        """
        return _fusion.RectangularPatternFeature__get_patternComputeOption(self)

    def _set_patternComputeOption(self, *args) -> "bool" :
        """
        Gets and sets the compute option for this pattern feature.
        This property only applies when patterning features and is ignored in the direct modeling environment.
        """
        return _fusion.RectangularPatternFeature__set_patternComputeOption(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RectangularPatternFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RectangularPatternFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.RectangularPatternFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.RectangularPatternFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RectangularPatternFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RectangularPatternFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.RectangularPatternFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.RectangularPatternFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.RectangularPatternFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.RectangularPatternFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.RectangularPatternFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.RectangularPatternFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.RectangularPatternFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.RectangularPatternFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.RectangularPatternFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.RectangularPatternFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.RectangularPatternFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.RectangularPatternFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.RectangularPatternFeature__get_isValid(self)
RectangularPatternFeature_swigregister = _fusion.RectangularPatternFeature_swigregister
RectangularPatternFeature_swigregister(RectangularPatternFeature)

def RectangularPatternFeature_classType() -> "char const *" :
  return _fusion.RectangularPatternFeature_classType()
RectangularPatternFeature_classType = _fusion.RectangularPatternFeature_classType

RectangularPatternFeature.__swig_getmethods__["inputEntities"] = RectangularPatternFeature._get_inputEntities
RectangularPatternFeature.__swig_setmethods__["inputEntities"] = RectangularPatternFeature._set_inputEntities
RectangularPatternFeature.inputEntities = property(RectangularPatternFeature._get_inputEntities, RectangularPatternFeature._set_inputEntities, doc="Gets and sets the input entities. The collection can contain faces, features, bodies or occurrences.\nAll of the entities must be of a single type. For example, it can't contain features and occurrences\nbut only features or occurrences.")

RectangularPatternFeature.__swig_getmethods__["directionOneEntity"] = RectangularPatternFeature._get_directionOneEntity
RectangularPatternFeature.__swig_setmethods__["directionOneEntity"] = RectangularPatternFeature._set_directionOneEntity
RectangularPatternFeature.directionOneEntity = property(RectangularPatternFeature._get_directionOneEntity, RectangularPatternFeature._set_directionOneEntity, doc="Gets and sets the first direction entity.\nThis can be a linear edge, construction axis, sketch line or rectangular pattern feature.\nIf a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.")

RectangularPatternFeature.__swig_getmethods__["directionTwoEntity"] = RectangularPatternFeature._get_directionTwoEntity
RectangularPatternFeature.__swig_setmethods__["directionTwoEntity"] = RectangularPatternFeature._set_directionTwoEntity
RectangularPatternFeature.directionTwoEntity = property(RectangularPatternFeature._get_directionTwoEntity, RectangularPatternFeature._set_directionTwoEntity, doc="Gets and sets the second direction entity.\nThis can be a linear edge, construction axis, sketch line or rectangular pattern feature.\nIf a rectangular pattern feature is set, the directionOneEntity and directionTwoEntity properties return the same rectangular pattern feature.\nThis can be null when not entity has been specified to control the second direction. In this case Fusion 360 will compute a default direction which is\n90 degrees to the direction one.")

RectangularPatternFeature.__swig_getmethods__["directionOne"] = RectangularPatternFeature._get_directionOne
RectangularPatternFeature.directionOne = property(RectangularPatternFeature._get_directionOne, doc="Returns a Vector3D indicating the positive direction of direction one.")

RectangularPatternFeature.__swig_getmethods__["directionTwo"] = RectangularPatternFeature._get_directionTwo
RectangularPatternFeature.directionTwo = property(RectangularPatternFeature._get_directionTwo, doc="Returns a Vector3D indicating the positive direction of direction two.")

RectangularPatternFeature.__swig_getmethods__["quantityOne"] = RectangularPatternFeature._get_quantityOne
RectangularPatternFeature.quantityOne = property(RectangularPatternFeature._get_quantityOne, doc="Gets the number of instances in the first direction.\nEdit the value through ModelParameter.\nReturns nothing in the case where the feature is non-parametric.")

RectangularPatternFeature.__swig_getmethods__["quantityTwo"] = RectangularPatternFeature._get_quantityTwo
RectangularPatternFeature.quantityTwo = property(RectangularPatternFeature._get_quantityTwo, doc="Gets the number of instances in the second direction.\nEdit the value through ModelParameter.\nReturns nothing in the case where the feature is non-parametric.")

RectangularPatternFeature.__swig_getmethods__["distanceOne"] = RectangularPatternFeature._get_distanceOne
RectangularPatternFeature.distanceOne = property(RectangularPatternFeature._get_distanceOne, doc="Gets the distance in the first direction.\nEdit the value through ModelParameter.\nReturns nothing in the case where the feature is non-parametric.")

RectangularPatternFeature.__swig_getmethods__["distanceTwo"] = RectangularPatternFeature._get_distanceTwo
RectangularPatternFeature.distanceTwo = property(RectangularPatternFeature._get_distanceTwo, doc="Gets the distance in the second direction.\nEdit the value through ModelParameter.\nReturns nothing in the case where the feature is non-parametric.")

RectangularPatternFeature.__swig_getmethods__["isSymmetricInDirectionOne"] = RectangularPatternFeature._get_isSymmetricInDirectionOne
RectangularPatternFeature.__swig_setmethods__["isSymmetricInDirectionOne"] = RectangularPatternFeature._set_isSymmetricInDirectionOne
RectangularPatternFeature.isSymmetricInDirectionOne = property(RectangularPatternFeature._get_isSymmetricInDirectionOne, RectangularPatternFeature._set_isSymmetricInDirectionOne, doc="Gets and sets if the pattern in direction one is in one direction or symmetric.")

RectangularPatternFeature.__swig_getmethods__["isSymmetricInDirectionTwo"] = RectangularPatternFeature._get_isSymmetricInDirectionTwo
RectangularPatternFeature.__swig_setmethods__["isSymmetricInDirectionTwo"] = RectangularPatternFeature._set_isSymmetricInDirectionTwo
RectangularPatternFeature.isSymmetricInDirectionTwo = property(RectangularPatternFeature._get_isSymmetricInDirectionTwo, RectangularPatternFeature._set_isSymmetricInDirectionTwo, doc="Gets and sets if the pattern in direction two is in one direction or symmetric.")

RectangularPatternFeature.__swig_getmethods__["patternDistanceType"] = RectangularPatternFeature._get_patternDistanceType
RectangularPatternFeature.__swig_setmethods__["patternDistanceType"] = RectangularPatternFeature._set_patternDistanceType
RectangularPatternFeature.patternDistanceType = property(RectangularPatternFeature._get_patternDistanceType, RectangularPatternFeature._set_patternDistanceType, doc="Gets and sets how the distance between elements is computed. Is initialized to ExtentPatternDistanceType when a new\nRectangularPatternFeatureInput has been created.")

RectangularPatternFeature.__swig_getmethods__["suppressedElementsIds"] = RectangularPatternFeature._get_suppressedElementsIds
RectangularPatternFeature.__swig_setmethods__["suppressedElementsIds"] = RectangularPatternFeature._set_suppressedElementsIds
RectangularPatternFeature.suppressedElementsIds = property(RectangularPatternFeature._get_suppressedElementsIds, RectangularPatternFeature._set_suppressedElementsIds, doc="Gets and sets the ids of the patterns to suppress.")

RectangularPatternFeature.__swig_getmethods__["patternElements"] = RectangularPatternFeature._get_patternElements
RectangularPatternFeature.patternElements = property(RectangularPatternFeature._get_patternElements, doc="Gets the PatternElements collection that contains the elements created by this pattern.")

RectangularPatternFeature.__swig_getmethods__["resultFeatures"] = RectangularPatternFeature._get_resultFeatures
RectangularPatternFeature.resultFeatures = property(RectangularPatternFeature._get_resultFeatures, doc="Get the features that were created for this pattern.\nReturns null in the case where the feature is parametric.")

RectangularPatternFeature.__swig_getmethods__["nativeObject"] = RectangularPatternFeature._get_nativeObject
RectangularPatternFeature.nativeObject = property(RectangularPatternFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

RectangularPatternFeature.__swig_getmethods__["patternEntityType"] = RectangularPatternFeature._get_patternEntityType
RectangularPatternFeature.patternEntityType = property(RectangularPatternFeature._get_patternEntityType, doc="Returns the type of entities the pattern consists of. This can be used to help\ndetermine the type of results that will be found in the pattern elements.")

RectangularPatternFeature.__swig_getmethods__["patternComputeOption"] = RectangularPatternFeature._get_patternComputeOption
RectangularPatternFeature.__swig_setmethods__["patternComputeOption"] = RectangularPatternFeature._set_patternComputeOption
RectangularPatternFeature.patternComputeOption = property(RectangularPatternFeature._get_patternComputeOption, RectangularPatternFeature._set_patternComputeOption, doc="Gets and sets the compute option for this pattern feature.\nThis property only applies when patterning features and is ignored in the direct modeling environment.")

RectangularPatternFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RectangularPatternFeature) else None
RectangularPatternFeature.cast = lambda arg: arg if isinstance(arg, RectangularPatternFeature) else None

class RemoveFeature(Feature):
    """Object that represents an existing Remove feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RemoveFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RemoveFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::RemoveFeature *" : return _fusion.RemoveFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.RemoveFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.RemoveFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.RemoveFeature_classType
    if _newclass:classType = staticmethod(_fusion.RemoveFeature_classType)
    __swig_destroy__ = _fusion.delete_RemoveFeature
    __del__ = lambda self : None;
    def _get_itemToRemove(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the body or component occurrence to remove. In order to access (get) the item
        removed, you must roll the timeline back to just before the remove feature whose item you want to access.
        """
        return _fusion.RemoveFeature__get_itemToRemove(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::RemoveFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.RemoveFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::RemoveFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.RemoveFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RemoveFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RemoveFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.RemoveFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.RemoveFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RemoveFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RemoveFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.RemoveFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.RemoveFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.RemoveFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.RemoveFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.RemoveFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.RemoveFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.RemoveFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.RemoveFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.RemoveFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.RemoveFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.RemoveFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.RemoveFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.RemoveFeature__get_isValid(self)
RemoveFeature_swigregister = _fusion.RemoveFeature_swigregister
RemoveFeature_swigregister(RemoveFeature)

def RemoveFeature_classType() -> "char const *" :
  return _fusion.RemoveFeature_classType()
RemoveFeature_classType = _fusion.RemoveFeature_classType

RemoveFeature.__swig_getmethods__["itemToRemove"] = RemoveFeature._get_itemToRemove
RemoveFeature.itemToRemove = property(RemoveFeature._get_itemToRemove, doc="Gets and sets the body or component occurrence to remove. In order to access (get) the item\nremoved, you must roll the timeline back to just before the remove feature whose item you want to access.")

RemoveFeature.__swig_getmethods__["nativeObject"] = RemoveFeature._get_nativeObject
RemoveFeature.nativeObject = property(RemoveFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

RemoveFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RemoveFeature) else None
RemoveFeature.cast = lambda arg: arg if isinstance(arg, RemoveFeature) else None

class ReplaceFaceFeature(Feature):
    """Object that represents an existing replace face feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ReplaceFaceFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ReplaceFaceFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ReplaceFaceFeature *" : return _fusion.ReplaceFaceFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ReplaceFaceFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ReplaceFaceFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ReplaceFaceFeature_classType
    if _newclass:classType = staticmethod(_fusion.ReplaceFaceFeature_classType)
    __swig_destroy__ = _fusion.delete_ReplaceFaceFeature
    __del__ = lambda self : None;
    def setInputEntities(self, *args) -> "bool" :
        """
        Method that sets faces to replace. 
        sourceFaces : The collection can contain the faces from a solid and/or from features. All the faces must be on the same body. 
        isTangentChain : A boolean value for setting whether or not faces that are tangentially connected to 
        the input faces (if any) will also be included. A value of true indicates that tangent
        faces will be included. 
        Returns true if successful.
        """
        return _fusion.ReplaceFaceFeature_setInputEntities(self, *args)

    def _get_targetFaces(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the entities that define the target faces. The new faces must completely intersect the part.
        The collection can contain the surface faces, surface bodies and construction planes.
        """
        return _fusion.ReplaceFaceFeature__get_targetFaces(self)

    def _set_targetFaces(self, *args) -> "bool" :
        """
        Gets and sets the entities that define the target faces. The new faces must completely intersect the part.
        The collection can contain the surface faces, surface bodies and construction planes.
        """
        return _fusion.ReplaceFaceFeature__set_targetFaces(self, *args)

    def _get_isTangentChain(self) -> "bool" :
        """
        Gets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities.
        """
        return _fusion.ReplaceFaceFeature__get_isTangentChain(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ReplaceFaceFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ReplaceFaceFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::ReplaceFaceFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ReplaceFaceFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ReplaceFaceFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ReplaceFaceFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ReplaceFaceFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.ReplaceFaceFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ReplaceFaceFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ReplaceFaceFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.ReplaceFaceFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.ReplaceFaceFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.ReplaceFaceFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.ReplaceFaceFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ReplaceFaceFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.ReplaceFaceFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.ReplaceFaceFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.ReplaceFaceFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ReplaceFaceFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.ReplaceFaceFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ReplaceFaceFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ReplaceFaceFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ReplaceFaceFeature__get_isValid(self)
ReplaceFaceFeature_swigregister = _fusion.ReplaceFaceFeature_swigregister
ReplaceFaceFeature_swigregister(ReplaceFaceFeature)

def ReplaceFaceFeature_classType() -> "char const *" :
  return _fusion.ReplaceFaceFeature_classType()
ReplaceFaceFeature_classType = _fusion.ReplaceFaceFeature_classType

ReplaceFaceFeature.__swig_getmethods__["targetFaces"] = ReplaceFaceFeature._get_targetFaces
ReplaceFaceFeature.__swig_setmethods__["targetFaces"] = ReplaceFaceFeature._set_targetFaces
ReplaceFaceFeature.targetFaces = property(ReplaceFaceFeature._get_targetFaces, ReplaceFaceFeature._set_targetFaces, doc="Gets and sets the entities that define the target faces. The new faces must completely intersect the part.\nThe collection can contain the surface faces, surface bodies and construction planes.")

ReplaceFaceFeature.__swig_getmethods__["isTangentChain"] = ReplaceFaceFeature._get_isTangentChain
ReplaceFaceFeature.isTangentChain = property(ReplaceFaceFeature._get_isTangentChain, doc="Gets if any faces that are tangentially connected to any of\nthe input faces will also be included in setting InputEntities.")

ReplaceFaceFeature.__swig_getmethods__["nativeObject"] = ReplaceFaceFeature._get_nativeObject
ReplaceFaceFeature.nativeObject = property(ReplaceFaceFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

ReplaceFaceFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ReplaceFaceFeature) else None
ReplaceFaceFeature.cast = lambda arg: arg if isinstance(arg, ReplaceFaceFeature) else None

class ReverseNormalFeature(Feature):
    """Object that represents an existing Reverse Normal feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ReverseNormalFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ReverseNormalFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ReverseNormalFeature *" : return _fusion.ReverseNormalFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ReverseNormalFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ReverseNormalFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ReverseNormalFeature_classType
    if _newclass:classType = staticmethod(_fusion.ReverseNormalFeature_classType)
    __swig_destroy__ = _fusion.delete_ReverseNormalFeature
    __del__ = lambda self : None;
    def _get_surfaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the surface bodies (open BRepBodies) whose faces normals are to be reversed. 
        All faces of the input surface bodies get reversed.
        """
        return _fusion.ReverseNormalFeature__get_surfaces(self)

    def _set_surfaces(self, *args) -> "bool" :
        """
        Gets and sets the surface bodies (open BRepBodies) whose faces normals are to be reversed. 
        All faces of the input surface bodies get reversed.
        """
        return _fusion.ReverseNormalFeature__set_surfaces(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ReverseNormalFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ReverseNormalFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::ReverseNormalFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.ReverseNormalFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ReverseNormalFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ReverseNormalFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ReverseNormalFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.ReverseNormalFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ReverseNormalFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ReverseNormalFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.ReverseNormalFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.ReverseNormalFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.ReverseNormalFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.ReverseNormalFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ReverseNormalFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.ReverseNormalFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.ReverseNormalFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.ReverseNormalFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ReverseNormalFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.ReverseNormalFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ReverseNormalFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ReverseNormalFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ReverseNormalFeature__get_isValid(self)
ReverseNormalFeature_swigregister = _fusion.ReverseNormalFeature_swigregister
ReverseNormalFeature_swigregister(ReverseNormalFeature)

def ReverseNormalFeature_classType() -> "char const *" :
  return _fusion.ReverseNormalFeature_classType()
ReverseNormalFeature_classType = _fusion.ReverseNormalFeature_classType

ReverseNormalFeature.__swig_getmethods__["surfaces"] = ReverseNormalFeature._get_surfaces
ReverseNormalFeature.__swig_setmethods__["surfaces"] = ReverseNormalFeature._set_surfaces
ReverseNormalFeature.surfaces = property(ReverseNormalFeature._get_surfaces, ReverseNormalFeature._set_surfaces, doc="Gets and sets the surface bodies (open BRepBodies) whose faces normals are to be reversed.\nAll faces of the input surface bodies get reversed.")

ReverseNormalFeature.__swig_getmethods__["nativeObject"] = ReverseNormalFeature._get_nativeObject
ReverseNormalFeature.nativeObject = property(ReverseNormalFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

ReverseNormalFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ReverseNormalFeature) else None
ReverseNormalFeature.cast = lambda arg: arg if isinstance(arg, ReverseNormalFeature) else None

class RevoluteJointMotion(JointMotion):
    """Represents the set of information specific to a revolute joint."""
    __swig_setmethods__ = {}
    for _s in [JointMotion]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RevoluteJointMotion, name, value)
    __swig_getmethods__ = {}
    for _s in [JointMotion]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RevoluteJointMotion, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::RevoluteJointMotion *" : return _fusion.RevoluteJointMotion___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.RevoluteJointMotion___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.RevoluteJointMotion___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.RevoluteJointMotion_classType
    if _newclass:classType = staticmethod(_fusion.RevoluteJointMotion_classType)
    __swig_destroy__ = _fusion.delete_RevoluteJointMotion
    __del__ = lambda self : None;
    def _get_rotationAxis(self) -> "adsk::fusion::JointDirections" :
        """
        Gets and sets the direction of the axis of rotation. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customRotationAxisEntity will return an entity
        that defines the axis. If there is a custom rotation axis defined and this
        property is set to one of the three standard axes, the custom rotation will
        be removed and customRotationAxisEntity will return null.
        """
        return _fusion.RevoluteJointMotion__get_rotationAxis(self)

    def _set_rotationAxis(self, *args) -> "bool" :
        """
        Gets and sets the direction of the axis of rotation. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customRotationAxisEntity will return an entity
        that defines the axis. If there is a custom rotation axis defined and this
        property is set to one of the three standard axes, the custom rotation will
        be removed and customRotationAxisEntity will return null.
        """
        return _fusion.RevoluteJointMotion__set_rotationAxis(self, *args)

    def _get_rotationAxisVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Returns the direction of the rotation axis. This property will return null in the case
        where the RevolutionJointMotion object was obtained from a JointInput object.
        """
        return _fusion.RevoluteJointMotion__get_rotationAxisVector(self)

    def _get_customRotationAxisEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        This property can be set using various types of entities that can infer an
        axis. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the rotationAxis property returns
        CustomJointDirection. Setting this property will automatically set
        the rotationAxis property to CustomJointDirection.
        """
        return _fusion.RevoluteJointMotion__get_customRotationAxisEntity(self)

    def _set_customRotationAxisEntity(self, *args) -> "bool" :
        """
        This property can be set using various types of entities that can infer an
        axis. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the rotationAxis property returns
        CustomJointDirection. Setting this property will automatically set
        the rotationAxis property to CustomJointDirection.
        """
        return _fusion.RevoluteJointMotion__set_customRotationAxisEntity(self, *args)

    def _get_rotationValue(self) -> "double" :
        """
        Gets and sets the rotation value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.RevoluteJointMotion__get_rotationValue(self)

    def _set_rotationValue(self, *args) -> "bool" :
        """
        Gets and sets the rotation value. This is in radians. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.RevoluteJointMotion__set_rotationValue(self, *args)

    def _get_rotationLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >" :
        """
        Returns a JointLimits object that defines the rotation limits for this joint.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.RevoluteJointMotion__get_rotationLimits(self)

    def _get_jointType(self) -> "adsk::fusion::JointTypes" :
        """Returns an enum value indicating the type of joint this joint represents."""
        return _fusion.RevoluteJointMotion__get_jointType(self)

    def _get_objectType(self) -> "char const *" : return _fusion.RevoluteJointMotion__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.RevoluteJointMotion__get_isValid(self)
RevoluteJointMotion_swigregister = _fusion.RevoluteJointMotion_swigregister
RevoluteJointMotion_swigregister(RevoluteJointMotion)

def RevoluteJointMotion_classType() -> "char const *" :
  return _fusion.RevoluteJointMotion_classType()
RevoluteJointMotion_classType = _fusion.RevoluteJointMotion_classType

RevoluteJointMotion.__swig_getmethods__["rotationAxis"] = RevoluteJointMotion._get_rotationAxis
RevoluteJointMotion.__swig_setmethods__["rotationAxis"] = RevoluteJointMotion._set_rotationAxis
RevoluteJointMotion.rotationAxis = property(RevoluteJointMotion._get_rotationAxis, RevoluteJointMotion._set_rotationAxis, doc="Gets and sets the direction of the axis of rotation. This can be set to\nXAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can\nreturn those three directions and CustomJointDirection. If this returns\nCustomJointDirection then the customRotationAxisEntity will return an entity\nthat defines the axis. If there is a custom rotation axis defined and this\nproperty is set to one of the three standard axes, the custom rotation will\nbe removed and customRotationAxisEntity will return null.")

RevoluteJointMotion.__swig_getmethods__["rotationAxisVector"] = RevoluteJointMotion._get_rotationAxisVector
RevoluteJointMotion.rotationAxisVector = property(RevoluteJointMotion._get_rotationAxisVector, doc="Returns the direction of the rotation axis. This property will return null in the case\nwhere the RevolutionJointMotion object was obtained from a JointInput object.")

RevoluteJointMotion.__swig_getmethods__["customRotationAxisEntity"] = RevoluteJointMotion._get_customRotationAxisEntity
RevoluteJointMotion.__swig_setmethods__["customRotationAxisEntity"] = RevoluteJointMotion._set_customRotationAxisEntity
RevoluteJointMotion.customRotationAxisEntity = property(RevoluteJointMotion._get_customRotationAxisEntity, RevoluteJointMotion._set_customRotationAxisEntity, doc="This property can be set using various types of entities that can infer an\naxis. For example, a linear edge, sketch line, planar face, and cylindrical face.\nThis property is only valid in the case where the rotationAxis property returns\nCustomJointDirection. Setting this property will automatically set\nthe rotationAxis property to CustomJointDirection.")

RevoluteJointMotion.__swig_getmethods__["rotationValue"] = RevoluteJointMotion._get_rotationValue
RevoluteJointMotion.__swig_setmethods__["rotationValue"] = RevoluteJointMotion._set_rotationValue
RevoluteJointMotion.rotationValue = property(RevoluteJointMotion._get_rotationValue, RevoluteJointMotion._set_rotationValue, doc="Gets and sets the rotation value. This is in radians. Setting this value is\nthe equivalent of using the Drive Joints command.")

RevoluteJointMotion.__swig_getmethods__["rotationLimits"] = RevoluteJointMotion._get_rotationLimits
RevoluteJointMotion.rotationLimits = property(RevoluteJointMotion._get_rotationLimits, doc="Returns a JointLimits object that defines the rotation limits for this joint.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")

RevoluteJointMotion.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RevoluteJointMotion) else None
RevoluteJointMotion.cast = lambda arg: arg if isinstance(arg, RevoluteJointMotion) else None

class RevolveFeature(Feature):
    """Object that represents an existing revolve feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RevolveFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RevolveFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::RevolveFeature *" : return _fusion.RevolveFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.RevolveFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.RevolveFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.RevolveFeature_classType
    if _newclass:classType = staticmethod(_fusion.RevolveFeature_classType)
    __swig_destroy__ = _fusion.delete_RevolveFeature
    __del__ = lambda self : None;
    def _get_profile(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the profiles or planar faces used to define the shape of the revolve.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        When setting this property of a surface (non-solid) extrusion, you can use the 
        createOpenProfile and createBRepEdgeProfile methods of the Component object to create
        an open profile.
        This property returns null in the case where the feature is non-parametric.
        """
        return _fusion.RevolveFeature__get_profile(self)

    def _set_profile(self, *args) -> "bool" :
        """
        Gets and sets the profiles or planar faces used to define the shape of the revolve.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        When setting this property of a surface (non-solid) extrusion, you can use the 
        createOpenProfile and createBRepEdgeProfile methods of the Component object to create
        an open profile.
        This property returns null in the case where the feature is non-parametric.
        """
        return _fusion.RevolveFeature__set_profile(self, *args)

    def _get_axis(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the entity used to define the axis of revolution.
        The axis can be a sketch line, construction axis, or linear edge. If it is not in
        the same plane as the profile, it is projected onto the profile plane.
        """
        return _fusion.RevolveFeature__get_axis(self)

    def _set_axis(self, *args) -> "bool" :
        """
        Gets and sets the entity used to define the axis of revolution.
        The axis can be a sketch line, construction axis, or linear edge. If it is not in
        the same plane as the profile, it is projected onto the profile plane.
        """
        return _fusion.RevolveFeature__set_axis(self, *args)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """Gets and sets the type of operation performed by the revolve."""
        return _fusion.RevolveFeature__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """Gets and sets the type of operation performed by the revolve."""
        return _fusion.RevolveFeature__set_operation(self, *args)

    def _get_extentDefinition(self) -> "adsk::core::Ptr< adsk::fusion::ExtentDefinition >" :
        """
        Gets the definition object that is defining the extent of the revolve. Modifying the
        definition object will cause the revolve to recompute. Various types of objects can
        be returned depending on the type of extent currently defined for the revolve.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.RevolveFeature__get_extentDefinition(self)

    def setAngleExtent(self, *args) -> "bool" :
        """
        Defines the extent of the revolution to be at a defined angle. 
        isSymmetric : Boolean that specifies if the extent is symmetric or not. 
        angle : ValueInput object that defines the angle. This can be a string or a value. If
        it's a string it is interpreted using the current document units and can include
        equations. For example all of the following are valid as long as they result in
        angle units; '45', '45 deg', 'a1 / 2'. If a value is input it is interpreted
        as radians.
        If isSymmetric is false a positive or negative angle can be
        used to control the direction. If isSymmetric is true, the angle is the extent in one
        direction so the entire angle of the revolution will be twice the specified angle. 
        Use an angle of 360 deg or 2 pi radians to create a full revolve. 
        Returns true if successful
        """
        return _fusion.RevolveFeature_setAngleExtent(self, *args)

    def setTwoSideAngleExtent(self, *args) -> "bool" :
        """
        Changes the extent of the revolve to be defined as a two sided angle extent. 
        angleOne : ValueInput object that defines the first angle. This can be a string or a value. If
        it's a string it is interpreted using the current document units and can include
        equations. For example all of the following are valid as long as they result in
        angle units; '45', '45 deg', 'a1 / 2'. If a value is input it is interpreted
        as radians. 
        angleTwo : ValueInput object that defines the second angle. This can be a string or a value. If
        it's a string it is interpreted using the current document units and can include
        equations. For example all of the following are valid as long as they result in
        angle units; '45', '45 deg', 'a1 / 2'. If a value is input it is interpreted
        as radians. 
        Returns true if successful
        """
        return _fusion.RevolveFeature_setTwoSideAngleExtent(self, *args)

    def setOneSideToExtent(self, *args) -> "bool" :
        """
        Changes the extent of the revolve to be from the sketch plane to the specified 'to' face. 
        toEntity : The entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For a revolve it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        directionHint : Specifies the direction of the revolve. 
        Returns true if successful.
        """
        return _fusion.RevolveFeature_setOneSideToExtent(self, *args)

    def setTwoSidesToExtent(self, *args) -> "bool" :
        """
        Changes the extent of the revolve to be defined as a two sided to extent. 
        toEntityOne : The first entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For a revolve it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        toEntityTwo : The second entity that defines the 'to' extent. The valid types of entities can vary depending on
        the type of feature this is being used with. For a revolve it can be a BRepBody, BRepFace,
        BRepVertex, ConstructionPlane, or ConstructionPoint. 
        Returns true if successful
        """
        return _fusion.RevolveFeature_setTwoSidesToExtent(self, *args)

    def _get_startFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Property that returns the set of faces that cap one end of the revolve and are coincident 
        with the sketch plane. In the case of a symmetric revolve these faces are the ones on the 
        positive normal side of the sketch plane. In the case where there aren't any start faces,
        this property will return null.
        """
        return _fusion.RevolveFeature__get_startFaces(self)

    def _get_endFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Property that returns the set of faces that cap the end of the revolve opposite the
        start faces. In the case where there aren't any start faces, this property will return null.
        """
        return _fusion.RevolveFeature__get_endFaces(self)

    def _get_sideFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """Property that returns all of the faces created around the perimeter of the feature."""
        return _fusion.RevolveFeature__get_sideFaces(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::RevolveFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.RevolveFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::RevolveFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.RevolveFeature_createForAssemblyContext(self, *args)

    def _get_isSolid(self) -> "bool" :
        """Indicates if this feature was initially created as a solid or a surface."""
        return _fusion.RevolveFeature__get_isSolid(self)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >" :
        """
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        When setting or getting this property, you must roll the timeline back to just before the feature 
        so that the model is in the state just before the feature is computed.
        """
        return _fusion.RevolveFeature__get_participantBodies(self)

    def _set_participantBodies(self, *args) -> "bool" :
        """
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        When setting or getting this property, you must roll the timeline back to just before the feature 
        so that the model is in the state just before the feature is computed.
        """
        return _fusion.RevolveFeature__set_participantBodies(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RevolveFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RevolveFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.RevolveFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.RevolveFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RevolveFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RevolveFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.RevolveFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.RevolveFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.RevolveFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.RevolveFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.RevolveFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.RevolveFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.RevolveFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.RevolveFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.RevolveFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.RevolveFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.RevolveFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.RevolveFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.RevolveFeature__get_isValid(self)
RevolveFeature_swigregister = _fusion.RevolveFeature_swigregister
RevolveFeature_swigregister(RevolveFeature)

def RevolveFeature_classType() -> "char const *" :
  return _fusion.RevolveFeature_classType()
RevolveFeature_classType = _fusion.RevolveFeature_classType

RevolveFeature.__swig_getmethods__["profile"] = RevolveFeature._get_profile
RevolveFeature.__swig_setmethods__["profile"] = RevolveFeature._set_profile
RevolveFeature.profile = property(RevolveFeature._get_profile, RevolveFeature._set_profile, doc="Gets and sets the profiles or planar faces used to define the shape of the revolve.\nThis property can return or be set with a single Profile, a single planar face, or\nan ObjectCollection consisting of multiple profiles and planar faces. When an\nObjectCollection is used all of the profiles and faces must be co-planar.\nWhen setting this property of a surface (non-solid) extrusion, you can use the\ncreateOpenProfile and createBRepEdgeProfile methods of the Component object to create\nan open profile.\nThis property returns null in the case where the feature is non-parametric.")

RevolveFeature.__swig_getmethods__["axis"] = RevolveFeature._get_axis
RevolveFeature.__swig_setmethods__["axis"] = RevolveFeature._set_axis
RevolveFeature.axis = property(RevolveFeature._get_axis, RevolveFeature._set_axis, doc="Gets and sets the entity used to define the axis of revolution.\nThe axis can be a sketch line, construction axis, or linear edge. If it is not in\nthe same plane as the profile, it is projected onto the profile plane.")

RevolveFeature.__swig_getmethods__["operation"] = RevolveFeature._get_operation
RevolveFeature.__swig_setmethods__["operation"] = RevolveFeature._set_operation
RevolveFeature.operation = property(RevolveFeature._get_operation, RevolveFeature._set_operation, doc="Gets and sets the type of operation performed by the revolve.")

RevolveFeature.__swig_getmethods__["extentDefinition"] = RevolveFeature._get_extentDefinition
RevolveFeature.extentDefinition = property(RevolveFeature._get_extentDefinition, doc="Gets the definition object that is defining the extent of the revolve. Modifying the\ndefinition object will cause the revolve to recompute. Various types of objects can\nbe returned depending on the type of extent currently defined for the revolve.\nThis property returns nothing in the case where the feature is non-parametric.")

RevolveFeature.__swig_getmethods__["startFaces"] = RevolveFeature._get_startFaces
RevolveFeature.startFaces = property(RevolveFeature._get_startFaces, doc="Property that returns the set of faces that cap one end of the revolve and are coincident\nwith the sketch plane. In the case of a symmetric revolve these faces are the ones on the\npositive normal side of the sketch plane. In the case where there aren't any start faces,\nthis property will return null.")

RevolveFeature.__swig_getmethods__["endFaces"] = RevolveFeature._get_endFaces
RevolveFeature.endFaces = property(RevolveFeature._get_endFaces, doc="Property that returns the set of faces that cap the end of the revolve opposite the\nstart faces. In the case where there aren't any start faces, this property will return null.")

RevolveFeature.__swig_getmethods__["sideFaces"] = RevolveFeature._get_sideFaces
RevolveFeature.sideFaces = property(RevolveFeature._get_sideFaces, doc="Property that returns all of the faces created around the perimeter of the feature.")

RevolveFeature.__swig_getmethods__["nativeObject"] = RevolveFeature._get_nativeObject
RevolveFeature.nativeObject = property(RevolveFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

RevolveFeature.__swig_getmethods__["isSolid"] = RevolveFeature._get_isSolid
RevolveFeature.isSolid = property(RevolveFeature._get_isSolid, doc="Indicates if this feature was initially created as a solid or a surface.")

RevolveFeature.__swig_getmethods__["participantBodies"] = RevolveFeature._get_participantBodies
RevolveFeature.__swig_setmethods__["participantBodies"] = RevolveFeature._set_participantBodies
RevolveFeature.participantBodies = property(RevolveFeature._get_participantBodies, RevolveFeature._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.\nWhen setting or getting this property, you must roll the timeline back to just before the feature\nso that the model is in the state just before the feature is computed.")

RevolveFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RevolveFeature) else None
RevolveFeature.cast = lambda arg: arg if isinstance(arg, RevolveFeature) else None

class RibFeature(Feature):
    """Object that represents an existing Rib feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RibFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RibFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::RibFeature *" : return _fusion.RibFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.RibFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.RibFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.RibFeature_classType
    if _newclass:classType = staticmethod(_fusion.RibFeature_classType)
    __swig_destroy__ = _fusion.delete_RibFeature
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RibFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RibFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.RibFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.RibFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RibFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RibFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.RibFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.RibFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.RibFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.RibFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.RibFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.RibFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.RibFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.RibFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.RibFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.RibFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.RibFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.RibFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.RibFeature__get_isValid(self)
RibFeature_swigregister = _fusion.RibFeature_swigregister
RibFeature_swigregister(RibFeature)

def RibFeature_classType() -> "char const *" :
  return _fusion.RibFeature_classType()
RibFeature_classType = _fusion.RibFeature_classType

RibFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RibFeature) else None
RibFeature.cast = lambda arg: arg if isinstance(arg, RibFeature) else None

class RigidJointMotion(JointMotion):
    """
    Represents the set of information specific to a rigid joint. A 
    rigid joint doesn't support any additional information beyond
    getting the joint type which it derives from JointMotion.
    """
    __swig_setmethods__ = {}
    for _s in [JointMotion]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RigidJointMotion, name, value)
    __swig_getmethods__ = {}
    for _s in [JointMotion]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RigidJointMotion, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::RigidJointMotion *" : return _fusion.RigidJointMotion___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.RigidJointMotion___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.RigidJointMotion___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.RigidJointMotion_classType
    if _newclass:classType = staticmethod(_fusion.RigidJointMotion_classType)
    __swig_destroy__ = _fusion.delete_RigidJointMotion
    __del__ = lambda self : None;
    def _get_jointType(self) -> "adsk::fusion::JointTypes" :
        """Returns an enum value indicating the type of joint this joint represents."""
        return _fusion.RigidJointMotion__get_jointType(self)

    def _get_objectType(self) -> "char const *" : return _fusion.RigidJointMotion__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.RigidJointMotion__get_isValid(self)
RigidJointMotion_swigregister = _fusion.RigidJointMotion_swigregister
RigidJointMotion_swigregister(RigidJointMotion)

def RigidJointMotion_classType() -> "char const *" :
  return _fusion.RigidJointMotion_classType()
RigidJointMotion_classType = _fusion.RigidJointMotion_classType

RigidJointMotion.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RigidJointMotion) else None
RigidJointMotion.cast = lambda arg: arg if isinstance(arg, RigidJointMotion) else None

class RuleFilletFeature(Feature):
    """Object that represents an existing rule fillet feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RuleFilletFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RuleFilletFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::RuleFilletFeature *" : return _fusion.RuleFilletFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.RuleFilletFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.RuleFilletFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.RuleFilletFeature_classType
    if _newclass:classType = staticmethod(_fusion.RuleFilletFeature_classType)
    __swig_destroy__ = _fusion.delete_RuleFilletFeature
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RuleFilletFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.RuleFilletFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.RuleFilletFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.RuleFilletFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RuleFilletFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.RuleFilletFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.RuleFilletFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.RuleFilletFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.RuleFilletFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.RuleFilletFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.RuleFilletFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.RuleFilletFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.RuleFilletFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.RuleFilletFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.RuleFilletFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.RuleFilletFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.RuleFilletFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.RuleFilletFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.RuleFilletFeature__get_isValid(self)
RuleFilletFeature_swigregister = _fusion.RuleFilletFeature_swigregister
RuleFilletFeature_swigregister(RuleFilletFeature)

def RuleFilletFeature_classType() -> "char const *" :
  return _fusion.RuleFilletFeature_classType()
RuleFilletFeature_classType = _fusion.RuleFilletFeature_classType

RuleFilletFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, RuleFilletFeature) else None
RuleFilletFeature.cast = lambda arg: arg if isinstance(arg, RuleFilletFeature) else None

class SATExportOptions(ExportOptions):
    """Defines that a SAT export is to be done and specifies the various options."""
    __swig_setmethods__ = {}
    for _s in [ExportOptions]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SATExportOptions, name, value)
    __swig_getmethods__ = {}
    for _s in [ExportOptions]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SATExportOptions, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SATExportOptions *" : return _fusion.SATExportOptions___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SATExportOptions___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SATExportOptions___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SATExportOptions_classType
    if _newclass:classType = staticmethod(_fusion.SATExportOptions_classType)
    __swig_destroy__ = _fusion.delete_SATExportOptions
    __del__ = lambda self : None;
    def _get_filename(self) -> "std::string" :
        """
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.SATExportOptions__get_filename(self)

    def _set_filename(self, *args) -> "bool" :
        """
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.SATExportOptions__set_filename(self, *args)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Specifies the geometry to export. This can be Occurrence, or the root Component. For STLExport, we also support BRepBody."""
        return _fusion.SATExportOptions__get_geometry(self)

    def _set_geometry(self, *args) -> "bool" :
        """Specifies the geometry to export. This can be Occurrence, or the root Component. For STLExport, we also support BRepBody."""
        return _fusion.SATExportOptions__set_geometry(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SATExportOptions__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SATExportOptions__get_isValid(self)
SATExportOptions_swigregister = _fusion.SATExportOptions_swigregister
SATExportOptions_swigregister(SATExportOptions)

def SATExportOptions_classType() -> "char const *" :
  return _fusion.SATExportOptions_classType()
SATExportOptions_classType = _fusion.SATExportOptions_classType

SATExportOptions.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SATExportOptions) else None
SATExportOptions.cast = lambda arg: arg if isinstance(arg, SATExportOptions) else None

class ScaleFeature(Feature):
    """Object that represents an existing scale feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScaleFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScaleFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ScaleFeature *" : return _fusion.ScaleFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ScaleFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ScaleFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ScaleFeature_classType
    if _newclass:classType = staticmethod(_fusion.ScaleFeature_classType)
    __swig_destroy__ = _fusion.delete_ScaleFeature
    __del__ = lambda self : None;
    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the input entities.
        This collection can contain sketches, BRep bodies and T-Spline bodies in parametric modeling.
        It can contain sketches, BRep bodies, T-Spline bodies, mesh bodies, root component and occurrences in non-parametric modeling.
        If the scaling is non-uniform (the isUniform property is false), this collection cannot contain sketches or components.
        """
        return _fusion.ScaleFeature__get_inputEntities(self)

    def _set_inputEntities(self, *args) -> "bool" :
        """
        Gets and sets the input entities.
        This collection can contain sketches, BRep bodies and T-Spline bodies in parametric modeling.
        It can contain sketches, BRep bodies, T-Spline bodies, mesh bodies, root component and occurrences in non-parametric modeling.
        If the scaling is non-uniform (the isUniform property is false), this collection cannot contain sketches or components.
        """
        return _fusion.ScaleFeature__set_inputEntities(self, *args)

    def _get_point(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets and sets the point as reference to scale. This can be a BRepVertex, a SketchPoint or a ConstructionPoint."""
        return _fusion.ScaleFeature__get_point(self)

    def _set_point(self, *args) -> "bool" :
        """Gets and sets the point as reference to scale. This can be a BRepVertex, a SketchPoint or a ConstructionPoint."""
        return _fusion.ScaleFeature__set_point(self, *args)

    def setToUniform(self, *args) -> "bool" :
        """
        Calling this method will change to a uniform scale.
        The isUniform is set to true if successful. 
        scaleFactor : A ValueInput object that defines the scale factor. 
        Returns true if successful.
        """
        return _fusion.ScaleFeature_setToUniform(self, *args)

    def setToNonUniform(self, *args) -> "bool" :
        """
        Calling this method will change to a non-uniform scale.
        Fails of the inputEntities collection contains sketches or components.
        The isUniform is set to false if successful. 
        xScale : A ValueInput object that defines the scale in the X direction. 
        yScale : A ValueInput object that defines the scale in the Y direction. 
        zScale : A ValueInput object that defines the scale in the Z direction. 
        Returns true if successful.
        """
        return _fusion.ScaleFeature_setToNonUniform(self, *args)

    def _get_isUniform(self) -> "bool" :
        """Gets if it's uniform scale."""
        return _fusion.ScaleFeature__get_isUniform(self)

    def _get_scaleFactor(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter that controls the uniform scale factor. This will return null in the case
        where isUniform is false or the feature is non-parametric. You can use the properties and 
        methods on the ModelParameter object to get and set the value.
        """
        return _fusion.ScaleFeature__get_scaleFactor(self)

    def _get_xScale(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter that controls the X scale factor. This will return null in the case
        where isUniform is false or the feature is non-parametric. You can use the properties and 
        methods on the ModelParameter object to get and set the value.
        """
        return _fusion.ScaleFeature__get_xScale(self)

    def _get_yScale(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter that controls the Y scale factor. This will return null in the case
        where isUniform is false or the feature is non-parametric. You can use the properties and 
        methods on the ModelParameter object to get and set the value.
        """
        return _fusion.ScaleFeature__get_yScale(self)

    def _get_zScale(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter that controls the Z scale factor. This will return null in the case
        where isUniform is false or the feature is non-parametric. You can use the properties and 
        methods on the ModelParameter object to get and set the value.
        """
        return _fusion.ScaleFeature__get_zScale(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ScaleFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ScaleFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::ScaleFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ScaleFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ScaleFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ScaleFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ScaleFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.ScaleFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ScaleFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ScaleFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.ScaleFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.ScaleFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.ScaleFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.ScaleFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ScaleFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.ScaleFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.ScaleFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.ScaleFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ScaleFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.ScaleFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ScaleFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ScaleFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ScaleFeature__get_isValid(self)
ScaleFeature_swigregister = _fusion.ScaleFeature_swigregister
ScaleFeature_swigregister(ScaleFeature)

def ScaleFeature_classType() -> "char const *" :
  return _fusion.ScaleFeature_classType()
ScaleFeature_classType = _fusion.ScaleFeature_classType

ScaleFeature.__swig_getmethods__["inputEntities"] = ScaleFeature._get_inputEntities
ScaleFeature.__swig_setmethods__["inputEntities"] = ScaleFeature._set_inputEntities
ScaleFeature.inputEntities = property(ScaleFeature._get_inputEntities, ScaleFeature._set_inputEntities, doc="Gets and sets the input entities.\nThis collection can contain sketches, BRep bodies and T-Spline bodies in parametric modeling.\nIt can contain sketches, BRep bodies, T-Spline bodies, mesh bodies, root component and occurrences in non-parametric modeling.\nIf the scaling is non-uniform (the isUniform property is false), this collection cannot contain sketches or components.")

ScaleFeature.__swig_getmethods__["point"] = ScaleFeature._get_point
ScaleFeature.__swig_setmethods__["point"] = ScaleFeature._set_point
ScaleFeature.point = property(ScaleFeature._get_point, ScaleFeature._set_point, doc="Gets and sets the point as reference to scale. This can be a BRepVertex, a SketchPoint or a ConstructionPoint.")

ScaleFeature.__swig_getmethods__["isUniform"] = ScaleFeature._get_isUniform
ScaleFeature.isUniform = property(ScaleFeature._get_isUniform, doc="Gets if it's uniform scale.")

ScaleFeature.__swig_getmethods__["scaleFactor"] = ScaleFeature._get_scaleFactor
ScaleFeature.scaleFactor = property(ScaleFeature._get_scaleFactor, doc="Returns the parameter that controls the uniform scale factor. This will return null in the case\nwhere isUniform is false or the feature is non-parametric. You can use the properties and\nmethods on the ModelParameter object to get and set the value.")

ScaleFeature.__swig_getmethods__["xScale"] = ScaleFeature._get_xScale
ScaleFeature.xScale = property(ScaleFeature._get_xScale, doc="Returns the parameter that controls the X scale factor. This will return null in the case\nwhere isUniform is false or the feature is non-parametric. You can use the properties and\nmethods on the ModelParameter object to get and set the value.")

ScaleFeature.__swig_getmethods__["yScale"] = ScaleFeature._get_yScale
ScaleFeature.yScale = property(ScaleFeature._get_yScale, doc="Returns the parameter that controls the Y scale factor. This will return null in the case\nwhere isUniform is false or the feature is non-parametric. You can use the properties and\nmethods on the ModelParameter object to get and set the value.")

ScaleFeature.__swig_getmethods__["zScale"] = ScaleFeature._get_zScale
ScaleFeature.zScale = property(ScaleFeature._get_zScale, doc="Returns the parameter that controls the Z scale factor. This will return null in the case\nwhere isUniform is false or the feature is non-parametric. You can use the properties and\nmethods on the ModelParameter object to get and set the value.")

ScaleFeature.__swig_getmethods__["nativeObject"] = ScaleFeature._get_nativeObject
ScaleFeature.nativeObject = property(ScaleFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

ScaleFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ScaleFeature) else None
ScaleFeature.cast = lambda arg: arg if isinstance(arg, ScaleFeature) else None

class ShellFeature(Feature):
    """Object that represents an existing shell feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShellFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShellFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ShellFeature *" : return _fusion.ShellFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ShellFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ShellFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ShellFeature_classType
    if _newclass:classType = staticmethod(_fusion.ShellFeature_classType)
    __swig_destroy__ = _fusion.delete_ShellFeature
    __del__ = lambda self : None;
    def setInputEntities(self, *args) -> "bool" :
        """
        Method that sets faces to remove and bodies to preform shell. Return false if any faces are input, and the owning bodies of the faces are also input. 
        inputEntities : The collection contains the faces to remove and the bodies to perform shell.
        Fails if any faces are input, and the owning bodies of the faces are also input. 
        isTangentChain : A boolean value for setting whether or not faces that are tangentially connected to 
        the input faces (if any) will also be included. It defaults to true. 
        Returns true if successful
        """
        return _fusion.ShellFeature_setInputEntities(self, *args)

    def setThicknesses(self, *args) -> "bool" :
        """
        Method that sets inside and outside thicknesses of the shell. 
        insideThickness : ValueInput object that defines the inside thickness. If set to null, remove the existing inside thickness. 
        outsideThickness : ValueInput object that defines the outside thickness. If set to null, remove the existing outside thickness. 
        Returns true if successful
        """
        return _fusion.ShellFeature_setThicknesses(self, *args)

    def _get_inputEntities(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """Gets the input faces/bodies."""
        return _fusion.ShellFeature__get_inputEntities(self)

    def _get_isTangentChain(self) -> "bool" :
        """
        Gets if any faces that are tangentially connected to any of 
        the input faces will also be included in setting InputEntities.
        """
        return _fusion.ShellFeature__get_isTangentChain(self)

    def _get_insideThickness(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the inside thickness.
        Edit the thickness through ModelParameter.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ShellFeature__get_insideThickness(self)

    def _get_outsideThickness(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the outside thickness.
        Edit the thickness through ModelParameter.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ShellFeature__get_outsideThickness(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ShellFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ShellFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::ShellFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ShellFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ShellFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ShellFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ShellFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.ShellFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ShellFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ShellFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.ShellFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.ShellFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.ShellFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.ShellFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ShellFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.ShellFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.ShellFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.ShellFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ShellFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.ShellFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ShellFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ShellFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ShellFeature__get_isValid(self)
ShellFeature_swigregister = _fusion.ShellFeature_swigregister
ShellFeature_swigregister(ShellFeature)

def ShellFeature_classType() -> "char const *" :
  return _fusion.ShellFeature_classType()
ShellFeature_classType = _fusion.ShellFeature_classType

ShellFeature.__swig_getmethods__["inputEntities"] = ShellFeature._get_inputEntities
ShellFeature.inputEntities = property(ShellFeature._get_inputEntities, doc="Gets the input faces/bodies.")

ShellFeature.__swig_getmethods__["isTangentChain"] = ShellFeature._get_isTangentChain
ShellFeature.isTangentChain = property(ShellFeature._get_isTangentChain, doc="Gets if any faces that are tangentially connected to any of\nthe input faces will also be included in setting InputEntities.")

ShellFeature.__swig_getmethods__["insideThickness"] = ShellFeature._get_insideThickness
ShellFeature.insideThickness = property(ShellFeature._get_insideThickness, doc="Gets the inside thickness.\nEdit the thickness through ModelParameter.\nThis property returns nothing in the case where the feature is non-parametric.")

ShellFeature.__swig_getmethods__["outsideThickness"] = ShellFeature._get_outsideThickness
ShellFeature.outsideThickness = property(ShellFeature._get_outsideThickness, doc="Gets the outside thickness.\nEdit the thickness through ModelParameter.\nThis property returns nothing in the case where the feature is non-parametric.")

ShellFeature.__swig_getmethods__["nativeObject"] = ShellFeature._get_nativeObject
ShellFeature.nativeObject = property(ShellFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

ShellFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ShellFeature) else None
ShellFeature.cast = lambda arg: arg if isinstance(arg, ShellFeature) else None

class SilhouetteSplitFeature(Feature):
    """Object that represents an existing silhouette split feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SilhouetteSplitFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SilhouetteSplitFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SilhouetteSplitFeature *" : return _fusion.SilhouetteSplitFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SilhouetteSplitFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SilhouetteSplitFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SilhouetteSplitFeature_classType
    if _newclass:classType = staticmethod(_fusion.SilhouetteSplitFeature_classType)
    __swig_destroy__ = _fusion.delete_SilhouetteSplitFeature
    __del__ = lambda self : None;
    def _get_viewDirection(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the entity that defines the silhouette view direction, which can be a 
        construction axis, linear BRepEdge, planar BRepFace or a construction plane.
        """
        return _fusion.SilhouetteSplitFeature__get_viewDirection(self)

    def _set_viewDirection(self, *args) -> "bool" :
        """
        Gets and sets the entity that defines the silhouette view direction, which can be a 
        construction axis, linear BRepEdge, planar BRepFace or a construction plane.
        """
        return _fusion.SilhouetteSplitFeature__set_viewDirection(self, *args)

    def _get_targetBody(self) -> "adsk::core::Ptr< adsk::fusion::BRepBody >" :
        """Gets and sets the solid body to split."""
        return _fusion.SilhouetteSplitFeature__get_targetBody(self)

    def _set_targetBody(self, *args) -> "bool" :
        """Gets and sets the solid body to split."""
        return _fusion.SilhouetteSplitFeature__set_targetBody(self, *args)

    def _get_operation(self) -> "adsk::fusion::SilhouetteSplitOperations" :
        """Gets the type of silhouette split operation."""
        return _fusion.SilhouetteSplitFeature__get_operation(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SilhouetteSplitFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SilhouetteSplitFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SilhouetteSplitFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.SilhouetteSplitFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SilhouetteSplitFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SilhouetteSplitFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.SilhouetteSplitFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.SilhouetteSplitFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SilhouetteSplitFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SilhouetteSplitFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.SilhouetteSplitFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.SilhouetteSplitFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.SilhouetteSplitFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.SilhouetteSplitFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SilhouetteSplitFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.SilhouetteSplitFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.SilhouetteSplitFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.SilhouetteSplitFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.SilhouetteSplitFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.SilhouetteSplitFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.SilhouetteSplitFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SilhouetteSplitFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SilhouetteSplitFeature__get_isValid(self)
SilhouetteSplitFeature_swigregister = _fusion.SilhouetteSplitFeature_swigregister
SilhouetteSplitFeature_swigregister(SilhouetteSplitFeature)

def SilhouetteSplitFeature_classType() -> "char const *" :
  return _fusion.SilhouetteSplitFeature_classType()
SilhouetteSplitFeature_classType = _fusion.SilhouetteSplitFeature_classType

SilhouetteSplitFeature.__swig_getmethods__["viewDirection"] = SilhouetteSplitFeature._get_viewDirection
SilhouetteSplitFeature.__swig_setmethods__["viewDirection"] = SilhouetteSplitFeature._set_viewDirection
SilhouetteSplitFeature.viewDirection = property(SilhouetteSplitFeature._get_viewDirection, SilhouetteSplitFeature._set_viewDirection, doc="Gets and sets the entity that defines the silhouette view direction, which can be a\nconstruction axis, linear BRepEdge, planar BRepFace or a construction plane.")

SilhouetteSplitFeature.__swig_getmethods__["targetBody"] = SilhouetteSplitFeature._get_targetBody
SilhouetteSplitFeature.__swig_setmethods__["targetBody"] = SilhouetteSplitFeature._set_targetBody
SilhouetteSplitFeature.targetBody = property(SilhouetteSplitFeature._get_targetBody, SilhouetteSplitFeature._set_targetBody, doc="Gets and sets the solid body to split.")

SilhouetteSplitFeature.__swig_getmethods__["operation"] = SilhouetteSplitFeature._get_operation
SilhouetteSplitFeature.operation = property(SilhouetteSplitFeature._get_operation, doc="Gets the type of silhouette split operation.")

SilhouetteSplitFeature.__swig_getmethods__["nativeObject"] = SilhouetteSplitFeature._get_nativeObject
SilhouetteSplitFeature.nativeObject = property(SilhouetteSplitFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SilhouetteSplitFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SilhouetteSplitFeature) else None
SilhouetteSplitFeature.cast = lambda arg: arg if isinstance(arg, SilhouetteSplitFeature) else None

class SketchAngularDimension(SketchDimension):
    """An angular dimension in a sketch."""
    __swig_setmethods__ = {}
    for _s in [SketchDimension]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchAngularDimension, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchDimension]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchAngularDimension, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchAngularDimension *" : return _fusion.SketchAngularDimension___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchAngularDimension___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchAngularDimension___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchAngularDimension_classType
    if _newclass:classType = staticmethod(_fusion.SketchAngularDimension_classType)
    __swig_destroy__ = _fusion.delete_SketchAngularDimension
    __del__ = lambda self : None;
    def _get_lineOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """The first line being constrained."""
        return _fusion.SketchAngularDimension__get_lineOne(self)

    def _get_lineTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """The second line being constrained."""
        return _fusion.SketchAngularDimension__get_lineTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchAngularDimension >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchAngularDimension__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchAngularDimension >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchAngularDimension_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchAngularDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this dimension is deletable."""
        return _fusion.SketchAngularDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchAngularDimension__get_textPosition(self)

    def _set_textPosition(self, *args) -> "bool" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchAngularDimension__set_textPosition(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.SketchAngularDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchAngularDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchAngularDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchAngularDimension__get_isDriving(self)

    def _set_isDriving(self, *args) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchAngularDimension__set_isDriving(self, *args)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchAngularDimension__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchAngularDimension__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchAngularDimension__get_isValid(self)
SketchAngularDimension_swigregister = _fusion.SketchAngularDimension_swigregister
SketchAngularDimension_swigregister(SketchAngularDimension)

def SketchAngularDimension_classType() -> "char const *" :
  return _fusion.SketchAngularDimension_classType()
SketchAngularDimension_classType = _fusion.SketchAngularDimension_classType

SketchAngularDimension.__swig_getmethods__["lineOne"] = SketchAngularDimension._get_lineOne
SketchAngularDimension.lineOne = property(SketchAngularDimension._get_lineOne, doc="The first line being constrained.")

SketchAngularDimension.__swig_getmethods__["lineTwo"] = SketchAngularDimension._get_lineTwo
SketchAngularDimension.lineTwo = property(SketchAngularDimension._get_lineTwo, doc="The second line being constrained.")

SketchAngularDimension.__swig_getmethods__["nativeObject"] = SketchAngularDimension._get_nativeObject
SketchAngularDimension.nativeObject = property(SketchAngularDimension._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SketchAngularDimension.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchAngularDimension) else None
SketchAngularDimension.cast = lambda arg: arg if isinstance(arg, SketchAngularDimension) else None

class SketchConcentricCircleDimension(SketchDimension):
    """A concentric circle dimension in a sketch."""
    __swig_setmethods__ = {}
    for _s in [SketchDimension]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchConcentricCircleDimension, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchDimension]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchConcentricCircleDimension, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchConcentricCircleDimension *" : return _fusion.SketchConcentricCircleDimension___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchConcentricCircleDimension___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchConcentricCircleDimension___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchConcentricCircleDimension_classType
    if _newclass:classType = staticmethod(_fusion.SketchConcentricCircleDimension_classType)
    __swig_destroy__ = _fusion.delete_SketchConcentricCircleDimension
    __del__ = lambda self : None;
    def _get_circleOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >" :
        """Returns the first concentric circle or arc."""
        return _fusion.SketchConcentricCircleDimension__get_circleOne(self)

    def _get_circleTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >" :
        """Returns the second concentric circle or arc."""
        return _fusion.SketchConcentricCircleDimension__get_circleTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchConcentricCircleDimension >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchConcentricCircleDimension__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchConcentricCircleDimension >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchConcentricCircleDimension_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchConcentricCircleDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this dimension is deletable."""
        return _fusion.SketchConcentricCircleDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchConcentricCircleDimension__get_textPosition(self)

    def _set_textPosition(self, *args) -> "bool" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchConcentricCircleDimension__set_textPosition(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.SketchConcentricCircleDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchConcentricCircleDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchConcentricCircleDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchConcentricCircleDimension__get_isDriving(self)

    def _set_isDriving(self, *args) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchConcentricCircleDimension__set_isDriving(self, *args)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchConcentricCircleDimension__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchConcentricCircleDimension__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchConcentricCircleDimension__get_isValid(self)
SketchConcentricCircleDimension_swigregister = _fusion.SketchConcentricCircleDimension_swigregister
SketchConcentricCircleDimension_swigregister(SketchConcentricCircleDimension)

def SketchConcentricCircleDimension_classType() -> "char const *" :
  return _fusion.SketchConcentricCircleDimension_classType()
SketchConcentricCircleDimension_classType = _fusion.SketchConcentricCircleDimension_classType

SketchConcentricCircleDimension.__swig_getmethods__["circleOne"] = SketchConcentricCircleDimension._get_circleOne
SketchConcentricCircleDimension.circleOne = property(SketchConcentricCircleDimension._get_circleOne, doc="Returns the first concentric circle or arc.")

SketchConcentricCircleDimension.__swig_getmethods__["circleTwo"] = SketchConcentricCircleDimension._get_circleTwo
SketchConcentricCircleDimension.circleTwo = property(SketchConcentricCircleDimension._get_circleTwo, doc="Returns the second concentric circle or arc.")

SketchConcentricCircleDimension.__swig_getmethods__["nativeObject"] = SketchConcentricCircleDimension._get_nativeObject
SketchConcentricCircleDimension.nativeObject = property(SketchConcentricCircleDimension._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SketchConcentricCircleDimension.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchConcentricCircleDimension) else None
SketchConcentricCircleDimension.cast = lambda arg: arg if isinstance(arg, SketchConcentricCircleDimension) else None

class SketchCurve(SketchEntity):
    """A single sketch curve. This is the base class for the specific curve types."""
    __swig_setmethods__ = {}
    for _s in [SketchEntity]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchCurve, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchEntity]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchCurve, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchCurve *" : return _fusion.SketchCurve___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchCurve___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchCurve___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchCurve_classType
    if _newclass:classType = staticmethod(_fusion.SketchCurve_classType)
    __swig_destroy__ = _fusion.delete_SketchCurve
    __del__ = lambda self : None;
    def _get_length(self) -> "double" :
        """Returns the length of the curve in centimeters."""
        return _fusion.SketchCurve__get_length(self)

    def _get_isConstruction(self) -> "bool" :
        """Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchCurve__get_isConstruction(self)

    def _set_isConstruction(self, *args) -> "bool" :
        """Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchCurve__set_isConstruction(self, *args)

    def split(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Split a curve at a position specified along the curve 
        splitPoint : A position (transient Point3D) on the curve that defines the point at which to split the curve 
        createConstraints : Constraints are created by default. Specify false to create no constraints. 
        Returns the resulting 2 curves; the original curve + the newly created curve
        When split spline the original is deleted and two new curves returned.
        Empty collection returned if curve is closed.
        """
        return _fusion.SketchCurve_split(self, *args)

    def trim(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Trim a curve by specifying a point that determines the segment of the curve to trim away 
        segmentPoint : A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
        The segment of the curve closest to the segmentPoint gets removed 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
        When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
        When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
        Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
        Trimming a curve having no intersections deletes the original and returns an empty collection
        """
        return _fusion.SketchCurve_trim(self, *args)

    def breakCurve(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
        sketch and splitting this curve at the nearest intersections to a specified point on the curve. 
        segmentPoint : A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
        intersection(s) to this point define the break location(s). 
        createConstraints : Optional argument that specifies if constraints should be created between the new curve segments. A value of
        true indicates constraints will be created. 
        All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
        are found and as a result the curve is not broken, an empty ObjectCollection is returned.
        """
        return _fusion.SketchCurve_breakCurve(self, *args)

    def extend(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Extend a curve by specifying a point that determines the end of the curve to extend 
        endPoint : A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
        The end of the curve closest to the endPoint gets extended 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        Returns the modified original curve if the start or end of the curve is extended
        If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
        If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
        """
        return _fusion.SketchCurve_extend(self, *args)

    def intersections(self, *args) -> "bool" :
        """
        Get the curves that intersect this curve along with the intersection points (Point2D) 
        sketchCurves : A collection of curves to attempt to find intersections with. 
        Set the value of this parameter to null to use all curves in the sketch for the calculation. 
        intersectingCurves : A collection of the actual intersecting curves 
        intersectionPoints : A collection of intersection points (Point3D)
        Item numbers in this collection correspond to the item numbers in the intersectingCurves collection. 
        Returns true if intersections are found
        """
        return _fusion.SketchCurve_intersections(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch."""
        return _fusion.SketchCurve__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >" :
        """Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchCurve__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >" :
        """Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchCurve__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool" :
        """Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchCurve__get_is2D(self)

    def _get_isReference(self) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchCurve__get_isReference(self)

    def _set_isReference(self, *args) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchCurve__set_isReference(self, *args)

    def _get_isFixed(self) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchCurve__get_isFixed(self)

    def _set_isFixed(self, *args) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchCurve__set_isFixed(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchCurve__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchCurve__get_boundingBox(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchCurve_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchCurve__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchCurve__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool" :
        """
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchCurve__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool" :
        """Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchCurve__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.SketchCurve__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchCurve__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchCurve__get_isValid(self)
SketchCurve_swigregister = _fusion.SketchCurve_swigregister
SketchCurve_swigregister(SketchCurve)

def SketchCurve_classType() -> "char const *" :
  return _fusion.SketchCurve_classType()
SketchCurve_classType = _fusion.SketchCurve_classType

SketchCurve.__swig_getmethods__["length"] = SketchCurve._get_length
SketchCurve.length = property(SketchCurve._get_length, doc="Returns the length of the curve in centimeters.")

SketchCurve.__swig_getmethods__["isConstruction"] = SketchCurve._get_isConstruction
SketchCurve.__swig_setmethods__["isConstruction"] = SketchCurve._set_isConstruction
SketchCurve.isConstruction = property(SketchCurve._get_isConstruction, SketchCurve._set_isConstruction, doc="Gets and sets whether this curve is construction geometry.")

SketchCurve.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchCurve) else None
SketchCurve.cast = lambda arg: arg if isinstance(arg, SketchCurve) else None

class SketchDiameterDimension(SketchDimension):
    """An diameter dimension in a sketch."""
    __swig_setmethods__ = {}
    for _s in [SketchDimension]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchDiameterDimension, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchDimension]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchDiameterDimension, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchDiameterDimension *" : return _fusion.SketchDiameterDimension___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchDiameterDimension___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchDiameterDimension___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchDiameterDimension_classType
    if _newclass:classType = staticmethod(_fusion.SketchDiameterDimension_classType)
    __swig_destroy__ = _fusion.delete_SketchDiameterDimension
    __del__ = lambda self : None;
    def _get_entity(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >" :
        """Returns the arc or circle being constrained."""
        return _fusion.SketchDiameterDimension__get_entity(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchDiameterDimension >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchDiameterDimension__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchDiameterDimension >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchDiameterDimension_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchDiameterDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this dimension is deletable."""
        return _fusion.SketchDiameterDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchDiameterDimension__get_textPosition(self)

    def _set_textPosition(self, *args) -> "bool" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchDiameterDimension__set_textPosition(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.SketchDiameterDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchDiameterDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchDiameterDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchDiameterDimension__get_isDriving(self)

    def _set_isDriving(self, *args) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchDiameterDimension__set_isDriving(self, *args)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchDiameterDimension__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchDiameterDimension__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchDiameterDimension__get_isValid(self)
SketchDiameterDimension_swigregister = _fusion.SketchDiameterDimension_swigregister
SketchDiameterDimension_swigregister(SketchDiameterDimension)

def SketchDiameterDimension_classType() -> "char const *" :
  return _fusion.SketchDiameterDimension_classType()
SketchDiameterDimension_classType = _fusion.SketchDiameterDimension_classType

SketchDiameterDimension.__swig_getmethods__["entity"] = SketchDiameterDimension._get_entity
SketchDiameterDimension.entity = property(SketchDiameterDimension._get_entity, doc="Returns the arc or circle being constrained.")

SketchDiameterDimension.__swig_getmethods__["nativeObject"] = SketchDiameterDimension._get_nativeObject
SketchDiameterDimension.nativeObject = property(SketchDiameterDimension._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SketchDiameterDimension.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchDiameterDimension) else None
SketchDiameterDimension.cast = lambda arg: arg if isinstance(arg, SketchDiameterDimension) else None

class SketchEllipseMajorRadiusDimension(SketchDimension):
    """An ellipse major radius dimension in a sketch."""
    __swig_setmethods__ = {}
    for _s in [SketchDimension]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchEllipseMajorRadiusDimension, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchDimension]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchEllipseMajorRadiusDimension, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchEllipseMajorRadiusDimension *" : return _fusion.SketchEllipseMajorRadiusDimension___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchEllipseMajorRadiusDimension___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchEllipseMajorRadiusDimension___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchEllipseMajorRadiusDimension_classType
    if _newclass:classType = staticmethod(_fusion.SketchEllipseMajorRadiusDimension_classType)
    __swig_destroy__ = _fusion.delete_SketchEllipseMajorRadiusDimension
    __del__ = lambda self : None;
    def _get_ellipse(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >" :
        """Returns the ellipse or elliptical arc being constrained."""
        return _fusion.SketchEllipseMajorRadiusDimension__get_ellipse(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchEllipseMajorRadiusDimension >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchEllipseMajorRadiusDimension__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchEllipseMajorRadiusDimension >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchEllipseMajorRadiusDimension_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchEllipseMajorRadiusDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this dimension is deletable."""
        return _fusion.SketchEllipseMajorRadiusDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchEllipseMajorRadiusDimension__get_textPosition(self)

    def _set_textPosition(self, *args) -> "bool" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchEllipseMajorRadiusDimension__set_textPosition(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.SketchEllipseMajorRadiusDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchEllipseMajorRadiusDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchEllipseMajorRadiusDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchEllipseMajorRadiusDimension__get_isDriving(self)

    def _set_isDriving(self, *args) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchEllipseMajorRadiusDimension__set_isDriving(self, *args)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchEllipseMajorRadiusDimension__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchEllipseMajorRadiusDimension__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchEllipseMajorRadiusDimension__get_isValid(self)
SketchEllipseMajorRadiusDimension_swigregister = _fusion.SketchEllipseMajorRadiusDimension_swigregister
SketchEllipseMajorRadiusDimension_swigregister(SketchEllipseMajorRadiusDimension)

def SketchEllipseMajorRadiusDimension_classType() -> "char const *" :
  return _fusion.SketchEllipseMajorRadiusDimension_classType()
SketchEllipseMajorRadiusDimension_classType = _fusion.SketchEllipseMajorRadiusDimension_classType

SketchEllipseMajorRadiusDimension.__swig_getmethods__["ellipse"] = SketchEllipseMajorRadiusDimension._get_ellipse
SketchEllipseMajorRadiusDimension.ellipse = property(SketchEllipseMajorRadiusDimension._get_ellipse, doc="Returns the ellipse or elliptical arc being constrained.")

SketchEllipseMajorRadiusDimension.__swig_getmethods__["nativeObject"] = SketchEllipseMajorRadiusDimension._get_nativeObject
SketchEllipseMajorRadiusDimension.nativeObject = property(SketchEllipseMajorRadiusDimension._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SketchEllipseMajorRadiusDimension.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchEllipseMajorRadiusDimension) else None
SketchEllipseMajorRadiusDimension.cast = lambda arg: arg if isinstance(arg, SketchEllipseMajorRadiusDimension) else None

class SketchEllipseMinorRadiusDimension(SketchDimension):
    """An ellipse minor radius dimension in a sketch."""
    __swig_setmethods__ = {}
    for _s in [SketchDimension]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchEllipseMinorRadiusDimension, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchDimension]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchEllipseMinorRadiusDimension, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchEllipseMinorRadiusDimension *" : return _fusion.SketchEllipseMinorRadiusDimension___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchEllipseMinorRadiusDimension___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchEllipseMinorRadiusDimension___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchEllipseMinorRadiusDimension_classType
    if _newclass:classType = staticmethod(_fusion.SketchEllipseMinorRadiusDimension_classType)
    __swig_destroy__ = _fusion.delete_SketchEllipseMinorRadiusDimension
    __del__ = lambda self : None;
    def _get_ellipse(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >" :
        """Returns the ellipse or elliptical arc being constrained."""
        return _fusion.SketchEllipseMinorRadiusDimension__get_ellipse(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchEllipseMinorRadiusDimension >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchEllipseMinorRadiusDimension__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchEllipseMinorRadiusDimension >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchEllipseMinorRadiusDimension_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchEllipseMinorRadiusDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this dimension is deletable."""
        return _fusion.SketchEllipseMinorRadiusDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchEllipseMinorRadiusDimension__get_textPosition(self)

    def _set_textPosition(self, *args) -> "bool" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchEllipseMinorRadiusDimension__set_textPosition(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.SketchEllipseMinorRadiusDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchEllipseMinorRadiusDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchEllipseMinorRadiusDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchEllipseMinorRadiusDimension__get_isDriving(self)

    def _set_isDriving(self, *args) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchEllipseMinorRadiusDimension__set_isDriving(self, *args)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchEllipseMinorRadiusDimension__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchEllipseMinorRadiusDimension__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchEllipseMinorRadiusDimension__get_isValid(self)
SketchEllipseMinorRadiusDimension_swigregister = _fusion.SketchEllipseMinorRadiusDimension_swigregister
SketchEllipseMinorRadiusDimension_swigregister(SketchEllipseMinorRadiusDimension)

def SketchEllipseMinorRadiusDimension_classType() -> "char const *" :
  return _fusion.SketchEllipseMinorRadiusDimension_classType()
SketchEllipseMinorRadiusDimension_classType = _fusion.SketchEllipseMinorRadiusDimension_classType

SketchEllipseMinorRadiusDimension.__swig_getmethods__["ellipse"] = SketchEllipseMinorRadiusDimension._get_ellipse
SketchEllipseMinorRadiusDimension.ellipse = property(SketchEllipseMinorRadiusDimension._get_ellipse, doc="Returns the ellipse or elliptical arc being constrained.")

SketchEllipseMinorRadiusDimension.__swig_getmethods__["nativeObject"] = SketchEllipseMinorRadiusDimension._get_nativeObject
SketchEllipseMinorRadiusDimension.nativeObject = property(SketchEllipseMinorRadiusDimension._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SketchEllipseMinorRadiusDimension.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchEllipseMinorRadiusDimension) else None
SketchEllipseMinorRadiusDimension.cast = lambda arg: arg if isinstance(arg, SketchEllipseMinorRadiusDimension) else None

class SketchLinearDimension(SketchDimension):
    """A linear dimension in a sketch."""
    __swig_setmethods__ = {}
    for _s in [SketchDimension]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchLinearDimension, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchDimension]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchLinearDimension, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchLinearDimension *" : return _fusion.SketchLinearDimension___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchLinearDimension___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchLinearDimension___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchLinearDimension_classType
    if _newclass:classType = staticmethod(_fusion.SketchLinearDimension_classType)
    __swig_destroy__ = _fusion.delete_SketchLinearDimension
    __del__ = lambda self : None;
    def _get_entityOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchEntity >" :
        """The first entity being constrained."""
        return _fusion.SketchLinearDimension__get_entityOne(self)

    def _get_entityTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchEntity >" :
        """The second entity being constrained."""
        return _fusion.SketchLinearDimension__get_entityTwo(self)

    def _get_orientation(self) -> "adsk::fusion::DimensionOrientations" :
        """The orientation of this dimension."""
        return _fusion.SketchLinearDimension__get_orientation(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchLinearDimension >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchLinearDimension__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchLinearDimension >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchLinearDimension_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchLinearDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this dimension is deletable."""
        return _fusion.SketchLinearDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchLinearDimension__get_textPosition(self)

    def _set_textPosition(self, *args) -> "bool" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchLinearDimension__set_textPosition(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.SketchLinearDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchLinearDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchLinearDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchLinearDimension__get_isDriving(self)

    def _set_isDriving(self, *args) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchLinearDimension__set_isDriving(self, *args)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchLinearDimension__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchLinearDimension__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchLinearDimension__get_isValid(self)
SketchLinearDimension_swigregister = _fusion.SketchLinearDimension_swigregister
SketchLinearDimension_swigregister(SketchLinearDimension)

def SketchLinearDimension_classType() -> "char const *" :
  return _fusion.SketchLinearDimension_classType()
SketchLinearDimension_classType = _fusion.SketchLinearDimension_classType

SketchLinearDimension.__swig_getmethods__["entityOne"] = SketchLinearDimension._get_entityOne
SketchLinearDimension.entityOne = property(SketchLinearDimension._get_entityOne, doc="The first entity being constrained.")

SketchLinearDimension.__swig_getmethods__["entityTwo"] = SketchLinearDimension._get_entityTwo
SketchLinearDimension.entityTwo = property(SketchLinearDimension._get_entityTwo, doc="The second entity being constrained.")

SketchLinearDimension.__swig_getmethods__["orientation"] = SketchLinearDimension._get_orientation
SketchLinearDimension.orientation = property(SketchLinearDimension._get_orientation, doc="The orientation of this dimension.")

SketchLinearDimension.__swig_getmethods__["nativeObject"] = SketchLinearDimension._get_nativeObject
SketchLinearDimension.nativeObject = property(SketchLinearDimension._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SketchLinearDimension.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchLinearDimension) else None
SketchLinearDimension.cast = lambda arg: arg if isinstance(arg, SketchLinearDimension) else None

class SketchOffsetCurvesDimension(SketchDimension):
    """A SketchOffsetCurvesDimension object is created automatically whenever curves are offset."""
    __swig_setmethods__ = {}
    for _s in [SketchDimension]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchOffsetCurvesDimension, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchDimension]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchOffsetCurvesDimension, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchOffsetCurvesDimension *" : return _fusion.SketchOffsetCurvesDimension___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchOffsetCurvesDimension___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchOffsetCurvesDimension___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchOffsetCurvesDimension_classType
    if _newclass:classType = staticmethod(_fusion.SketchOffsetCurvesDimension_classType)
    __swig_destroy__ = _fusion.delete_SketchOffsetCurvesDimension
    __del__ = lambda self : None;
    def _get_offsetConstraint(self) -> "adsk::core::Ptr< adsk::fusion::OffsetConstraint >" :
        """
        Returns the OffsetConstraint object that defines the curve offset. From the constraint
        you can get the original curves, the offset curves, and the dimension controlling the offset distance.
        """
        return _fusion.SketchOffsetCurvesDimension__get_offsetConstraint(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchOffsetCurvesDimension >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchOffsetCurvesDimension__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchOffsetCurvesDimension >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchOffsetCurvesDimension_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchOffsetCurvesDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this dimension is deletable."""
        return _fusion.SketchOffsetCurvesDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchOffsetCurvesDimension__get_textPosition(self)

    def _set_textPosition(self, *args) -> "bool" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchOffsetCurvesDimension__set_textPosition(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.SketchOffsetCurvesDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchOffsetCurvesDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchOffsetCurvesDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchOffsetCurvesDimension__get_isDriving(self)

    def _set_isDriving(self, *args) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchOffsetCurvesDimension__set_isDriving(self, *args)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchOffsetCurvesDimension__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchOffsetCurvesDimension__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchOffsetCurvesDimension__get_isValid(self)
SketchOffsetCurvesDimension_swigregister = _fusion.SketchOffsetCurvesDimension_swigregister
SketchOffsetCurvesDimension_swigregister(SketchOffsetCurvesDimension)

def SketchOffsetCurvesDimension_classType() -> "char const *" :
  return _fusion.SketchOffsetCurvesDimension_classType()
SketchOffsetCurvesDimension_classType = _fusion.SketchOffsetCurvesDimension_classType

SketchOffsetCurvesDimension.__swig_getmethods__["offsetConstraint"] = SketchOffsetCurvesDimension._get_offsetConstraint
SketchOffsetCurvesDimension.offsetConstraint = property(SketchOffsetCurvesDimension._get_offsetConstraint, doc="Returns the OffsetConstraint object that defines the curve offset. From the constraint\nyou can get the original curves, the offset curves, and the dimension controlling the offset distance.")

SketchOffsetCurvesDimension.__swig_getmethods__["nativeObject"] = SketchOffsetCurvesDimension._get_nativeObject
SketchOffsetCurvesDimension.nativeObject = property(SketchOffsetCurvesDimension._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SketchOffsetCurvesDimension.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchOffsetCurvesDimension) else None
SketchOffsetCurvesDimension.cast = lambda arg: arg if isinstance(arg, SketchOffsetCurvesDimension) else None

class SketchOffsetDimension(SketchDimension):
    """An offset dimension in a sketch."""
    __swig_setmethods__ = {}
    for _s in [SketchDimension]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchOffsetDimension, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchDimension]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchOffsetDimension, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchOffsetDimension *" : return _fusion.SketchOffsetDimension___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchOffsetDimension___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchOffsetDimension___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchOffsetDimension_classType
    if _newclass:classType = staticmethod(_fusion.SketchOffsetDimension_classType)
    __swig_destroy__ = _fusion.delete_SketchOffsetDimension
    __del__ = lambda self : None;
    def _get_line(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """The first line being constrained."""
        return _fusion.SketchOffsetDimension__get_line(self)

    def _get_entityTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchEntity >" :
        """The second entity being constrained. (a parallel SketchLine or a SketchPoint)"""
        return _fusion.SketchOffsetDimension__get_entityTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchOffsetDimension >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchOffsetDimension__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchOffsetDimension >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchOffsetDimension_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchOffsetDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this dimension is deletable."""
        return _fusion.SketchOffsetDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchOffsetDimension__get_textPosition(self)

    def _set_textPosition(self, *args) -> "bool" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchOffsetDimension__set_textPosition(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.SketchOffsetDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchOffsetDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchOffsetDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchOffsetDimension__get_isDriving(self)

    def _set_isDriving(self, *args) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchOffsetDimension__set_isDriving(self, *args)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchOffsetDimension__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchOffsetDimension__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchOffsetDimension__get_isValid(self)
SketchOffsetDimension_swigregister = _fusion.SketchOffsetDimension_swigregister
SketchOffsetDimension_swigregister(SketchOffsetDimension)

def SketchOffsetDimension_classType() -> "char const *" :
  return _fusion.SketchOffsetDimension_classType()
SketchOffsetDimension_classType = _fusion.SketchOffsetDimension_classType

SketchOffsetDimension.__swig_getmethods__["line"] = SketchOffsetDimension._get_line
SketchOffsetDimension.line = property(SketchOffsetDimension._get_line, doc="The first line being constrained.")

SketchOffsetDimension.__swig_getmethods__["entityTwo"] = SketchOffsetDimension._get_entityTwo
SketchOffsetDimension.entityTwo = property(SketchOffsetDimension._get_entityTwo, doc="The second entity being constrained. (a parallel SketchLine or a SketchPoint)")

SketchOffsetDimension.__swig_getmethods__["nativeObject"] = SketchOffsetDimension._get_nativeObject
SketchOffsetDimension.nativeObject = property(SketchOffsetDimension._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SketchOffsetDimension.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchOffsetDimension) else None
SketchOffsetDimension.cast = lambda arg: arg if isinstance(arg, SketchOffsetDimension) else None

class SketchPoint(SketchEntity):
    """A point within a sketch."""
    __swig_setmethods__ = {}
    for _s in [SketchEntity]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchPoint, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchEntity]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchPoint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchPoint *" : return _fusion.SketchPoint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchPoint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchPoint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchPoint_classType
    if _newclass:classType = staticmethod(_fusion.SketchPoint_classType)
    __swig_destroy__ = _fusion.delete_SketchPoint
    __del__ = lambda self : None;
    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        Returns a Point3D object which provides the position of the sketch point.
        The returned geometry is always in sketch space.
        """
        return _fusion.SketchPoint__get_geometry(self)

    def _get_worldGeometry(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        Returns a Point3D object which provides the position of the sketch point in world space.
        The returned coordinate takes into account the assembly context and the position of the
        sketch in it's parent component, which means the coordinate will be returned in the root
        component space.
        """
        return _fusion.SketchPoint__get_worldGeometry(self)

    def move(self, *args) -> "bool" :
        """
        Moves the sketch geometry using the specified transform.
        Move respects any constraints that would normally prohibit the move.
        This will fail in the case where the IsReference property is true. 
        translation : The vector that defines the distance and direction to move. 
        Returns true if moving the sketch point was successful.
        """
        return _fusion.SketchPoint_move(self, *args)

    def merge(self, *args) -> "bool" :
        """
        Merges the input sketch point into this sketch point. This effectively
        deletes the other sketch point and changes all entities that referenced
        that sketch point to reference this sketch point.
        This is the equivalent of dragging a sketch point on top of another
        sketch point in the user interface. 
        point : The point to merge with this point. 
        Returns true if the merge was successful.
        """
        return _fusion.SketchPoint_merge(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchPoint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchPoint_createForAssemblyContext(self, *args)

    def _get_connectedEntities(self) -> "adsk::core::Ptr< adsk::fusion::SketchEntityList >" :
        """
        Returns the set of sketch entities that are directly connected to this point. For
        example any entities that use this point as their start point or end point will be returned
        and any circle, arc or ellipse who have this point as a center point will be returned. This
        does not include entities that are related to the point through a constraint.
        """
        return _fusion.SketchPoint__get_connectedEntities(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch."""
        return _fusion.SketchPoint__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >" :
        """Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchPoint__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >" :
        """Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchPoint__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool" :
        """Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchPoint__get_is2D(self)

    def _get_isReference(self) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchPoint__get_isReference(self)

    def _set_isReference(self, *args) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchPoint__set_isReference(self, *args)

    def _get_isFixed(self) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchPoint__get_isFixed(self)

    def _set_isFixed(self, *args) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchPoint__set_isFixed(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchPoint__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchPoint__get_boundingBox(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchPoint_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchPoint__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchPoint__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool" :
        """
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchPoint__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool" :
        """Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchPoint__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.SketchPoint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchPoint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchPoint__get_isValid(self)
SketchPoint_swigregister = _fusion.SketchPoint_swigregister
SketchPoint_swigregister(SketchPoint)

def SketchPoint_classType() -> "char const *" :
  return _fusion.SketchPoint_classType()
SketchPoint_classType = _fusion.SketchPoint_classType

SketchPoint.__swig_getmethods__["geometry"] = SketchPoint._get_geometry
SketchPoint.geometry = property(SketchPoint._get_geometry, doc="Returns a Point3D object which provides the position of the sketch point.\nThe returned geometry is always in sketch space.")

SketchPoint.__swig_getmethods__["worldGeometry"] = SketchPoint._get_worldGeometry
SketchPoint.worldGeometry = property(SketchPoint._get_worldGeometry, doc="Returns a Point3D object which provides the position of the sketch point in world space.\nThe returned coordinate takes into account the assembly context and the position of the\nsketch in it's parent component, which means the coordinate will be returned in the root\ncomponent space.")

SketchPoint.__swig_getmethods__["nativeObject"] = SketchPoint._get_nativeObject
SketchPoint.nativeObject = property(SketchPoint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SketchPoint.__swig_getmethods__["connectedEntities"] = SketchPoint._get_connectedEntities
SketchPoint.connectedEntities = property(SketchPoint._get_connectedEntities, doc="Returns the set of sketch entities that are directly connected to this point. For\nexample any entities that use this point as their start point or end point will be returned\nand any circle, arc or ellipse who have this point as a center point will be returned. This\ndoes not include entities that are related to the point through a constraint.")

SketchPoint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchPoint) else None
SketchPoint.cast = lambda arg: arg if isinstance(arg, SketchPoint) else None

class SketchPointHolePositionDefinition(HolePositionDefinition):
    """Provides positioning information for a hole that is positioned by a sketch point."""
    __swig_setmethods__ = {}
    for _s in [HolePositionDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchPointHolePositionDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [HolePositionDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchPointHolePositionDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchPointHolePositionDefinition *" : return _fusion.SketchPointHolePositionDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchPointHolePositionDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchPointHolePositionDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchPointHolePositionDefinition_classType
    if _newclass:classType = staticmethod(_fusion.SketchPointHolePositionDefinition_classType)
    __swig_destroy__ = _fusion.delete_SketchPointHolePositionDefinition
    __del__ = lambda self : None;
    def _get_sketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """Returns the sketch point that defines the center of the hole."""
        return _fusion.SketchPointHolePositionDefinition__get_sketchPoint(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchPointHolePositionDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchPointHolePositionDefinition__get_isValid(self)
SketchPointHolePositionDefinition_swigregister = _fusion.SketchPointHolePositionDefinition_swigregister
SketchPointHolePositionDefinition_swigregister(SketchPointHolePositionDefinition)

def SketchPointHolePositionDefinition_classType() -> "char const *" :
  return _fusion.SketchPointHolePositionDefinition_classType()
SketchPointHolePositionDefinition_classType = _fusion.SketchPointHolePositionDefinition_classType

SketchPointHolePositionDefinition.__swig_getmethods__["sketchPoint"] = SketchPointHolePositionDefinition._get_sketchPoint
SketchPointHolePositionDefinition.sketchPoint = property(SketchPointHolePositionDefinition._get_sketchPoint, doc="Returns the sketch point that defines the center of the hole.")

SketchPointHolePositionDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchPointHolePositionDefinition) else None
SketchPointHolePositionDefinition.cast = lambda arg: arg if isinstance(arg, SketchPointHolePositionDefinition) else None

class SketchPointsHolePositionDefinition(HolePositionDefinition):
    """Provides positioning information for a hole that is positioned by a sketch point."""
    __swig_setmethods__ = {}
    for _s in [HolePositionDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchPointsHolePositionDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [HolePositionDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchPointsHolePositionDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchPointsHolePositionDefinition *" : return _fusion.SketchPointsHolePositionDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchPointsHolePositionDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchPointsHolePositionDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchPointsHolePositionDefinition_classType
    if _newclass:classType = staticmethod(_fusion.SketchPointsHolePositionDefinition_classType)
    __swig_destroy__ = _fusion.delete_SketchPointsHolePositionDefinition
    __del__ = lambda self : None;
    def _get_sketchPoints(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """Returns the sketch point that defines the center of the hole."""
        return _fusion.SketchPointsHolePositionDefinition__get_sketchPoints(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchPointsHolePositionDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchPointsHolePositionDefinition__get_isValid(self)
SketchPointsHolePositionDefinition_swigregister = _fusion.SketchPointsHolePositionDefinition_swigregister
SketchPointsHolePositionDefinition_swigregister(SketchPointsHolePositionDefinition)

def SketchPointsHolePositionDefinition_classType() -> "char const *" :
  return _fusion.SketchPointsHolePositionDefinition_classType()
SketchPointsHolePositionDefinition_classType = _fusion.SketchPointsHolePositionDefinition_classType

SketchPointsHolePositionDefinition.__swig_getmethods__["sketchPoints"] = SketchPointsHolePositionDefinition._get_sketchPoints
SketchPointsHolePositionDefinition.sketchPoints = property(SketchPointsHolePositionDefinition._get_sketchPoints, doc="Returns the sketch point that defines the center of the hole.")

SketchPointsHolePositionDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchPointsHolePositionDefinition) else None
SketchPointsHolePositionDefinition.cast = lambda arg: arg if isinstance(arg, SketchPointsHolePositionDefinition) else None

class SketchRadialDimension(SketchDimension):
    """An radial dimension in a sketch."""
    __swig_setmethods__ = {}
    for _s in [SketchDimension]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchRadialDimension, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchDimension]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchRadialDimension, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchRadialDimension *" : return _fusion.SketchRadialDimension___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchRadialDimension___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchRadialDimension___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchRadialDimension_classType
    if _newclass:classType = staticmethod(_fusion.SketchRadialDimension_classType)
    __swig_destroy__ = _fusion.delete_SketchRadialDimension
    __del__ = lambda self : None;
    def _get_entity(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >" :
        """The arc or circle being constrained."""
        return _fusion.SketchRadialDimension__get_entity(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchRadialDimension >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchRadialDimension__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchRadialDimension >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchRadialDimension_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this dimension. The IsDeletable property indicates if this dimension can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SketchRadialDimension_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this dimension is deletable."""
        return _fusion.SketchRadialDimension__get_isDeletable(self)

    def _get_textPosition(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchRadialDimension__get_textPosition(self)

    def _set_textPosition(self, *args) -> "bool" :
        """Gets and sets position of the dimension text."""
        return _fusion.SketchRadialDimension__set_textPosition(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.SketchRadialDimension__get_parentSketch(self)

    def _get_parameter(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """Returns the associated parameter or null if there is no associated parameter."""
        return _fusion.SketchRadialDimension__get_parameter(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchRadialDimension__get_assemblyContext(self)

    def _get_isDriving(self) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchRadialDimension__get_isDriving(self)

    def _set_isDriving(self, *args) -> "bool" :
        """
        Gets and sets if the dimension is Driving or is Driven. Setting this property to true for a given dimension 
        may fail if the result would overconstrain the sketch. Fusion 360 does not allow overconstrained sketches.
        """
        return _fusion.SketchRadialDimension__set_isDriving(self, *args)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this sketch dimension."""
        return _fusion.SketchRadialDimension__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchRadialDimension__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchRadialDimension__get_isValid(self)
SketchRadialDimension_swigregister = _fusion.SketchRadialDimension_swigregister
SketchRadialDimension_swigregister(SketchRadialDimension)

def SketchRadialDimension_classType() -> "char const *" :
  return _fusion.SketchRadialDimension_classType()
SketchRadialDimension_classType = _fusion.SketchRadialDimension_classType

SketchRadialDimension.__swig_getmethods__["entity"] = SketchRadialDimension._get_entity
SketchRadialDimension.entity = property(SketchRadialDimension._get_entity, doc="The arc or circle being constrained.")

SketchRadialDimension.__swig_getmethods__["nativeObject"] = SketchRadialDimension._get_nativeObject
SketchRadialDimension.nativeObject = property(SketchRadialDimension._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SketchRadialDimension.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchRadialDimension) else None
SketchRadialDimension.cast = lambda arg: arg if isinstance(arg, SketchRadialDimension) else None

class SketchText(SketchEntity):
    """Text in a sketch."""
    __swig_setmethods__ = {}
    for _s in [SketchEntity]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchText, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchEntity]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchText, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchText *" : return _fusion.SketchText___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchText___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchText___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchText_classType
    if _newclass:classType = staticmethod(_fusion.SketchText_classType)
    __swig_destroy__ = _fusion.delete_SketchText
    __del__ = lambda self : None;
    def _get_height(self) -> "double" :
        """Gets and sets the height of the text in centimeters."""
        return _fusion.SketchText__get_height(self)

    def _set_height(self, *args) -> "bool" :
        """Gets and sets the height of the text in centimeters."""
        return _fusion.SketchText__set_height(self, *args)

    def _get_text(self) -> "std::string" :
        """Gets and sets the text. This is a simple string and ignores any formatting defined within the text."""
        return _fusion.SketchText__get_text(self)

    def _set_text(self, *args) -> "bool" :
        """Gets and sets the text. This is a simple string and ignores any formatting defined within the text."""
        return _fusion.SketchText__set_text(self, *args)

    def _get_position(self) -> "adsk::core::Ptr< adsk::core::Point3D >" :
        """
        Gets and sets the position of the text on the x-y plane of the sketch. The text must lie on the x-y plane so the Z component
        of the point is ignored and always treated as zero.
        """
        return _fusion.SketchText__get_position(self)

    def _set_position(self, *args) -> "bool" :
        """
        Gets and sets the position of the text on the x-y plane of the sketch. The text must lie on the x-y plane so the Z component
        of the point is ignored and always treated as zero.
        """
        return _fusion.SketchText__set_position(self, *args)

    def _get_fontName(self) -> "std::string" :
        """Gets and sets the name of the font to use."""
        return _fusion.SketchText__get_fontName(self)

    def _set_fontName(self, *args) -> "bool" :
        """Gets and sets the name of the font to use."""
        return _fusion.SketchText__set_fontName(self, *args)

    def _get_angle(self) -> "double" :
        """Gets and sets the angle of the text relative to the x-axis of the x-y plane of the sketch."""
        return _fusion.SketchText__get_angle(self)

    def _set_angle(self, *args) -> "bool" :
        """Gets and sets the angle of the text relative to the x-axis of the x-y plane of the sketch."""
        return _fusion.SketchText__set_angle(self, *args)

    def _get_textStyle(self) -> "adsk::fusion::TextStyles" :
        """
        Gets and sets the text style to apply to the entire text. This is a bitwise enum so styles
        can be combined to apply multiple styles. For example you can apply bold and underline.
        """
        return _fusion.SketchText__get_textStyle(self)

    def _set_textStyle(self, *args) -> "bool" :
        """
        Gets and sets the text style to apply to the entire text. This is a bitwise enum so styles
        can be combined to apply multiple styles. For example you can apply bold and underline.
        """
        return _fusion.SketchText__set_textStyle(self, *args)

    def _get_boundaryLines(self) -> "adsk::core::Ptr< adsk::fusion::SketchLineList >" :
        """
        Returns the four sketch lines that define the boundary of the sketch text. By adding constraints to these lines
        you can associatively control the size, position and angle of the sketch text.
        """
        return _fusion.SketchText__get_boundaryLines(self)

    def explode(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::SketchCurve >,std::allocator< adsk::core::Ptr< adsk::fusion::SketchCurve > > >" :
        """
        Explodes the SketchText into a set of curves. The original SketchText is deleted as a result of calling this. 
        Returns an array of the sketch curves that were created that represent the text.
        """
        return _fusion.SketchText_explode(self)

    def asCurves(self) -> "std::vector< adsk::core::Ptr< adsk::core::Curve3D >,std::allocator< adsk::core::Ptr< adsk::core::Curve3D > > >" :
        """
        Returns the underlying curves that define the outline of the text. Calling this does not affect the
        SketchText and does not create any new sketch geometry but returns the geometrical definition of the
        sketch outline. 
        Returns an array of transient curves that represent the outline of the text.
        """
        return _fusion.SketchText_asCurves(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch."""
        return _fusion.SketchText__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >" :
        """Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchText__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >" :
        """Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchText__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool" :
        """Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchText__get_is2D(self)

    def _get_isReference(self) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchText__get_isReference(self)

    def _set_isReference(self, *args) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchText__set_isReference(self, *args)

    def _get_isFixed(self) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchText__get_isFixed(self)

    def _set_isFixed(self, *args) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchText__set_isFixed(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchText__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchText__get_boundingBox(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchText_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchText__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchText__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool" :
        """
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchText__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool" :
        """Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchText__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.SketchText__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchText__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchText__get_isValid(self)
SketchText_swigregister = _fusion.SketchText_swigregister
SketchText_swigregister(SketchText)

def SketchText_classType() -> "char const *" :
  return _fusion.SketchText_classType()
SketchText_classType = _fusion.SketchText_classType

SketchText.__swig_getmethods__["height"] = SketchText._get_height
SketchText.__swig_setmethods__["height"] = SketchText._set_height
SketchText.height = property(SketchText._get_height, SketchText._set_height, doc="Gets and sets the height of the text in centimeters.")

SketchText.__swig_getmethods__["text"] = SketchText._get_text
SketchText.__swig_setmethods__["text"] = SketchText._set_text
SketchText.text = property(SketchText._get_text, SketchText._set_text, doc="Gets and sets the text. This is a simple string and ignores any formatting defined within the text.")

SketchText.__swig_getmethods__["position"] = SketchText._get_position
SketchText.__swig_setmethods__["position"] = SketchText._set_position
SketchText.position = property(SketchText._get_position, SketchText._set_position, doc="Gets and sets the position of the text on the x-y plane of the sketch. The text must lie on the x-y plane so the Z component\nof the point is ignored and always treated as zero.")

SketchText.__swig_getmethods__["fontName"] = SketchText._get_fontName
SketchText.__swig_setmethods__["fontName"] = SketchText._set_fontName
SketchText.fontName = property(SketchText._get_fontName, SketchText._set_fontName, doc="Gets and sets the name of the font to use.")

SketchText.__swig_getmethods__["angle"] = SketchText._get_angle
SketchText.__swig_setmethods__["angle"] = SketchText._set_angle
SketchText.angle = property(SketchText._get_angle, SketchText._set_angle, doc="Gets and sets the angle of the text relative to the x-axis of the x-y plane of the sketch.")

SketchText.__swig_getmethods__["textStyle"] = SketchText._get_textStyle
SketchText.__swig_setmethods__["textStyle"] = SketchText._set_textStyle
SketchText.textStyle = property(SketchText._get_textStyle, SketchText._set_textStyle, doc="Gets and sets the text style to apply to the entire text. This is a bitwise enum so styles\ncan be combined to apply multiple styles. For example you can apply bold and underline.")

SketchText.__swig_getmethods__["boundaryLines"] = SketchText._get_boundaryLines
SketchText.boundaryLines = property(SketchText._get_boundaryLines, doc="Returns the four sketch lines that define the boundary of the sketch text. By adding constraints to these lines\nyou can associatively control the size, position and angle of the sketch text.")

SketchText.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchText) else None
SketchText.cast = lambda arg: arg if isinstance(arg, SketchText) else None

class SliderJointMotion(JointMotion):
    """Represents the set of information specific to a slider joint."""
    __swig_setmethods__ = {}
    for _s in [JointMotion]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SliderJointMotion, name, value)
    __swig_getmethods__ = {}
    for _s in [JointMotion]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SliderJointMotion, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SliderJointMotion *" : return _fusion.SliderJointMotion___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SliderJointMotion___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SliderJointMotion___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SliderJointMotion_classType
    if _newclass:classType = staticmethod(_fusion.SliderJointMotion_classType)
    __swig_destroy__ = _fusion.delete_SliderJointMotion
    __del__ = lambda self : None;
    def _get_slideDirection(self) -> "adsk::fusion::JointDirections" :
        """
        Gets and sets the direction of the slide. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customSlideDirectionEntity will return an entity
        that defines the direction. If there is a custom direction defined and this
        property is set to one of the three standard axes, the custom direction will
        be removed and customSlideDirectionEntity will return null.
        """
        return _fusion.SliderJointMotion__get_slideDirection(self)

    def _set_slideDirection(self, *args) -> "bool" :
        """
        Gets and sets the direction of the slide. This can be set to
        XAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can
        return those three directions and CustomJointDirection. If this returns
        CustomJointDirection then the customSlideDirectionEntity will return an entity
        that defines the direction. If there is a custom direction defined and this
        property is set to one of the three standard axes, the custom direction will
        be removed and customSlideDirectionEntity will return null.
        """
        return _fusion.SliderJointMotion__set_slideDirection(self, *args)

    def _get_slideDirectionVector(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Returns the direction of the slide. This property will return null in the case
        where the SliderJointMotion object was obtained from a JointInput object.
        """
        return _fusion.SliderJointMotion__get_slideDirectionVector(self)

    def _get_customSlideDirectionEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        This property can be set using various types of entities that can infer a
        direction. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the slideDirection property returns
        CustomJointDirection. Setting this property will automatically set
        the slideDirection property to CustomJointDirection.
        """
        return _fusion.SliderJointMotion__get_customSlideDirectionEntity(self)

    def _set_customSlideDirectionEntity(self, *args) -> "bool" :
        """
        This property can be set using various types of entities that can infer a
        direction. For example, a linear edge, sketch line, planar face, and cylindrical face.
        This property is only valid in the case where the slideDirection property returns
        CustomJointDirection. Setting this property will automatically set
        the slideDirection property to CustomJointDirection.
        """
        return _fusion.SliderJointMotion__set_customSlideDirectionEntity(self, *args)

    def _get_slideValue(self) -> "double" :
        """
        Gets and sets the slide value. This is in centimeters. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.SliderJointMotion__get_slideValue(self)

    def _set_slideValue(self, *args) -> "bool" :
        """
        Gets and sets the slide value. This is in centimeters. Setting this value is
        the equivalent of using the Drive Joints command.
        """
        return _fusion.SliderJointMotion__set_slideValue(self, *args)

    def _get_slideLimits(self) -> "adsk::core::Ptr< adsk::fusion::JointLimits >" :
        """
        Returns a JointLimits object that defines the slide limits for this joint.
        Use the functionality of the returned JointLimits object to get, set, and modify
        the joint limits.
        """
        return _fusion.SliderJointMotion__get_slideLimits(self)

    def _get_jointType(self) -> "adsk::fusion::JointTypes" :
        """Returns an enum value indicating the type of joint this joint represents."""
        return _fusion.SliderJointMotion__get_jointType(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SliderJointMotion__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SliderJointMotion__get_isValid(self)
SliderJointMotion_swigregister = _fusion.SliderJointMotion_swigregister
SliderJointMotion_swigregister(SliderJointMotion)

def SliderJointMotion_classType() -> "char const *" :
  return _fusion.SliderJointMotion_classType()
SliderJointMotion_classType = _fusion.SliderJointMotion_classType

SliderJointMotion.__swig_getmethods__["slideDirection"] = SliderJointMotion._get_slideDirection
SliderJointMotion.__swig_setmethods__["slideDirection"] = SliderJointMotion._set_slideDirection
SliderJointMotion.slideDirection = property(SliderJointMotion._get_slideDirection, SliderJointMotion._set_slideDirection, doc="Gets and sets the direction of the slide. This can be set to\nXAxisJointDirection, YAxisJointDirection, or ZAxisJointDirection. It can\nreturn those three directions and CustomJointDirection. If this returns\nCustomJointDirection then the customSlideDirectionEntity will return an entity\nthat defines the direction. If there is a custom direction defined and this\nproperty is set to one of the three standard axes, the custom direction will\nbe removed and customSlideDirectionEntity will return null.")

SliderJointMotion.__swig_getmethods__["slideDirectionVector"] = SliderJointMotion._get_slideDirectionVector
SliderJointMotion.slideDirectionVector = property(SliderJointMotion._get_slideDirectionVector, doc="Returns the direction of the slide. This property will return null in the case\nwhere the SliderJointMotion object was obtained from a JointInput object.")

SliderJointMotion.__swig_getmethods__["customSlideDirectionEntity"] = SliderJointMotion._get_customSlideDirectionEntity
SliderJointMotion.__swig_setmethods__["customSlideDirectionEntity"] = SliderJointMotion._set_customSlideDirectionEntity
SliderJointMotion.customSlideDirectionEntity = property(SliderJointMotion._get_customSlideDirectionEntity, SliderJointMotion._set_customSlideDirectionEntity, doc="This property can be set using various types of entities that can infer a\ndirection. For example, a linear edge, sketch line, planar face, and cylindrical face.\nThis property is only valid in the case where the slideDirection property returns\nCustomJointDirection. Setting this property will automatically set\nthe slideDirection property to CustomJointDirection.")

SliderJointMotion.__swig_getmethods__["slideValue"] = SliderJointMotion._get_slideValue
SliderJointMotion.__swig_setmethods__["slideValue"] = SliderJointMotion._set_slideValue
SliderJointMotion.slideValue = property(SliderJointMotion._get_slideValue, SliderJointMotion._set_slideValue, doc="Gets and sets the slide value. This is in centimeters. Setting this value is\nthe equivalent of using the Drive Joints command.")

SliderJointMotion.__swig_getmethods__["slideLimits"] = SliderJointMotion._get_slideLimits
SliderJointMotion.slideLimits = property(SliderJointMotion._get_slideLimits, doc="Returns a JointLimits object that defines the slide limits for this joint.\nUse the functionality of the returned JointLimits object to get, set, and modify\nthe joint limits.")

SliderJointMotion.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SliderJointMotion) else None
SliderJointMotion.cast = lambda arg: arg if isinstance(arg, SliderJointMotion) else None

class SmoothConstraint(GeometricConstraint):
    """A smooth constraint in a sketch."""
    __swig_setmethods__ = {}
    for _s in [GeometricConstraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SmoothConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricConstraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SmoothConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SmoothConstraint *" : return _fusion.SmoothConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SmoothConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SmoothConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SmoothConstraint_classType
    if _newclass:classType = staticmethod(_fusion.SmoothConstraint_classType)
    __swig_destroy__ = _fusion.delete_SmoothConstraint
    __del__ = lambda self : None;
    def _get_curveOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >" :
        """Returns the first curve."""
        return _fusion.SmoothConstraint__get_curveOne(self)

    def _get_curveTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >" :
        """Returns the second curve."""
        return _fusion.SmoothConstraint__get_curveTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SmoothConstraint >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SmoothConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SmoothConstraint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SmoothConstraint_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SmoothConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.SmoothConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.SmoothConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SmoothConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.SmoothConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SmoothConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SmoothConstraint__get_isValid(self)
SmoothConstraint_swigregister = _fusion.SmoothConstraint_swigregister
SmoothConstraint_swigregister(SmoothConstraint)

def SmoothConstraint_classType() -> "char const *" :
  return _fusion.SmoothConstraint_classType()
SmoothConstraint_classType = _fusion.SmoothConstraint_classType

SmoothConstraint.__swig_getmethods__["curveOne"] = SmoothConstraint._get_curveOne
SmoothConstraint.curveOne = property(SmoothConstraint._get_curveOne, doc="Returns the first curve.")

SmoothConstraint.__swig_getmethods__["curveTwo"] = SmoothConstraint._get_curveTwo
SmoothConstraint.curveTwo = property(SmoothConstraint._get_curveTwo, doc="Returns the second curve.")

SmoothConstraint.__swig_getmethods__["nativeObject"] = SmoothConstraint._get_nativeObject
SmoothConstraint.nativeObject = property(SmoothConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SmoothConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SmoothConstraint) else None
SmoothConstraint.cast = lambda arg: arg if isinstance(arg, SmoothConstraint) else None

class SMTExportOptions(ExportOptions):
    """Defines that an SMT export is to be done and specifies the various options."""
    __swig_setmethods__ = {}
    for _s in [ExportOptions]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SMTExportOptions, name, value)
    __swig_getmethods__ = {}
    for _s in [ExportOptions]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SMTExportOptions, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SMTExportOptions *" : return _fusion.SMTExportOptions___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SMTExportOptions___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SMTExportOptions___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SMTExportOptions_classType
    if _newclass:classType = staticmethod(_fusion.SMTExportOptions_classType)
    __swig_destroy__ = _fusion.delete_SMTExportOptions
    __del__ = lambda self : None;
    def _get_version(self) -> "int" :
        """
        Gets and set the version of the SMT format to write to. The default
        is to use the current version of the Autodesk Shape Manager kernel
        that Fusion 360 is using. Specifying an invalid version will result
        in an assert.
        Valid versions are 218 up to the current version, which is what this
        property returns by default when a new SMTExportOptions object is
        created.
        """
        return _fusion.SMTExportOptions__get_version(self)

    def _set_version(self, *args) -> "bool" :
        """
        Gets and set the version of the SMT format to write to. The default
        is to use the current version of the Autodesk Shape Manager kernel
        that Fusion 360 is using. Specifying an invalid version will result
        in an assert.
        Valid versions are 218 up to the current version, which is what this
        property returns by default when a new SMTExportOptions object is
        created.
        """
        return _fusion.SMTExportOptions__set_version(self, *args)

    def _get_filename(self) -> "std::string" :
        """
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.SMTExportOptions__get_filename(self)

    def _set_filename(self, *args) -> "bool" :
        """
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.SMTExportOptions__set_filename(self, *args)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Specifies the geometry to export. This can be Occurrence, or the root Component. For STLExport, we also support BRepBody."""
        return _fusion.SMTExportOptions__get_geometry(self)

    def _set_geometry(self, *args) -> "bool" :
        """Specifies the geometry to export. This can be Occurrence, or the root Component. For STLExport, we also support BRepBody."""
        return _fusion.SMTExportOptions__set_geometry(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.SMTExportOptions__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SMTExportOptions__get_isValid(self)
SMTExportOptions_swigregister = _fusion.SMTExportOptions_swigregister
SMTExportOptions_swigregister(SMTExportOptions)

def SMTExportOptions_classType() -> "char const *" :
  return _fusion.SMTExportOptions_classType()
SMTExportOptions_classType = _fusion.SMTExportOptions_classType

SMTExportOptions.__swig_getmethods__["version"] = SMTExportOptions._get_version
SMTExportOptions.__swig_setmethods__["version"] = SMTExportOptions._set_version
SMTExportOptions.version = property(SMTExportOptions._get_version, SMTExportOptions._set_version, doc="Gets and set the version of the SMT format to write to. The default\nis to use the current version of the Autodesk Shape Manager kernel\nthat Fusion 360 is using. Specifying an invalid version will result\nin an assert.\nValid versions are 218 up to the current version, which is what this\nproperty returns by default when a new SMTExportOptions object is\ncreated.")

SMTExportOptions.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SMTExportOptions) else None
SMTExportOptions.cast = lambda arg: arg if isinstance(arg, SMTExportOptions) else None

class SphereFeature(Feature):
    """Object that represents an existing sphere feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SphereFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SphereFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SphereFeature *" : return _fusion.SphereFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SphereFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SphereFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SphereFeature_classType
    if _newclass:classType = staticmethod(_fusion.SphereFeature_classType)
    __swig_destroy__ = _fusion.delete_SphereFeature
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SphereFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SphereFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.SphereFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.SphereFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SphereFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SphereFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.SphereFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.SphereFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.SphereFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.SphereFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SphereFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.SphereFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.SphereFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.SphereFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.SphereFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.SphereFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.SphereFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SphereFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SphereFeature__get_isValid(self)
SphereFeature_swigregister = _fusion.SphereFeature_swigregister
SphereFeature_swigregister(SphereFeature)

def SphereFeature_classType() -> "char const *" :
  return _fusion.SphereFeature_classType()
SphereFeature_classType = _fusion.SphereFeature_classType

SphereFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SphereFeature) else None
SphereFeature.cast = lambda arg: arg if isinstance(arg, SphereFeature) else None

class SplitBodyFeature(Feature):
    """Object that represents an existing split body feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SplitBodyFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SplitBodyFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SplitBodyFeature *" : return _fusion.SplitBodyFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SplitBodyFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SplitBodyFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SplitBodyFeature_classType
    if _newclass:classType = staticmethod(_fusion.SplitBodyFeature_classType)
    __swig_destroy__ = _fusion.delete_SplitBodyFeature
    __del__ = lambda self : None;
    def _get_splitBodies(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """Gets and sets the input solid or open bodies that are split."""
        return _fusion.SplitBodyFeature__get_splitBodies(self)

    def _set_splitBodies(self, *args) -> "bool" :
        """Gets and sets the input solid or open bodies that are split."""
        return _fusion.SplitBodyFeature__set_splitBodies(self, *args)

    def setSplittingTool(self, *args) -> "bool" :
        """
        Sets the splitting tool used for the feature. 
        splittingTool : Input entity that defines the splitting tool. The splitting tool is a single entity that can be either a solid body,
        open body, construction plane, face, or sketch curve that partially or fully intersects the body to split. 
        isSplittingToolExtended : A boolean value for setting whether or not the splittingTool is to be automatically extended (if possible) so as to
        completely intersect the facesToSplit. 
        Returns true if successful.
        """
        return _fusion.SplitBodyFeature_setSplittingTool(self, *args)

    def _get_splittingTool(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the entity that defines the splitting tool. The splitting tool is a single entity that can be either a 
        solid body, open body, plane, sketch curve or face that partially or fully intersects the bodyToSplit.
        """
        return _fusion.SplitBodyFeature__get_splittingTool(self)

    def _get_isSplittingToolExtended(self) -> "bool" :
        """
        Gets whether or not the splitting tool is to be automatically extended (if possible) so as to
        completely intersect the bodyToSplit.
        """
        return _fusion.SplitBodyFeature__get_isSplittingToolExtended(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SplitBodyFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SplitBodyFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SplitBodyFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.SplitBodyFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SplitBodyFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SplitBodyFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.SplitBodyFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.SplitBodyFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SplitBodyFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SplitBodyFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.SplitBodyFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.SplitBodyFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.SplitBodyFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.SplitBodyFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SplitBodyFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.SplitBodyFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.SplitBodyFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.SplitBodyFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.SplitBodyFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.SplitBodyFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.SplitBodyFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SplitBodyFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SplitBodyFeature__get_isValid(self)
SplitBodyFeature_swigregister = _fusion.SplitBodyFeature_swigregister
SplitBodyFeature_swigregister(SplitBodyFeature)

def SplitBodyFeature_classType() -> "char const *" :
  return _fusion.SplitBodyFeature_classType()
SplitBodyFeature_classType = _fusion.SplitBodyFeature_classType

SplitBodyFeature.__swig_getmethods__["splitBodies"] = SplitBodyFeature._get_splitBodies
SplitBodyFeature.__swig_setmethods__["splitBodies"] = SplitBodyFeature._set_splitBodies
SplitBodyFeature.splitBodies = property(SplitBodyFeature._get_splitBodies, SplitBodyFeature._set_splitBodies, doc="Gets and sets the input solid or open bodies that are split.")

SplitBodyFeature.__swig_getmethods__["splittingTool"] = SplitBodyFeature._get_splittingTool
SplitBodyFeature.splittingTool = property(SplitBodyFeature._get_splittingTool, doc="Gets the entity that defines the splitting tool. The splitting tool is a single entity that can be either a\nsolid body, open body, plane, sketch curve or face that partially or fully intersects the bodyToSplit.")

SplitBodyFeature.__swig_getmethods__["isSplittingToolExtended"] = SplitBodyFeature._get_isSplittingToolExtended
SplitBodyFeature.isSplittingToolExtended = property(SplitBodyFeature._get_isSplittingToolExtended, doc="Gets whether or not the splitting tool is to be automatically extended (if possible) so as to\ncompletely intersect the bodyToSplit.")

SplitBodyFeature.__swig_getmethods__["nativeObject"] = SplitBodyFeature._get_nativeObject
SplitBodyFeature.nativeObject = property(SplitBodyFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SplitBodyFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SplitBodyFeature) else None
SplitBodyFeature.cast = lambda arg: arg if isinstance(arg, SplitBodyFeature) else None

class SplitFaceFeature(Feature):
    """Object that represents an existing split face feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SplitFaceFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SplitFaceFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SplitFaceFeature *" : return _fusion.SplitFaceFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SplitFaceFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SplitFaceFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SplitFaceFeature_classType
    if _newclass:classType = staticmethod(_fusion.SplitFaceFeature_classType)
    __swig_destroy__ = _fusion.delete_SplitFaceFeature
    __del__ = lambda self : None;
    def _get_facesToSplit(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the faces to be split.
        The collection can contain one or more faces selected from solid and/or open bodies.
        """
        return _fusion.SplitFaceFeature__get_facesToSplit(self)

    def _set_facesToSplit(self, *args) -> "bool" :
        """
        Gets and sets the faces to be split.
        The collection can contain one or more faces selected from solid and/or open bodies.
        """
        return _fusion.SplitFaceFeature__set_facesToSplit(self, *args)

    def setSplittingTool(self, *args) -> "bool" :
        """
        Sets the splitting tool used for the feature. 
        splittingTool : Input entity that defines the splitting tool. The splitting tool is a single entity that can be either a solid body,
        open body, construction plane, face, or sketch curve that partially or fully intersects the facesToSplit.
        The input for this argument can be one of the valid types or an ObjectCollection in the case where multiple splitting
        tools are being defined. 
        isSplittingToolExtended : A boolean value for setting whether or not the splittingTool is to be automatically extended (if possible) so as to
        completely intersect the facesToSplit. 
        Returns true if successful.
        """
        return _fusion.SplitFaceFeature_setSplittingTool(self, *args)

    def _get_splittingTool(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the entity(s) that define the splitting tool(s). The splitting tool can consist of one or more of 
        the following: BRepBody, ConstructionPlane, BRepFace, sketch curve that extends or can
        be extended beyond the extents of the face. To set the splitting tool, use one of the set methods to
        also define the split type.
        """
        return _fusion.SplitFaceFeature__get_splittingTool(self)

    def _get_isSplittingToolExtended(self) -> "bool" :
        """
        Gets whether or not the setting to automatically extend the splittingTool was set when the feature was created.
        This property is valid only when the splitType property returns surfaceIntersectionSplitType.
        """
        return _fusion.SplitFaceFeature__get_isSplittingToolExtended(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SplitFaceFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SplitFaceFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SplitFaceFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.SplitFaceFeature_createForAssemblyContext(self, *args)

    def setAsSurfaceIntersectionSplitType(self, *args) -> "bool" :
        """
        Set the split type to be a surface to surface intersection. If the split tool is a curve
        it will be extruded into a surface to use in the split. If it's a surface, the surface will
        be used and optionally extended to fully intersect the faces to be split. 
        splittingTool : Input entity(s) that defines the splitting tool. The splitting tool can be a single entity or an ObjectCollection
        containing solid and/or open bodies, construction planes, faces, or sketch curves that partially or fully intersect
        the faces that are being split. 
        isSplittingToolExtended : Specifies if the splitting tool should be extended so that is fully intersects the faces to be split. 
        Returns true is setting the split type was successful.
        """
        return _fusion.SplitFaceFeature_setAsSurfaceIntersectionSplitType(self, *args)

    def setAsAlongVectorSplitType(self, *args) -> "bool" :
        """
        Sets the split type to project the splitting tool along the direction defined by the
        specified entity. 
        splittingTool : Input entity(s) that defines the splitting tool. The splitting tool can be a single entity or an ObjectCollection
        containing faces or sketch curves. If faces are input, the edges of the face are used as the splitting tool. 
        directionEntity : An entity that defines the direction of projection of the splitting tool. This can be
        a linear BRepEdge, SketchLine, ConstructionLine, or a planar face where the face
        normal is used. 
        Returns true is setting the split type was successful.
        """
        return _fusion.SplitFaceFeature_setAsAlongVectorSplitType(self, *args)

    def setAsClosestPointSplitType(self, *args) -> "bool" :
        """
        Sets the split type to be a curve that defined by projecting the splitting curve to the
        closest point on the surface. 
        splittingTool : Input entity(s) that defines the splitting tool. The splitting tool can be a single entity or an ObjectCollection
        containing faces or sketch curves. If faces are input, the edges of the face are used as the splitting tool. 
        Returns true if setting the closest point split type was successful.
        """
        return _fusion.SplitFaceFeature_setAsClosestPointSplitType(self, *args)

    def _get_directionEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets the direction entity when the split type is along a vector. If the split type
        is not alongVectorSplitType this property will return null.
        To set the direction entity use the setAsAlongVectorSplitType method.
        """
        return _fusion.SplitFaceFeature__get_directionEntity(self)

    def _get_splitType(self) -> "adsk::fusion::SplitFaceSplitTypes" :
        """
        Returns the type of split type currently defined. To change the split type, use
        one of the set methods.
        """
        return _fusion.SplitFaceFeature__get_splitType(self)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SplitFaceFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SplitFaceFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.SplitFaceFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.SplitFaceFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SplitFaceFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SplitFaceFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.SplitFaceFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.SplitFaceFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.SplitFaceFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.SplitFaceFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SplitFaceFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.SplitFaceFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.SplitFaceFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.SplitFaceFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.SplitFaceFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.SplitFaceFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.SplitFaceFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SplitFaceFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SplitFaceFeature__get_isValid(self)
SplitFaceFeature_swigregister = _fusion.SplitFaceFeature_swigregister
SplitFaceFeature_swigregister(SplitFaceFeature)

def SplitFaceFeature_classType() -> "char const *" :
  return _fusion.SplitFaceFeature_classType()
SplitFaceFeature_classType = _fusion.SplitFaceFeature_classType

SplitFaceFeature.__swig_getmethods__["facesToSplit"] = SplitFaceFeature._get_facesToSplit
SplitFaceFeature.__swig_setmethods__["facesToSplit"] = SplitFaceFeature._set_facesToSplit
SplitFaceFeature.facesToSplit = property(SplitFaceFeature._get_facesToSplit, SplitFaceFeature._set_facesToSplit, doc="Gets and sets the faces to be split.\nThe collection can contain one or more faces selected from solid and/or open bodies.")

SplitFaceFeature.__swig_getmethods__["splittingTool"] = SplitFaceFeature._get_splittingTool
SplitFaceFeature.splittingTool = property(SplitFaceFeature._get_splittingTool, doc="Gets and sets the entity(s) that define the splitting tool(s). The splitting tool can consist of one or more of\nthe following: BRepBody, ConstructionPlane, BRepFace, sketch curve that extends or can\nbe extended beyond the extents of the face. To set the splitting tool, use one of the set methods to\nalso define the split type.")

SplitFaceFeature.__swig_getmethods__["isSplittingToolExtended"] = SplitFaceFeature._get_isSplittingToolExtended
SplitFaceFeature.isSplittingToolExtended = property(SplitFaceFeature._get_isSplittingToolExtended, doc="Gets whether or not the setting to automatically extend the splittingTool was set when the feature was created.\nThis property is valid only when the splitType property returns surfaceIntersectionSplitType.")

SplitFaceFeature.__swig_getmethods__["nativeObject"] = SplitFaceFeature._get_nativeObject
SplitFaceFeature.nativeObject = property(SplitFaceFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SplitFaceFeature.__swig_getmethods__["directionEntity"] = SplitFaceFeature._get_directionEntity
SplitFaceFeature.directionEntity = property(SplitFaceFeature._get_directionEntity, doc="Gets the direction entity when the split type is along a vector. If the split type\nis not alongVectorSplitType this property will return null.\nTo set the direction entity use the setAsAlongVectorSplitType method.")

SplitFaceFeature.__swig_getmethods__["splitType"] = SplitFaceFeature._get_splitType
SplitFaceFeature.splitType = property(SplitFaceFeature._get_splitType, doc="Returns the type of split type currently defined. To change the split type, use\none of the set methods.")

SplitFaceFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SplitFaceFeature) else None
SplitFaceFeature.cast = lambda arg: arg if isinstance(arg, SplitFaceFeature) else None

class STEPExportOptions(ExportOptions):
    """Defines that a STEP export is to be done and specifies the various options."""
    __swig_setmethods__ = {}
    for _s in [ExportOptions]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, STEPExportOptions, name, value)
    __swig_getmethods__ = {}
    for _s in [ExportOptions]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, STEPExportOptions, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::STEPExportOptions *" : return _fusion.STEPExportOptions___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.STEPExportOptions___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.STEPExportOptions___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.STEPExportOptions_classType
    if _newclass:classType = staticmethod(_fusion.STEPExportOptions_classType)
    __swig_destroy__ = _fusion.delete_STEPExportOptions
    __del__ = lambda self : None;
    def _get_filename(self) -> "std::string" :
        """
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.STEPExportOptions__get_filename(self)

    def _set_filename(self, *args) -> "bool" :
        """
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.STEPExportOptions__set_filename(self, *args)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Specifies the geometry to export. This can be Occurrence, or the root Component. For STLExport, we also support BRepBody."""
        return _fusion.STEPExportOptions__get_geometry(self)

    def _set_geometry(self, *args) -> "bool" :
        """Specifies the geometry to export. This can be Occurrence, or the root Component. For STLExport, we also support BRepBody."""
        return _fusion.STEPExportOptions__set_geometry(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.STEPExportOptions__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.STEPExportOptions__get_isValid(self)
STEPExportOptions_swigregister = _fusion.STEPExportOptions_swigregister
STEPExportOptions_swigregister(STEPExportOptions)

def STEPExportOptions_classType() -> "char const *" :
  return _fusion.STEPExportOptions_classType()
STEPExportOptions_classType = _fusion.STEPExportOptions_classType

STEPExportOptions.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, STEPExportOptions) else None
STEPExportOptions.cast = lambda arg: arg if isinstance(arg, STEPExportOptions) else None

class StitchFeature(Feature):
    """Object that represents an existing stitch feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StitchFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StitchFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::StitchFeature *" : return _fusion.StitchFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.StitchFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.StitchFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.StitchFeature_classType
    if _newclass:classType = staticmethod(_fusion.StitchFeature_classType)
    __swig_destroy__ = _fusion.delete_StitchFeature
    __del__ = lambda self : None;
    def _get_stitchSurfaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the surfaces to stitch together. In some cases the stitch operation results in 
        faces being merged so the original faces are no longer available after the feature is created.
        in this case you need to reposition the timeline marker to just before this feature
        when the faces do exist.
        To get valid results and when setting this property, the timeline should be rolled back to 
        immediately before this feature.
        """
        return _fusion.StitchFeature__get_stitchSurfaces(self)

    def _set_stitchSurfaces(self, *args) -> "bool" :
        """
        Gets and sets the surfaces to stitch together. In some cases the stitch operation results in 
        faces being merged so the original faces are no longer available after the feature is created.
        in this case you need to reposition the timeline marker to just before this feature
        when the faces do exist.
        To get valid results and when setting this property, the timeline should be rolled back to 
        immediately before this feature.
        """
        return _fusion.StitchFeature__set_stitchSurfaces(self, *args)

    def _get_tolerance(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter controlling the tolerance. You can edit the tolerance
        by editing the value of the parameter object.
        """
        return _fusion.StitchFeature__get_tolerance(self)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """
        Gets and sets the feature operation to perform. This property value is ignored if the stitched result does not 
        form a solid body.
        """
        return _fusion.StitchFeature__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """
        Gets and sets the feature operation to perform. This property value is ignored if the stitched result does not 
        form a solid body.
        """
        return _fusion.StitchFeature__set_operation(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::StitchFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.StitchFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::StitchFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.StitchFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.StitchFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.StitchFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.StitchFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.StitchFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.StitchFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.StitchFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.StitchFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.StitchFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.StitchFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.StitchFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.StitchFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.StitchFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.StitchFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.StitchFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.StitchFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.StitchFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.StitchFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.StitchFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.StitchFeature__get_isValid(self)
StitchFeature_swigregister = _fusion.StitchFeature_swigregister
StitchFeature_swigregister(StitchFeature)

def StitchFeature_classType() -> "char const *" :
  return _fusion.StitchFeature_classType()
StitchFeature_classType = _fusion.StitchFeature_classType

StitchFeature.__swig_getmethods__["stitchSurfaces"] = StitchFeature._get_stitchSurfaces
StitchFeature.__swig_setmethods__["stitchSurfaces"] = StitchFeature._set_stitchSurfaces
StitchFeature.stitchSurfaces = property(StitchFeature._get_stitchSurfaces, StitchFeature._set_stitchSurfaces, doc="Gets and sets the surfaces to stitch together. In some cases the stitch operation results in\nfaces being merged so the original faces are no longer available after the feature is created.\nin this case you need to reposition the timeline marker to just before this feature\nwhen the faces do exist.\nTo get valid results and when setting this property, the timeline should be rolled back to\nimmediately before this feature.")

StitchFeature.__swig_getmethods__["tolerance"] = StitchFeature._get_tolerance
StitchFeature.tolerance = property(StitchFeature._get_tolerance, doc="Returns the parameter controlling the tolerance. You can edit the tolerance\nby editing the value of the parameter object.")

StitchFeature.__swig_getmethods__["operation"] = StitchFeature._get_operation
StitchFeature.__swig_setmethods__["operation"] = StitchFeature._set_operation
StitchFeature.operation = property(StitchFeature._get_operation, StitchFeature._set_operation, doc="Gets and sets the feature operation to perform. This property value is ignored if the stitched result does not\nform a solid body.")

StitchFeature.__swig_getmethods__["nativeObject"] = StitchFeature._get_nativeObject
StitchFeature.nativeObject = property(StitchFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

StitchFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, StitchFeature) else None
StitchFeature.cast = lambda arg: arg if isinstance(arg, StitchFeature) else None

class STLExportOptions(ExportOptions):
    """Defines that a STL export is to be done and specifies the various options."""
    __swig_setmethods__ = {}
    for _s in [ExportOptions]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, STLExportOptions, name, value)
    __swig_getmethods__ = {}
    for _s in [ExportOptions]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, STLExportOptions, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::STLExportOptions *" : return _fusion.STLExportOptions___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.STLExportOptions___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.STLExportOptions___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.STLExportOptions_classType
    if _newclass:classType = staticmethod(_fusion.STLExportOptions_classType)
    __swig_destroy__ = _fusion.delete_STLExportOptions
    __del__ = lambda self : None;
    def _get_isBinaryFormat(self) -> "bool" :
        """Indicates if the STL file is to be an ASCII or binary STL format. The default is true."""
        return _fusion.STLExportOptions__get_isBinaryFormat(self)

    def _set_isBinaryFormat(self, *args) -> "bool" :
        """Indicates if the STL file is to be an ASCII or binary STL format. The default is true."""
        return _fusion.STLExportOptions__set_isBinaryFormat(self, *args)

    def _get_isOneFilePerBody(self) -> "bool" :
        """
        If the input is an Occurrence or the root Component, this specifies if a single file should be created containing
        all of the bodies within that occurrence or component or if multiple files should be created; one for each body.
        If multiple files are created, the body name is appended to the filename. The default is false.
        """
        return _fusion.STLExportOptions__get_isOneFilePerBody(self)

    def _set_isOneFilePerBody(self, *args) -> "bool" :
        """
        If the input is an Occurrence or the root Component, this specifies if a single file should be created containing
        all of the bodies within that occurrence or component or if multiple files should be created; one for each body.
        If multiple files are created, the body name is appended to the filename. The default is false.
        """
        return _fusion.STLExportOptions__set_isOneFilePerBody(self, *args)

    def _get_meshRefinement(self) -> "adsk::fusion::MeshRefinementSettings" :
        """
        Gets and sets the current simple mesh refinement settings. Setting this property
        will reset the surfaceDeviation, normalDeviation, maximumEdgeLength, and aspectRatio
        to values that correspond to the specified mesh refinement. The default is MeshRefinementMedium
        """
        return _fusion.STLExportOptions__get_meshRefinement(self)

    def _set_meshRefinement(self, *args) -> "bool" :
        """
        Gets and sets the current simple mesh refinement settings. Setting this property
        will reset the surfaceDeviation, normalDeviation, maximumEdgeLength, and aspectRatio
        to values that correspond to the specified mesh refinement. The default is MeshRefinementMedium
        """
        return _fusion.STLExportOptions__set_meshRefinement(self, *args)

    def _get_surfaceDeviation(self) -> "double" :
        """
        Gets and sets the current surface deviation, or the distance the mesh can deviate
        from the actual surface. This is defined in centimetre. Setting this property
        will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
        associated with medium mesh refinement.
        """
        return _fusion.STLExportOptions__get_surfaceDeviation(self)

    def _set_surfaceDeviation(self, *args) -> "bool" :
        """
        Gets and sets the current surface deviation, or the distance the mesh can deviate
        from the actual surface. This is defined in centimetre. Setting this property
        will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
        associated with medium mesh refinement.
        """
        return _fusion.STLExportOptions__set_surfaceDeviation(self, *args)

    def _get_normalDeviation(self) -> "double" :
        """
        Gets and sets the current normal deviation, or the angle the mesh normals at the vertices can deviate
        from the actual surface normals. This is defined in radians. Setting this property
        will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
        associated with medium mesh refinement.
        """
        return _fusion.STLExportOptions__get_normalDeviation(self)

    def _set_normalDeviation(self, *args) -> "bool" :
        """
        Gets and sets the current normal deviation, or the angle the mesh normals at the vertices can deviate
        from the actual surface normals. This is defined in radians. Setting this property
        will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
        associated with medium mesh refinement.
        """
        return _fusion.STLExportOptions__set_normalDeviation(self, *args)

    def _get_maximumEdgeLength(self) -> "double" :
        """
        Gets and sets the maximum length of any mesh edge. This is defined in centimetre. Setting this property
        will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
        associated with medium mesh refinement.
        """
        return _fusion.STLExportOptions__get_maximumEdgeLength(self)

    def _set_maximumEdgeLength(self, *args) -> "bool" :
        """
        Gets and sets the maximum length of any mesh edge. This is defined in centimetre. Setting this property
        will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
        associated with medium mesh refinement.
        """
        return _fusion.STLExportOptions__set_maximumEdgeLength(self, *args)

    def _get_aspectRatio(self) -> "double" :
        """
        Gets and sets the minimum aspect ratio for that triangles that are generated for the mesh. Setting this property
        will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
        associated with medium mesh refinement.
        """
        return _fusion.STLExportOptions__get_aspectRatio(self)

    def _set_aspectRatio(self, *args) -> "bool" :
        """
        Gets and sets the minimum aspect ratio for that triangles that are generated for the mesh. Setting this property
        will automatically set the meshRefinement to MeshRefinementCustom. The default is the value
        associated with medium mesh refinement.
        """
        return _fusion.STLExportOptions__set_aspectRatio(self, *args)

    def _get_availablePrintUtilities(self) -> "std::vector< std::string,std::allocator< std::string > >" :
        """
        Returns a list of the known available print utilities. These strings can be used to set the PrintUtility
        property to specify which print utility to open the STL file in.
        """
        return _fusion.STLExportOptions__get_availablePrintUtilities(self)

    def _get_printUtility(self) -> "std::string" :
        """
        Specifies which print utility to use when opening the STL file if the sendToPrintUtility property is true.
        The value of this property can be one of the strings returned by the availalbePrintUtilities property, which
        will specify one of the know print utilities. You can also specify a custom print utility by specifying
        the full path to the print utility executable. The default value of this property is the last setting specified
        in the user-interface.
        """
        return _fusion.STLExportOptions__get_printUtility(self)

    def _set_printUtility(self, *args) -> "bool" :
        """
        Specifies which print utility to use when opening the STL file if the sendToPrintUtility property is true.
        The value of this property can be one of the strings returned by the availalbePrintUtilities property, which
        will specify one of the know print utilities. You can also specify a custom print utility by specifying
        the full path to the print utility executable. The default value of this property is the last setting specified
        in the user-interface.
        """
        return _fusion.STLExportOptions__set_printUtility(self, *args)

    def _get_sendToPrintUtility(self) -> "bool" :
        """
        Gets and sets whether the created STL file will be sent to the print utility specified by the printUtility property. If this
        is false a filename must be defined.
        """
        return _fusion.STLExportOptions__get_sendToPrintUtility(self)

    def _set_sendToPrintUtility(self, *args) -> "bool" :
        """
        Gets and sets whether the created STL file will be sent to the print utility specified by the printUtility property. If this
        is false a filename must be defined.
        """
        return _fusion.STLExportOptions__set_sendToPrintUtility(self, *args)

    def _get_filename(self) -> "std::string" :
        """
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.STLExportOptions__get_filename(self)

    def _set_filename(self, *args) -> "bool" :
        """
        Gets and sets the filename that the exported file will be written to. This can
        be empty in the case of STL export and sending the result to the mesh editor.
        """
        return _fusion.STLExportOptions__set_filename(self, *args)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Specifies the geometry to export. This can be Occurrence, or the root Component. For STLExport, we also support BRepBody."""
        return _fusion.STLExportOptions__get_geometry(self)

    def _set_geometry(self, *args) -> "bool" :
        """Specifies the geometry to export. This can be Occurrence, or the root Component. For STLExport, we also support BRepBody."""
        return _fusion.STLExportOptions__set_geometry(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.STLExportOptions__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.STLExportOptions__get_isValid(self)
STLExportOptions_swigregister = _fusion.STLExportOptions_swigregister
STLExportOptions_swigregister(STLExportOptions)

def STLExportOptions_classType() -> "char const *" :
  return _fusion.STLExportOptions_classType()
STLExportOptions_classType = _fusion.STLExportOptions_classType

STLExportOptions.__swig_getmethods__["isBinaryFormat"] = STLExportOptions._get_isBinaryFormat
STLExportOptions.__swig_setmethods__["isBinaryFormat"] = STLExportOptions._set_isBinaryFormat
STLExportOptions.isBinaryFormat = property(STLExportOptions._get_isBinaryFormat, STLExportOptions._set_isBinaryFormat, doc="Indicates if the STL file is to be an ASCII or binary STL format. The default is true.")

STLExportOptions.__swig_getmethods__["isOneFilePerBody"] = STLExportOptions._get_isOneFilePerBody
STLExportOptions.__swig_setmethods__["isOneFilePerBody"] = STLExportOptions._set_isOneFilePerBody
STLExportOptions.isOneFilePerBody = property(STLExportOptions._get_isOneFilePerBody, STLExportOptions._set_isOneFilePerBody, doc="If the input is an Occurrence or the root Component, this specifies if a single file should be created containing\nall of the bodies within that occurrence or component or if multiple files should be created; one for each body.\nIf multiple files are created, the body name is appended to the filename. The default is false.")

STLExportOptions.__swig_getmethods__["meshRefinement"] = STLExportOptions._get_meshRefinement
STLExportOptions.__swig_setmethods__["meshRefinement"] = STLExportOptions._set_meshRefinement
STLExportOptions.meshRefinement = property(STLExportOptions._get_meshRefinement, STLExportOptions._set_meshRefinement, doc="Gets and sets the current simple mesh refinement settings. Setting this property\nwill reset the surfaceDeviation, normalDeviation, maximumEdgeLength, and aspectRatio\nto values that correspond to the specified mesh refinement. The default is MeshRefinementMedium")

STLExportOptions.__swig_getmethods__["surfaceDeviation"] = STLExportOptions._get_surfaceDeviation
STLExportOptions.__swig_setmethods__["surfaceDeviation"] = STLExportOptions._set_surfaceDeviation
STLExportOptions.surfaceDeviation = property(STLExportOptions._get_surfaceDeviation, STLExportOptions._set_surfaceDeviation, doc="Gets and sets the current surface deviation, or the distance the mesh can deviate\nfrom the actual surface. This is defined in centimetre. Setting this property\nwill automatically set the meshRefinement to MeshRefinementCustom. The default is the value\nassociated with medium mesh refinement.")

STLExportOptions.__swig_getmethods__["normalDeviation"] = STLExportOptions._get_normalDeviation
STLExportOptions.__swig_setmethods__["normalDeviation"] = STLExportOptions._set_normalDeviation
STLExportOptions.normalDeviation = property(STLExportOptions._get_normalDeviation, STLExportOptions._set_normalDeviation, doc="Gets and sets the current normal deviation, or the angle the mesh normals at the vertices can deviate\nfrom the actual surface normals. This is defined in radians. Setting this property\nwill automatically set the meshRefinement to MeshRefinementCustom. The default is the value\nassociated with medium mesh refinement.")

STLExportOptions.__swig_getmethods__["maximumEdgeLength"] = STLExportOptions._get_maximumEdgeLength
STLExportOptions.__swig_setmethods__["maximumEdgeLength"] = STLExportOptions._set_maximumEdgeLength
STLExportOptions.maximumEdgeLength = property(STLExportOptions._get_maximumEdgeLength, STLExportOptions._set_maximumEdgeLength, doc="Gets and sets the maximum length of any mesh edge. This is defined in centimetre. Setting this property\nwill automatically set the meshRefinement to MeshRefinementCustom. The default is the value\nassociated with medium mesh refinement.")

STLExportOptions.__swig_getmethods__["aspectRatio"] = STLExportOptions._get_aspectRatio
STLExportOptions.__swig_setmethods__["aspectRatio"] = STLExportOptions._set_aspectRatio
STLExportOptions.aspectRatio = property(STLExportOptions._get_aspectRatio, STLExportOptions._set_aspectRatio, doc="Gets and sets the minimum aspect ratio for that triangles that are generated for the mesh. Setting this property\nwill automatically set the meshRefinement to MeshRefinementCustom. The default is the value\nassociated with medium mesh refinement.")

STLExportOptions.__swig_getmethods__["availablePrintUtilities"] = STLExportOptions._get_availablePrintUtilities
STLExportOptions.availablePrintUtilities = property(STLExportOptions._get_availablePrintUtilities, doc="Returns a list of the known available print utilities. These strings can be used to set the PrintUtility\nproperty to specify which print utility to open the STL file in.")

STLExportOptions.__swig_getmethods__["printUtility"] = STLExportOptions._get_printUtility
STLExportOptions.__swig_setmethods__["printUtility"] = STLExportOptions._set_printUtility
STLExportOptions.printUtility = property(STLExportOptions._get_printUtility, STLExportOptions._set_printUtility, doc="Specifies which print utility to use when opening the STL file if the sendToPrintUtility property is true.\nThe value of this property can be one of the strings returned by the availalbePrintUtilities property, which\nwill specify one of the know print utilities. You can also specify a custom print utility by specifying\nthe full path to the print utility executable. The default value of this property is the last setting specified\nin the user-interface.")

STLExportOptions.__swig_getmethods__["sendToPrintUtility"] = STLExportOptions._get_sendToPrintUtility
STLExportOptions.__swig_setmethods__["sendToPrintUtility"] = STLExportOptions._set_sendToPrintUtility
STLExportOptions.sendToPrintUtility = property(STLExportOptions._get_sendToPrintUtility, STLExportOptions._set_sendToPrintUtility, doc="Gets and sets whether the created STL file will be sent to the print utility specified by the printUtility property. If this\nis false a filename must be defined.")

STLExportOptions.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, STLExportOptions) else None
STLExportOptions.cast = lambda arg: arg if isinstance(arg, STLExportOptions) else None

class SurfaceDeleteFaceFeature(Feature):
    """
    Object that represents an existing Surface Delete Face feature in a design.
    The SurfaceDeleteFaceFeature and DeleteFaceFeature differ in that the SurfaceDeleteFaceFeature
    can delete any face without any restrictions. If the body is a solid, it will become a surface
    when the first face is deleted. The specified face is deleted without any other changes being
    made to the body. The DeleteFaceFeature deletes the specified face and also modifies the other faces
    in the body to heal or fill in the area of the deleted face. This means that a solid body will
    remain solid.
    """
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SurfaceDeleteFaceFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SurfaceDeleteFaceFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SurfaceDeleteFaceFeature *" : return _fusion.SurfaceDeleteFaceFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SurfaceDeleteFaceFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SurfaceDeleteFaceFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SurfaceDeleteFaceFeature_classType
    if _newclass:classType = staticmethod(_fusion.SurfaceDeleteFaceFeature_classType)
    __swig_destroy__ = _fusion.delete_SurfaceDeleteFaceFeature
    __del__ = lambda self : None;
    def _get_deletedFaces(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepFace >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepFace > > >" :
        """
        Gets and sets the set of faces that are deleted by this feature. To 
        be able to use this property to both get and set the faces, you need to 
        first roll the timeline to immediately before this feature. This can be
        accomplished using the following code where thisFeature is a reference
        to a SurfaceDeleteFaceFeature:
        thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SurfaceDeleteFaceFeature__get_deletedFaces(self)

    def _set_deletedFaces(self, *args) -> "bool" :
        """
        Gets and sets the set of faces that are deleted by this feature. To 
        be able to use this property to both get and set the faces, you need to 
        first roll the timeline to immediately before this feature. This can be
        accomplished using the following code where thisFeature is a reference
        to a SurfaceDeleteFaceFeature:
        thisFeature.timelineObject.rollTo(True)
        """
        return _fusion.SurfaceDeleteFaceFeature__set_deletedFaces(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SurfaceDeleteFaceFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SurfaceDeleteFaceFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SurfaceDeleteFaceFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.SurfaceDeleteFaceFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SurfaceDeleteFaceFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SurfaceDeleteFaceFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.SurfaceDeleteFaceFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.SurfaceDeleteFaceFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SurfaceDeleteFaceFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SurfaceDeleteFaceFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.SurfaceDeleteFaceFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.SurfaceDeleteFaceFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.SurfaceDeleteFaceFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.SurfaceDeleteFaceFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SurfaceDeleteFaceFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.SurfaceDeleteFaceFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.SurfaceDeleteFaceFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.SurfaceDeleteFaceFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.SurfaceDeleteFaceFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.SurfaceDeleteFaceFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.SurfaceDeleteFaceFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SurfaceDeleteFaceFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SurfaceDeleteFaceFeature__get_isValid(self)
SurfaceDeleteFaceFeature_swigregister = _fusion.SurfaceDeleteFaceFeature_swigregister
SurfaceDeleteFaceFeature_swigregister(SurfaceDeleteFaceFeature)

def SurfaceDeleteFaceFeature_classType() -> "char const *" :
  return _fusion.SurfaceDeleteFaceFeature_classType()
SurfaceDeleteFaceFeature_classType = _fusion.SurfaceDeleteFaceFeature_classType

SurfaceDeleteFaceFeature.__swig_getmethods__["deletedFaces"] = SurfaceDeleteFaceFeature._get_deletedFaces
SurfaceDeleteFaceFeature.__swig_setmethods__["deletedFaces"] = SurfaceDeleteFaceFeature._set_deletedFaces
SurfaceDeleteFaceFeature.deletedFaces = property(SurfaceDeleteFaceFeature._get_deletedFaces, SurfaceDeleteFaceFeature._set_deletedFaces, doc="Gets and sets the set of faces that are deleted by this feature. To\nbe able to use this property to both get and set the faces, you need to\nfirst roll the timeline to immediately before this feature. This can be\naccomplished using the following code where thisFeature is a reference\nto a SurfaceDeleteFaceFeature:\nthisFeature.timelineObject.rollTo(True)")

SurfaceDeleteFaceFeature.__swig_getmethods__["nativeObject"] = SurfaceDeleteFaceFeature._get_nativeObject
SurfaceDeleteFaceFeature.nativeObject = property(SurfaceDeleteFaceFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SurfaceDeleteFaceFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SurfaceDeleteFaceFeature) else None
SurfaceDeleteFaceFeature.cast = lambda arg: arg if isinstance(arg, SurfaceDeleteFaceFeature) else None

class SweepFeature(Feature):
    """Object that represents an existing sweep feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SweepFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SweepFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SweepFeature *" : return _fusion.SweepFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SweepFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SweepFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SweepFeature_classType
    if _newclass:classType = staticmethod(_fusion.SweepFeature_classType)
    __swig_destroy__ = _fusion.delete_SweepFeature
    __del__ = lambda self : None;
    def _get_profile(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the profiles or planar faces used to define the shape of the sweep.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.SweepFeature__get_profile(self)

    def _set_profile(self, *args) -> "bool" :
        """
        Gets and sets the profiles or planar faces used to define the shape of the sweep.
        This property can return or be set with a single Profile, a single planar face, or 
        an ObjectCollection consisting of multiple profiles and planar faces. When an 
        ObjectCollection is used all of the profiles and faces must be co-planar.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.SweepFeature__set_profile(self, *args)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """Gets and sets the type of operation performed by the sweep."""
        return _fusion.SweepFeature__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """Gets and sets the type of operation performed by the sweep."""
        return _fusion.SweepFeature__set_operation(self, *args)

    def _get_path(self) -> "adsk::core::Ptr< adsk::fusion::Path >" :
        """
        Gets and sets the path to create the sweep.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.SweepFeature__get_path(self)

    def _set_path(self, *args) -> "bool" :
        """
        Gets and sets the path to create the sweep.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.SweepFeature__set_path(self, *args)

    def _get_distanceOne(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the distance for the first side.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.SweepFeature__get_distanceOne(self)

    def _get_distanceTwo(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the distance for the second side.
        Returns nothing if the path is only on one side of the profile or if the sweep definition includes a guide rail.
        It's always the distance against the normal of the profile if available.
        This property returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.SweepFeature__get_distanceTwo(self)

    def _get_orientation(self) -> "adsk::fusion::SweepOrientationTypes" :
        """Gets and sets the sweep orientation. It defaults to PerpendicularOrientationType."""
        return _fusion.SweepFeature__get_orientation(self)

    def _set_orientation(self, *args) -> "bool" :
        """Gets and sets the sweep orientation. It defaults to PerpendicularOrientationType."""
        return _fusion.SweepFeature__set_orientation(self, *args)

    def _get_startFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Property that returns the set of that cap one end of the sweep that are coincident with the sketch plane. 
        In the cases where there aren't any start faces this property will return Nothing.
        """
        return _fusion.SweepFeature__get_startFaces(self)

    def _get_endFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Property that returns the set of that cap one end of the sweep that are coincident with the sketch plane. 
        The end faces are those not coincident to the sketch plane of the feature's profile. 
        In the case of a symmetric revolution these faces are the ones on the negative normal side of the sketch plane. 
        In the cases where there aren't any end faces this property will return Nothing.
        """
        return _fusion.SweepFeature__get_endFaces(self)

    def _get_sideFaces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """Property that returns a object that provides access to all of the faces created around the perimeter of the feature."""
        return _fusion.SweepFeature__get_sideFaces(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SweepFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SweepFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SweepFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SweepFeature_createForAssemblyContext(self, *args)

    def _get_isSolid(self) -> "bool" :
        """Indicates if this feature was initially created as a solid or a surface."""
        return _fusion.SweepFeature__get_isSolid(self)

    def _get_guideRail(self) -> "adsk::core::Ptr< adsk::fusion::Path >" :
        """
        Gets and sets the guide rail to create the sweep. This can be set to null
        to have a path only sweep.
        """
        return _fusion.SweepFeature__get_guideRail(self)

    def _set_guideRail(self, *args) -> "bool" :
        """
        Gets and sets the guide rail to create the sweep. This can be set to null
        to have a path only sweep.
        """
        return _fusion.SweepFeature__set_guideRail(self, *args)

    def _get_isDirectionFlipped(self) -> "bool" :
        """
        Gets and sets if the direction of the sweep is flipped. 
        This property only applies to sweep features that include a guide rail and whose path runs on both 
        sides of the profile.
        """
        return _fusion.SweepFeature__get_isDirectionFlipped(self)

    def _set_isDirectionFlipped(self, *args) -> "bool" :
        """
        Gets and sets if the direction of the sweep is flipped. 
        This property only applies to sweep features that include a guide rail and whose path runs on both 
        sides of the profile.
        """
        return _fusion.SweepFeature__set_isDirectionFlipped(self, *args)

    def _get_profileScaling(self) -> "adsk::fusion::SweepProfileScalingOptions" :
        """
        Gets and sets the sweep profile scaling option. It defaults to SweepProfileScaleOption. This
        property is only used when a guide rail has been specified.
        """
        return _fusion.SweepFeature__get_profileScaling(self)

    def _set_profileScaling(self, *args) -> "bool" :
        """
        Gets and sets the sweep profile scaling option. It defaults to SweepProfileScaleOption. This
        property is only used when a guide rail has been specified.
        """
        return _fusion.SweepFeature__set_profileScaling(self, *args)

    def _get_participantBodies(self) -> "std::vector< adsk::core::Ptr< adsk::fusion::BRepBody >,std::allocator< adsk::core::Ptr< adsk::fusion::BRepBody > > >" :
        """
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        When setting or getting this property, you must roll the timeline back to just before the feature 
        so that the model is in the state just before the feature is computed.
        """
        return _fusion.SweepFeature__get_participantBodies(self)

    def _set_participantBodies(self, *args) -> "bool" :
        """
        Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.
        When setting or getting this property, you must roll the timeline back to just before the feature 
        so that the model is in the state just before the feature is computed.
        """
        return _fusion.SweepFeature__set_participantBodies(self, *args)

    def _get_taperAngle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the ModelParameter that defines the taper angle of the sweep feature.
        The value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.
        """
        return _fusion.SweepFeature__get_taperAngle(self)

    def _get_twistAngle(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the ModelParameter that defines the twist angle of the sweep feature.
        The value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.
        """
        return _fusion.SweepFeature__get_twistAngle(self)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SweepFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.SweepFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.SweepFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.SweepFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SweepFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.SweepFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.SweepFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.SweepFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.SweepFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.SweepFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SweepFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.SweepFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.SweepFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.SweepFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.SweepFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.SweepFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.SweepFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SweepFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SweepFeature__get_isValid(self)
SweepFeature_swigregister = _fusion.SweepFeature_swigregister
SweepFeature_swigregister(SweepFeature)

def SweepFeature_classType() -> "char const *" :
  return _fusion.SweepFeature_classType()
SweepFeature_classType = _fusion.SweepFeature_classType

SweepFeature.__swig_getmethods__["profile"] = SweepFeature._get_profile
SweepFeature.__swig_setmethods__["profile"] = SweepFeature._set_profile
SweepFeature.profile = property(SweepFeature._get_profile, SweepFeature._set_profile, doc="Gets and sets the profiles or planar faces used to define the shape of the sweep.\nThis property can return or be set with a single Profile, a single planar face, or\nan ObjectCollection consisting of multiple profiles and planar faces. When an\nObjectCollection is used all of the profiles and faces must be co-planar.\nThis property returns nothing in the case where the feature is non-parametric.")

SweepFeature.__swig_getmethods__["operation"] = SweepFeature._get_operation
SweepFeature.__swig_setmethods__["operation"] = SweepFeature._set_operation
SweepFeature.operation = property(SweepFeature._get_operation, SweepFeature._set_operation, doc="Gets and sets the type of operation performed by the sweep.")

SweepFeature.__swig_getmethods__["path"] = SweepFeature._get_path
SweepFeature.__swig_setmethods__["path"] = SweepFeature._set_path
SweepFeature.path = property(SweepFeature._get_path, SweepFeature._set_path, doc="Gets and sets the path to create the sweep.\nThis property returns nothing in the case where the feature is non-parametric.")

SweepFeature.__swig_getmethods__["distanceOne"] = SweepFeature._get_distanceOne
SweepFeature.distanceOne = property(SweepFeature._get_distanceOne, doc="Gets the distance for the first side.\nThis property returns nothing in the case where the feature is non-parametric.")

SweepFeature.__swig_getmethods__["distanceTwo"] = SweepFeature._get_distanceTwo
SweepFeature.distanceTwo = property(SweepFeature._get_distanceTwo, doc="Gets the distance for the second side.\nReturns nothing if the path is only on one side of the profile or if the sweep definition includes a guide rail.\nIt's always the distance against the normal of the profile if available.\nThis property returns nothing in the case where the feature is non-parametric.")

SweepFeature.__swig_getmethods__["orientation"] = SweepFeature._get_orientation
SweepFeature.__swig_setmethods__["orientation"] = SweepFeature._set_orientation
SweepFeature.orientation = property(SweepFeature._get_orientation, SweepFeature._set_orientation, doc="Gets and sets the sweep orientation. It defaults to PerpendicularOrientationType.")

SweepFeature.__swig_getmethods__["startFaces"] = SweepFeature._get_startFaces
SweepFeature.startFaces = property(SweepFeature._get_startFaces, doc="Property that returns the set of that cap one end of the sweep that are coincident with the sketch plane.\nIn the cases where there aren't any start faces this property will return Nothing.")

SweepFeature.__swig_getmethods__["endFaces"] = SweepFeature._get_endFaces
SweepFeature.endFaces = property(SweepFeature._get_endFaces, doc="Property that returns the set of that cap one end of the sweep that are coincident with the sketch plane.\nThe end faces are those not coincident to the sketch plane of the feature's profile.\nIn the case of a symmetric revolution these faces are the ones on the negative normal side of the sketch plane.\nIn the cases where there aren't any end faces this property will return Nothing.")

SweepFeature.__swig_getmethods__["sideFaces"] = SweepFeature._get_sideFaces
SweepFeature.sideFaces = property(SweepFeature._get_sideFaces, doc="Property that returns a object that provides access to all of the faces created around the perimeter of the feature.")

SweepFeature.__swig_getmethods__["nativeObject"] = SweepFeature._get_nativeObject
SweepFeature.nativeObject = property(SweepFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SweepFeature.__swig_getmethods__["isSolid"] = SweepFeature._get_isSolid
SweepFeature.isSolid = property(SweepFeature._get_isSolid, doc="Indicates if this feature was initially created as a solid or a surface.")

SweepFeature.__swig_getmethods__["guideRail"] = SweepFeature._get_guideRail
SweepFeature.__swig_setmethods__["guideRail"] = SweepFeature._set_guideRail
SweepFeature.guideRail = property(SweepFeature._get_guideRail, SweepFeature._set_guideRail, doc="Gets and sets the guide rail to create the sweep. This can be set to null\nto have a path only sweep.")

SweepFeature.__swig_getmethods__["isDirectionFlipped"] = SweepFeature._get_isDirectionFlipped
SweepFeature.__swig_setmethods__["isDirectionFlipped"] = SweepFeature._set_isDirectionFlipped
SweepFeature.isDirectionFlipped = property(SweepFeature._get_isDirectionFlipped, SweepFeature._set_isDirectionFlipped, doc="Gets and sets if the direction of the sweep is flipped.\nThis property only applies to sweep features that include a guide rail and whose path runs on both\nsides of the profile.")

SweepFeature.__swig_getmethods__["profileScaling"] = SweepFeature._get_profileScaling
SweepFeature.__swig_setmethods__["profileScaling"] = SweepFeature._set_profileScaling
SweepFeature.profileScaling = property(SweepFeature._get_profileScaling, SweepFeature._set_profileScaling, doc="Gets and sets the sweep profile scaling option. It defaults to SweepProfileScaleOption. This\nproperty is only used when a guide rail has been specified.")

SweepFeature.__swig_getmethods__["participantBodies"] = SweepFeature._get_participantBodies
SweepFeature.__swig_setmethods__["participantBodies"] = SweepFeature._set_participantBodies
SweepFeature.participantBodies = property(SweepFeature._get_participantBodies, SweepFeature._set_participantBodies, doc="Gets and sets the list of bodies that will participate in the feature when the operation is a cut or intersection.\nWhen setting or getting this property, you must roll the timeline back to just before the feature\nso that the model is in the state just before the feature is computed.")

SweepFeature.__swig_getmethods__["taperAngle"] = SweepFeature._get_taperAngle
SweepFeature.taperAngle = property(SweepFeature._get_taperAngle, doc="Gets the ModelParameter that defines the taper angle of the sweep feature.\nThe value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.")

SweepFeature.__swig_getmethods__["twistAngle"] = SweepFeature._get_twistAngle
SweepFeature.twistAngle = property(SweepFeature._get_twistAngle, doc="Gets the ModelParameter that defines the twist angle of the sweep feature.\nThe value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.")

SweepFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SweepFeature) else None
SweepFeature.cast = lambda arg: arg if isinstance(arg, SweepFeature) else None

class SymmetricExtentDefinition(ExtentDefinition):
    """A definition object that is used to define the extents of a feature to be symmetric."""
    __swig_setmethods__ = {}
    for _s in [ExtentDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SymmetricExtentDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ExtentDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SymmetricExtentDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SymmetricExtentDefinition *" : return _fusion.SymmetricExtentDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SymmetricExtentDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SymmetricExtentDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SymmetricExtentDefinition_classType
    if _newclass:classType = staticmethod(_fusion.SymmetricExtentDefinition_classType)
    __swig_getmethods__["create"] = lambda x: _fusion.SymmetricExtentDefinition_create
    if _newclass:create = staticmethod(_fusion.SymmetricExtentDefinition_create)
    __swig_destroy__ = _fusion.delete_SymmetricExtentDefinition
    __del__ = lambda self : None;
    def _get_isFullLength(self) -> "bool" :
        """
        Gets and sets if the distance defines the full extent length or half the length. A value of
        True indicates if defines the full length.
        """
        return _fusion.SymmetricExtentDefinition__get_isFullLength(self)

    def _set_isFullLength(self, *args) -> "bool" :
        """
        Gets and sets if the distance defines the full extent length or half the length. A value of
        True indicates if defines the full length.
        """
        return _fusion.SymmetricExtentDefinition__set_isFullLength(self, *args)

    def _get_distance(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the current extent distance. If the SymmetricExtentDefinition object has been created statically and isn't associated with
        a feature this will return a ValueInput object. If the SymmetricExtentDefinition object is obtained from a feature this
        will return a ModelParameter object. You can use properties of the parameter to edit it's value which will result in
        the feature updating.
        """
        return _fusion.SymmetricExtentDefinition__get_distance(self)

    def _get_taperAngle(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the current taper angle. If the SymmetricExtentDefinition object has been created statically and isn't associated with
        a feature this will return a ValueInput object. If the SymmetricExtentDefinition object is obtained from a feature this
        will return a ModelParameter object. You can use properties of the parameter to edit it's value which will result in
        the feature updating.
        """
        return _fusion.SymmetricExtentDefinition__get_taperAngle(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        """
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.SymmetricExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SymmetricExtentDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SymmetricExtentDefinition__get_isValid(self)
SymmetricExtentDefinition_swigregister = _fusion.SymmetricExtentDefinition_swigregister
SymmetricExtentDefinition_swigregister(SymmetricExtentDefinition)

def SymmetricExtentDefinition_classType() -> "char const *" :
  return _fusion.SymmetricExtentDefinition_classType()
SymmetricExtentDefinition_classType = _fusion.SymmetricExtentDefinition_classType

def SymmetricExtentDefinition_create(*args) -> "adsk::core::Ptr< adsk::core::ValueInput > const &" :
  return _fusion.SymmetricExtentDefinition_create(*args)
SymmetricExtentDefinition_create = _fusion.SymmetricExtentDefinition_create

SymmetricExtentDefinition.__swig_getmethods__["isFullLength"] = SymmetricExtentDefinition._get_isFullLength
SymmetricExtentDefinition.__swig_setmethods__["isFullLength"] = SymmetricExtentDefinition._set_isFullLength
SymmetricExtentDefinition.isFullLength = property(SymmetricExtentDefinition._get_isFullLength, SymmetricExtentDefinition._set_isFullLength, doc="Gets and sets if the distance defines the full extent length or half the length. A value of\nTrue indicates if defines the full length.")

SymmetricExtentDefinition.__swig_getmethods__["distance"] = SymmetricExtentDefinition._get_distance
SymmetricExtentDefinition.distance = property(SymmetricExtentDefinition._get_distance, doc="Returns the current extent distance. If the SymmetricExtentDefinition object has been created statically and isn't associated with\na feature this will return a ValueInput object. If the SymmetricExtentDefinition object is obtained from a feature this\nwill return a ModelParameter object. You can use properties of the parameter to edit it's value which will result in\nthe feature updating.")

SymmetricExtentDefinition.__swig_getmethods__["taperAngle"] = SymmetricExtentDefinition._get_taperAngle
SymmetricExtentDefinition.taperAngle = property(SymmetricExtentDefinition._get_taperAngle, doc="Returns the current taper angle. If the SymmetricExtentDefinition object has been created statically and isn't associated with\na feature this will return a ValueInput object. If the SymmetricExtentDefinition object is obtained from a feature this\nwill return a ModelParameter object. You can use properties of the parameter to edit it's value which will result in\nthe feature updating.")

SymmetricExtentDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SymmetricExtentDefinition) else None
SymmetricExtentDefinition.cast = lambda arg: arg if isinstance(arg, SymmetricExtentDefinition) else None

class SymmetryConstraint(GeometricConstraint):
    """A symmetry constraint in a sketch."""
    __swig_setmethods__ = {}
    for _s in [GeometricConstraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SymmetryConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricConstraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SymmetryConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SymmetryConstraint *" : return _fusion.SymmetryConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SymmetryConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SymmetryConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SymmetryConstraint_classType
    if _newclass:classType = staticmethod(_fusion.SymmetryConstraint_classType)
    __swig_destroy__ = _fusion.delete_SymmetryConstraint
    __del__ = lambda self : None;
    def _get_entityOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchEntity >" :
        """Returns the first curve."""
        return _fusion.SymmetryConstraint__get_entityOne(self)

    def _get_entityTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchEntity >" :
        """Returns the second curve."""
        return _fusion.SymmetryConstraint__get_entityTwo(self)

    def _get_symmetryLine(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """Returns the axis (SketchLine) that defines the symmetry."""
        return _fusion.SymmetryConstraint__get_symmetryLine(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SymmetryConstraint >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SymmetryConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SymmetryConstraint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SymmetryConstraint_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.SymmetryConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.SymmetryConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.SymmetryConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SymmetryConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.SymmetryConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SymmetryConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SymmetryConstraint__get_isValid(self)
SymmetryConstraint_swigregister = _fusion.SymmetryConstraint_swigregister
SymmetryConstraint_swigregister(SymmetryConstraint)

def SymmetryConstraint_classType() -> "char const *" :
  return _fusion.SymmetryConstraint_classType()
SymmetryConstraint_classType = _fusion.SymmetryConstraint_classType

SymmetryConstraint.__swig_getmethods__["entityOne"] = SymmetryConstraint._get_entityOne
SymmetryConstraint.entityOne = property(SymmetryConstraint._get_entityOne, doc="Returns the first curve.")

SymmetryConstraint.__swig_getmethods__["entityTwo"] = SymmetryConstraint._get_entityTwo
SymmetryConstraint.entityTwo = property(SymmetryConstraint._get_entityTwo, doc="Returns the second curve.")

SymmetryConstraint.__swig_getmethods__["symmetryLine"] = SymmetryConstraint._get_symmetryLine
SymmetryConstraint.symmetryLine = property(SymmetryConstraint._get_symmetryLine, doc="Returns the axis (SketchLine) that defines the symmetry.")

SymmetryConstraint.__swig_getmethods__["nativeObject"] = SymmetryConstraint._get_nativeObject
SymmetryConstraint.nativeObject = property(SymmetryConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SymmetryConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SymmetryConstraint) else None
SymmetryConstraint.cast = lambda arg: arg if isinstance(arg, SymmetryConstraint) else None

class TangentConstraint(GeometricConstraint):
    """A tangent constraint in a sketch."""
    __swig_setmethods__ = {}
    for _s in [GeometricConstraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TangentConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricConstraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TangentConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TangentConstraint *" : return _fusion.TangentConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TangentConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TangentConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TangentConstraint_classType
    if _newclass:classType = staticmethod(_fusion.TangentConstraint_classType)
    __swig_destroy__ = _fusion.delete_TangentConstraint
    __del__ = lambda self : None;
    def _get_curveOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >" :
        """Returns the first curve."""
        return _fusion.TangentConstraint__get_curveOne(self)

    def _get_curveTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchCurve >" :
        """Returns the second curve."""
        return _fusion.TangentConstraint__get_curveTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::TangentConstraint >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.TangentConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::TangentConstraint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.TangentConstraint_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.TangentConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.TangentConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.TangentConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.TangentConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.TangentConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.TangentConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TangentConstraint__get_isValid(self)
TangentConstraint_swigregister = _fusion.TangentConstraint_swigregister
TangentConstraint_swigregister(TangentConstraint)

def TangentConstraint_classType() -> "char const *" :
  return _fusion.TangentConstraint_classType()
TangentConstraint_classType = _fusion.TangentConstraint_classType

TangentConstraint.__swig_getmethods__["curveOne"] = TangentConstraint._get_curveOne
TangentConstraint.curveOne = property(TangentConstraint._get_curveOne, doc="Returns the first curve.")

TangentConstraint.__swig_getmethods__["curveTwo"] = TangentConstraint._get_curveTwo
TangentConstraint.curveTwo = property(TangentConstraint._get_curveTwo, doc="Returns the second curve.")

TangentConstraint.__swig_getmethods__["nativeObject"] = TangentConstraint._get_nativeObject
TangentConstraint.nativeObject = property(TangentConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

TangentConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TangentConstraint) else None
TangentConstraint.cast = lambda arg: arg if isinstance(arg, TangentConstraint) else None

class ThickenFeature(Feature):
    """Object that represents an existing Thicken feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThickenFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThickenFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ThickenFeature *" : return _fusion.ThickenFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ThickenFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ThickenFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ThickenFeature_classType
    if _newclass:classType = staticmethod(_fusion.ThickenFeature_classType)
    __swig_destroy__ = _fusion.delete_ThickenFeature
    __del__ = lambda self : None;
    def setInputEntities(self, *args) -> "bool" :
        """
        Sets the faces and patch bodies to thicken 
        inputFaces : The faces or patch bodies to thicken. Faces need not be from the same component or body, nor do they need to be 
        connected or touching one another. 
        isChainSelection : A boolean value for setting whether or not faces that are tangentially connected to 
        the input faces (if any) will be included in the offset. The default value is true. 
        Returns true if successful
        """
        return _fusion.ThickenFeature_setInputEntities(self, *args)

    def _get_inputFaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """Gets and sets the ObjectCollection containing the face and/or patch bodies to thicken."""
        return _fusion.ThickenFeature__get_inputFaces(self)

    def _set_inputFaces(self, *args) -> "bool" :
        """Gets and sets the ObjectCollection containing the face and/or patch bodies to thicken."""
        return _fusion.ThickenFeature__set_inputFaces(self, *args)

    def _get_thickness(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter controlling the thickness. You can edit the thickness value
        by editing the value of the parameter object.
        """
        return _fusion.ThickenFeature__get_thickness(self)

    def _get_isSymmetric(self) -> "bool" :
        """Gets and sets whether to add thickness symmetrically or only on one side of the face/s to thicken"""
        return _fusion.ThickenFeature__get_isSymmetric(self)

    def _set_isSymmetric(self, *args) -> "bool" :
        """Gets and sets whether to add thickness symmetrically or only on one side of the face/s to thicken"""
        return _fusion.ThickenFeature__set_isSymmetric(self, *args)

    def _get_operation(self) -> "adsk::fusion::FeatureOperations" :
        """Gets and sets the feature operation to perform."""
        return _fusion.ThickenFeature__get_operation(self)

    def _set_operation(self, *args) -> "bool" :
        """Gets and sets the feature operation to perform."""
        return _fusion.ThickenFeature__set_operation(self, *args)

    def _get_isChainSelection(self) -> "bool" :
        """Get and sets whether faces that are tangentially connected to the input faces will be included in the thicken feature."""
        return _fusion.ThickenFeature__get_isChainSelection(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ThickenFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ThickenFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::ThickenFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.ThickenFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ThickenFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ThickenFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ThickenFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.ThickenFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ThickenFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ThickenFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.ThickenFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.ThickenFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.ThickenFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.ThickenFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ThickenFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.ThickenFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.ThickenFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.ThickenFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ThickenFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.ThickenFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ThickenFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ThickenFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ThickenFeature__get_isValid(self)
ThickenFeature_swigregister = _fusion.ThickenFeature_swigregister
ThickenFeature_swigregister(ThickenFeature)

def ThickenFeature_classType() -> "char const *" :
  return _fusion.ThickenFeature_classType()
ThickenFeature_classType = _fusion.ThickenFeature_classType

ThickenFeature.__swig_getmethods__["inputFaces"] = ThickenFeature._get_inputFaces
ThickenFeature.__swig_setmethods__["inputFaces"] = ThickenFeature._set_inputFaces
ThickenFeature.inputFaces = property(ThickenFeature._get_inputFaces, ThickenFeature._set_inputFaces, doc="Gets and sets the ObjectCollection containing the face and/or patch bodies to thicken.")

ThickenFeature.__swig_getmethods__["thickness"] = ThickenFeature._get_thickness
ThickenFeature.thickness = property(ThickenFeature._get_thickness, doc="Returns the parameter controlling the thickness. You can edit the thickness value\nby editing the value of the parameter object.")

ThickenFeature.__swig_getmethods__["isSymmetric"] = ThickenFeature._get_isSymmetric
ThickenFeature.__swig_setmethods__["isSymmetric"] = ThickenFeature._set_isSymmetric
ThickenFeature.isSymmetric = property(ThickenFeature._get_isSymmetric, ThickenFeature._set_isSymmetric, doc="Gets and sets whether to add thickness symmetrically or only on one side of the face/s to thicken")

ThickenFeature.__swig_getmethods__["operation"] = ThickenFeature._get_operation
ThickenFeature.__swig_setmethods__["operation"] = ThickenFeature._set_operation
ThickenFeature.operation = property(ThickenFeature._get_operation, ThickenFeature._set_operation, doc="Gets and sets the feature operation to perform.")

ThickenFeature.__swig_getmethods__["isChainSelection"] = ThickenFeature._get_isChainSelection
ThickenFeature.isChainSelection = property(ThickenFeature._get_isChainSelection, doc="Get and sets whether faces that are tangentially connected to the input faces will be included in the thicken feature.")

ThickenFeature.__swig_getmethods__["nativeObject"] = ThickenFeature._get_nativeObject
ThickenFeature.nativeObject = property(ThickenFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

ThickenFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ThickenFeature) else None
ThickenFeature.cast = lambda arg: arg if isinstance(arg, ThickenFeature) else None

class ThreadFeature(Feature):
    """Object that represents an existing thread feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThreadFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThreadFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ThreadFeature *" : return _fusion.ThreadFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ThreadFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ThreadFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ThreadFeature_classType
    if _newclass:classType = staticmethod(_fusion.ThreadFeature_classType)
    __swig_destroy__ = _fusion.delete_ThreadFeature
    __del__ = lambda self : None;
    def _get_inputCylindricalFace(self) -> "adsk::core::Ptr< adsk::fusion::BRepFace >" :
        """
        Gets and sets the threaded face. In the case where there are multiple faces, only the first one is returned.
        Setting this results in a thread being applied to only a single face.
        It is recommended that you use the inputCylindricalfaces property in order to have full access to the collection of faces
        to be threaded.
        """
        return _fusion.ThreadFeature__get_inputCylindricalFace(self)

    def _set_inputCylindricalFace(self, *args) -> "bool" :
        """
        Gets and sets the threaded face. In the case where there are multiple faces, only the first one is returned.
        Setting this results in a thread being applied to only a single face.
        It is recommended that you use the inputCylindricalfaces property in order to have full access to the collection of faces
        to be threaded.
        """
        return _fusion.ThreadFeature__set_inputCylindricalFace(self, *args)

    def _get_isModeled(self) -> "bool" :
        """
        Gets and sets if the thread is physical or cosmetic thread. A value of true indicates a physical thread.
        It defaults to false.
        """
        return _fusion.ThreadFeature__get_isModeled(self)

    def _set_isModeled(self, *args) -> "bool" :
        """
        Gets and sets if the thread is physical or cosmetic thread. A value of true indicates a physical thread.
        It defaults to false.
        """
        return _fusion.ThreadFeature__set_isModeled(self, *args)

    def _get_isFullLength(self) -> "bool" :
        """
        Gets and sets if this thread is the full length of the cylinder.
        It only can be set to true.
        """
        return _fusion.ThreadFeature__get_isFullLength(self)

    def _set_isFullLength(self, *args) -> "bool" :
        """
        Gets and sets if this thread is the full length of the cylinder.
        It only can be set to true.
        """
        return _fusion.ThreadFeature__set_isFullLength(self, *args)

    def setThreadOffsetLength(self, *args) -> "bool" :
        """
        Sets the thread offset, length and location.
        Calling this method will cause the isFullLength property to be set to false. 
        threadOffset : A ValueInput object that defines the thread offset. 
        threadLength : A ValueInput object that defines the thread length. 
        threadLocation : Indicates where the thread length is measured from. 
        Returns true if successful.
        """
        return _fusion.ThreadFeature_setThreadOffsetLength(self, *args)

    def _get_threadLength(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the parameter that controls the depth of the thread. 
        Even though the parameter for the thread depth is always created and accessible through this property, 
        it is only used in the case where the isFullLength property is false.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ThreadFeature__get_threadLength(self)

    def _get_threadOffset(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the parameter that controls the offset value of the thread. 
        The offset is the distance along the axis of the cylinder from the edge to the start of the thread,
        it is only used in the case where the isFullLength property is false.
        Returns nothing in the case where the feature is non-parametric.
        """
        return _fusion.ThreadFeature__get_threadOffset(self)

    def _get_threadLocation(self) -> "adsk::fusion::ThreadLocations" :
        """
        Gets and sets where the thread length is measured from.
        This property is only used in the case where the isFullLength property is false.
        """
        return _fusion.ThreadFeature__get_threadLocation(self)

    def _set_threadLocation(self, *args) -> "bool" :
        """
        Gets and sets where the thread length is measured from.
        This property is only used in the case where the isFullLength property is false.
        """
        return _fusion.ThreadFeature__set_threadLocation(self, *args)

    def _get_threadInfo(self) -> "adsk::core::Ptr< adsk::fusion::ThreadInfo >" :
        """
        Gets and sets the thread data. 
        Also can edit the thread through the properties and methods on the ThreadInfo object.
        """
        return _fusion.ThreadFeature__get_threadInfo(self)

    def _set_threadInfo(self, *args) -> "bool" :
        """
        Gets and sets the thread data. 
        Also can edit the thread through the properties and methods on the ThreadInfo object.
        """
        return _fusion.ThreadFeature__set_threadInfo(self, *args)

    def _get_isRightHanded(self) -> "bool" :
        """
        Gets and sets if the thread is right or left-handed thread. A value of true indicates a right-handed thread.
        It defaults to true.
        """
        return _fusion.ThreadFeature__get_isRightHanded(self)

    def _set_isRightHanded(self, *args) -> "bool" :
        """
        Gets and sets if the thread is right or left-handed thread. A value of true indicates a right-handed thread.
        It defaults to true.
        """
        return _fusion.ThreadFeature__set_isRightHanded(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::ThreadFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.ThreadFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::ThreadFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.ThreadFeature_createForAssemblyContext(self, *args)

    def _get_inputCylindricalFaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """Gets and sets the cylindrical input faces."""
        return _fusion.ThreadFeature__get_inputCylindricalFaces(self)

    def _set_inputCylindricalFaces(self, *args) -> "bool" :
        """Gets and sets the cylindrical input faces."""
        return _fusion.ThreadFeature__set_inputCylindricalFaces(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ThreadFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.ThreadFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.ThreadFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.ThreadFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ThreadFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.ThreadFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.ThreadFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.ThreadFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.ThreadFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.ThreadFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.ThreadFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.ThreadFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.ThreadFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.ThreadFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.ThreadFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.ThreadFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.ThreadFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ThreadFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ThreadFeature__get_isValid(self)
ThreadFeature_swigregister = _fusion.ThreadFeature_swigregister
ThreadFeature_swigregister(ThreadFeature)

def ThreadFeature_classType() -> "char const *" :
  return _fusion.ThreadFeature_classType()
ThreadFeature_classType = _fusion.ThreadFeature_classType

ThreadFeature.__swig_getmethods__["inputCylindricalFace"] = ThreadFeature._get_inputCylindricalFace
ThreadFeature.__swig_setmethods__["inputCylindricalFace"] = ThreadFeature._set_inputCylindricalFace
ThreadFeature.inputCylindricalFace = property(ThreadFeature._get_inputCylindricalFace, ThreadFeature._set_inputCylindricalFace, doc="Gets and sets the threaded face. In the case where there are multiple faces, only the first one is returned.\nSetting this results in a thread being applied to only a single face.\nIt is recommended that you use the inputCylindricalfaces property in order to have full access to the collection of faces\nto be threaded.")

ThreadFeature.__swig_getmethods__["isModeled"] = ThreadFeature._get_isModeled
ThreadFeature.__swig_setmethods__["isModeled"] = ThreadFeature._set_isModeled
ThreadFeature.isModeled = property(ThreadFeature._get_isModeled, ThreadFeature._set_isModeled, doc="Gets and sets if the thread is physical or cosmetic thread. A value of true indicates a physical thread.\nIt defaults to false.")

ThreadFeature.__swig_getmethods__["isFullLength"] = ThreadFeature._get_isFullLength
ThreadFeature.__swig_setmethods__["isFullLength"] = ThreadFeature._set_isFullLength
ThreadFeature.isFullLength = property(ThreadFeature._get_isFullLength, ThreadFeature._set_isFullLength, doc="Gets and sets if this thread is the full length of the cylinder.\nIt only can be set to true.")

ThreadFeature.__swig_getmethods__["threadLength"] = ThreadFeature._get_threadLength
ThreadFeature.threadLength = property(ThreadFeature._get_threadLength, doc="Gets the parameter that controls the depth of the thread.\nEven though the parameter for the thread depth is always created and accessible through this property,\nit is only used in the case where the isFullLength property is false.\nReturns nothing in the case where the feature is non-parametric.")

ThreadFeature.__swig_getmethods__["threadOffset"] = ThreadFeature._get_threadOffset
ThreadFeature.threadOffset = property(ThreadFeature._get_threadOffset, doc="Gets the parameter that controls the offset value of the thread.\nThe offset is the distance along the axis of the cylinder from the edge to the start of the thread,\nit is only used in the case where the isFullLength property is false.\nReturns nothing in the case where the feature is non-parametric.")

ThreadFeature.__swig_getmethods__["threadLocation"] = ThreadFeature._get_threadLocation
ThreadFeature.__swig_setmethods__["threadLocation"] = ThreadFeature._set_threadLocation
ThreadFeature.threadLocation = property(ThreadFeature._get_threadLocation, ThreadFeature._set_threadLocation, doc="Gets and sets where the thread length is measured from.\nThis property is only used in the case where the isFullLength property is false.")

ThreadFeature.__swig_getmethods__["threadInfo"] = ThreadFeature._get_threadInfo
ThreadFeature.__swig_setmethods__["threadInfo"] = ThreadFeature._set_threadInfo
ThreadFeature.threadInfo = property(ThreadFeature._get_threadInfo, ThreadFeature._set_threadInfo, doc="Gets and sets the thread data.\nAlso can edit the thread through the properties and methods on the ThreadInfo object.")

ThreadFeature.__swig_getmethods__["isRightHanded"] = ThreadFeature._get_isRightHanded
ThreadFeature.__swig_setmethods__["isRightHanded"] = ThreadFeature._set_isRightHanded
ThreadFeature.isRightHanded = property(ThreadFeature._get_isRightHanded, ThreadFeature._set_isRightHanded, doc="Gets and sets if the thread is right or left-handed thread. A value of true indicates a right-handed thread.\nIt defaults to true.")

ThreadFeature.__swig_getmethods__["nativeObject"] = ThreadFeature._get_nativeObject
ThreadFeature.nativeObject = property(ThreadFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

ThreadFeature.__swig_getmethods__["inputCylindricalFaces"] = ThreadFeature._get_inputCylindricalFaces
ThreadFeature.__swig_setmethods__["inputCylindricalFaces"] = ThreadFeature._set_inputCylindricalFaces
ThreadFeature.inputCylindricalFaces = property(ThreadFeature._get_inputCylindricalFaces, ThreadFeature._set_inputCylindricalFaces, doc="Gets and sets the cylindrical input faces.")

ThreadFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ThreadFeature) else None
ThreadFeature.cast = lambda arg: arg if isinstance(arg, ThreadFeature) else None

class ThroughAllExtentDefinition(ExtentDefinition):
    """A definition object that is used to define the extents of a feature to be through all."""
    __swig_setmethods__ = {}
    for _s in [ExtentDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThroughAllExtentDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ExtentDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThroughAllExtentDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ThroughAllExtentDefinition *" : return _fusion.ThroughAllExtentDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ThroughAllExtentDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ThroughAllExtentDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ThroughAllExtentDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ThroughAllExtentDefinition_classType)
    __swig_getmethods__["create"] = lambda x: _fusion.ThroughAllExtentDefinition_create
    if _newclass:create = staticmethod(_fusion.ThroughAllExtentDefinition_create)
    __swig_destroy__ = _fusion.delete_ThroughAllExtentDefinition
    __del__ = lambda self : None;
    def _get_isPositiveDirection(self) -> "bool" :
        """
        Gets and sets if the direction is positive or negative. A value of true indicates it is 
        in the same direction as the z direction of the profile's sketch plane. 
        This is only used when the extrusion is only defined in a single direction from the 
        profile plane. If it's a two sided extrusion, this value is ignored.
        """
        return _fusion.ThroughAllExtentDefinition__get_isPositiveDirection(self)

    def _set_isPositiveDirection(self, *args) -> "bool" :
        """
        Gets and sets if the direction is positive or negative. A value of true indicates it is 
        in the same direction as the z direction of the profile's sketch plane. 
        This is only used when the extrusion is only defined in a single direction from the 
        profile plane. If it's a two sided extrusion, this value is ignored.
        """
        return _fusion.ThroughAllExtentDefinition__set_isPositiveDirection(self, *args)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        """
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.ThroughAllExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ThroughAllExtentDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ThroughAllExtentDefinition__get_isValid(self)
ThroughAllExtentDefinition_swigregister = _fusion.ThroughAllExtentDefinition_swigregister
ThroughAllExtentDefinition_swigregister(ThroughAllExtentDefinition)

def ThroughAllExtentDefinition_classType() -> "char const *" :
  return _fusion.ThroughAllExtentDefinition_classType()
ThroughAllExtentDefinition_classType = _fusion.ThroughAllExtentDefinition_classType

def ThroughAllExtentDefinition_create() -> "adsk::core::Ptr< adsk::fusion::ThroughAllExtentDefinition >" :
  return _fusion.ThroughAllExtentDefinition_create()
ThroughAllExtentDefinition_create = _fusion.ThroughAllExtentDefinition_create

ThroughAllExtentDefinition.__swig_getmethods__["isPositiveDirection"] = ThroughAllExtentDefinition._get_isPositiveDirection
ThroughAllExtentDefinition.__swig_setmethods__["isPositiveDirection"] = ThroughAllExtentDefinition._set_isPositiveDirection
ThroughAllExtentDefinition.isPositiveDirection = property(ThroughAllExtentDefinition._get_isPositiveDirection, ThroughAllExtentDefinition._set_isPositiveDirection, doc="Gets and sets if the direction is positive or negative. A value of true indicates it is\nin the same direction as the z direction of the profile's sketch plane.\nThis is only used when the extrusion is only defined in a single direction from the\nprofile plane. If it's a two sided extrusion, this value is ignored.")

ThroughAllExtentDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ThroughAllExtentDefinition) else None
ThroughAllExtentDefinition.cast = lambda arg: arg if isinstance(arg, ThroughAllExtentDefinition) else None

class TimelineGroup(TimelineObject):
    """Represents a group in the timeline."""
    __swig_setmethods__ = {}
    for _s in [TimelineObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimelineGroup, name, value)
    __swig_getmethods__ = {}
    for _s in [TimelineObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TimelineGroup, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TimelineGroup *" : return _fusion.TimelineGroup___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TimelineGroup___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TimelineGroup___ne__(self, *args)

    def __len__(self) -> "size_t" : return _fusion.TimelineGroup___len__(self)
    def __getitem__(self, *args) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        if isinstance(args[0], slice):
            return [self[ii] for ii in range(*args[0].indices(len(self)))]
        if args[0] < 0:
            args = ((args[0] + len(self)),) + args[1:]
        if args[0] < 0 or args[0] >= len(self):
            raise IndexError("The index (%d) is out of range." % args[0])


        return _fusion.TimelineGroup___getitem__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TimelineGroup_classType
    if _newclass:classType = staticmethod(_fusion.TimelineGroup_classType)
    __swig_destroy__ = _fusion.delete_TimelineGroup
    __del__ = lambda self : None;
    def deleteMe(self, *args) -> "bool" :
        """
        Deletes the group with the option of deleting or keeping the contents. 
        deleteGroupAndContents : Indicates if the group and its contents should be deleted or if only the group
        should be deleted and the contents kept and expanded. A value of true will delete
        the group and its contents. 
        Returns true if the delete was successful.
        """
        return _fusion.TimelineGroup_deleteMe(self, *args)

    def _get_isCollapsed(self) -> "bool" :
        """Indicates if the group is collapsed or expanded."""
        return _fusion.TimelineGroup__get_isCollapsed(self)

    def _set_isCollapsed(self, *args) -> "bool" :
        """Indicates if the group is collapsed or expanded."""
        return _fusion.TimelineGroup__set_isCollapsed(self, *args)

    def item(self, *args) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """
        Function that returns the specified timeline object within the group using an index into the collection. 
        index : The index of the item within the collection to return. The first item in the collection has an index of 0. 
        Returns the specified item or null if an invalid index was specified.
        """
        return _fusion.TimelineGroup_item(self, *args)

    def _get_count(self) -> "size_t" :
        """The number of items in the group."""
        return _fusion.TimelineGroup__get_count(self)

    def _get_isSuppressed(self) -> "bool" :
        """Gets and sets if this object is suppressed."""
        return _fusion.TimelineGroup__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """Gets and sets if this object is suppressed."""
        return _fusion.TimelineGroup__set_isSuppressed(self, *args)

    def _get_parentGroup(self) -> "adsk::core::Ptr< adsk::fusion::TimelineGroup >" :
        """
        Returns the parent group, if this object is part of a group.
        Returns null if this object is not part of a group.
        """
        return _fusion.TimelineGroup__get_parentGroup(self)

    def _get_index(self) -> "int" :
        """
        Returns the position of this item within the timeline where
        the first item has an index of 0.
        This property can return -1 in the two cases where this object
        is not currently represented in the timeline. The two cases are:
        1. When this is a TimelineGroup object and the group is expanded.
        2. When this object is part of a group and the group is collapsed.
        """
        return _fusion.TimelineGroup__get_index(self)

    def _get_isRolledBack(self) -> "bool" :
        """
        Indicates if this item is currently not being computed
        because it has been rolled back.
        If this is a timelineGroup object and the group is expanded
        the value of this property should be ignored.
        """
        return _fusion.TimelineGroup__get_isRolledBack(self)

    def rollTo(self, *args) -> "bool" :
        """
        Rolls the timeline by repositioning the marker to either before or after this object.
        This method will fail if this is a timelineGroup object and the group is expanded. 
        rollBefore : Set rollBefore to true to reposition the marker before this object or to false to
        reposition the marker after this object 
        Returns true if the move was successful
        """
        return _fusion.TimelineGroup_rollTo(self, *args)

    def _get_entity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the entity associated with this timeline object.
        Edit operations can be performed by getting the object
        representing the associated entity and using the methods
        and properties on that entity to make changes.
        Returns null if this is a TimelineGroup object
        """
        return _fusion.TimelineGroup__get_entity(self)

    def canReorder(self, *args) -> "bool" :
        """
        Checks to see if this object can be reordered to the specified position.
        The default value of -1 indicates the end of the timeline.
        This method will fail if this is a timelineGroup object and the group is expanded. 
        beforeIndex : The index number of the position in the timeline to check 
        Returns true if the object can be reordered to the specified position
        """
        return _fusion.TimelineGroup_canReorder(self, *args)

    def reorder(self, *args) -> "bool" :
        """
        Reorders this object to the position specified.
        The default value of -1 indicates the end of the timeline. 
        beforeIndex : The index number of the position in the timeline to place this object before 
        Returns true if the reorder operation was successful
        This method will fail and return false if this is a timelineGroup object and the 
        group is expanded.
        """
        return _fusion.TimelineGroup_reorder(self, *args)

    def _get_isGroup(self) -> "bool" :
        """
        Indicates if this TimelineObject represents a group. If True you can
        operate on this object as a TimelineGroup object.
        """
        return _fusion.TimelineGroup__get_isGroup(self)

    def _get_name(self) -> "std::string" :
        """
        Gets and sets the name of this timeline object. This name is shared by the object
        the timeline object represents. For example, if the TimelineObject represents a Sketch
        and you change the name using the TimelineObject, the name of the sketch in the browser
        is also changed. The reverse is also true. Setting the name of an object; sketch, feature
        construction geometry, etc, will also change the name of the associated node in the timeline.
        """
        return _fusion.TimelineGroup__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """
        Gets and sets the name of this timeline object. This name is shared by the object
        the timeline object represents. For example, if the TimelineObject represents a Sketch
        and you change the name using the TimelineObject, the name of the sketch in the browser
        is also changed. The reverse is also true. Setting the name of an object; sketch, feature
        construction geometry, etc, will also change the name of the associated node in the timeline.
        """
        return _fusion.TimelineGroup__set_name(self, *args)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the object associated with this TimelineObject."""
        return _fusion.TimelineGroup__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.TimelineGroup__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.TimelineGroup__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TimelineGroup__get_isValid(self)
TimelineGroup_swigregister = _fusion.TimelineGroup_swigregister
TimelineGroup_swigregister(TimelineGroup)

def TimelineGroup_classType() -> "char const *" :
  return _fusion.TimelineGroup_classType()
TimelineGroup_classType = _fusion.TimelineGroup_classType

TimelineGroup.__swig_getmethods__["isCollapsed"] = TimelineGroup._get_isCollapsed
TimelineGroup.__swig_setmethods__["isCollapsed"] = TimelineGroup._set_isCollapsed
TimelineGroup.isCollapsed = property(TimelineGroup._get_isCollapsed, TimelineGroup._set_isCollapsed, doc="Indicates if the group is collapsed or expanded.")

TimelineGroup.__swig_getmethods__["count"] = TimelineGroup._get_count
TimelineGroup.count = property(TimelineGroup._get_count, doc="The number of items in the group.")

TimelineGroup.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TimelineGroup) else None
TimelineGroup.cast = lambda arg: arg if isinstance(arg, TimelineGroup) else None

class ToEntityExtentDefinition(ExtentDefinition):
    """
    A definition object that is used to define the extents of a feature to be up to a specified
    construction plane or face.
    """
    __swig_setmethods__ = {}
    for _s in [ExtentDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ToEntityExtentDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ExtentDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ToEntityExtentDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::ToEntityExtentDefinition *" : return _fusion.ToEntityExtentDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.ToEntityExtentDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.ToEntityExtentDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.ToEntityExtentDefinition_classType
    if _newclass:classType = staticmethod(_fusion.ToEntityExtentDefinition_classType)
    __swig_getmethods__["create"] = lambda x: _fusion.ToEntityExtentDefinition_create
    if _newclass:create = staticmethod(_fusion.ToEntityExtentDefinition_create)
    __swig_destroy__ = _fusion.delete_ToEntityExtentDefinition
    __del__ = lambda self : None;
    def _get_entity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the entity that the feature extent is defined up to. This can be a ConstructionPlane, Profile, BrepFace,
        BrepBody, or BRepVertex.
        """
        return _fusion.ToEntityExtentDefinition__get_entity(self)

    def _set_entity(self, *args) -> "bool" :
        """
        Gets and sets the entity that the feature extent is defined up to. This can be a ConstructionPlane, Profile, BrepFace,
        BrepBody, or BRepVertex.
        """
        return _fusion.ToEntityExtentDefinition__set_entity(self, *args)

    def _get_offset(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the current offset. If the EntityExtentDefinition object has been created statically and isn't associated with
        a feature this will return a ValueInput object. If the EntityExtentDefinition object is obtained from a feature this
        will return a ModelParameter object. You can use properties of the parameter to edit it's value which will result in
        the feature updating.
        """
        return _fusion.ToEntityExtentDefinition__get_offset(self)

    def _get_isChained(self) -> "bool" :
        """
        Gets and sets whether connected faces to the input entity should also be used when calculating the extent or if the 
        input entity should be extended. A value of true indicates that connected entities should be used.
        """
        return _fusion.ToEntityExtentDefinition__get_isChained(self)

    def _set_isChained(self, *args) -> "bool" :
        """
        Gets and sets whether connected faces to the input entity should also be used when calculating the extent or if the 
        input entity should be extended. A value of true indicates that connected entities should be used.
        """
        return _fusion.ToEntityExtentDefinition__set_isChained(self, *args)

    def _get_directionHint(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Gets and sets a direction that is used when the result is ambiguous. For example, if you have a profile in
        the center of a torus and are extruding to the torus, the extrusion can go in either direction. When needed,
        this provides the information to tell Fusion 360 which direction to go. In most cases this is not needed and
        the property will be null.
        """
        return _fusion.ToEntityExtentDefinition__get_directionHint(self)

    def _set_directionHint(self, *args) -> "bool" :
        """
        Gets and sets a direction that is used when the result is ambiguous. For example, if you have a profile in
        the center of a torus and are extruding to the torus, the extrusion can go in either direction. When needed,
        this provides the information to tell Fusion 360 which direction to go. In most cases this is not needed and
        the property will be null.
        """
        return _fusion.ToEntityExtentDefinition__set_directionHint(self, *args)

    def _get_isMinimumSolution(self) -> "bool" :
        """
        Gets and sets if the minimum or maximum solution is calculated. This is only used when the input entity is
        a body and defines if the extrusion to go to the near side (minimum solution) of the body or the far side.
        When a new ToEntityExtentDefinition object is created, this property defaults to True.
        """
        return _fusion.ToEntityExtentDefinition__get_isMinimumSolution(self)

    def _set_isMinimumSolution(self, *args) -> "bool" :
        """
        Gets and sets if the minimum or maximum solution is calculated. This is only used when the input entity is
        a body and defines if the extrusion to go to the near side (minimum solution) of the body or the far side.
        When a new ToEntityExtentDefinition object is created, this property defaults to True.
        """
        return _fusion.ToEntityExtentDefinition__set_isMinimumSolution(self, *args)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        """
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.ToEntityExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.ToEntityExtentDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.ToEntityExtentDefinition__get_isValid(self)
ToEntityExtentDefinition_swigregister = _fusion.ToEntityExtentDefinition_swigregister
ToEntityExtentDefinition_swigregister(ToEntityExtentDefinition)

def ToEntityExtentDefinition_classType() -> "char const *" :
  return _fusion.ToEntityExtentDefinition_classType()
ToEntityExtentDefinition_classType = _fusion.ToEntityExtentDefinition_classType

def ToEntityExtentDefinition_create(*args) -> "adsk::core::Ptr< adsk::fusion::ToEntityExtentDefinition >" :
  return _fusion.ToEntityExtentDefinition_create(*args)
ToEntityExtentDefinition_create = _fusion.ToEntityExtentDefinition_create

ToEntityExtentDefinition.__swig_getmethods__["entity"] = ToEntityExtentDefinition._get_entity
ToEntityExtentDefinition.__swig_setmethods__["entity"] = ToEntityExtentDefinition._set_entity
ToEntityExtentDefinition.entity = property(ToEntityExtentDefinition._get_entity, ToEntityExtentDefinition._set_entity, doc="Gets and sets the entity that the feature extent is defined up to. This can be a ConstructionPlane, Profile, BrepFace,\nBrepBody, or BRepVertex.")

ToEntityExtentDefinition.__swig_getmethods__["offset"] = ToEntityExtentDefinition._get_offset
ToEntityExtentDefinition.offset = property(ToEntityExtentDefinition._get_offset, doc="Returns the current offset. If the EntityExtentDefinition object has been created statically and isn't associated with\na feature this will return a ValueInput object. If the EntityExtentDefinition object is obtained from a feature this\nwill return a ModelParameter object. You can use properties of the parameter to edit it's value which will result in\nthe feature updating.")

ToEntityExtentDefinition.__swig_getmethods__["isChained"] = ToEntityExtentDefinition._get_isChained
ToEntityExtentDefinition.__swig_setmethods__["isChained"] = ToEntityExtentDefinition._set_isChained
ToEntityExtentDefinition.isChained = property(ToEntityExtentDefinition._get_isChained, ToEntityExtentDefinition._set_isChained, doc="Gets and sets whether connected faces to the input entity should also be used when calculating the extent or if the\ninput entity should be extended. A value of true indicates that connected entities should be used.")

ToEntityExtentDefinition.__swig_getmethods__["directionHint"] = ToEntityExtentDefinition._get_directionHint
ToEntityExtentDefinition.__swig_setmethods__["directionHint"] = ToEntityExtentDefinition._set_directionHint
ToEntityExtentDefinition.directionHint = property(ToEntityExtentDefinition._get_directionHint, ToEntityExtentDefinition._set_directionHint, doc="Gets and sets a direction that is used when the result is ambiguous. For example, if you have a profile in\nthe center of a torus and are extruding to the torus, the extrusion can go in either direction. When needed,\nthis provides the information to tell Fusion 360 which direction to go. In most cases this is not needed and\nthe property will be null.")

ToEntityExtentDefinition.__swig_getmethods__["isMinimumSolution"] = ToEntityExtentDefinition._get_isMinimumSolution
ToEntityExtentDefinition.__swig_setmethods__["isMinimumSolution"] = ToEntityExtentDefinition._set_isMinimumSolution
ToEntityExtentDefinition.isMinimumSolution = property(ToEntityExtentDefinition._get_isMinimumSolution, ToEntityExtentDefinition._set_isMinimumSolution, doc="Gets and sets if the minimum or maximum solution is calculated. This is only used when the input entity is\na body and defines if the extrusion to go to the near side (minimum solution) of the body or the far side.\nWhen a new ToEntityExtentDefinition object is created, this property defaults to True.")

ToEntityExtentDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, ToEntityExtentDefinition) else None
ToEntityExtentDefinition.cast = lambda arg: arg if isinstance(arg, ToEntityExtentDefinition) else None

class TorusFeature(Feature):
    """Object that represents an existing torus feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TorusFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TorusFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TorusFeature *" : return _fusion.TorusFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TorusFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TorusFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TorusFeature_classType
    if _newclass:classType = staticmethod(_fusion.TorusFeature_classType)
    __swig_destroy__ = _fusion.delete_TorusFeature
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.TorusFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.TorusFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.TorusFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.TorusFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.TorusFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.TorusFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.TorusFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.TorusFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.TorusFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.TorusFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.TorusFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.TorusFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.TorusFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.TorusFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.TorusFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.TorusFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.TorusFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.TorusFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TorusFeature__get_isValid(self)
TorusFeature_swigregister = _fusion.TorusFeature_swigregister
TorusFeature_swigregister(TorusFeature)

def TorusFeature_classType() -> "char const *" :
  return _fusion.TorusFeature_classType()
TorusFeature_classType = _fusion.TorusFeature_classType

TorusFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TorusFeature) else None
TorusFeature.cast = lambda arg: arg if isinstance(arg, TorusFeature) else None

class TrimFeature(Feature):
    """Object that represents an existing trim feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TrimFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TrimFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TrimFeature *" : return _fusion.TrimFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TrimFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TrimFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TrimFeature_classType
    if _newclass:classType = staticmethod(_fusion.TrimFeature_classType)
    __swig_destroy__ = _fusion.delete_TrimFeature
    __del__ = lambda self : None;
    def _get_trimTool(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """Gets and sets the entity (a patch body, B-Rep face, construction plane or sketch curve) that intersects the trim tool"""
        return _fusion.TrimFeature__get_trimTool(self)

    def _set_trimTool(self, *args) -> "bool" :
        """Gets and sets the entity (a patch body, B-Rep face, construction plane or sketch curve) that intersects the trim tool"""
        return _fusion.TrimFeature__set_trimTool(self, *args)

    def _get_bRepCells(self) -> "adsk::core::Ptr< adsk::fusion::BRepCells >" :
        """
        Returns the collection of the valid cells that have been calculated based on the trim tool.
        Use this collection to specify which cells to trim away.
        """
        return _fusion.TrimFeature__get_bRepCells(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::TrimFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.TrimFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::TrimFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.TrimFeature_createForAssemblyContext(self, *args)

    def applyCellChanges(self) -> "bool" :
        """
        After making any changes to the set of selected cells you must call this method to 
        indicate all changes have been made and to apply those changes to the feature. 
        Returns true if the apply was successful.
        """
        return _fusion.TrimFeature_applyCellChanges(self)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.TrimFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.TrimFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.TrimFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.TrimFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.TrimFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.TrimFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.TrimFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.TrimFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.TrimFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.TrimFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.TrimFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.TrimFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.TrimFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.TrimFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.TrimFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.TrimFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.TrimFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.TrimFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TrimFeature__get_isValid(self)
TrimFeature_swigregister = _fusion.TrimFeature_swigregister
TrimFeature_swigregister(TrimFeature)

def TrimFeature_classType() -> "char const *" :
  return _fusion.TrimFeature_classType()
TrimFeature_classType = _fusion.TrimFeature_classType

TrimFeature.__swig_getmethods__["trimTool"] = TrimFeature._get_trimTool
TrimFeature.__swig_setmethods__["trimTool"] = TrimFeature._set_trimTool
TrimFeature.trimTool = property(TrimFeature._get_trimTool, TrimFeature._set_trimTool, doc="Gets and sets the entity (a patch body, B-Rep face, construction plane or sketch curve) that intersects the trim tool")

TrimFeature.__swig_getmethods__["bRepCells"] = TrimFeature._get_bRepCells
TrimFeature.bRepCells = property(TrimFeature._get_bRepCells, doc="Returns the collection of the valid cells that have been calculated based on the trim tool.\nUse this collection to specify which cells to trim away.")

TrimFeature.__swig_getmethods__["nativeObject"] = TrimFeature._get_nativeObject
TrimFeature.nativeObject = property(TrimFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

TrimFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TrimFeature) else None
TrimFeature.cast = lambda arg: arg if isinstance(arg, TrimFeature) else None

class TwoDistancesChamferTypeDefinition(ChamferTypeDefinition):
    """Provides information to create a chamfer that is defined by a two distances from the edge."""
    __swig_setmethods__ = {}
    for _s in [ChamferTypeDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TwoDistancesChamferTypeDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ChamferTypeDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TwoDistancesChamferTypeDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TwoDistancesChamferTypeDefinition *" : return _fusion.TwoDistancesChamferTypeDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TwoDistancesChamferTypeDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TwoDistancesChamferTypeDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TwoDistancesChamferTypeDefinition_classType
    if _newclass:classType = staticmethod(_fusion.TwoDistancesChamferTypeDefinition_classType)
    __swig_destroy__ = _fusion.delete_TwoDistancesChamferTypeDefinition
    __del__ = lambda self : None;
    def _get_distanceOne(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter controlling the first distance. You can edit the distance
        by editing the value of the parameter object.
        """
        return _fusion.TwoDistancesChamferTypeDefinition__get_distanceOne(self)

    def _get_distanceTwo(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the parameter controlling the second distance. You can edit the distance
        by editing the value of the parameter object.
        """
        return _fusion.TwoDistancesChamferTypeDefinition__get_distanceTwo(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::ChamferFeature >" :
        """Returns the feature that owns this chamfer type definition"""
        return _fusion.TwoDistancesChamferTypeDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.TwoDistancesChamferTypeDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TwoDistancesChamferTypeDefinition__get_isValid(self)
TwoDistancesChamferTypeDefinition_swigregister = _fusion.TwoDistancesChamferTypeDefinition_swigregister
TwoDistancesChamferTypeDefinition_swigregister(TwoDistancesChamferTypeDefinition)

def TwoDistancesChamferTypeDefinition_classType() -> "char const *" :
  return _fusion.TwoDistancesChamferTypeDefinition_classType()
TwoDistancesChamferTypeDefinition_classType = _fusion.TwoDistancesChamferTypeDefinition_classType

TwoDistancesChamferTypeDefinition.__swig_getmethods__["distanceOne"] = TwoDistancesChamferTypeDefinition._get_distanceOne
TwoDistancesChamferTypeDefinition.distanceOne = property(TwoDistancesChamferTypeDefinition._get_distanceOne, doc="Returns the parameter controlling the first distance. You can edit the distance\nby editing the value of the parameter object.")

TwoDistancesChamferTypeDefinition.__swig_getmethods__["distanceTwo"] = TwoDistancesChamferTypeDefinition._get_distanceTwo
TwoDistancesChamferTypeDefinition.distanceTwo = property(TwoDistancesChamferTypeDefinition._get_distanceTwo, doc="Returns the parameter controlling the second distance. You can edit the distance\nby editing the value of the parameter object.")

TwoDistancesChamferTypeDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TwoDistancesChamferTypeDefinition) else None
TwoDistancesChamferTypeDefinition.cast = lambda arg: arg if isinstance(arg, TwoDistancesChamferTypeDefinition) else None

class TwoSidesAngleExtentDefinition(ExtentDefinition):
    """
    Defines the inputs for a TwoSidesAngleExtentDefinition object.
    This feature extent type defines the extents of the feature using angle extents on two sides.
    """
    __swig_setmethods__ = {}
    for _s in [ExtentDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TwoSidesAngleExtentDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ExtentDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TwoSidesAngleExtentDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TwoSidesAngleExtentDefinition *" : return _fusion.TwoSidesAngleExtentDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TwoSidesAngleExtentDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TwoSidesAngleExtentDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TwoSidesAngleExtentDefinition_classType
    if _newclass:classType = staticmethod(_fusion.TwoSidesAngleExtentDefinition_classType)
    __swig_destroy__ = _fusion.delete_TwoSidesAngleExtentDefinition
    __del__ = lambda self : None;
    def _get_angleOne(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the ModelParameter that defines the angle on the first side.
        The value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.
        """
        return _fusion.TwoSidesAngleExtentDefinition__get_angleOne(self)

    def _get_angleTwo(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Gets the ModelParameter that defines the angle on the second side.
        The value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.
        """
        return _fusion.TwoSidesAngleExtentDefinition__get_angleTwo(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        """
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.TwoSidesAngleExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.TwoSidesAngleExtentDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TwoSidesAngleExtentDefinition__get_isValid(self)
TwoSidesAngleExtentDefinition_swigregister = _fusion.TwoSidesAngleExtentDefinition_swigregister
TwoSidesAngleExtentDefinition_swigregister(TwoSidesAngleExtentDefinition)

def TwoSidesAngleExtentDefinition_classType() -> "char const *" :
  return _fusion.TwoSidesAngleExtentDefinition_classType()
TwoSidesAngleExtentDefinition_classType = _fusion.TwoSidesAngleExtentDefinition_classType

TwoSidesAngleExtentDefinition.__swig_getmethods__["angleOne"] = TwoSidesAngleExtentDefinition._get_angleOne
TwoSidesAngleExtentDefinition.angleOne = property(TwoSidesAngleExtentDefinition._get_angleOne, doc="Gets the ModelParameter that defines the angle on the first side.\nThe value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.")

TwoSidesAngleExtentDefinition.__swig_getmethods__["angleTwo"] = TwoSidesAngleExtentDefinition._get_angleTwo
TwoSidesAngleExtentDefinition.angleTwo = property(TwoSidesAngleExtentDefinition._get_angleTwo, doc="Gets the ModelParameter that defines the angle on the second side.\nThe value of the angle can be edited by using the properties on the ModelParameter object to edit the parameter.")

TwoSidesAngleExtentDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TwoSidesAngleExtentDefinition) else None
TwoSidesAngleExtentDefinition.cast = lambda arg: arg if isinstance(arg, TwoSidesAngleExtentDefinition) else None

class TwoSidesDistanceExtentDefinition(ExtentDefinition):
    """
    Defines the inputs for a TwoSidesDistanceExtentDefinition object. 
    This defines a feature extent where the distance in each direction can be a different value.
    """
    __swig_setmethods__ = {}
    for _s in [ExtentDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TwoSidesDistanceExtentDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ExtentDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TwoSidesDistanceExtentDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TwoSidesDistanceExtentDefinition *" : return _fusion.TwoSidesDistanceExtentDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TwoSidesDistanceExtentDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TwoSidesDistanceExtentDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TwoSidesDistanceExtentDefinition_classType
    if _newclass:classType = staticmethod(_fusion.TwoSidesDistanceExtentDefinition_classType)
    __swig_destroy__ = _fusion.delete_TwoSidesDistanceExtentDefinition
    __del__ = lambda self : None;
    def _get_distanceOne(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """Gets the ModelParameter that defines the first distance"""
        return _fusion.TwoSidesDistanceExtentDefinition__get_distanceOne(self)

    def _get_distanceTwo(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """Gets the ModelParameter that defines the second distance"""
        return _fusion.TwoSidesDistanceExtentDefinition__get_distanceTwo(self)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        """
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.TwoSidesDistanceExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.TwoSidesDistanceExtentDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TwoSidesDistanceExtentDefinition__get_isValid(self)
TwoSidesDistanceExtentDefinition_swigregister = _fusion.TwoSidesDistanceExtentDefinition_swigregister
TwoSidesDistanceExtentDefinition_swigregister(TwoSidesDistanceExtentDefinition)

def TwoSidesDistanceExtentDefinition_classType() -> "char const *" :
  return _fusion.TwoSidesDistanceExtentDefinition_classType()
TwoSidesDistanceExtentDefinition_classType = _fusion.TwoSidesDistanceExtentDefinition_classType

TwoSidesDistanceExtentDefinition.__swig_getmethods__["distanceOne"] = TwoSidesDistanceExtentDefinition._get_distanceOne
TwoSidesDistanceExtentDefinition.distanceOne = property(TwoSidesDistanceExtentDefinition._get_distanceOne, doc="Gets the ModelParameter that defines the first distance")

TwoSidesDistanceExtentDefinition.__swig_getmethods__["distanceTwo"] = TwoSidesDistanceExtentDefinition._get_distanceTwo
TwoSidesDistanceExtentDefinition.distanceTwo = property(TwoSidesDistanceExtentDefinition._get_distanceTwo, doc="Gets the ModelParameter that defines the second distance")

TwoSidesDistanceExtentDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TwoSidesDistanceExtentDefinition) else None
TwoSidesDistanceExtentDefinition.cast = lambda arg: arg if isinstance(arg, TwoSidesDistanceExtentDefinition) else None

class TwoSidesToExtentDefinition(ExtentDefinition):
    """
    Defines the inputs for a TwoSidesToExtentDefinition object
    This defines a feature extent where the extents of feature go up to faces or construction planes in both directions.
    """
    __swig_setmethods__ = {}
    for _s in [ExtentDefinition]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TwoSidesToExtentDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [ExtentDefinition]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TwoSidesToExtentDefinition, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::TwoSidesToExtentDefinition *" : return _fusion.TwoSidesToExtentDefinition___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.TwoSidesToExtentDefinition___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.TwoSidesToExtentDefinition___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.TwoSidesToExtentDefinition_classType
    if _newclass:classType = staticmethod(_fusion.TwoSidesToExtentDefinition_classType)
    __swig_destroy__ = _fusion.delete_TwoSidesToExtentDefinition
    __del__ = lambda self : None;
    def _get_toEntityOne(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the entity that defines the extent on side one. The valid types of entities can vary depending on
        the type of feature this is being used with.
        """
        return _fusion.TwoSidesToExtentDefinition__get_toEntityOne(self)

    def _set_toEntityOne(self, *args) -> "bool" :
        """
        Gets and sets the entity that defines the extent on side one. The valid types of entities can vary depending on
        the type of feature this is being used with.
        """
        return _fusion.TwoSidesToExtentDefinition__set_toEntityOne(self, *args)

    def _get_toEntityTwo(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Gets and sets the entity that defines the extent on side two. The valid types of entities can vary depending on
        the type of feature this is being used with.
        """
        return _fusion.TwoSidesToExtentDefinition__get_toEntityTwo(self)

    def _set_toEntityTwo(self, *args) -> "bool" :
        """
        Gets and sets the entity that defines the extent on side two. The valid types of entities can vary depending on
        the type of feature this is being used with.
        """
        return _fusion.TwoSidesToExtentDefinition__set_toEntityTwo(self, *args)

    def _get_matchShape(self) -> "bool" :
        """Gets and sets whether the toEntity is extended to fully intersect the extrusion."""
        return _fusion.TwoSidesToExtentDefinition__get_matchShape(self)

    def _set_matchShape(self, *args) -> "bool" :
        """Gets and sets whether the toEntity is extended to fully intersect the extrusion."""
        return _fusion.TwoSidesToExtentDefinition__set_matchShape(self, *args)

    def _get_parentFeature(self) -> "adsk::core::Ptr< adsk::fusion::Feature >" :
        """
        Returns the parent feature that this definition is associated with. If this definition has been created
        statically and is not associated with a feature this property will return null.
        """
        return _fusion.TwoSidesToExtentDefinition__get_parentFeature(self)

    def _get_objectType(self) -> "char const *" : return _fusion.TwoSidesToExtentDefinition__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.TwoSidesToExtentDefinition__get_isValid(self)
TwoSidesToExtentDefinition_swigregister = _fusion.TwoSidesToExtentDefinition_swigregister
TwoSidesToExtentDefinition_swigregister(TwoSidesToExtentDefinition)

def TwoSidesToExtentDefinition_classType() -> "char const *" :
  return _fusion.TwoSidesToExtentDefinition_classType()
TwoSidesToExtentDefinition_classType = _fusion.TwoSidesToExtentDefinition_classType

TwoSidesToExtentDefinition.__swig_getmethods__["toEntityOne"] = TwoSidesToExtentDefinition._get_toEntityOne
TwoSidesToExtentDefinition.__swig_setmethods__["toEntityOne"] = TwoSidesToExtentDefinition._set_toEntityOne
TwoSidesToExtentDefinition.toEntityOne = property(TwoSidesToExtentDefinition._get_toEntityOne, TwoSidesToExtentDefinition._set_toEntityOne, doc="Gets and sets the entity that defines the extent on side one. The valid types of entities can vary depending on\nthe type of feature this is being used with.")

TwoSidesToExtentDefinition.__swig_getmethods__["toEntityTwo"] = TwoSidesToExtentDefinition._get_toEntityTwo
TwoSidesToExtentDefinition.__swig_setmethods__["toEntityTwo"] = TwoSidesToExtentDefinition._set_toEntityTwo
TwoSidesToExtentDefinition.toEntityTwo = property(TwoSidesToExtentDefinition._get_toEntityTwo, TwoSidesToExtentDefinition._set_toEntityTwo, doc="Gets and sets the entity that defines the extent on side two. The valid types of entities can vary depending on\nthe type of feature this is being used with.")

TwoSidesToExtentDefinition.__swig_getmethods__["matchShape"] = TwoSidesToExtentDefinition._get_matchShape
TwoSidesToExtentDefinition.__swig_setmethods__["matchShape"] = TwoSidesToExtentDefinition._set_matchShape
TwoSidesToExtentDefinition.matchShape = property(TwoSidesToExtentDefinition._get_matchShape, TwoSidesToExtentDefinition._set_matchShape, doc="Gets and sets whether the toEntity is extended to fully intersect the extrusion.")

TwoSidesToExtentDefinition.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, TwoSidesToExtentDefinition) else None
TwoSidesToExtentDefinition.cast = lambda arg: arg if isinstance(arg, TwoSidesToExtentDefinition) else None

class UnstitchFeature(Feature):
    """Object that represents an existing Unstitch feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UnstitchFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UnstitchFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::UnstitchFeature *" : return _fusion.UnstitchFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.UnstitchFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.UnstitchFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.UnstitchFeature_classType
    if _newclass:classType = staticmethod(_fusion.UnstitchFeature_classType)
    __swig_destroy__ = _fusion.delete_UnstitchFeature
    __del__ = lambda self : None;
    def setInputFaces(self, *args) -> "bool" :
        """
        Sets the faces and/or bodies to be unstiched 
        faces : The faces and/or bodies to Unstitch. Individual faces can be unstitched from solids and/or patch bodies. 
        The faces being unstitched need not all come from the same body. 
        isChainSelection : A boolean value for setting whether or not faces that are connected and adjacent to 
        the input faces will be included in the selection. The default value is true. 
        Returns true if successful.
        """
        return _fusion.UnstitchFeature_setInputFaces(self, *args)

    def _get_inputFaces(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """Gets the faces that were input to be unstitched."""
        return _fusion.UnstitchFeature__get_inputFaces(self)

    def _get_isChainSelection(self) -> "bool" :
        """
        A boolean value for setting whether or not faces that are connected and adjacent to 
        the input faces will be included in the selection. The default value is true.
        """
        return _fusion.UnstitchFeature__get_isChainSelection(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::UnstitchFeature >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.UnstitchFeature__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::UnstitchFeature >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this is not the NativeObject.
        """
        return _fusion.UnstitchFeature_createForAssemblyContext(self, *args)

    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.UnstitchFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.UnstitchFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.UnstitchFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.UnstitchFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.UnstitchFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.UnstitchFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.UnstitchFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.UnstitchFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.UnstitchFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.UnstitchFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.UnstitchFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.UnstitchFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.UnstitchFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.UnstitchFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.UnstitchFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.UnstitchFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.UnstitchFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.UnstitchFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.UnstitchFeature__get_isValid(self)
UnstitchFeature_swigregister = _fusion.UnstitchFeature_swigregister
UnstitchFeature_swigregister(UnstitchFeature)

def UnstitchFeature_classType() -> "char const *" :
  return _fusion.UnstitchFeature_classType()
UnstitchFeature_classType = _fusion.UnstitchFeature_classType

UnstitchFeature.__swig_getmethods__["inputFaces"] = UnstitchFeature._get_inputFaces
UnstitchFeature.inputFaces = property(UnstitchFeature._get_inputFaces, doc="Gets the faces that were input to be unstitched.")

UnstitchFeature.__swig_getmethods__["isChainSelection"] = UnstitchFeature._get_isChainSelection
UnstitchFeature.isChainSelection = property(UnstitchFeature._get_isChainSelection, doc="A boolean value for setting whether or not faces that are connected and adjacent to\nthe input faces will be included in the selection. The default value is true.")

UnstitchFeature.__swig_getmethods__["nativeObject"] = UnstitchFeature._get_nativeObject
UnstitchFeature.nativeObject = property(UnstitchFeature._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

UnstitchFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, UnstitchFeature) else None
UnstitchFeature.cast = lambda arg: arg if isinstance(arg, UnstitchFeature) else None

class UserParameter(Parameter):
    """Represents a User Parameter."""
    __swig_setmethods__ = {}
    for _s in [Parameter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UserParameter, name, value)
    __swig_getmethods__ = {}
    for _s in [Parameter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UserParameter, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::UserParameter *" : return _fusion.UserParameter___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.UserParameter___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.UserParameter___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.UserParameter_classType
    if _newclass:classType = staticmethod(_fusion.UserParameter_classType)
    __swig_destroy__ = _fusion.delete_UserParameter
    __del__ = lambda self : None;
    def deleteMe(self) -> "bool" :
        """
        Deletes the user parameter
        A parameter can only be deleted if it is a UserParameter and
        it is not referenced by other parameters. 
        Returns a bool indicating if the delete was successful or not.
        Bug!!! Currently returning true if the parameter can't be deleted because it is
        being referenced by other parameters.
        """
        return _fusion.UserParameter_deleteMe(self)

    def _get_userParameters(self) -> "adsk::core::Ptr< adsk::fusion::UserParameters >" :
        """Returns the Collection containing the UserParameter."""
        return _fusion.UserParameter__get_userParameters(self)

    def _get_design(self) -> "adsk::core::Ptr< adsk::fusion::Design >" :
        """Returns the Design containing the UserParameter."""
        return _fusion.UserParameter__get_design(self)

    def _get_value(self) -> "double" :
        """
        Gets and sets the real value (a double) of the parameter in database units. 
        Setting this property will set/reset the expression value for this parameter
        """
        return _fusion.UserParameter__get_value(self)

    def _set_value(self, *args) -> "bool" :
        """
        Gets and sets the real value (a double) of the parameter in database units. 
        Setting this property will set/reset the expression value for this parameter
        """
        return _fusion.UserParameter__set_value(self, *args)

    def _get_expression(self) -> "std::string" :
        """Gets and sets the expression (ie. '22.064 mm') used to calculate the value of the parameter"""
        return _fusion.UserParameter__get_expression(self)

    def _set_expression(self, *args) -> "bool" :
        """Gets and sets the expression (ie. '22.064 mm') used to calculate the value of the parameter"""
        return _fusion.UserParameter__set_expression(self, *args)

    def _get_name(self) -> "std::string" :
        """
        Gets and sets the name of the parameter. Setting the name can fail if the name 
        is not unique with respect to all other parameters in the design.
        """
        return _fusion.UserParameter__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """
        Gets and sets the name of the parameter. Setting the name can fail if the name 
        is not unique with respect to all other parameters in the design.
        """
        return _fusion.UserParameter__set_name(self, *args)

    def _get_unit(self) -> "std::string" :
        """
        The unit type associated with this parameter. An empty string is returned for parameters
        that don't have a unit type.
        """
        return _fusion.UserParameter__get_unit(self)

    def _get_comment(self) -> "std::string" :
        """The comment associated with this parameter"""
        return _fusion.UserParameter__get_comment(self)

    def _set_comment(self, *args) -> "bool" :
        """The comment associated with this parameter"""
        return _fusion.UserParameter__set_comment(self, *args)

    def _get_isFavorite(self) -> "bool" :
        """
        Gets and sets whether this parameter is included in the Favorites list in the
        parameters dialog
        """
        return _fusion.UserParameter__get_isFavorite(self)

    def _set_isFavorite(self, *args) -> "bool" :
        """
        Gets and sets whether this parameter is included in the Favorites list in the
        parameters dialog
        """
        return _fusion.UserParameter__set_isFavorite(self, *args)

    def _get_dependentParameters(self) -> "adsk::core::Ptr< adsk::fusion::ParameterList >" :
        """
        Returns a list of parameters that are dependent on this parameter as a result
        of this parameter being referenced in their equation.
        """
        return _fusion.UserParameter__get_dependentParameters(self)

    def _get_isDeletable(self) -> "bool" :
        """
        Gets if this parameter can be deleted. Parameters that cannot be deleted are: Model Parameters and 
        User Parameters that have dependents.
        """
        return _fusion.UserParameter__get_isDeletable(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.UserParameter__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.UserParameter__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.UserParameter__get_isValid(self)
UserParameter_swigregister = _fusion.UserParameter_swigregister
UserParameter_swigregister(UserParameter)

def UserParameter_classType() -> "char const *" :
  return _fusion.UserParameter_classType()
UserParameter_classType = _fusion.UserParameter_classType

UserParameter.__swig_getmethods__["userParameters"] = UserParameter._get_userParameters
UserParameter.userParameters = property(UserParameter._get_userParameters, doc="Returns the Collection containing the UserParameter.")

UserParameter.__swig_getmethods__["design"] = UserParameter._get_design
UserParameter.design = property(UserParameter._get_design, doc="Returns the Design containing the UserParameter.")

UserParameter.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, UserParameter) else None
UserParameter.cast = lambda arg: arg if isinstance(arg, UserParameter) else None

class VariableRadiusFilletEdgeSet(FilletEdgeSet):
    """Provides access to the edges and the parameters associated with a variable radius fillet."""
    __swig_setmethods__ = {}
    for _s in [FilletEdgeSet]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VariableRadiusFilletEdgeSet, name, value)
    __swig_getmethods__ = {}
    for _s in [FilletEdgeSet]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, VariableRadiusFilletEdgeSet, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::VariableRadiusFilletEdgeSet *" : return _fusion.VariableRadiusFilletEdgeSet___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.VariableRadiusFilletEdgeSet___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.VariableRadiusFilletEdgeSet___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.VariableRadiusFilletEdgeSet_classType
    if _newclass:classType = staticmethod(_fusion.VariableRadiusFilletEdgeSet_classType)
    __swig_destroy__ = _fusion.delete_VariableRadiusFilletEdgeSet
    __del__ = lambda self : None;
    def _get_edges(self) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Gets and sets the edges that will be filleted. In order to access (get) the input edges
        of a fillet, you must roll the timeline back to just before the fillet feature
        whose edges you want to access.
        """
        return _fusion.VariableRadiusFilletEdgeSet__get_edges(self)

    def _set_edges(self, *args) -> "bool" :
        """
        Gets and sets the edges that will be filleted. In order to access (get) the input edges
        of a fillet, you must roll the timeline back to just before the fillet feature
        whose edges you want to access.
        """
        return _fusion.VariableRadiusFilletEdgeSet__set_edges(self, *args)

    def _get_startRadius(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the model parameter that controls the start radius of the fillet. You can edit
        the start radius by using the properties on the returned ModelParameter object.
        """
        return _fusion.VariableRadiusFilletEdgeSet__get_startRadius(self)

    def _get_endRadius(self) -> "adsk::core::Ptr< adsk::fusion::ModelParameter >" :
        """
        Returns the model parameter that controls the end radius of the fillet. You can edit
        the end radius by using the properties on the returned ModelParameter object.
        """
        return _fusion.VariableRadiusFilletEdgeSet__get_endRadius(self)

    def _get_midRadii(self) -> "adsk::core::Ptr< adsk::fusion::ParameterList >" :
        """
        Returns a list of model parameters that control radius of the fillet at each position defined along the edge set.
        You can edit any of these radii by using the properties on its returned ModelParameter object. This list does
        not include the parameters for the start and end radii. Use the startRadius and endRadius properties to get those.
        """
        return _fusion.VariableRadiusFilletEdgeSet__get_midRadii(self)

    def _get_midPositions(self) -> "adsk::core::Ptr< adsk::fusion::ParameterList >" :
        """
        Returns a list of model parameters that control the location of each mid point radius. These positions are defined
        from 0 to 1 where 0 is at the start of the edge and 1 is at the end. You can edit any of these positions by 
        using the properties on its returned ModelParameter object.
        """
        return _fusion.VariableRadiusFilletEdgeSet__get_midPositions(self)

    def addMidPosition(self, *args) -> "bool" :
        """
        Creates a new mid position radius on the variable radius edge set. 
        position : The position where the new radius is to be created. This is a value between 0 and 1 where 0 is at the start of the 
        edge and 1 is at the end. If the ValueInput uses a real then it is interpreted as a unitless value. If it is a string
        then it must resolve to a unitless value. 
        radius : A ValueInput object that defines the radius at the defined position. If the ValueInput uses a real 
        then it is interpreted as centimeters. If it is a string then the units can be defined as part of 
        the string (i.e. '2 in'). If no units are specified it will be interpreted using the current 
        default units for length. 
        Returns true if successful.
        """
        return _fusion.VariableRadiusFilletEdgeSet_addMidPosition(self, *args)

    def deleteMidPosition(self, *args) -> "bool" :
        """
        Deletes the specified mid position from the variable radius fillet. 
        positionIndex : The index of the mid position to delete. The points are in the order they appear along the edge
        where the first point has an index of 0. The number of mid positions and their locations can be
        obtained by getting the list of mid positions using the midPositions property. 
        Returns true if successful.
        """
        return _fusion.VariableRadiusFilletEdgeSet_deleteMidPosition(self, *args)

    def _get_objectType(self) -> "char const *" : return _fusion.VariableRadiusFilletEdgeSet__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.VariableRadiusFilletEdgeSet__get_isValid(self)
VariableRadiusFilletEdgeSet_swigregister = _fusion.VariableRadiusFilletEdgeSet_swigregister
VariableRadiusFilletEdgeSet_swigregister(VariableRadiusFilletEdgeSet)

def VariableRadiusFilletEdgeSet_classType() -> "char const *" :
  return _fusion.VariableRadiusFilletEdgeSet_classType()
VariableRadiusFilletEdgeSet_classType = _fusion.VariableRadiusFilletEdgeSet_classType

VariableRadiusFilletEdgeSet.__swig_getmethods__["edges"] = VariableRadiusFilletEdgeSet._get_edges
VariableRadiusFilletEdgeSet.__swig_setmethods__["edges"] = VariableRadiusFilletEdgeSet._set_edges
VariableRadiusFilletEdgeSet.edges = property(VariableRadiusFilletEdgeSet._get_edges, VariableRadiusFilletEdgeSet._set_edges, doc="Gets and sets the edges that will be filleted. In order to access (get) the input edges\nof a fillet, you must roll the timeline back to just before the fillet feature\nwhose edges you want to access.")

VariableRadiusFilletEdgeSet.__swig_getmethods__["startRadius"] = VariableRadiusFilletEdgeSet._get_startRadius
VariableRadiusFilletEdgeSet.startRadius = property(VariableRadiusFilletEdgeSet._get_startRadius, doc="Returns the model parameter that controls the start radius of the fillet. You can edit\nthe start radius by using the properties on the returned ModelParameter object.")

VariableRadiusFilletEdgeSet.__swig_getmethods__["endRadius"] = VariableRadiusFilletEdgeSet._get_endRadius
VariableRadiusFilletEdgeSet.endRadius = property(VariableRadiusFilletEdgeSet._get_endRadius, doc="Returns the model parameter that controls the end radius of the fillet. You can edit\nthe end radius by using the properties on the returned ModelParameter object.")

VariableRadiusFilletEdgeSet.__swig_getmethods__["midRadii"] = VariableRadiusFilletEdgeSet._get_midRadii
VariableRadiusFilletEdgeSet.midRadii = property(VariableRadiusFilletEdgeSet._get_midRadii, doc="Returns a list of model parameters that control radius of the fillet at each position defined along the edge set.\nYou can edit any of these radii by using the properties on its returned ModelParameter object. This list does\nnot include the parameters for the start and end radii. Use the startRadius and endRadius properties to get those.")

VariableRadiusFilletEdgeSet.__swig_getmethods__["midPositions"] = VariableRadiusFilletEdgeSet._get_midPositions
VariableRadiusFilletEdgeSet.midPositions = property(VariableRadiusFilletEdgeSet._get_midPositions, doc="Returns a list of model parameters that control the location of each mid point radius. These positions are defined\nfrom 0 to 1 where 0 is at the start of the edge and 1 is at the end. You can edit any of these positions by\nusing the properties on its returned ModelParameter object.")

VariableRadiusFilletEdgeSet.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, VariableRadiusFilletEdgeSet) else None
VariableRadiusFilletEdgeSet.cast = lambda arg: arg if isinstance(arg, VariableRadiusFilletEdgeSet) else None

class VerticalConstraint(GeometricConstraint):
    """A vertical constraint in a sketch."""
    __swig_setmethods__ = {}
    for _s in [GeometricConstraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VerticalConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricConstraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, VerticalConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::VerticalConstraint *" : return _fusion.VerticalConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.VerticalConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.VerticalConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.VerticalConstraint_classType
    if _newclass:classType = staticmethod(_fusion.VerticalConstraint_classType)
    __swig_destroy__ = _fusion.delete_VerticalConstraint
    __del__ = lambda self : None;
    def _get_line(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """Returns the line being constrained."""
        return _fusion.VerticalConstraint__get_line(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::VerticalConstraint >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.VerticalConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::VerticalConstraint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.VerticalConstraint_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.VerticalConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.VerticalConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.VerticalConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.VerticalConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.VerticalConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.VerticalConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.VerticalConstraint__get_isValid(self)
VerticalConstraint_swigregister = _fusion.VerticalConstraint_swigregister
VerticalConstraint_swigregister(VerticalConstraint)

def VerticalConstraint_classType() -> "char const *" :
  return _fusion.VerticalConstraint_classType()
VerticalConstraint_classType = _fusion.VerticalConstraint_classType

VerticalConstraint.__swig_getmethods__["line"] = VerticalConstraint._get_line
VerticalConstraint.line = property(VerticalConstraint._get_line, doc="Returns the line being constrained.")

VerticalConstraint.__swig_getmethods__["nativeObject"] = VerticalConstraint._get_nativeObject
VerticalConstraint.nativeObject = property(VerticalConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

VerticalConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, VerticalConstraint) else None
VerticalConstraint.cast = lambda arg: arg if isinstance(arg, VerticalConstraint) else None

class VerticalPointsConstraint(GeometricConstraint):
    """A vertical constraint between two points in a sketch."""
    __swig_setmethods__ = {}
    for _s in [GeometricConstraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VerticalPointsConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [GeometricConstraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, VerticalPointsConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::VerticalPointsConstraint *" : return _fusion.VerticalPointsConstraint___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.VerticalPointsConstraint___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.VerticalPointsConstraint___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.VerticalPointsConstraint_classType
    if _newclass:classType = staticmethod(_fusion.VerticalPointsConstraint_classType)
    __swig_destroy__ = _fusion.delete_VerticalPointsConstraint
    __del__ = lambda self : None;
    def _get_pointOne(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """Returns the first point."""
        return _fusion.VerticalPointsConstraint__get_pointOne(self)

    def _get_pointTwo(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """Returns the second point."""
        return _fusion.VerticalPointsConstraint__get_pointTwo(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::VerticalPointsConstraint >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.VerticalPointsConstraint__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::VerticalPointsConstraint >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.VerticalPointsConstraint_createForAssemblyContext(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes this constraint. The IsDeletable property can be used to determine if this 
        constraint can be deleted. 
        Returns true if the delete was successful.
        """
        return _fusion.VerticalPointsConstraint_deleteMe(self)

    def _get_isDeletable(self) -> "bool" :
        """Indicates if this constraint is deletable."""
        return _fusion.VerticalPointsConstraint__get_isDeletable(self)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch object."""
        return _fusion.VerticalPointsConstraint__get_parentSketch(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.VerticalPointsConstraint__get_assemblyContext(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this geometric constraint."""
        return _fusion.VerticalPointsConstraint__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.VerticalPointsConstraint__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.VerticalPointsConstraint__get_isValid(self)
VerticalPointsConstraint_swigregister = _fusion.VerticalPointsConstraint_swigregister
VerticalPointsConstraint_swigregister(VerticalPointsConstraint)

def VerticalPointsConstraint_classType() -> "char const *" :
  return _fusion.VerticalPointsConstraint_classType()
VerticalPointsConstraint_classType = _fusion.VerticalPointsConstraint_classType

VerticalPointsConstraint.__swig_getmethods__["pointOne"] = VerticalPointsConstraint._get_pointOne
VerticalPointsConstraint.pointOne = property(VerticalPointsConstraint._get_pointOne, doc="Returns the first point.")

VerticalPointsConstraint.__swig_getmethods__["pointTwo"] = VerticalPointsConstraint._get_pointTwo
VerticalPointsConstraint.pointTwo = property(VerticalPointsConstraint._get_pointTwo, doc="Returns the second point.")

VerticalPointsConstraint.__swig_getmethods__["nativeObject"] = VerticalPointsConstraint._get_nativeObject
VerticalPointsConstraint.nativeObject = property(VerticalPointsConstraint._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

VerticalPointsConstraint.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, VerticalPointsConstraint) else None
VerticalPointsConstraint.cast = lambda arg: arg if isinstance(arg, VerticalPointsConstraint) else None

class WebFeature(Feature):
    """Object that represents an existing web feature in a design."""
    __swig_setmethods__ = {}
    for _s in [Feature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WebFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [Feature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WebFeature, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::WebFeature *" : return _fusion.WebFeature___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.WebFeature___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.WebFeature___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.WebFeature_classType
    if _newclass:classType = staticmethod(_fusion.WebFeature_classType)
    __swig_destroy__ = _fusion.delete_WebFeature
    __del__ = lambda self : None;
    def _get_name(self) -> "std::string" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.WebFeature__get_name(self)

    def _set_name(self, *args) -> "bool" :
        """Returns the name of the feature as seen in the browser (non-parametric) or in the timeline (parametric)."""
        return _fusion.WebFeature__set_name(self, *args)

    def deleteMe(self) -> "bool" :
        """
        Deletes the feature.
        This works for both parametric and non-parametric features. 
        Returns a bool indicating if the delete was successful or not.
        """
        return _fusion.WebFeature_deleteMe(self)

    def dissolve(self) -> "bool" :
        """
        Dissolves the feature so that the feature information is lost
        and only the B-Rep geometry defined by the feature remains.
        This is only valid for non-parametric features. 
        Returns a bool indicating if the dissolve was successful or not.
        """
        return _fusion.WebFeature_dissolve(self)

    def _get_isSuppressed(self) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.WebFeature__get_isSuppressed(self)

    def _set_isSuppressed(self, *args) -> "bool" :
        """
        Gets and sets if this feature is suppressed. This is only valid
        for parametric features.
        """
        return _fusion.WebFeature__set_isSuppressed(self, *args)

    def _get_isParametric(self) -> "bool" :
        """Indicates if this feature is parametric or not."""
        return _fusion.WebFeature__get_isParametric(self)

    def _get_faces(self) -> "adsk::core::Ptr< adsk::fusion::BRepFaces >" :
        """
        Returns the faces that were created by this feature. 
        This works for both parametric and non-parametric features.
        """
        return _fusion.WebFeature__get_faces(self)

    def _get_parentComponent(self) -> "adsk::core::Ptr< adsk::fusion::Component >" :
        """Returns the parent component that owns this feature."""
        return _fusion.WebFeature__get_parentComponent(self)

    def _get_linkedFeatures(self) -> "adsk::core::Ptr< adsk::fusion::FeatureList >" :
        """
        Returns the set of features that are linked to this feature. The set of linked features
        are all of the features that were created in various components as the result of a 
        single feature being created in the user interface.
        """
        return _fusion.WebFeature__get_linkedFeatures(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.WebFeature__get_assemblyContext(self)

    def _get_timelineObject(self) -> "adsk::core::Ptr< adsk::fusion::TimelineObject >" :
        """Returns the timeline object associated with this feature."""
        return _fusion.WebFeature__get_timelineObject(self)

    def _get_bodies(self) -> "adsk::core::Ptr< adsk::fusion::BRepBodies >" :
        """
        Returns the bodies that were modified or created by this feature. 
        This works for both parametric and non-parametric features. For a BaseFeature
        this returns the bodies that are owned by the base feature.
        """
        return _fusion.WebFeature__get_bodies(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.WebFeature__get_attributes(self)

    def _get_baseFeature(self) -> "adsk::core::Ptr< adsk::fusion::BaseFeature >" :
        """
        If this feature is associated with a base feature, this property will return that base feature.
        If it's not associated with a base feature, this property will return null.
        """
        return _fusion.WebFeature__get_baseFeature(self)

    def _get_healthState(self) -> "adsk::fusion::FeatureHealthStates" :
        """Returns the current health state of the feature."""
        return _fusion.WebFeature__get_healthState(self)

    def _get_errorOrWarningMessage(self) -> "std::string" :
        """
        Returns the error or warning message in the case where the healthState property returns either
        WarningFeatureHealthState or ErrorFeatureHealthState. Otherwise this property returns an empty string.
        """
        return _fusion.WebFeature__get_errorOrWarningMessage(self)

    def _get_objectType(self) -> "char const *" : return _fusion.WebFeature__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.WebFeature__get_isValid(self)
WebFeature_swigregister = _fusion.WebFeature_swigregister
WebFeature_swigregister(WebFeature)

def WebFeature_classType() -> "char const *" :
  return _fusion.WebFeature_classType()
WebFeature_classType = _fusion.WebFeature_classType

WebFeature.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, WebFeature) else None
WebFeature.cast = lambda arg: arg if isinstance(arg, WebFeature) else None

class SketchArc(SketchCurve):
    """An arc in a sketch."""
    __swig_setmethods__ = {}
    for _s in [SketchCurve]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchArc, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchCurve]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchArc, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchArc *" : return _fusion.SketchArc___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchArc___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchArc___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchArc_classType
    if _newclass:classType = staticmethod(_fusion.SketchArc_classType)
    __swig_destroy__ = _fusion.delete_SketchArc
    __del__ = lambda self : None;
    def _get_centerSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """
        The sketch point at the center of the arc. The arc is dependent on this point and moving the
        point will cause the arc to adjust.
        """
        return _fusion.SketchArc__get_centerSketchPoint(self)

    def _get_startSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """
        The sketch point at the start of the arc. The arc is dependent on this point and moving the
        point will cause the arc to adjust.
        """
        return _fusion.SketchArc__get_startSketchPoint(self)

    def _get_endSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """
        The sketch point at the end of the arc. The arc is dependent on this point and moving the
        point will cause the arc to adjust.
        """
        return _fusion.SketchArc__get_endSketchPoint(self)

    def _get_radius(self) -> "double" :
        """
        Gets and sets the radius of the arc. Changing the radius is limited
        by any constraints that might exist on the circle. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchArc__get_radius(self)

    def _set_radius(self, *args) -> "bool" :
        """
        Gets and sets the radius of the arc. Changing the radius is limited
        by any constraints that might exist on the circle. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchArc__set_radius(self, *args)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Arc3D >" :
        """
        Returns the transient geometry of the arc which provides geometric
        information about the arc. The returned geometry is always in sketch space.
        """
        return _fusion.SketchArc__get_geometry(self)

    def _get_worldGeometry(self) -> "adsk::core::Ptr< adsk::core::Arc3D >" :
        """
        Returns an Arc3D object which provides geometric information in world space.
        The returned geometry takes into account the assembly context and the position of the
        sketch in it's parent component, which means the geometry will be returned in the root
        component space.
        """
        return _fusion.SketchArc__get_worldGeometry(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchArc >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchArc__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchArc >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchArc_createForAssemblyContext(self, *args)

    def _get_length(self) -> "double" :
        """Returns the length of the curve in centimeters."""
        return _fusion.SketchArc__get_length(self)

    def _get_isConstruction(self) -> "bool" :
        """Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchArc__get_isConstruction(self)

    def _set_isConstruction(self, *args) -> "bool" :
        """Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchArc__set_isConstruction(self, *args)

    def split(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Split a curve at a position specified along the curve 
        splitPoint : A position (transient Point3D) on the curve that defines the point at which to split the curve 
        createConstraints : Constraints are created by default. Specify false to create no constraints. 
        Returns the resulting 2 curves; the original curve + the newly created curve
        When split spline the original is deleted and two new curves returned.
        Empty collection returned if curve is closed.
        """
        return _fusion.SketchArc_split(self, *args)

    def trim(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Trim a curve by specifying a point that determines the segment of the curve to trim away 
        segmentPoint : A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
        The segment of the curve closest to the segmentPoint gets removed 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
        When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
        When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
        Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
        Trimming a curve having no intersections deletes the original and returns an empty collection
        """
        return _fusion.SketchArc_trim(self, *args)

    def breakCurve(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
        sketch and splitting this curve at the nearest intersections to a specified point on the curve. 
        segmentPoint : A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
        intersection(s) to this point define the break location(s). 
        createConstraints : Optional argument that specifies if constraints should be created between the new curve segments. A value of
        true indicates constraints will be created. 
        All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
        are found and as a result the curve is not broken, an empty ObjectCollection is returned.
        """
        return _fusion.SketchArc_breakCurve(self, *args)

    def extend(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Extend a curve by specifying a point that determines the end of the curve to extend 
        endPoint : A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
        The end of the curve closest to the endPoint gets extended 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        Returns the modified original curve if the start or end of the curve is extended
        If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
        If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
        """
        return _fusion.SketchArc_extend(self, *args)

    def intersections(self, *args) -> "bool" :
        """
        Get the curves that intersect this curve along with the intersection points (Point2D) 
        sketchCurves : A collection of curves to attempt to find intersections with. 
        Set the value of this parameter to null to use all curves in the sketch for the calculation. 
        intersectingCurves : A collection of the actual intersecting curves 
        intersectionPoints : A collection of intersection points (Point3D)
        Item numbers in this collection correspond to the item numbers in the intersectingCurves collection. 
        Returns true if intersections are found
        """
        return _fusion.SketchArc_intersections(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch."""
        return _fusion.SketchArc__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >" :
        """Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchArc__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >" :
        """Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchArc__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool" :
        """Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchArc__get_is2D(self)

    def _get_isReference(self) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchArc__get_isReference(self)

    def _set_isReference(self, *args) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchArc__set_isReference(self, *args)

    def _get_isFixed(self) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchArc__get_isFixed(self)

    def _set_isFixed(self, *args) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchArc__set_isFixed(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchArc__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchArc__get_boundingBox(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchArc_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchArc__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchArc__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool" :
        """
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchArc__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool" :
        """Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchArc__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.SketchArc__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchArc__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchArc__get_isValid(self)
SketchArc_swigregister = _fusion.SketchArc_swigregister
SketchArc_swigregister(SketchArc)

def SketchArc_classType() -> "char const *" :
  return _fusion.SketchArc_classType()
SketchArc_classType = _fusion.SketchArc_classType

SketchArc.__swig_getmethods__["centerSketchPoint"] = SketchArc._get_centerSketchPoint
SketchArc.centerSketchPoint = property(SketchArc._get_centerSketchPoint, doc="The sketch point at the center of the arc. The arc is dependent on this point and moving the\npoint will cause the arc to adjust.")

SketchArc.__swig_getmethods__["startSketchPoint"] = SketchArc._get_startSketchPoint
SketchArc.startSketchPoint = property(SketchArc._get_startSketchPoint, doc="The sketch point at the start of the arc. The arc is dependent on this point and moving the\npoint will cause the arc to adjust.")

SketchArc.__swig_getmethods__["endSketchPoint"] = SketchArc._get_endSketchPoint
SketchArc.endSketchPoint = property(SketchArc._get_endSketchPoint, doc="The sketch point at the end of the arc. The arc is dependent on this point and moving the\npoint will cause the arc to adjust.")

SketchArc.__swig_getmethods__["radius"] = SketchArc._get_radius
SketchArc.__swig_setmethods__["radius"] = SketchArc._set_radius
SketchArc.radius = property(SketchArc._get_radius, SketchArc._set_radius, doc="Gets and sets the radius of the arc. Changing the radius is limited\nby any constraints that might exist on the circle. Setting the radius\ncan fail in cases where the radius is fully defined through constraints.")

SketchArc.__swig_getmethods__["geometry"] = SketchArc._get_geometry
SketchArc.geometry = property(SketchArc._get_geometry, doc="Returns the transient geometry of the arc which provides geometric\ninformation about the arc. The returned geometry is always in sketch space.")

SketchArc.__swig_getmethods__["worldGeometry"] = SketchArc._get_worldGeometry
SketchArc.worldGeometry = property(SketchArc._get_worldGeometry, doc="Returns an Arc3D object which provides geometric information in world space.\nThe returned geometry takes into account the assembly context and the position of the\nsketch in it's parent component, which means the geometry will be returned in the root\ncomponent space.")

SketchArc.__swig_getmethods__["nativeObject"] = SketchArc._get_nativeObject
SketchArc.nativeObject = property(SketchArc._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SketchArc.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchArc) else None
SketchArc.cast = lambda arg: arg if isinstance(arg, SketchArc) else None

class SketchCircle(SketchCurve):
    """A circle in a sketch."""
    __swig_setmethods__ = {}
    for _s in [SketchCurve]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchCircle, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchCurve]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchCircle, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchCircle *" : return _fusion.SketchCircle___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchCircle___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchCircle___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchCircle_classType
    if _newclass:classType = staticmethod(_fusion.SketchCircle_classType)
    __swig_destroy__ = _fusion.delete_SketchCircle
    __del__ = lambda self : None;
    def _get_centerSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """Returns the sketch point at the center of the circle."""
        return _fusion.SketchCircle__get_centerSketchPoint(self)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Circle3D >" :
        """
        Returns the transient geometry of the circle which provides geometric
        information about the circle. The returned geometry is always in sketch space.
        """
        return _fusion.SketchCircle__get_geometry(self)

    def _get_worldGeometry(self) -> "adsk::core::Ptr< adsk::core::Circle3D >" :
        """
        Returns a Point3D object which provides the position of the sketch point in world space.
        The returned coordinate takes into account the assembly context and the position of the
        sketch in it's parent component, which means the coordinate will be returned in the root
        component space.
        """
        return _fusion.SketchCircle__get_worldGeometry(self)

    def _get_area(self) -> "double" :
        """Returns the area of the circle in square centimeters."""
        return _fusion.SketchCircle__get_area(self)

    def _get_radius(self) -> "double" :
        """
        Gets and sets the radius of the circle. Changing the radius is limited
        by any constraints that might exist on the circle.
        """
        return _fusion.SketchCircle__get_radius(self)

    def _set_radius(self, *args) -> "bool" :
        """
        Gets and sets the radius of the circle. Changing the radius is limited
        by any constraints that might exist on the circle.
        """
        return _fusion.SketchCircle__set_radius(self, *args)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchCircle >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchCircle__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchCircle >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchCircle_createForAssemblyContext(self, *args)

    def _get_length(self) -> "double" :
        """Returns the length of the curve in centimeters."""
        return _fusion.SketchCircle__get_length(self)

    def _get_isConstruction(self) -> "bool" :
        """Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchCircle__get_isConstruction(self)

    def _set_isConstruction(self, *args) -> "bool" :
        """Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchCircle__set_isConstruction(self, *args)

    def split(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Split a curve at a position specified along the curve 
        splitPoint : A position (transient Point3D) on the curve that defines the point at which to split the curve 
        createConstraints : Constraints are created by default. Specify false to create no constraints. 
        Returns the resulting 2 curves; the original curve + the newly created curve
        When split spline the original is deleted and two new curves returned.
        Empty collection returned if curve is closed.
        """
        return _fusion.SketchCircle_split(self, *args)

    def trim(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Trim a curve by specifying a point that determines the segment of the curve to trim away 
        segmentPoint : A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
        The segment of the curve closest to the segmentPoint gets removed 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
        When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
        When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
        Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
        Trimming a curve having no intersections deletes the original and returns an empty collection
        """
        return _fusion.SketchCircle_trim(self, *args)

    def breakCurve(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
        sketch and splitting this curve at the nearest intersections to a specified point on the curve. 
        segmentPoint : A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
        intersection(s) to this point define the break location(s). 
        createConstraints : Optional argument that specifies if constraints should be created between the new curve segments. A value of
        true indicates constraints will be created. 
        All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
        are found and as a result the curve is not broken, an empty ObjectCollection is returned.
        """
        return _fusion.SketchCircle_breakCurve(self, *args)

    def extend(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Extend a curve by specifying a point that determines the end of the curve to extend 
        endPoint : A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
        The end of the curve closest to the endPoint gets extended 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        Returns the modified original curve if the start or end of the curve is extended
        If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
        If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
        """
        return _fusion.SketchCircle_extend(self, *args)

    def intersections(self, *args) -> "bool" :
        """
        Get the curves that intersect this curve along with the intersection points (Point2D) 
        sketchCurves : A collection of curves to attempt to find intersections with. 
        Set the value of this parameter to null to use all curves in the sketch for the calculation. 
        intersectingCurves : A collection of the actual intersecting curves 
        intersectionPoints : A collection of intersection points (Point3D)
        Item numbers in this collection correspond to the item numbers in the intersectingCurves collection. 
        Returns true if intersections are found
        """
        return _fusion.SketchCircle_intersections(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch."""
        return _fusion.SketchCircle__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >" :
        """Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchCircle__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >" :
        """Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchCircle__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool" :
        """Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchCircle__get_is2D(self)

    def _get_isReference(self) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchCircle__get_isReference(self)

    def _set_isReference(self, *args) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchCircle__set_isReference(self, *args)

    def _get_isFixed(self) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchCircle__get_isFixed(self)

    def _set_isFixed(self, *args) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchCircle__set_isFixed(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchCircle__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchCircle__get_boundingBox(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchCircle_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchCircle__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchCircle__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool" :
        """
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchCircle__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool" :
        """Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchCircle__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.SketchCircle__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchCircle__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchCircle__get_isValid(self)
SketchCircle_swigregister = _fusion.SketchCircle_swigregister
SketchCircle_swigregister(SketchCircle)

def SketchCircle_classType() -> "char const *" :
  return _fusion.SketchCircle_classType()
SketchCircle_classType = _fusion.SketchCircle_classType

SketchCircle.__swig_getmethods__["centerSketchPoint"] = SketchCircle._get_centerSketchPoint
SketchCircle.centerSketchPoint = property(SketchCircle._get_centerSketchPoint, doc="Returns the sketch point at the center of the circle.")

SketchCircle.__swig_getmethods__["geometry"] = SketchCircle._get_geometry
SketchCircle.geometry = property(SketchCircle._get_geometry, doc="Returns the transient geometry of the circle which provides geometric\ninformation about the circle. The returned geometry is always in sketch space.")

SketchCircle.__swig_getmethods__["worldGeometry"] = SketchCircle._get_worldGeometry
SketchCircle.worldGeometry = property(SketchCircle._get_worldGeometry, doc="Returns a Point3D object which provides the position of the sketch point in world space.\nThe returned coordinate takes into account the assembly context and the position of the\nsketch in it's parent component, which means the coordinate will be returned in the root\ncomponent space.")

SketchCircle.__swig_getmethods__["area"] = SketchCircle._get_area
SketchCircle.area = property(SketchCircle._get_area, doc="Returns the area of the circle in square centimeters.")

SketchCircle.__swig_getmethods__["radius"] = SketchCircle._get_radius
SketchCircle.__swig_setmethods__["radius"] = SketchCircle._set_radius
SketchCircle.radius = property(SketchCircle._get_radius, SketchCircle._set_radius, doc="Gets and sets the radius of the circle. Changing the radius is limited\nby any constraints that might exist on the circle.")

SketchCircle.__swig_getmethods__["nativeObject"] = SketchCircle._get_nativeObject
SketchCircle.nativeObject = property(SketchCircle._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SketchCircle.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchCircle) else None
SketchCircle.cast = lambda arg: arg if isinstance(arg, SketchCircle) else None

class SketchConicCurve(SketchCurve):
    """The SketchConicCurve class represents conic curves in a sketch."""
    __swig_setmethods__ = {}
    for _s in [SketchCurve]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchConicCurve, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchCurve]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchConicCurve, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchConicCurve *" : return _fusion.SketchConicCurve___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchConicCurve___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchConicCurve___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchConicCurve_classType
    if _newclass:classType = staticmethod(_fusion.SketchConicCurve_classType)
    __swig_destroy__ = _fusion.delete_SketchConicCurve
    __del__ = lambda self : None;
    def _get_startSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """The sketch point at the start of the curve."""
        return _fusion.SketchConicCurve__get_startSketchPoint(self)

    def _get_endSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """The sketch point at the end of the curve."""
        return _fusion.SketchConicCurve__get_endSketchPoint(self)

    def _get_apexSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """The sketch point at the apex of the conic curve."""
        return _fusion.SketchConicCurve__get_apexSketchPoint(self)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >" :
        """
        Returns the transient geometry of the curve which provides geometric
        information about the curve. The returned geometry is always in sketch space.
        Because the fixed spline can be analytically defined, for example it
        can be the precise intersection of a surface and the sketch plane,
        returning a NURBS curve that represents the spline may be an 
        approximation of the actual curve. You can use the Evaluator
        property of the SketchFixedSpline object to perform evaluations
        on the precise curve.
        """
        return _fusion.SketchConicCurve__get_geometry(self)

    def _get_worldGeometry(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >" :
        """
        Returns a NurbsCurve3D object that is the equivalent of this sketch curve 
        but is in the space of the parent component rather than in sketch space.
        """
        return _fusion.SketchConicCurve__get_worldGeometry(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >" :
        """
        Returns an evaluator object that lets you perform evaluations
        on the precise geometry of the curve.
        """
        return _fusion.SketchConicCurve__get_evaluator(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchConicCurve >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchConicCurve__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchConicCurve >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchConicCurve_createForAssemblyContext(self, *args)

    def _get_length(self) -> "double" :
        """Returns the length of the curve in centimeters."""
        return _fusion.SketchConicCurve__get_length(self)

    def _get_isConstruction(self) -> "bool" :
        """Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchConicCurve__get_isConstruction(self)

    def _set_isConstruction(self, *args) -> "bool" :
        """Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchConicCurve__set_isConstruction(self, *args)

    def split(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Split a curve at a position specified along the curve 
        splitPoint : A position (transient Point3D) on the curve that defines the point at which to split the curve 
        createConstraints : Constraints are created by default. Specify false to create no constraints. 
        Returns the resulting 2 curves; the original curve + the newly created curve
        When split spline the original is deleted and two new curves returned.
        Empty collection returned if curve is closed.
        """
        return _fusion.SketchConicCurve_split(self, *args)

    def trim(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Trim a curve by specifying a point that determines the segment of the curve to trim away 
        segmentPoint : A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
        The segment of the curve closest to the segmentPoint gets removed 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
        When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
        When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
        Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
        Trimming a curve having no intersections deletes the original and returns an empty collection
        """
        return _fusion.SketchConicCurve_trim(self, *args)

    def breakCurve(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
        sketch and splitting this curve at the nearest intersections to a specified point on the curve. 
        segmentPoint : A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
        intersection(s) to this point define the break location(s). 
        createConstraints : Optional argument that specifies if constraints should be created between the new curve segments. A value of
        true indicates constraints will be created. 
        All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
        are found and as a result the curve is not broken, an empty ObjectCollection is returned.
        """
        return _fusion.SketchConicCurve_breakCurve(self, *args)

    def extend(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Extend a curve by specifying a point that determines the end of the curve to extend 
        endPoint : A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
        The end of the curve closest to the endPoint gets extended 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        Returns the modified original curve if the start or end of the curve is extended
        If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
        If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
        """
        return _fusion.SketchConicCurve_extend(self, *args)

    def intersections(self, *args) -> "bool" :
        """
        Get the curves that intersect this curve along with the intersection points (Point2D) 
        sketchCurves : A collection of curves to attempt to find intersections with. 
        Set the value of this parameter to null to use all curves in the sketch for the calculation. 
        intersectingCurves : A collection of the actual intersecting curves 
        intersectionPoints : A collection of intersection points (Point3D)
        Item numbers in this collection correspond to the item numbers in the intersectingCurves collection. 
        Returns true if intersections are found
        """
        return _fusion.SketchConicCurve_intersections(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch."""
        return _fusion.SketchConicCurve__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >" :
        """Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchConicCurve__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >" :
        """Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchConicCurve__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool" :
        """Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchConicCurve__get_is2D(self)

    def _get_isReference(self) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchConicCurve__get_isReference(self)

    def _set_isReference(self, *args) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchConicCurve__set_isReference(self, *args)

    def _get_isFixed(self) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchConicCurve__get_isFixed(self)

    def _set_isFixed(self, *args) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchConicCurve__set_isFixed(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchConicCurve__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchConicCurve__get_boundingBox(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchConicCurve_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchConicCurve__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchConicCurve__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool" :
        """
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchConicCurve__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool" :
        """Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchConicCurve__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.SketchConicCurve__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchConicCurve__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchConicCurve__get_isValid(self)
SketchConicCurve_swigregister = _fusion.SketchConicCurve_swigregister
SketchConicCurve_swigregister(SketchConicCurve)

def SketchConicCurve_classType() -> "char const *" :
  return _fusion.SketchConicCurve_classType()
SketchConicCurve_classType = _fusion.SketchConicCurve_classType

SketchConicCurve.__swig_getmethods__["startSketchPoint"] = SketchConicCurve._get_startSketchPoint
SketchConicCurve.startSketchPoint = property(SketchConicCurve._get_startSketchPoint, doc="The sketch point at the start of the curve.")

SketchConicCurve.__swig_getmethods__["endSketchPoint"] = SketchConicCurve._get_endSketchPoint
SketchConicCurve.endSketchPoint = property(SketchConicCurve._get_endSketchPoint, doc="The sketch point at the end of the curve.")

SketchConicCurve.__swig_getmethods__["apexSketchPoint"] = SketchConicCurve._get_apexSketchPoint
SketchConicCurve.apexSketchPoint = property(SketchConicCurve._get_apexSketchPoint, doc="The sketch point at the apex of the conic curve.")

SketchConicCurve.__swig_getmethods__["geometry"] = SketchConicCurve._get_geometry
SketchConicCurve.geometry = property(SketchConicCurve._get_geometry, doc="Returns the transient geometry of the curve which provides geometric\ninformation about the curve. The returned geometry is always in sketch space.\nBecause the fixed spline can be analytically defined, for example it\ncan be the precise intersection of a surface and the sketch plane,\nreturning a NURBS curve that represents the spline may be an\napproximation of the actual curve. You can use the Evaluator\nproperty of the SketchFixedSpline object to perform evaluations\non the precise curve.")

SketchConicCurve.__swig_getmethods__["worldGeometry"] = SketchConicCurve._get_worldGeometry
SketchConicCurve.worldGeometry = property(SketchConicCurve._get_worldGeometry, doc="Returns a NurbsCurve3D object that is the equivalent of this sketch curve\nbut is in the space of the parent component rather than in sketch space.")

SketchConicCurve.__swig_getmethods__["evaluator"] = SketchConicCurve._get_evaluator
SketchConicCurve.evaluator = property(SketchConicCurve._get_evaluator, doc="Returns an evaluator object that lets you perform evaluations\non the precise geometry of the curve.")

SketchConicCurve.__swig_getmethods__["nativeObject"] = SketchConicCurve._get_nativeObject
SketchConicCurve.nativeObject = property(SketchConicCurve._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SketchConicCurve.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchConicCurve) else None
SketchConicCurve.cast = lambda arg: arg if isinstance(arg, SketchConicCurve) else None

class SketchEllipse(SketchCurve):
    """An ellipse in a sketch."""
    __swig_setmethods__ = {}
    for _s in [SketchCurve]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchEllipse, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchCurve]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchEllipse, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchEllipse *" : return _fusion.SketchEllipse___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchEllipse___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchEllipse___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchEllipse_classType
    if _newclass:classType = staticmethod(_fusion.SketchEllipse_classType)
    __swig_destroy__ = _fusion.delete_SketchEllipse
    __del__ = lambda self : None;
    def _get_centerSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """
        Returns the sketch point that defines the center of the ellipse. You can
        reposition the ellipse by moving the sketch point, assuming any existing
        constraints allow the desired change.
        """
        return _fusion.SketchEllipse__get_centerSketchPoint(self)

    def _get_majorAxis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Gets and sets the major axis direction of the ellipse. Changing the axis is 
        limited by any constraints that might exist on the ellipse. Setting the axis
        can fail in cases where the direction is fully defined through constraints.
        """
        return _fusion.SketchEllipse__get_majorAxis(self)

    def _set_majorAxis(self, *args) -> "bool" :
        """
        Gets and sets the major axis direction of the ellipse. Changing the axis is 
        limited by any constraints that might exist on the ellipse. Setting the axis
        can fail in cases where the direction is fully defined through constraints.
        """
        return _fusion.SketchEllipse__set_majorAxis(self, *args)

    def _get_majorAxisRadius(self) -> "double" :
        """
        Gets and sets the major axis radius of the ellipse. Changing the radius is 
        limited by any constraints that might exist on the ellipse. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchEllipse__get_majorAxisRadius(self)

    def _set_majorAxisRadius(self, *args) -> "bool" :
        """
        Gets and sets the major axis radius of the ellipse. Changing the radius is 
        limited by any constraints that might exist on the ellipse. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchEllipse__set_majorAxisRadius(self, *args)

    def _get_minorAxisRadius(self) -> "double" :
        """
        Gets and sets the minor axis radius of the ellipse. Changing the radius is 
        limited by any constraints that might exist on the ellipse. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchEllipse__get_minorAxisRadius(self)

    def _set_minorAxisRadius(self, *args) -> "bool" :
        """
        Gets and sets the minor axis radius of the ellipse. Changing the radius is 
        limited by any constraints that might exist on the ellipse. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchEllipse__set_minorAxisRadius(self, *args)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Ellipse3D >" :
        """
        Returns the transient geometry of the ellipse which provides geometric
        information about the ellipse. The returned geometry is always in sketch space.
        """
        return _fusion.SketchEllipse__get_geometry(self)

    def _get_worldGeometry(self) -> "adsk::core::Ptr< adsk::core::Ellipse3D >" :
        """
        Returns an Ellipse3D object which provides geometric information in world space.
        The returned geometry takes into account the assembly context and the position of the
        sketch in it's parent component, which means the geometry will be returned in the root
        component space.
        """
        return _fusion.SketchEllipse__get_worldGeometry(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchEllipse >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchEllipse__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchEllipse >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchEllipse_createForAssemblyContext(self, *args)

    def _get_majorAxisLine(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """
        Returns the sketch line associated with the ellipse that lies along the major axis.
        This can return null in the case where the line has been deleted.
        """
        return _fusion.SketchEllipse__get_majorAxisLine(self)

    def _get_minorAxisLine(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """
        Returns the sketch line associated with the ellipse that lies along the minor axis.
        This can return null in the case where the line has been deleted.
        """
        return _fusion.SketchEllipse__get_minorAxisLine(self)

    def _get_length(self) -> "double" :
        """Returns the length of the curve in centimeters."""
        return _fusion.SketchEllipse__get_length(self)

    def _get_isConstruction(self) -> "bool" :
        """Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchEllipse__get_isConstruction(self)

    def _set_isConstruction(self, *args) -> "bool" :
        """Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchEllipse__set_isConstruction(self, *args)

    def split(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Split a curve at a position specified along the curve 
        splitPoint : A position (transient Point3D) on the curve that defines the point at which to split the curve 
        createConstraints : Constraints are created by default. Specify false to create no constraints. 
        Returns the resulting 2 curves; the original curve + the newly created curve
        When split spline the original is deleted and two new curves returned.
        Empty collection returned if curve is closed.
        """
        return _fusion.SketchEllipse_split(self, *args)

    def trim(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Trim a curve by specifying a point that determines the segment of the curve to trim away 
        segmentPoint : A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
        The segment of the curve closest to the segmentPoint gets removed 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
        When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
        When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
        Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
        Trimming a curve having no intersections deletes the original and returns an empty collection
        """
        return _fusion.SketchEllipse_trim(self, *args)

    def breakCurve(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
        sketch and splitting this curve at the nearest intersections to a specified point on the curve. 
        segmentPoint : A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
        intersection(s) to this point define the break location(s). 
        createConstraints : Optional argument that specifies if constraints should be created between the new curve segments. A value of
        true indicates constraints will be created. 
        All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
        are found and as a result the curve is not broken, an empty ObjectCollection is returned.
        """
        return _fusion.SketchEllipse_breakCurve(self, *args)

    def extend(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Extend a curve by specifying a point that determines the end of the curve to extend 
        endPoint : A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
        The end of the curve closest to the endPoint gets extended 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        Returns the modified original curve if the start or end of the curve is extended
        If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
        If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
        """
        return _fusion.SketchEllipse_extend(self, *args)

    def intersections(self, *args) -> "bool" :
        """
        Get the curves that intersect this curve along with the intersection points (Point2D) 
        sketchCurves : A collection of curves to attempt to find intersections with. 
        Set the value of this parameter to null to use all curves in the sketch for the calculation. 
        intersectingCurves : A collection of the actual intersecting curves 
        intersectionPoints : A collection of intersection points (Point3D)
        Item numbers in this collection correspond to the item numbers in the intersectingCurves collection. 
        Returns true if intersections are found
        """
        return _fusion.SketchEllipse_intersections(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch."""
        return _fusion.SketchEllipse__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >" :
        """Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchEllipse__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >" :
        """Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchEllipse__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool" :
        """Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchEllipse__get_is2D(self)

    def _get_isReference(self) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchEllipse__get_isReference(self)

    def _set_isReference(self, *args) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchEllipse__set_isReference(self, *args)

    def _get_isFixed(self) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchEllipse__get_isFixed(self)

    def _set_isFixed(self, *args) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchEllipse__set_isFixed(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchEllipse__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchEllipse__get_boundingBox(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchEllipse_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchEllipse__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchEllipse__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool" :
        """
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchEllipse__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool" :
        """Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchEllipse__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.SketchEllipse__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchEllipse__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchEllipse__get_isValid(self)
SketchEllipse_swigregister = _fusion.SketchEllipse_swigregister
SketchEllipse_swigregister(SketchEllipse)

def SketchEllipse_classType() -> "char const *" :
  return _fusion.SketchEllipse_classType()
SketchEllipse_classType = _fusion.SketchEllipse_classType

SketchEllipse.__swig_getmethods__["centerSketchPoint"] = SketchEllipse._get_centerSketchPoint
SketchEllipse.centerSketchPoint = property(SketchEllipse._get_centerSketchPoint, doc="Returns the sketch point that defines the center of the ellipse. You can\nreposition the ellipse by moving the sketch point, assuming any existing\nconstraints allow the desired change.")

SketchEllipse.__swig_getmethods__["majorAxis"] = SketchEllipse._get_majorAxis
SketchEllipse.__swig_setmethods__["majorAxis"] = SketchEllipse._set_majorAxis
SketchEllipse.majorAxis = property(SketchEllipse._get_majorAxis, SketchEllipse._set_majorAxis, doc="Gets and sets the major axis direction of the ellipse. Changing the axis is\nlimited by any constraints that might exist on the ellipse. Setting the axis\ncan fail in cases where the direction is fully defined through constraints.")

SketchEllipse.__swig_getmethods__["majorAxisRadius"] = SketchEllipse._get_majorAxisRadius
SketchEllipse.__swig_setmethods__["majorAxisRadius"] = SketchEllipse._set_majorAxisRadius
SketchEllipse.majorAxisRadius = property(SketchEllipse._get_majorAxisRadius, SketchEllipse._set_majorAxisRadius, doc="Gets and sets the major axis radius of the ellipse. Changing the radius is\nlimited by any constraints that might exist on the ellipse. Setting the radius\ncan fail in cases where the radius is fully defined through constraints.")

SketchEllipse.__swig_getmethods__["minorAxisRadius"] = SketchEllipse._get_minorAxisRadius
SketchEllipse.__swig_setmethods__["minorAxisRadius"] = SketchEllipse._set_minorAxisRadius
SketchEllipse.minorAxisRadius = property(SketchEllipse._get_minorAxisRadius, SketchEllipse._set_minorAxisRadius, doc="Gets and sets the minor axis radius of the ellipse. Changing the radius is\nlimited by any constraints that might exist on the ellipse. Setting the radius\ncan fail in cases where the radius is fully defined through constraints.")

SketchEllipse.__swig_getmethods__["geometry"] = SketchEllipse._get_geometry
SketchEllipse.geometry = property(SketchEllipse._get_geometry, doc="Returns the transient geometry of the ellipse which provides geometric\ninformation about the ellipse. The returned geometry is always in sketch space.")

SketchEllipse.__swig_getmethods__["worldGeometry"] = SketchEllipse._get_worldGeometry
SketchEllipse.worldGeometry = property(SketchEllipse._get_worldGeometry, doc="Returns an Ellipse3D object which provides geometric information in world space.\nThe returned geometry takes into account the assembly context and the position of the\nsketch in it's parent component, which means the geometry will be returned in the root\ncomponent space.")

SketchEllipse.__swig_getmethods__["nativeObject"] = SketchEllipse._get_nativeObject
SketchEllipse.nativeObject = property(SketchEllipse._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SketchEllipse.__swig_getmethods__["majorAxisLine"] = SketchEllipse._get_majorAxisLine
SketchEllipse.majorAxisLine = property(SketchEllipse._get_majorAxisLine, doc="Returns the sketch line associated with the ellipse that lies along the major axis.\nThis can return null in the case where the line has been deleted.")

SketchEllipse.__swig_getmethods__["minorAxisLine"] = SketchEllipse._get_minorAxisLine
SketchEllipse.minorAxisLine = property(SketchEllipse._get_minorAxisLine, doc="Returns the sketch line associated with the ellipse that lies along the minor axis.\nThis can return null in the case where the line has been deleted.")

SketchEllipse.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchEllipse) else None
SketchEllipse.cast = lambda arg: arg if isinstance(arg, SketchEllipse) else None

class SketchEllipticalArc(SketchCurve):
    """An elliptical arc in a sketch."""
    __swig_setmethods__ = {}
    for _s in [SketchCurve]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchEllipticalArc, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchCurve]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchEllipticalArc, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchEllipticalArc *" : return _fusion.SketchEllipticalArc___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchEllipticalArc___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchEllipticalArc___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchEllipticalArc_classType
    if _newclass:classType = staticmethod(_fusion.SketchEllipticalArc_classType)
    __swig_destroy__ = _fusion.delete_SketchEllipticalArc
    __del__ = lambda self : None;
    def _get_centerSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """
        Gets the sketch point that defines the center of the elliptical arc. You can
        reposition the elliptical arc by moving the sketch point, assuming any existing
        constraints allow the desired change.
        """
        return _fusion.SketchEllipticalArc__get_centerSketchPoint(self)

    def _get_startSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """
        Gets the sketch point that defines the start of the elliptical arc. You can
        reposition the sketch point, assuming any existing constraints allow the 
        desired change.
        """
        return _fusion.SketchEllipticalArc__get_startSketchPoint(self)

    def _get_endSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """
        Gets the sketch point that defines the end of the elliptical arc. You can
        reposition the sketch point, assuming any existing constraints allow the 
        desired change.
        """
        return _fusion.SketchEllipticalArc__get_endSketchPoint(self)

    def _get_majorAxis(self) -> "adsk::core::Ptr< adsk::core::Vector3D >" :
        """
        Gets and sets the major axis direction of the elliptical arc. Changing the axis is 
        limited by any constraints that might exist on the elliptical arc. Setting the axis
        can fail in cases where the direction is fully defined through constraints.
        """
        return _fusion.SketchEllipticalArc__get_majorAxis(self)

    def _set_majorAxis(self, *args) -> "bool" :
        """
        Gets and sets the major axis direction of the elliptical arc. Changing the axis is 
        limited by any constraints that might exist on the elliptical arc. Setting the axis
        can fail in cases where the direction is fully defined through constraints.
        """
        return _fusion.SketchEllipticalArc__set_majorAxis(self, *args)

    def _get_majorAxisRadius(self) -> "double" :
        """
        Gets and sets the major axis radius of the elliptical arc. Changing the radius is 
        limited by any constraints that might exist on the elliptical arc. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchEllipticalArc__get_majorAxisRadius(self)

    def _set_majorAxisRadius(self, *args) -> "bool" :
        """
        Gets and sets the major axis radius of the elliptical arc. Changing the radius is 
        limited by any constraints that might exist on the elliptical arc. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchEllipticalArc__set_majorAxisRadius(self, *args)

    def _get_minorAxisRadius(self) -> "double" :
        """
        Gets and sets the minor axis radius of the elliptical arc. Changing the radius is 
        limited by any constraints that might exist on the elliptical arc. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchEllipticalArc__get_minorAxisRadius(self)

    def _set_minorAxisRadius(self, *args) -> "bool" :
        """
        Gets and sets the minor axis radius of the elliptical arc. Changing the radius is 
        limited by any constraints that might exist on the elliptical arc. Setting the radius
        can fail in cases where the radius is fully defined through constraints.
        """
        return _fusion.SketchEllipticalArc__set_minorAxisRadius(self, *args)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::EllipticalArc3D >" :
        """
        Returns the transient geometry of the elliptical arc which provides geometric
        information about the elliptical arc. The returned geometry is always in sketch space.
        """
        return _fusion.SketchEllipticalArc__get_geometry(self)

    def _get_worldGeometry(self) -> "adsk::core::Ptr< adsk::core::EllipticalArc3D >" :
        """
        Returns an EllipticalArc3D object which provides geometric information in world space.
        The returned geometry takes into account the assembly context and the position of the
        sketch in it's parent component, which means the geometry will be returned in the root
        component space.
        """
        return _fusion.SketchEllipticalArc__get_worldGeometry(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchEllipticalArc >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchEllipticalArc__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchEllipticalArc >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchEllipticalArc_createForAssemblyContext(self, *args)

    def _get_length(self) -> "double" :
        """Returns the length of the curve in centimeters."""
        return _fusion.SketchEllipticalArc__get_length(self)

    def _get_isConstruction(self) -> "bool" :
        """Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchEllipticalArc__get_isConstruction(self)

    def _set_isConstruction(self, *args) -> "bool" :
        """Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchEllipticalArc__set_isConstruction(self, *args)

    def split(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Split a curve at a position specified along the curve 
        splitPoint : A position (transient Point3D) on the curve that defines the point at which to split the curve 
        createConstraints : Constraints are created by default. Specify false to create no constraints. 
        Returns the resulting 2 curves; the original curve + the newly created curve
        When split spline the original is deleted and two new curves returned.
        Empty collection returned if curve is closed.
        """
        return _fusion.SketchEllipticalArc_split(self, *args)

    def trim(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Trim a curve by specifying a point that determines the segment of the curve to trim away 
        segmentPoint : A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
        The segment of the curve closest to the segmentPoint gets removed 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
        When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
        When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
        Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
        Trimming a curve having no intersections deletes the original and returns an empty collection
        """
        return _fusion.SketchEllipticalArc_trim(self, *args)

    def breakCurve(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
        sketch and splitting this curve at the nearest intersections to a specified point on the curve. 
        segmentPoint : A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
        intersection(s) to this point define the break location(s). 
        createConstraints : Optional argument that specifies if constraints should be created between the new curve segments. A value of
        true indicates constraints will be created. 
        All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
        are found and as a result the curve is not broken, an empty ObjectCollection is returned.
        """
        return _fusion.SketchEllipticalArc_breakCurve(self, *args)

    def extend(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Extend a curve by specifying a point that determines the end of the curve to extend 
        endPoint : A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
        The end of the curve closest to the endPoint gets extended 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        Returns the modified original curve if the start or end of the curve is extended
        If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
        If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
        """
        return _fusion.SketchEllipticalArc_extend(self, *args)

    def intersections(self, *args) -> "bool" :
        """
        Get the curves that intersect this curve along with the intersection points (Point2D) 
        sketchCurves : A collection of curves to attempt to find intersections with. 
        Set the value of this parameter to null to use all curves in the sketch for the calculation. 
        intersectingCurves : A collection of the actual intersecting curves 
        intersectionPoints : A collection of intersection points (Point3D)
        Item numbers in this collection correspond to the item numbers in the intersectingCurves collection. 
        Returns true if intersections are found
        """
        return _fusion.SketchEllipticalArc_intersections(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch."""
        return _fusion.SketchEllipticalArc__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >" :
        """Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchEllipticalArc__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >" :
        """Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchEllipticalArc__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool" :
        """Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchEllipticalArc__get_is2D(self)

    def _get_isReference(self) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchEllipticalArc__get_isReference(self)

    def _set_isReference(self, *args) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchEllipticalArc__set_isReference(self, *args)

    def _get_isFixed(self) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchEllipticalArc__get_isFixed(self)

    def _set_isFixed(self, *args) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchEllipticalArc__set_isFixed(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchEllipticalArc__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchEllipticalArc__get_boundingBox(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchEllipticalArc_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchEllipticalArc__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchEllipticalArc__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool" :
        """
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchEllipticalArc__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool" :
        """Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchEllipticalArc__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.SketchEllipticalArc__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchEllipticalArc__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchEllipticalArc__get_isValid(self)
SketchEllipticalArc_swigregister = _fusion.SketchEllipticalArc_swigregister
SketchEllipticalArc_swigregister(SketchEllipticalArc)

def SketchEllipticalArc_classType() -> "char const *" :
  return _fusion.SketchEllipticalArc_classType()
SketchEllipticalArc_classType = _fusion.SketchEllipticalArc_classType

SketchEllipticalArc.__swig_getmethods__["centerSketchPoint"] = SketchEllipticalArc._get_centerSketchPoint
SketchEllipticalArc.centerSketchPoint = property(SketchEllipticalArc._get_centerSketchPoint, doc="Gets the sketch point that defines the center of the elliptical arc. You can\nreposition the elliptical arc by moving the sketch point, assuming any existing\nconstraints allow the desired change.")

SketchEllipticalArc.__swig_getmethods__["startSketchPoint"] = SketchEllipticalArc._get_startSketchPoint
SketchEllipticalArc.startSketchPoint = property(SketchEllipticalArc._get_startSketchPoint, doc="Gets the sketch point that defines the start of the elliptical arc. You can\nreposition the sketch point, assuming any existing constraints allow the\ndesired change.")

SketchEllipticalArc.__swig_getmethods__["endSketchPoint"] = SketchEllipticalArc._get_endSketchPoint
SketchEllipticalArc.endSketchPoint = property(SketchEllipticalArc._get_endSketchPoint, doc="Gets the sketch point that defines the end of the elliptical arc. You can\nreposition the sketch point, assuming any existing constraints allow the\ndesired change.")

SketchEllipticalArc.__swig_getmethods__["majorAxis"] = SketchEllipticalArc._get_majorAxis
SketchEllipticalArc.__swig_setmethods__["majorAxis"] = SketchEllipticalArc._set_majorAxis
SketchEllipticalArc.majorAxis = property(SketchEllipticalArc._get_majorAxis, SketchEllipticalArc._set_majorAxis, doc="Gets and sets the major axis direction of the elliptical arc. Changing the axis is\nlimited by any constraints that might exist on the elliptical arc. Setting the axis\ncan fail in cases where the direction is fully defined through constraints.")

SketchEllipticalArc.__swig_getmethods__["majorAxisRadius"] = SketchEllipticalArc._get_majorAxisRadius
SketchEllipticalArc.__swig_setmethods__["majorAxisRadius"] = SketchEllipticalArc._set_majorAxisRadius
SketchEllipticalArc.majorAxisRadius = property(SketchEllipticalArc._get_majorAxisRadius, SketchEllipticalArc._set_majorAxisRadius, doc="Gets and sets the major axis radius of the elliptical arc. Changing the radius is\nlimited by any constraints that might exist on the elliptical arc. Setting the radius\ncan fail in cases where the radius is fully defined through constraints.")

SketchEllipticalArc.__swig_getmethods__["minorAxisRadius"] = SketchEllipticalArc._get_minorAxisRadius
SketchEllipticalArc.__swig_setmethods__["minorAxisRadius"] = SketchEllipticalArc._set_minorAxisRadius
SketchEllipticalArc.minorAxisRadius = property(SketchEllipticalArc._get_minorAxisRadius, SketchEllipticalArc._set_minorAxisRadius, doc="Gets and sets the minor axis radius of the elliptical arc. Changing the radius is\nlimited by any constraints that might exist on the elliptical arc. Setting the radius\ncan fail in cases where the radius is fully defined through constraints.")

SketchEllipticalArc.__swig_getmethods__["geometry"] = SketchEllipticalArc._get_geometry
SketchEllipticalArc.geometry = property(SketchEllipticalArc._get_geometry, doc="Returns the transient geometry of the elliptical arc which provides geometric\ninformation about the elliptical arc. The returned geometry is always in sketch space.")

SketchEllipticalArc.__swig_getmethods__["worldGeometry"] = SketchEllipticalArc._get_worldGeometry
SketchEllipticalArc.worldGeometry = property(SketchEllipticalArc._get_worldGeometry, doc="Returns an EllipticalArc3D object which provides geometric information in world space.\nThe returned geometry takes into account the assembly context and the position of the\nsketch in it's parent component, which means the geometry will be returned in the root\ncomponent space.")

SketchEllipticalArc.__swig_getmethods__["nativeObject"] = SketchEllipticalArc._get_nativeObject
SketchEllipticalArc.nativeObject = property(SketchEllipticalArc._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SketchEllipticalArc.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchEllipticalArc) else None
SketchEllipticalArc.cast = lambda arg: arg if isinstance(arg, SketchEllipticalArc) else None

class SketchFittedSpline(SketchCurve):
    """A fitted spline in a sketch."""
    __swig_setmethods__ = {}
    for _s in [SketchCurve]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchFittedSpline, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchCurve]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchFittedSpline, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchFittedSpline *" : return _fusion.SketchFittedSpline___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchFittedSpline___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchFittedSpline___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchFittedSpline_classType
    if _newclass:classType = staticmethod(_fusion.SketchFittedSpline_classType)
    __swig_destroy__ = _fusion.delete_SketchFittedSpline
    __del__ = lambda self : None;
    def _get_startSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """
        Returns the sketch point that defines the starting position
        of the spline. Editing the position of this sketch point
        will result in editing the spline.
        """
        return _fusion.SketchFittedSpline__get_startSketchPoint(self)

    def _get_endSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """
        Returns the sketch point that defines the ending position
        of the spline. Editing the position of this sketch point
        will result in editing the spline.
        """
        return _fusion.SketchFittedSpline__get_endSketchPoint(self)

    def _get_fitPoints(self) -> "adsk::core::Ptr< adsk::fusion::SketchPointList >" :
        """
        Returns the set of sketch points that the spline fits through.
        The points include the start and end points and are returned in
        the same order as the spline fits through them where the first point
        in the list is the start point and the last point is the end point.
        Editing the position of these sketch points will result in
        editing the spline.
        """
        return _fusion.SketchFittedSpline__get_fitPoints(self)

    def _get_isClosed(self) -> "bool" :
        """
        Gets and sets if this spline is closed. A closed spline
        is also periodic. This property can return false even in 
        the case where the spline is physically closed. It's possible
        that the start and end points of a spline can be the same point
        but the curve is still not considered closed. This can happen
        when the start and end points of an open curve are merged. The 
        curve is physically closed but is not periodic and can have a 
        discontinuity at the joint. Setting it to closed will cause it
        to be periodic and to always remain closed even as fit points
        are deleted.
        """
        return _fusion.SketchFittedSpline__get_isClosed(self)

    def _set_isClosed(self, *args) -> "bool" :
        """
        Gets and sets if this spline is closed. A closed spline
        is also periodic. This property can return false even in 
        the case where the spline is physically closed. It's possible
        that the start and end points of a spline can be the same point
        but the curve is still not considered closed. This can happen
        when the start and end points of an open curve are merged. The 
        curve is physically closed but is not periodic and can have a 
        discontinuity at the joint. Setting it to closed will cause it
        to be periodic and to always remain closed even as fit points
        are deleted.
        """
        return _fusion.SketchFittedSpline__set_isClosed(self, *args)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >" :
        """
        Returns the transient geometry of the curve which provides geometric
        information about the curve. The returned geometry is always in sketch space.
        """
        return _fusion.SketchFittedSpline__get_geometry(self)

    def _get_worldGeometry(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >" :
        """
        Returns an NurbsCurve3D object which provides geometric information in world space.
        The returned geometry takes into account the assembly context and the position of the
        sketch in it's parent component, which means the geometry will be returned in the root
        component space.
        """
        return _fusion.SketchFittedSpline__get_worldGeometry(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchFittedSpline >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchFittedSpline__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchFittedSpline >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchFittedSpline_createForAssemblyContext(self, *args)

    def activateTangentHandle(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """
        Activates the tangent handle for the specified fit point and returns the sketch line
        that acts as the handle to control the tangency. You can use the getTangentHandle
        property to determine if the tangent handle has already been activated. If this method
        is called for a handle that already exists, nothing changes and the existing sketch line
        that acts as the tangent handle is returned.
        The getTangentHandle method can be used to determine if the handle has already been
        activated.
        To deactivate a sketch handle you can delete the sketch line. 
        fitPoint : The fit point on the curve where you want to activate the tangent handle.
        The fit points can be obtained by using the fitPoints property of the SketchFittedSpline object. 
        Returns the sketch line that acts as the tangent handle at the specified fit point.
        """
        return _fusion.SketchFittedSpline_activateTangentHandle(self, *args)

    def getTangentHandle(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """
        Returns the sketch line that acts as the handle to control the tangency at the specified fit
        point. Returns null in the case where the tangent handle has not been activated at that sketch point.
        Deleting the returned line will deactivate the tangent handle. Use the activateTangentHandle method
        to activate the tangent handle. 
        fitPoint : The fit point on the curve where you want to get the tangent handle.
        The fit points can be obtained by using the fitPoints property of the SketchFittedSpline object. 
        Returns the sketch line that acts as the handle to control the tangency at the specified point or
        returns null in the case where the tangency handle has not been activated at the specified sketch point.
        """
        return _fusion.SketchFittedSpline_getTangentHandle(self, *args)

    def activateCurvatureHandle(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchArc >" :
        """
        Activates the curvature handle for the specified fit point and returns the sketch arc
        that acts as the handle to control the curvature. You can use the getCurvatureHandle
        property to determine if the curvature handle has already been activated. If this method
        is called for a handle that already exists, nothing changes and the existing sketch arc
        that acts as the curvature handle is returned.
        The getCurvatureHandle method can be used to determine if the handle has already been
        activated.
        To deactivate a sketch handle you can delete the sketch arc. 
        fitPoint : The fit point on the curve where you want to activate the curvature handle.
        The fit points can be obtained by using the fitPoints property of the SketchFittedSpline object. 
        Returns the sketch arc that acts as the curvature handle at the specified fit point.
        """
        return _fusion.SketchFittedSpline_activateCurvatureHandle(self, *args)

    def getCurvatureHandle(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchArc >" :
        """
        Returns the sketch arc that acts as the handle to control the curvature at the specified fit
        point. Returns null in the case where the curvature handle has not been activated at that sketch point.
        Deleting the returned arc will deactivate the curvature handle. Use the activateCurvatureHandle method
        to activate the curvature handle. 
        fitPoint : The fit point on the curve where you want to get the curvature handle.
        The fit points can be obtained by using the fitPoints property of the SketchFittedSpline object. 
        Returns the sketch arc that acts as the handle to control the curvature at the specified point or
        returns null in the case where the curvature handle has not been activated at the specified sketch point.
        """
        return _fusion.SketchFittedSpline_getCurvatureHandle(self, *args)

    def _get_length(self) -> "double" :
        """Returns the length of the curve in centimeters."""
        return _fusion.SketchFittedSpline__get_length(self)

    def _get_isConstruction(self) -> "bool" :
        """Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchFittedSpline__get_isConstruction(self)

    def _set_isConstruction(self, *args) -> "bool" :
        """Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchFittedSpline__set_isConstruction(self, *args)

    def split(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Split a curve at a position specified along the curve 
        splitPoint : A position (transient Point3D) on the curve that defines the point at which to split the curve 
        createConstraints : Constraints are created by default. Specify false to create no constraints. 
        Returns the resulting 2 curves; the original curve + the newly created curve
        When split spline the original is deleted and two new curves returned.
        Empty collection returned if curve is closed.
        """
        return _fusion.SketchFittedSpline_split(self, *args)

    def trim(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Trim a curve by specifying a point that determines the segment of the curve to trim away 
        segmentPoint : A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
        The segment of the curve closest to the segmentPoint gets removed 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
        When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
        When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
        Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
        Trimming a curve having no intersections deletes the original and returns an empty collection
        """
        return _fusion.SketchFittedSpline_trim(self, *args)

    def breakCurve(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
        sketch and splitting this curve at the nearest intersections to a specified point on the curve. 
        segmentPoint : A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
        intersection(s) to this point define the break location(s). 
        createConstraints : Optional argument that specifies if constraints should be created between the new curve segments. A value of
        true indicates constraints will be created. 
        All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
        are found and as a result the curve is not broken, an empty ObjectCollection is returned.
        """
        return _fusion.SketchFittedSpline_breakCurve(self, *args)

    def extend(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Extend a curve by specifying a point that determines the end of the curve to extend 
        endPoint : A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
        The end of the curve closest to the endPoint gets extended 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        Returns the modified original curve if the start or end of the curve is extended
        If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
        If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
        """
        return _fusion.SketchFittedSpline_extend(self, *args)

    def intersections(self, *args) -> "bool" :
        """
        Get the curves that intersect this curve along with the intersection points (Point2D) 
        sketchCurves : A collection of curves to attempt to find intersections with. 
        Set the value of this parameter to null to use all curves in the sketch for the calculation. 
        intersectingCurves : A collection of the actual intersecting curves 
        intersectionPoints : A collection of intersection points (Point3D)
        Item numbers in this collection correspond to the item numbers in the intersectingCurves collection. 
        Returns true if intersections are found
        """
        return _fusion.SketchFittedSpline_intersections(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch."""
        return _fusion.SketchFittedSpline__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >" :
        """Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchFittedSpline__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >" :
        """Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchFittedSpline__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool" :
        """Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchFittedSpline__get_is2D(self)

    def _get_isReference(self) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchFittedSpline__get_isReference(self)

    def _set_isReference(self, *args) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchFittedSpline__set_isReference(self, *args)

    def _get_isFixed(self) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchFittedSpline__get_isFixed(self)

    def _set_isFixed(self, *args) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchFittedSpline__set_isFixed(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchFittedSpline__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchFittedSpline__get_boundingBox(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchFittedSpline_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchFittedSpline__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchFittedSpline__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool" :
        """
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchFittedSpline__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool" :
        """Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchFittedSpline__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.SketchFittedSpline__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchFittedSpline__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchFittedSpline__get_isValid(self)
SketchFittedSpline_swigregister = _fusion.SketchFittedSpline_swigregister
SketchFittedSpline_swigregister(SketchFittedSpline)

def SketchFittedSpline_classType() -> "char const *" :
  return _fusion.SketchFittedSpline_classType()
SketchFittedSpline_classType = _fusion.SketchFittedSpline_classType

SketchFittedSpline.__swig_getmethods__["startSketchPoint"] = SketchFittedSpline._get_startSketchPoint
SketchFittedSpline.startSketchPoint = property(SketchFittedSpline._get_startSketchPoint, doc="Returns the sketch point that defines the starting position\nof the spline. Editing the position of this sketch point\nwill result in editing the spline.")

SketchFittedSpline.__swig_getmethods__["endSketchPoint"] = SketchFittedSpline._get_endSketchPoint
SketchFittedSpline.endSketchPoint = property(SketchFittedSpline._get_endSketchPoint, doc="Returns the sketch point that defines the ending position\nof the spline. Editing the position of this sketch point\nwill result in editing the spline.")

SketchFittedSpline.__swig_getmethods__["fitPoints"] = SketchFittedSpline._get_fitPoints
SketchFittedSpline.fitPoints = property(SketchFittedSpline._get_fitPoints, doc="Returns the set of sketch points that the spline fits through.\nThe points include the start and end points and are returned in\nthe same order as the spline fits through them where the first point\nin the list is the start point and the last point is the end point.\nEditing the position of these sketch points will result in\nediting the spline.")

SketchFittedSpline.__swig_getmethods__["isClosed"] = SketchFittedSpline._get_isClosed
SketchFittedSpline.__swig_setmethods__["isClosed"] = SketchFittedSpline._set_isClosed
SketchFittedSpline.isClosed = property(SketchFittedSpline._get_isClosed, SketchFittedSpline._set_isClosed, doc="Gets and sets if this spline is closed. A closed spline\nis also periodic. This property can return false even in\nthe case where the spline is physically closed. It's possible\nthat the start and end points of a spline can be the same point\nbut the curve is still not considered closed. This can happen\nwhen the start and end points of an open curve are merged. The\ncurve is physically closed but is not periodic and can have a\ndiscontinuity at the joint. Setting it to closed will cause it\nto be periodic and to always remain closed even as fit points\nare deleted.")

SketchFittedSpline.__swig_getmethods__["geometry"] = SketchFittedSpline._get_geometry
SketchFittedSpline.geometry = property(SketchFittedSpline._get_geometry, doc="Returns the transient geometry of the curve which provides geometric\ninformation about the curve. The returned geometry is always in sketch space.")

SketchFittedSpline.__swig_getmethods__["worldGeometry"] = SketchFittedSpline._get_worldGeometry
SketchFittedSpline.worldGeometry = property(SketchFittedSpline._get_worldGeometry, doc="Returns an NurbsCurve3D object which provides geometric information in world space.\nThe returned geometry takes into account the assembly context and the position of the\nsketch in it's parent component, which means the geometry will be returned in the root\ncomponent space.")

SketchFittedSpline.__swig_getmethods__["nativeObject"] = SketchFittedSpline._get_nativeObject
SketchFittedSpline.nativeObject = property(SketchFittedSpline._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SketchFittedSpline.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchFittedSpline) else None
SketchFittedSpline.cast = lambda arg: arg if isinstance(arg, SketchFittedSpline) else None

class SketchFixedSpline(SketchCurve):
    """
    The SketchFixedSpline class represents splines in a sketch that are
    uneditable. These can result from including splines from other sketches
    or the spline edges. They can also be created by intersections and 
    projecting splines onto a sketch.
    """
    __swig_setmethods__ = {}
    for _s in [SketchCurve]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchFixedSpline, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchCurve]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchFixedSpline, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchFixedSpline *" : return _fusion.SketchFixedSpline___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchFixedSpline___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchFixedSpline___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchFixedSpline_classType
    if _newclass:classType = staticmethod(_fusion.SketchFixedSpline_classType)
    __swig_destroy__ = _fusion.delete_SketchFixedSpline
    __del__ = lambda self : None;
    def _get_startSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """The sketch point at the start of the spline."""
        return _fusion.SketchFixedSpline__get_startSketchPoint(self)

    def _get_endSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """The sketch point at the end of the spline."""
        return _fusion.SketchFixedSpline__get_endSketchPoint(self)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >" :
        """
        Returns the transient geometry of the curve which provides geometric
        information about the curve. The returned geometry is always in sketch space.
        Because the fixed spline can be analytically defined, for example it
        can be the precise intersection of a surface and the sketch plane,
        returning a NURBS curve that represents the spline may be an 
        approximation of the actual curve. You can use the Evaluator
        property of the SketchFixedSpline object to perform evaluations
        on the precise curve.
        """
        return _fusion.SketchFixedSpline__get_geometry(self)

    def _get_worldGeometry(self) -> "adsk::core::Ptr< adsk::core::NurbsCurve3D >" :
        """
        Returns a NurbsCurve3D object that is the equivalent of this sketch curve 
        but is in the space of the parent component rather than in sketch space.
        """
        return _fusion.SketchFixedSpline__get_worldGeometry(self)

    def _get_evaluator(self) -> "adsk::core::Ptr< adsk::core::CurveEvaluator3D >" :
        """
        Returns an evaluator object that lets you perform evaluations
        on the precise geometry of the curve.
        """
        return _fusion.SketchFixedSpline__get_evaluator(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchFixedSpline >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchFixedSpline__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchFixedSpline >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchFixedSpline_createForAssemblyContext(self, *args)

    def _get_length(self) -> "double" :
        """Returns the length of the curve in centimeters."""
        return _fusion.SketchFixedSpline__get_length(self)

    def _get_isConstruction(self) -> "bool" :
        """Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchFixedSpline__get_isConstruction(self)

    def _set_isConstruction(self, *args) -> "bool" :
        """Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchFixedSpline__set_isConstruction(self, *args)

    def split(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Split a curve at a position specified along the curve 
        splitPoint : A position (transient Point3D) on the curve that defines the point at which to split the curve 
        createConstraints : Constraints are created by default. Specify false to create no constraints. 
        Returns the resulting 2 curves; the original curve + the newly created curve
        When split spline the original is deleted and two new curves returned.
        Empty collection returned if curve is closed.
        """
        return _fusion.SketchFixedSpline_split(self, *args)

    def trim(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Trim a curve by specifying a point that determines the segment of the curve to trim away 
        segmentPoint : A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
        The segment of the curve closest to the segmentPoint gets removed 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
        When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
        When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
        Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
        Trimming a curve having no intersections deletes the original and returns an empty collection
        """
        return _fusion.SketchFixedSpline_trim(self, *args)

    def breakCurve(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
        sketch and splitting this curve at the nearest intersections to a specified point on the curve. 
        segmentPoint : A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
        intersection(s) to this point define the break location(s). 
        createConstraints : Optional argument that specifies if constraints should be created between the new curve segments. A value of
        true indicates constraints will be created. 
        All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
        are found and as a result the curve is not broken, an empty ObjectCollection is returned.
        """
        return _fusion.SketchFixedSpline_breakCurve(self, *args)

    def extend(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Extend a curve by specifying a point that determines the end of the curve to extend 
        endPoint : A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
        The end of the curve closest to the endPoint gets extended 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        Returns the modified original curve if the start or end of the curve is extended
        If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
        If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
        """
        return _fusion.SketchFixedSpline_extend(self, *args)

    def intersections(self, *args) -> "bool" :
        """
        Get the curves that intersect this curve along with the intersection points (Point2D) 
        sketchCurves : A collection of curves to attempt to find intersections with. 
        Set the value of this parameter to null to use all curves in the sketch for the calculation. 
        intersectingCurves : A collection of the actual intersecting curves 
        intersectionPoints : A collection of intersection points (Point3D)
        Item numbers in this collection correspond to the item numbers in the intersectingCurves collection. 
        Returns true if intersections are found
        """
        return _fusion.SketchFixedSpline_intersections(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch."""
        return _fusion.SketchFixedSpline__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >" :
        """Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchFixedSpline__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >" :
        """Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchFixedSpline__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool" :
        """Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchFixedSpline__get_is2D(self)

    def _get_isReference(self) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchFixedSpline__get_isReference(self)

    def _set_isReference(self, *args) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchFixedSpline__set_isReference(self, *args)

    def _get_isFixed(self) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchFixedSpline__get_isFixed(self)

    def _set_isFixed(self, *args) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchFixedSpline__set_isFixed(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchFixedSpline__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchFixedSpline__get_boundingBox(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchFixedSpline_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchFixedSpline__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchFixedSpline__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool" :
        """
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchFixedSpline__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool" :
        """Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchFixedSpline__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.SketchFixedSpline__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchFixedSpline__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchFixedSpline__get_isValid(self)
SketchFixedSpline_swigregister = _fusion.SketchFixedSpline_swigregister
SketchFixedSpline_swigregister(SketchFixedSpline)

def SketchFixedSpline_classType() -> "char const *" :
  return _fusion.SketchFixedSpline_classType()
SketchFixedSpline_classType = _fusion.SketchFixedSpline_classType

SketchFixedSpline.__swig_getmethods__["startSketchPoint"] = SketchFixedSpline._get_startSketchPoint
SketchFixedSpline.startSketchPoint = property(SketchFixedSpline._get_startSketchPoint, doc="The sketch point at the start of the spline.")

SketchFixedSpline.__swig_getmethods__["endSketchPoint"] = SketchFixedSpline._get_endSketchPoint
SketchFixedSpline.endSketchPoint = property(SketchFixedSpline._get_endSketchPoint, doc="The sketch point at the end of the spline.")

SketchFixedSpline.__swig_getmethods__["geometry"] = SketchFixedSpline._get_geometry
SketchFixedSpline.geometry = property(SketchFixedSpline._get_geometry, doc="Returns the transient geometry of the curve which provides geometric\ninformation about the curve. The returned geometry is always in sketch space.\nBecause the fixed spline can be analytically defined, for example it\ncan be the precise intersection of a surface and the sketch plane,\nreturning a NURBS curve that represents the spline may be an\napproximation of the actual curve. You can use the Evaluator\nproperty of the SketchFixedSpline object to perform evaluations\non the precise curve.")

SketchFixedSpline.__swig_getmethods__["worldGeometry"] = SketchFixedSpline._get_worldGeometry
SketchFixedSpline.worldGeometry = property(SketchFixedSpline._get_worldGeometry, doc="Returns a NurbsCurve3D object that is the equivalent of this sketch curve\nbut is in the space of the parent component rather than in sketch space.")

SketchFixedSpline.__swig_getmethods__["evaluator"] = SketchFixedSpline._get_evaluator
SketchFixedSpline.evaluator = property(SketchFixedSpline._get_evaluator, doc="Returns an evaluator object that lets you perform evaluations\non the precise geometry of the curve.")

SketchFixedSpline.__swig_getmethods__["nativeObject"] = SketchFixedSpline._get_nativeObject
SketchFixedSpline.nativeObject = property(SketchFixedSpline._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SketchFixedSpline.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchFixedSpline) else None
SketchFixedSpline.cast = lambda arg: arg if isinstance(arg, SketchFixedSpline) else None

class SketchLine(SketchCurve):
    """A line in a sketch."""
    __swig_setmethods__ = {}
    for _s in [SketchCurve]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SketchLine, name, value)
    __swig_getmethods__ = {}
    for _s in [SketchCurve]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SketchLine, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __deref__(self) -> "adsk::fusion::SketchLine *" : return _fusion.SketchLine___deref__(self)
    def __eq__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])) :
           return False


        return _fusion.SketchLine___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        if not isinstance(self, type(args[0])):
           return True


        return _fusion.SketchLine___ne__(self, *args)

    __swig_getmethods__["classType"] = lambda x: _fusion.SketchLine_classType
    if _newclass:classType = staticmethod(_fusion.SketchLine_classType)
    __swig_destroy__ = _fusion.delete_SketchLine
    __del__ = lambda self : None;
    def _get_startSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """
        The sketch point at the start of the line. The line is dependent on this point and moving the
        point will cause the line to adjust.
        """
        return _fusion.SketchLine__get_startSketchPoint(self)

    def _get_endSketchPoint(self) -> "adsk::core::Ptr< adsk::fusion::SketchPoint >" :
        """
        The sketch point at the end of the line. The line is dependent on this point and moving the
        point will cause the line to adjust.
        """
        return _fusion.SketchLine__get_endSketchPoint(self)

    def _get_geometry(self) -> "adsk::core::Ptr< adsk::core::Line3D >" :
        """
        Returns the transient geometry of the line which provides geometry 
        information about the line. The returned geometry is always in sketch space.
        """
        return _fusion.SketchLine__get_geometry(self)

    def _get_worldGeometry(self) -> "adsk::core::Ptr< adsk::core::Line3D >" :
        """
        Returns a Line3D object which provides geometric information in world space.
        The returned geometry takes into account the assembly context and the position of the
        sketch in it's parent component, which means the geometry will be returned in the root
        component space.
        """
        return _fusion.SketchLine__get_worldGeometry(self)

    def _get_nativeObject(self) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """
        The NativeObject is the object outside the context of an assembly and
        in the context of it's parent component.
        Returns null in the case where this object is not in the context of 
        an assembly but is already the native object.
        """
        return _fusion.SketchLine__get_nativeObject(self)

    def createForAssemblyContext(self, *args) -> "adsk::core::Ptr< adsk::fusion::SketchLine >" :
        """
        Creates or returns a proxy for the native object
        - i.e. a new object that represents this object but adds the assembly context
        defined by the input occurrence. 
        occurrence : The occurrence that defines the context to create the proxy in. 
        Returns the proxy object or null if this isn't the NativeObject.
        """
        return _fusion.SketchLine_createForAssemblyContext(self, *args)

    def _get_length(self) -> "double" :
        """Returns the length of the curve in centimeters."""
        return _fusion.SketchLine__get_length(self)

    def _get_isConstruction(self) -> "bool" :
        """Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchLine__get_isConstruction(self)

    def _set_isConstruction(self, *args) -> "bool" :
        """Gets and sets whether this curve is construction geometry."""
        return _fusion.SketchLine__set_isConstruction(self, *args)

    def split(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Split a curve at a position specified along the curve 
        splitPoint : A position (transient Point3D) on the curve that defines the point at which to split the curve 
        createConstraints : Constraints are created by default. Specify false to create no constraints. 
        Returns the resulting 2 curves; the original curve + the newly created curve
        When split spline the original is deleted and two new curves returned.
        Empty collection returned if curve is closed.
        """
        return _fusion.SketchLine_split(self, *args)

    def trim(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Trim a curve by specifying a point that determines the segment of the curve to trim away 
        segmentPoint : A point (transient Point3D) on or closest to the segment of the curve to remove. (start, end or middle)
        The segment of the curve closest to the segmentPoint gets removed 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        When trimming the start or end side of a line, unclosed circular or elliptical arc, the original entity is modified and returned
        When trimming the middle of a line, unclosed circular or elliptical arc the original entity is deleted and two new entities are returned
        When trimming the start or end of any type of closed curve, the original is deleted and a new curve is returned
        Any trimming of a spline (open or closed) deletes the original and new spline/s are returned
        Trimming a curve having no intersections deletes the original and returns an empty collection
        """
        return _fusion.SketchLine_trim(self, *args)

    def breakCurve(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Breaks a curve into two or three pieces by finding intersections of this curve with all other curves in the
        sketch and splitting this curve at the nearest intersections to a specified point on the curve. 
        segmentPoint : A point that specifies the segment of the curve that is to be split from the rest of the curve. The nearest
        intersection(s) to this point define the break location(s). 
        createConstraints : Optional argument that specifies if constraints should be created between the new curve segments. A value of
        true indicates constraints will be created. 
        All of the curves resulting from the break are returned in an ObjectCollection. In the case where no intersections
        are found and as a result the curve is not broken, an empty ObjectCollection is returned.
        """
        return _fusion.SketchLine_breakCurve(self, *args)

    def extend(self, *args) -> "adsk::core::Ptr< adsk::core::ObjectCollection >" :
        """
        Extend a curve by specifying a point that determines the end of the curve to extend 
        endPoint : A point (transient Point3D) on or closest to the end of the curve to extend. (start or end)
        The end of the curve closest to the endPoint gets extended 
        createConstraints : Constraints are created by default. Specify false to not create constraints. 
        Returns the modified original curve if the start or end of the curve is extended
        If the extend joins a curve to another, the two original curves are deleted and a new curve is returned
        If an arc is extended so as to become a circle, the original arc is deleted and a new circle is returned
        """
        return _fusion.SketchLine_extend(self, *args)

    def intersections(self, *args) -> "bool" :
        """
        Get the curves that intersect this curve along with the intersection points (Point2D) 
        sketchCurves : A collection of curves to attempt to find intersections with. 
        Set the value of this parameter to null to use all curves in the sketch for the calculation. 
        intersectingCurves : A collection of the actual intersecting curves 
        intersectionPoints : A collection of intersection points (Point3D)
        Item numbers in this collection correspond to the item numbers in the intersectingCurves collection. 
        Returns true if intersections are found
        """
        return _fusion.SketchLine_intersections(self, *args)

    def _get_parentSketch(self) -> "adsk::core::Ptr< adsk::fusion::Sketch >" :
        """Returns the parent sketch."""
        return _fusion.SketchLine__get_parentSketch(self)

    def _get_sketchDimensions(self) -> "adsk::core::Ptr< adsk::fusion::SketchDimensionList >" :
        """Returns the sketch dimensions that are attached to this curve."""
        return _fusion.SketchLine__get_sketchDimensions(self)

    def _get_geometricConstraints(self) -> "adsk::core::Ptr< adsk::fusion::GeometricConstraintList >" :
        """Returns the sketch constraints that are attached to this curve."""
        return _fusion.SketchLine__get_geometricConstraints(self)

    def _get_is2D(self) -> "bool" :
        """Indicates if this curve lies entirely on the sketch x-y plane."""
        return _fusion.SketchLine__get_is2D(self)

    def _get_isReference(self) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchLine__get_isReference(self)

    def _set_isReference(self, *args) -> "bool" :
        """
        Indicates if this geometry is a reference.
        Changing this property from true to false removes the reference. 
        This property can not be set to true if it is already false.
        """
        return _fusion.SketchLine__set_isReference(self, *args)

    def _get_isFixed(self) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchLine__get_isFixed(self)

    def _set_isFixed(self, *args) -> "bool" :
        """Indicates if this geometry is 'fixed'."""
        return _fusion.SketchLine__set_isFixed(self, *args)

    def _get_isVisible(self) -> "bool" :
        """
        When a sketch is created, geometry is sometimes automatically added to the sketch.
        For example a sketch point that references the origin point is always included and 
        if a face was selected to create the sketch on, geometry from the face is also included. 
        This automatically created geometry behaves in a special way in that it is invisible 
        but is available for selection and it also participates in profile calculations. It's 
        not possible to make them visible but they can be deleted and they can be used for any 
        other standard sketch operation.
        """
        return _fusion.SketchLine__get_isVisible(self)

    def _get_boundingBox(self) -> "adsk::core::Ptr< adsk::core::BoundingBox3D >" :
        """Returns the bounding box of the entity in sketch space."""
        return _fusion.SketchLine__get_boundingBox(self)

    def deleteMe(self) -> "bool" :
        """
        Deletes the entity from the sketch. 
        Returns true is the delete was successful.
        """
        return _fusion.SketchLine_deleteMe(self)

    def _get_referencedEntity(self) -> "adsk::core::Ptr< adsk::core::Base >" :
        """
        Returns the referenced entity in the case where IsReference
        is true. However, this property can also return null when 
        IsReference is true in the case where the reference is not
        parametric.
        """
        return _fusion.SketchLine__get_referencedEntity(self)

    def _get_assemblyContext(self) -> "adsk::core::Ptr< adsk::fusion::Occurrence >" :
        """
        Returns the assembly occurrence (i.e. the occurrence) of this object
        in an assembly. This is only valid in the case where this is acting
        as a proxy in an assembly. Returns null in the case where the object
        is not in the context of an assembly but is already the native object.
        """
        return _fusion.SketchLine__get_assemblyContext(self)

    def _get_isDeletable(self) -> "bool" :
        """
        Indicates if this sketch entity can be deleted. There are cases, especially with sketch
        points where another entity is dependent on an entity so deleting it is not allowed. 
        For example, you can't delete the center point of circle by itself but deleting the circle 
        will delete the point. The same is true for the end points of a line.
        """
        return _fusion.SketchLine__get_isDeletable(self)

    def _get_isFullyConstrained(self) -> "bool" :
        """Indicates if this sketch entity is fully constrained."""
        return _fusion.SketchLine__get_isFullyConstrained(self)

    def _get_attributes(self) -> "adsk::core::Ptr< adsk::core::Attributes >" :
        """Returns the collection of attributes associated with this face."""
        return _fusion.SketchLine__get_attributes(self)

    def _get_objectType(self) -> "char const *" : return _fusion.SketchLine__get_objectType(self)
    def _get_isValid(self) -> "bool" : return _fusion.SketchLine__get_isValid(self)
SketchLine_swigregister = _fusion.SketchLine_swigregister
SketchLine_swigregister(SketchLine)

def SketchLine_classType() -> "char const *" :
  return _fusion.SketchLine_classType()
SketchLine_classType = _fusion.SketchLine_classType

SketchLine.__swig_getmethods__["startSketchPoint"] = SketchLine._get_startSketchPoint
SketchLine.startSketchPoint = property(SketchLine._get_startSketchPoint, doc="The sketch point at the start of the line. The line is dependent on this point and moving the\npoint will cause the line to adjust.")

SketchLine.__swig_getmethods__["endSketchPoint"] = SketchLine._get_endSketchPoint
SketchLine.endSketchPoint = property(SketchLine._get_endSketchPoint, doc="The sketch point at the end of the line. The line is dependent on this point and moving the\npoint will cause the line to adjust.")

SketchLine.__swig_getmethods__["geometry"] = SketchLine._get_geometry
SketchLine.geometry = property(SketchLine._get_geometry, doc="Returns the transient geometry of the line which provides geometry\ninformation about the line. The returned geometry is always in sketch space.")

SketchLine.__swig_getmethods__["worldGeometry"] = SketchLine._get_worldGeometry
SketchLine.worldGeometry = property(SketchLine._get_worldGeometry, doc="Returns a Line3D object which provides geometric information in world space.\nThe returned geometry takes into account the assembly context and the position of the\nsketch in it's parent component, which means the geometry will be returned in the root\ncomponent space.")

SketchLine.__swig_getmethods__["nativeObject"] = SketchLine._get_nativeObject
SketchLine.nativeObject = property(SketchLine._get_nativeObject, doc="The NativeObject is the object outside the context of an assembly and\nin the context of it's parent component.\nReturns null in the case where this object is not in the context of\nan assembly but is already the native object.")

SketchLine.__swig_getmethods__["cast"] = lambda arg: arg if isinstance(arg, SketchLine) else None
SketchLine.cast = lambda arg: arg if isinstance(arg, SketchLine) else None

# This file is compatible with both classic and new-style classes.


